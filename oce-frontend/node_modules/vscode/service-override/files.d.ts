import { IEditorOverrideServices } from '../vscode/src/vs/editor/standalone/browser/standaloneServices.js';
export { InMemoryFileSystemProvider } from '../vscode/src/vs/platform/files/common/inMemoryFilesystemProvider.js';
import { URI } from '../vscode/src/vs/base/common/uri.js';
import { FileType, IStat, IFileSystemProviderWithFileReadWriteCapability, IFileSystemProviderWithOpenReadWriteCloseCapability, IFileSystemProviderWithFileReadStreamCapability, IFileSystemProviderWithFileAtomicReadCapability, IFileSystemProviderWithFileAtomicWriteCapability, IFileSystemProviderWithFileAtomicDeleteCapability, IFileChange, IFileReadStreamOptions, IFileWriteOptions, IWatchOptions, IFileDeleteOptions, IFileOverwriteOptions, IFileSystemProvider, FileSystemProviderCapabilities, FileChangeType } from '../vscode/src/vs/platform/files/common/files.js';
export { FilePermission, FileSystemProviderError, FileSystemProviderErrorCode } from '../vscode/src/vs/platform/files/common/files.js';
import { Disposable, IDisposable } from '../vscode/src/vs/base/common/lifecycle.js';
import { Emitter, Event } from '../vscode/src/vs/base/common/event.js';
export { HTMLFileSystemProvider } from '../vscode/src/vs/platform/files/browser/htmlFileSystemProvider.js';
import { IndexedDBFileSystemProvider } from '../vscode/src/vs/platform/files/browser/indexedDBFileSystemProvider.js';
export { IndexedDB } from '../vscode/src/vs/base/browser/indexedDB.js';
import { ReadableStreamEvents } from '../vscode/src/vs/base/common/stream.js';
import { CancellationToken } from '../vscode/src/vs/base/common/cancellation.js';

interface _RegisteredNode {
    type: FileType;
    stats(): Promise<IStat>;
    onDidDelete: Event<void>;
    onDidChange: Event<void>;
}
interface RegisteredFileNode extends _RegisteredNode {
    type: FileType.File;
    uri: URI;
    read(): Promise<Uint8Array>;
    readStream?(): Promise<ReadableStream<Uint8Array>>;
    write(content: Uint8Array): Promise<void>;
    delete(): void;
}
interface RegisteredDirectoryNode extends _RegisteredNode {
    type: FileType.Directory;
    addChild(name: string, node: RegisteredNode): IDisposable;
    deleteChild(name: string): boolean;
    getChildren(name: string): RegisteredNode | undefined;
    read(): [string, FileType][];
}
type RegisteredNode = RegisteredFileNode | RegisteredDirectoryNode;
declare abstract class RegisteredFile implements RegisteredFileNode {
    uri: URI;
    private readonly;
    protected ctime: number;
    protected mtime: number;
    readonly type = FileType.File;
    protected _onDidChange: Emitter<void>;
    onDidChange: Event<void>;
    protected _onDidDelete: Emitter<void>;
    onDidDelete: Event<void>;
    constructor(uri: URI, readonly: boolean);
    stats(): Promise<IStat>;
    abstract getSize(): Promise<number>;
    delete(): Promise<void>;
    abstract read(): Promise<Uint8Array>;
    abstract write(content: Uint8Array): Promise<void>;
}
declare class RegisteredReadOnlyFile extends RegisteredFile {
    read: () => Promise<Uint8Array>;
    private size;
    constructor(uri: URI, read: () => Promise<Uint8Array>, size: number);
    getSize(): Promise<number>;
    write(): Promise<void>;
    delete(): Promise<void>;
}
interface ExtensionFileMetadata {
    mimeType?: string;
    size?: number;
}
declare class RegisteredUriFile extends RegisteredFile {
    private url;
    private metadata?;
    constructor(location: URI, url: string, metadata?: ExtensionFileMetadata | undefined);
    private fetch;
    getSize(): Promise<number>;
    read(): Promise<Uint8Array>;
    readStream(): Promise<ReadableStream<Uint8Array>>;
    write(): Promise<void>;
    delete(): Promise<void>;
}
declare class RegisteredMemoryFile extends RegisteredFile {
    private content;
    constructor(uri: URI, content: string | Uint8Array);
    getSize(): Promise<number>;
    read(): Promise<Uint8Array>;
    write(content: Uint8Array): Promise<void>;
}
declare class RegisteredFileSystemProvider extends Disposable implements IFileSystemProviderWithFileReadWriteCapability, IFileSystemProviderWithOpenReadWriteCloseCapability, IFileSystemProviderWithFileReadStreamCapability, IFileSystemProviderWithFileAtomicReadCapability, IFileSystemProviderWithFileAtomicWriteCapability, IFileSystemProviderWithFileAtomicDeleteCapability {
    private memoryFdCounter;
    private readonly fdMemory;
    private rootByAuthority;
    onDidChangeCapabilities: Event<any>;
    _onDidChangeFile: Emitter<readonly IFileChange[]>;
    onDidChangeFile: Event<readonly IFileChange[]>;
    capabilities: number;
    constructor(readonly: boolean);
    open(resource: URI): Promise<number>;
    close(fd: number): Promise<void>;
    read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;
    write(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;
    private _lookupRoot;
    private _lookup;
    private _lookupAsDirectory;
    private _lookupAsFile;
    registerFile(file: RegisteredFileNode): IDisposable;
    stat(resource: URI): Promise<IStat>;
    readdirSync(resource: URI): [string, FileType][];
    readdir(resource: URI): Promise<[string, FileType][]>;
    readFile(resource: URI): Promise<Uint8Array>;
    readFileStream(resource: URI, opts: IFileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array>;
    watch(): IDisposable;
    writeFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void>;
    rename(): Promise<void>;
    mkdirSync(resource: URI): RegisteredDirectoryNode;
    mkdir(): Promise<void>;
    private deleteSync;
    delete(resource: URI): Promise<void>;
    private _bufferedChanges;
    private _fireSoonHandle?;
    private _fireSoon;
}
declare class OverlayFileSystemProvider implements IFileSystemProviderWithFileReadWriteCapability, IFileSystemProviderWithFileReadStreamCapability, IFileSystemProviderWithFileAtomicReadCapability, IFileSystemProviderWithFileAtomicWriteCapability, IFileSystemProviderWithFileAtomicDeleteCapability {
    private providers;
    register(priority: number, provider: IFileSystemProviderWithFileReadWriteCapability): IDisposable;
    get delegates(): IFileSystemProviderWithFileReadWriteCapability[];
    onDidChangeCapabilities: Event<any>;
    _onDidChangeFile: Emitter<readonly IFileChange[]>;
    onDidChangeFile: Event<readonly IFileChange[]>;
    _onDidChangeOverlays: Emitter<void>;
    onDidChangeOverlays: Event<void>;
    capabilities: number;
    private readFromDelegates;
    private readFromDelegatesSync;
    private writeToDelegates;
    stat(resource: URI): Promise<IStat>;
    readFile(resource: URI): Promise<Uint8Array>;
    readFileStream(resource: URI, opts: IFileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array>;
    readdir(resource: URI): Promise<[string, FileType][]>;
    watch(resource: URI, opts: IWatchOptions): IDisposable;
    writeFile(resource: URI, content: Uint8Array, opts: IFileWriteOptions): Promise<void>;
    mkdir(resource: URI): Promise<void>;
    delete(resource: URI, opts: IFileDeleteOptions): Promise<void>;
    rename(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void>;
}
declare class DelegateFileSystemProvider implements IFileSystemProvider {
    private options;
    constructor(options: {
        delegate: IFileSystemProvider;
        toDelegate: (uri: URI) => URI;
        fromDeletate: (uri: URI) => URI;
    });
    get capabilities(): FileSystemProviderCapabilities;
    onDidChangeCapabilities: Event<void>;
    onDidChangeFile: Event<{
        type: FileChangeType;
        resource: URI;
    }[]>;
    readFile: ((resource: URI) => Promise<Uint8Array>) | undefined;
    writeFile: ((resource: URI, content: Uint8Array, opts: IFileWriteOptions) => Promise<void>) | undefined;
    watch(resource: URI, opts: IWatchOptions): IDisposable;
    stat(resource: URI): Promise<IStat>;
    mkdir(resource: URI): Promise<void>;
    readdir(resource: URI): Promise<[string, FileType][]>;
    delete(resource: URI, opts: IFileDeleteOptions): Promise<void>;
    rename(from: URI, to: URI, opts: IFileOverwriteOptions): Promise<void>;
}
declare class EmptyFileSystemProvider implements IFileSystemProviderWithFileReadWriteCapability {
    readFile(): Promise<Uint8Array>;
    writeFile(): Promise<void>;
    capabilities: number;
    onDidChangeCapabilities: Event<any>;
    onDidChangeFile: Event<any>;
    watch(): IDisposable;
    stat(): Promise<IStat>;
    mkdir(): Promise<void>;
    readdir(): Promise<[string, FileType][]>;
    delete(): Promise<void>;
    rename(): Promise<void>;
}
declare namespace CustomSchemas {
    /**
     * A schema that is used for models that exist in memory
     * only and that have no correspondence on a server or such.
     */
    const extensionFile = "extension-file";
}
declare function getServiceOverride(): IEditorOverrideServices;
/**
 * Register a custom file system provider for the given scheme. This allows us to override
 * the default file system provider for a given scheme.
 */
declare function registerCustomProvider(scheme: string, provider: IFileSystemProvider): void;
declare function registerExtensionFile(file: RegisteredFileNode): IDisposable;
/**
 * Can be used to create a file before the fileService is initialized
 */
declare function initFile(file: URI, content: Uint8Array | string, options?: Partial<IFileWriteOptions>): Promise<void>;
/**
 * Can be used to replace memory providers by indexeddb providers before the fileService is initialized
 */
declare function createIndexedDBProviders(): Promise<IndexedDBFileSystemProvider>;
/**
 * Can be used to replace the default filesystem provider by the HTMLFileSystemProvider before the fileService is initialized
 * Should be called "after" createIndexedDBProviders if used
 */
declare function registerHTMLFileSystemProvider(): void;
/**
 * Register a file system overlay
 *
 * By default, a memory filesystem is used to read and write file
 *
 * This method allows to register another fileSystemProvider in front OR behind the default memory one.
 *
 * The default one is registered as priority: 0, so:
 * - any provider registered with a positive priority will be in front of the default one
 * - any provider registered with a negative priority will be behind the default one
 */
declare function registerFileSystemOverlay(priority: number, provider: IFileSystemProviderWithFileReadWriteCapability): IDisposable;

export { CustomSchemas, DelegateFileSystemProvider, EmptyFileSystemProvider, type ExtensionFileMetadata, FileChangeType, FileSystemProviderCapabilities, FileType, IFileChange, IFileDeleteOptions, IFileOverwriteOptions, IFileSystemProviderWithFileReadWriteCapability, IFileWriteOptions, IStat, IWatchOptions, IndexedDBFileSystemProvider, OverlayFileSystemProvider, RegisteredFile, RegisteredFileSystemProvider, RegisteredMemoryFile, RegisteredReadOnlyFile, RegisteredUriFile, createIndexedDBProviders, getServiceOverride as default, initFile, registerCustomProvider, registerExtensionFile, registerFileSystemOverlay, registerHTMLFileSystemProvider };
