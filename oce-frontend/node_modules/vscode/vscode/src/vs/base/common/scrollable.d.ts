import { Event } from './event.js';
import { Disposable, IDisposable } from './lifecycle.js';

declare const enum ScrollbarVisibility {
    Auto = 1,
    Hidden = 2,
    Visible = 3
}
interface ScrollEvent {
    inSmoothScrolling: boolean;
    oldWidth: number;
    oldScrollWidth: number;
    oldScrollLeft: number;
    width: number;
    scrollWidth: number;
    scrollLeft: number;
    oldHeight: number;
    oldScrollHeight: number;
    oldScrollTop: number;
    height: number;
    scrollHeight: number;
    scrollTop: number;
    widthChanged: boolean;
    scrollWidthChanged: boolean;
    scrollLeftChanged: boolean;
    heightChanged: boolean;
    scrollHeightChanged: boolean;
    scrollTopChanged: boolean;
}
interface IScrollDimensions {
    readonly width: number;
    readonly scrollWidth: number;
    readonly height: number;
    readonly scrollHeight: number;
}
interface INewScrollDimensions {
    width?: number;
    scrollWidth?: number;
    height?: number;
    scrollHeight?: number;
}
interface IScrollPosition {
    readonly scrollLeft: number;
    readonly scrollTop: number;
}
interface INewScrollPosition {
    scrollLeft?: number;
    scrollTop?: number;
}
interface IScrollableOptions {
    /**
     * Define if the scroll values should always be integers.
     */
    forceIntegerValues: boolean;
    /**
     * Set the duration (ms) used for smooth scroll animations.
     */
    smoothScrollDuration: number;
    /**
     * A function to schedule an update at the next frame (used for smooth scroll animations).
     */
    scheduleAtNextAnimationFrame: (callback: () => void) => IDisposable;
}
declare class Scrollable extends Disposable {
    _scrollableBrand: void;
    private _smoothScrollDuration;
    private readonly _scheduleAtNextAnimationFrame;
    private _state;
    private _smoothScrolling;
    private _onScroll;
    readonly onScroll: Event<ScrollEvent>;
    constructor(options: IScrollableOptions);
    dispose(): void;
    setSmoothScrollDuration(smoothScrollDuration: number): void;
    validateScrollPosition(scrollPosition: INewScrollPosition): IScrollPosition;
    getScrollDimensions(): IScrollDimensions;
    setScrollDimensions(dimensions: INewScrollDimensions, useRawScrollPositions: boolean): void;
    /**
     * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.
     * If no scroll animation is occurring, it will return the current scroll position instead.
     */
    getFutureScrollPosition(): IScrollPosition;
    /**
     * Returns the current scroll position.
     * Note: This result might be an intermediate scroll position, as there might be an ongoing smooth scroll animation.
     */
    getCurrentScrollPosition(): IScrollPosition;
    setScrollPositionNow(update: INewScrollPosition): void;
    setScrollPositionSmooth(update: INewScrollPosition, reuseAnimation?: boolean): void;
    hasPendingScrollAnimation(): boolean;
    private _performSmoothScrolling;
    private _setState;
}

export { type INewScrollDimensions, type INewScrollPosition, type IScrollDimensions, type IScrollPosition, type IScrollableOptions, type ScrollEvent, Scrollable, ScrollbarVisibility };
