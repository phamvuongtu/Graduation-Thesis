type TypeConstraint = string | Function;
/**
 * Given an object with all optional properties, requires at least one to be defined.
 * i.e. AtLeastOne<MyObject>;
 */
type AtLeastOne<T, U = {
    [K in keyof T]: Pick<T, K>;
}> = Partial<T> & U[keyof U];
/**
 * Only picks the non-optional properties of a type.
 */
type OmitOptional<T> = {
    [K in keyof T as T[K] extends Required<T>[K] ? K : never]: T[K];
};
/**
 * A type that recursively makes all properties of `T` required
 */
type DeepRequiredNonNullable<T> = {
    [P in keyof T]-?: T[P] extends object ? DeepRequiredNonNullable<T[P]> : Required<NonNullable<T[P]>>;
};
/**
 * Represents a type that is a partial version of a given type `T`, where all properties are optional and can be deeply nested.
 */
type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : Partial<T[P]>;
};
/**
 * Represents a type that is a partial version of a given type `T`, except a subset.
 */
type PartialExcept<T, K extends keyof T> = Partial<Omit<T, K>> & Pick<T, K>;

export type { AtLeastOne, DeepPartial, DeepRequiredNonNullable, OmitOptional, PartialExcept, TypeConstraint };
