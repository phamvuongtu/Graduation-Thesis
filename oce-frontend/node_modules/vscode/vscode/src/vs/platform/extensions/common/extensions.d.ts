import { IJSONSchema } from '../../../base/common/jsonSchema.js';
import Severity from '../../../base/common/severity.js';
import { URI } from '../../../base/common/uri.js';
import { ILocalizedString } from '../../action/common/action.js';
import { ExtensionKind } from '../../environment/common/environment.js';

interface ICommand {
    /**
     * Identifier of the command to execute
     */
    readonly command: string;
    /**
     * Title by which the command is represented in the UI
     */
    readonly title: string | ILocalizedString;
    readonly shortTitle?: string;
    /**
     * (Optional) Category string by which the command is grouped in the UI
     */
    readonly category?: string | ILocalizedString;
    /**
     * (Optional) Condition which must be true to enable the command in the UI (menu and keybindings). Does not prevent executing the command by other means, like the `executeCommand`-api.
     */
    readonly enablement?: string;
    /**
     * (Optional) Icon which is used to represent the command in the UI. Either a file path, an object with file paths for dark and light themes, or a theme icon references, like `\$(zap)`
     */
    readonly icon?: string | {
        /**
         * Icon path when a light theme is used
         */
        readonly light?: string;
        /**
         * Icon path when a dark theme is used
         */
        readonly dark?: string;
    };
}
interface IConfiguration {
    /**
     * A title for the current category of settings. This label will be rendered in the Settings editor as a subheading. If the title is the same as the extension display name, then the category will be grouped under the main extension heading.
     */
    readonly title?: string;
    /**
     * When specified, gives the order of this category of settings relative to other categories.
     */
    readonly order?: number;
    /**
     * Description of the configuration properties.
     */
    readonly properties: {
        [key: string]: IJSONSchema;
    };
}
interface IDebugger {
    /**
     * Unique identifier for this debug adapter.
     */
    readonly type: string;
    /**
     * Display name for this debug adapter.
     */
    readonly label?: string;
    /**
     * Path to the debug adapter program. Path is either absolute or relative to the extension folder.
     */
    readonly program?: string;
    /**
     * Optional arguments to pass to the adapter.
     */
    readonly args?: unknown[];
    /**
     * Optional runtime in case the program attribute is not an executable but requires a runtime.
     */
    readonly runtime?: string;
    /**
     * Optional runtime arguments.
     */
    readonly runtimeArgs?: unknown[];
    /**
     * Mapping from interactive variables (e.g. ${action.pickProcess}) in `launch.json` to a command.
     */
    readonly variables?: {};
    /**
     * Configurations for generating the initial 'launch.json'.
     */
    readonly initialConfigurations?: unknown[] | string;
    /**
     * List of languages for which the debug extension could be considered the "default debugger".
     */
    readonly languages?: unknown[];
    /**
     * Snippets for adding new configurations in 'launch.json'.
     */
    readonly configurationSnippets?: unknown[];
    /**
     * JSON schema configurations for validating 'launch.json'.
     */
    readonly configurationAttributes?: {};
    /**
     * Condition which must be true to enable this type of debugger. Consider using 'shellExecutionSupported', 'virtualWorkspace', 'resourceScheme' or an extension-defined context key as appropriate for this.
     */
    readonly when?: string;
    /**
     * When this condition is true, this debugger type is hidden from the debugger list, but is still enabled.
     */
    readonly hiddenWhen?: string;
    /**
     * Optional message to mark this debug type as being deprecated.
     */
    readonly deprecated?: string;
    /**
     * Windows specific settings.
     */
    readonly windows?: {
        /**
         * Runtime used for Windows.
         */
        runtime?: string;
    };
    /**
     * macOS specific settings.
     */
    readonly osx?: {
        /**
         * Runtime used for macOS.
         */
        runtime?: string;
    };
    /**
     * Linux specific settings.
     */
    readonly linux?: {
        /**
         * Runtime used for Linux.
         */
        readonly runtime?: string;
    };
    /**
     * UI strings contributed by this debug adapter.
     */
    readonly strings?: {
        /**
         * When there are unverified breakpoints in a language supported by this debug adapter, this message will appear on the breakpoint hover and in the breakpoints view. Markdown and command links are supported.
         */
        readonly unverifiedBreakpoints?: string;
    };
}
interface IGrammar {
    /**
     * Language identifier for which this syntax is contributed to.
     */
    readonly language: string;
    /**
     * Textmate scope name used by the tmLanguage file.
     */
    readonly scopeName: string;
    /**
     * Path of the tmLanguage file. The path is relative to the extension folder and typically starts with './syntaxes/'.
     */
    readonly path: string;
    /**
     * A map of scope name to language id if this grammar contains embedded languages.
     */
    readonly embeddedLanguages?: {};
    /**
     * A map of scope name to token types.
     */
    readonly tokenTypes?: {
        [k: string]: 'string' | 'comment' | 'other';
    };
    /**
     * List of language scope names to which this grammar is injected to.
     */
    readonly injectTo?: string[];
    /**
     * Defines which scope names contain balanced brackets.
     */
    readonly balancedBracketScopes?: string[];
    /**
     * Defines which scope names do not contain balanced brackets.
     */
    readonly unbalancedBracketScopes?: string[];
}
interface IJSONValidation {
    /**
     * The file pattern (or an array of patterns) to match, for example "package.json" or "*.launch". Exclusion patterns start with '!'
     */
    readonly fileMatch?: string | string[];
    /**
     * A schema URL ('http:', 'https:') or relative path to the extension folder ('./').
     */
    readonly url: string;
}
interface IKeyBinding {
    /**
     * Identifier of the command to run when keybinding is triggered.
     */
    readonly command: string;
    /**
     * Arguments to pass to the command to execute.
     */
    readonly args?: {
        [k: string]: unknown;
    };
    /**
     * Key or key sequence (separate keys with plus-sign and sequences with space, e.g. Ctrl+O and Ctrl+L L for a chord).
     */
    readonly key: string;
    /**
     * Mac specific key or key sequence.
     */
    readonly mac?: string;
    /**
     * Linux specific key or key sequence.
     */
    readonly linux?: string;
    /**
     * Windows specific key or key sequence.
     */
    readonly win?: string;
    /**
     * Condition when the key is active.
     */
    readonly when?: string;
}
interface ILanguage {
    /**
     * ID of the language.
     */
    readonly id: string;
    /**
     * Name aliases for the language.
     */
    readonly aliases?: string[];
    /**
     * File extensions associated to the language.
     */
    readonly extensions?: string[];
    /**
     * File names associated to the language.
     */
    readonly filenames?: string[];
    /**
     * File name glob patterns associated to the language.
     */
    readonly filenamePatterns?: string[];
    /**
     * Mime types associated to the language.
     */
    readonly mimetypes?: string[];
    /**
     * A regular expression matching the first line of a file of the language.
     */
    readonly firstLine?: string;
    /**
     * A relative path to a file containing configuration options for the language.
     */
    readonly configuration?: string;
    /**
     * A icon to use as file icon, if no icon theme provides one for the language.
     */
    readonly icon?: {
        /**
         * Icon path when a light theme is used
         */
        readonly light?: string;
        /**
         * Icon path when a dark theme is used
         */
        readonly dark?: string;
    };
}
interface IMenu {
    /**
     * Identifier of the command to execute. The command must be declared in the 'commands'-section
     */
    readonly command: string;
    /**
     * Identifier of an alternative command to execute. The command must be declared in the 'commands'-section
     */
    readonly alt?: string;
    /**
     * Condition which must be true to show this item
     */
    readonly when?: string;
    /**
     * Group into which this item belongs
     */
    readonly group?: string;
}
interface ISnippet {
    /**
     * Language identifier for which this snippet is contributed to.
     */
    readonly language: string;
    /**
     * Path of the snippets file. The path is relative to the extension folder and typically starts with './snippets/'.
     */
    readonly path: string;
}
interface IColorTheme {
    /**
     * Id of the color theme as used in the user settings.
     */
    readonly id: string;
    /**
     * Label of the color theme as shown in the UI.
     */
    readonly label: string;
    /**
     * Base theme defining the colors around the editor: 'vs' is the light color theme, 'vs-dark' is the dark color theme. 'hc-black' is the dark high contrast theme, 'hc-light' is the light high contrast theme.
     */
    readonly uiTheme: 'vs' | 'vs-dark' | 'hc-black' | 'hc-light';
    /**
     * Path of the tmTheme file. The path is relative to the extension folder and is typically './colorthemes/awesome-color-theme.json'.
     */
    readonly path: string;
}
interface IIconTheme {
    /**
     * Id of the file icon theme as used in the user settings.
     */
    readonly id: string;
    /**
     * Label of the file icon theme as shown in the UI.
     */
    readonly label: string;
    /**
     * Path of the file icon theme definition file. The path is relative to the extension folder and is typically './fileicons/awesome-icon-theme.json'.
     */
    readonly path: string;
}
interface IProductTheme {
    /**
     * Id of the product icon theme as used in the user settings.
     */
    readonly id: string;
    /**
     * Label of the product icon theme as shown in the UI.
     */
    readonly label: string;
    /**
     * Path of the product icon theme definition file. The path is relative to the extension folder and is typically './producticons/awesome-product-icon-theme.json'.
     */
    readonly path: string;
}
interface IViewContainer {
    /**
     * Unique id used to identify the container in which views can be contributed using 'views' contribution point
     */
    readonly id: string;
    /**
     * Human readable string used to render the container
     */
    readonly title: string;
    /**
     * Path to the container icon. Icons are 24x24 centered on a 50x40 block and have a fill color of 'rgb(215, 218, 224)' or '#d7dae0'. It is recommended that icons be in SVG, though any image file type is accepted.
     */
    readonly icon: string;
}
interface IView {
    readonly type?: 'tree' | 'webview';
    readonly id: string;
    /**
     * The human-readable name of the view. Will be shown
     */
    readonly name: string;
    /**
     * Condition which must be true to show this view
     */
    readonly when?: string;
    /**
     * Path to the view icon. View icons are displayed when the name of the view cannot be shown. It is recommended that icons be in SVG, though any image file type is accepted.
     */
    readonly icon?: string;
    /**
     * Human-readable context for when the view is moved out of its original location. By default, the view's container name will be used.
     */
    readonly contextualTitle?: string;
    /**
     * Initial state of the view when the extension is first installed. Once the user has changed the view state by collapsing, moving, or hiding the view, the initial state will not be used again.
     */
    readonly visibility?: 'visible' | 'hidden' | 'collapsed';
    /**
     * The initial size of the view. The size will behave like the css 'flex' property, and will set the initial size when the view is first shown. In the side bar, this is the height of the view. This value is only respected when the same extension owns both the view and the view container.
     */
    readonly initialSize?: number;
}
interface IColor {
    /**
     * The identifier of the themable color
     */
    readonly id: string;
    /**
     * The description of the themable color
     */
    readonly description: string;
    readonly defaults: {
        /**
         * The default color for light themes. Either a color value in hex (#RRGGBB[AA]) or the identifier of a themable color which provides the default.
         */
        readonly light: string;
        /**
         * The default color for dark themes. Either a color value in hex (#RRGGBB[AA]) or the identifier of a themable color which provides the default.
         */
        readonly dark: string;
        /**
         * The default color for high contrast dark themes. Either a color value in hex (#RRGGBB[AA]) or the identifier of a themable color which provides the default. If not provided, the `dark` color is used as default for high contrast dark themes.
         */
        readonly highContrast?: string;
        /**
         * The default color for high contrast light themes. Either a color value in hex (#RRGGBB[AA]) or the identifier of a themable color which provides the default. If not provided, the `light` color is used as default for high contrast light themes.
         */
        readonly highContrastLight?: string;
    };
}
interface IWebviewEditor {
    readonly viewType: string;
    readonly priority: string;
    /**
     * Human readable name of the custom editor. This is displayed to users when selecting which editor to use.
     */
    readonly displayName: string;
    /**
     * Set of globs that the custom editor is enabled for.
     */
    readonly selector: {
        /**
         * Glob that the custom editor is enabled for.
         */
        readonly filenamePattern?: string;
    }[];
}
interface ICodeActionContributionAction {
    readonly kind: string;
    /**
     * Label for the code action used in the UI.
     */
    readonly title: string;
    /**
     * Description of what the code action does.
     */
    readonly description?: string;
}
interface ICodeActionContribution {
    /**
     * Language modes that the code actions are enabled for.
     */
    readonly languages: string[];
    readonly actions: readonly ICodeActionContributionAction[];
}
interface IAuthenticationContribution {
    /**
     * The id of the authentication provider.
     */
    readonly id: string;
    /**
     * The human readable name of the authentication provider.
     */
    readonly label: string;
}
interface IWalkthroughStep {
    /**
     * Unique identifier for this step. This is used to keep track of which steps have been completed.
     */
    readonly id: string;
    /**
     * Title of step.
     */
    readonly title: string;
    /**
     * Description of step. Supports ``preformatted``, __italic__, and **bold** text. Use markdown-style links for commands or external links: [Title](command:myext.command), [Title](command:toSide:myext.command), or [Title](https://aka.ms). Links on their own line will be rendered as buttons.
     */
    readonly description?: string;
    readonly button?: {
        [k: string]: unknown;
    };
    /**
     * Media to show alongside this step, either an image or markdown content.
     */
    readonly media: {
        readonly path?: {
            [k: string]: unknown;
        };
        /**
         * Path to an image - or object consisting of paths to light, dark, and hc images - relative to extension directory. Depending on context, the image will be displayed from 400px to 800px wide, with similar bounds on height. To support HIDPI displays, the image will be rendered at 1.5x scaling, for example a 900 physical pixels wide image will be displayed as 600 logical pixels wide.
         */
        readonly image: string | {
            /**
             * Path to the image for dark themes, relative to extension directory.
             */
            readonly dark: string;
            /**
             * Path to the image for light themes, relative to extension directory.
             */
            readonly light: string;
            /**
             * Path to the image for hc themes, relative to extension directory.
             */
            readonly hc: string;
            /**
             * Path to the image for hc light themes, relative to extension directory.
             */
            readonly hcLight: string;
        };
        /**
         * Alternate text to display when the image cannot be loaded or in screen readers.
         */
        readonly altText: string;
        readonly markdown?: never;
        readonly svg?: never;
    } | {
        /**
         * Path to an svg, color tokens are supported in variables to support theming to match the workbench.
         */
        readonly svg: string;
        /**
         * Alternate text to display when the image cannot be loaded or in screen readers.
         */
        readonly altText: string;
        readonly image?: never;
        readonly markdown?: never;
    } | {
        readonly path?: {
            [k: string]: unknown;
        };
        /**
         * Path to the markdown document, relative to extension directory.
         */
        readonly markdown: string;
        readonly image?: never;
        readonly svg?: never;
    };
    /**
     * Events that should trigger this step to become checked off. If empty or not defined, the step will check off when any of the step's buttons or links are clicked; if the step has no buttons or links it will check on when it is selected.
     */
    readonly completionEvents?: string[];
    /**
     * Signal to mark step as complete.
     * @deprecated use `completionEvents: 'onCommand:...'`
     **/
    readonly doneOn?: {
        command: string;
    };
    /**
     * Context key expression to control the visibility of this step.
     */
    readonly when?: string;
}
interface IWalkthrough {
    /**
     * Unique identifier for this walkthrough.
     */
    readonly id: string;
    /**
     * Title of walkthrough.
     */
    readonly title: string;
    /**
     * Relative path to the icon of the walkthrough. The path is relative to the extension location. If not specified, the icon defaults to the extension icon if available.
     */
    readonly icon?: string;
    /**
     * Description of walkthrough.
     */
    readonly description: string;
    /**
     * Walkthroughs that match one of these glob patterns appear as 'featured' in workspaces with the specified files. For example, a walkthrough for TypeScript projects might specify `tsconfig.json` here.
     */
    readonly featuredFor?: string[];
    /**
     * Context key expression to control the visibility of this walkthrough.
     */
    readonly when?: string;
    readonly steps: IWalkthroughStep[];
}
interface IStartEntry {
    readonly title: string;
    readonly description: string;
    readonly command: string;
    readonly when?: string;
    readonly category: 'file' | 'folder' | 'notebook';
}
interface INotebookEntry {
    /**
     * Type of the notebook.
     */
    readonly type: string;
    /**
     * Human readable name of the notebook.
     */
    readonly displayName: string;
    /**
     * Set of globs that the notebook is for.
     */
    readonly selector: {
        /**
         * Glob that the notebook is enabled for.
         */
        readonly filenamePattern?: string;
        /**
         * Glob that the notebook is disabled for.
         */
        readonly excludeFileNamePattern?: string;
    }[];
    readonly priority?: 'default' | 'option';
}
interface INotebookRendererContribution {
    /**
     * Unique identifier of the notebook output renderer.
     */
    readonly id: string;
    /**
     * Human readable name of the notebook output renderer.
     */
    readonly displayName: string;
    readonly dependencies?: string[];
    readonly optionalDependencies?: string[];
    /**
     * Defines how and if the renderer needs to communicate with an extension host, via `createRendererMessaging`. Renderers with stronger messaging requirements may not work in all environments.
     */
    readonly requiresMessaging?: 'always' | 'optional' | 'never';
    /**
     * Set of globs that the notebook is for.
     */
    readonly mimeTypes: string[];
    readonly entrypoint: string | {
        readonly extends: string;
        readonly path: string;
    };
}
interface IDebugVisualizationContribution {
    readonly id: string;
    readonly when: string;
}
interface ITranslation {
    /**
     * Id of VS Code or Extension for which this translation is contributed to. Id of VS Code is always `vscode` and of extension should be in format `publisherId.extensionName`.
     */
    readonly id: string;
    /**
     * A relative path to a file containing translations for the language.
     */
    readonly path: string;
}
interface ILocalizationContribution {
    /**
     * Id of the language into which the display strings are translated.
     */
    readonly languageId: string;
    /**
     * Name of the language in English.
     */
    readonly languageName?: string;
    /**
     * Name of the language in contributed language.
     */
    readonly localizedLanguageName?: string;
    /**
     *
     */
    readonly translations: ITranslation[];
}
interface ITerminal {
    readonly profiles?: {
        readonly id: string;
        readonly title: string;
        readonly icon?: (string | {
            /**
             * Icon path when a light theme is used
             */
            readonly light?: string;
            /**
             * Icon path when a dark theme is used
             */
            readonly dark?: string;
            [k: string]: unknown;
        });
    }[];
}
interface IStatusBarItem {
    readonly id: string;
    /**
     * The name of the entry, like 'Python Language Indicator', 'Git Status' etc. Try to keep the length of the name short, yet descriptive enough that users can understand what the status bar item is about.
     */
    readonly name: string;
    /**
     * The text to show for the entry. You can embed icons in the text by leveraging the `$(<name>)`-syntax, like 'Hello $(globe)!'
     */
    readonly text: string;
    /**
     * The tooltip text for the entry.
     */
    readonly tooltip?: string;
    /**
     * The command to execute when the status bar entry is clicked.
     */
    readonly command?: string;
    /**
     * The alignment of the status bar entry.
     */
    readonly alignment: 'left' | 'right';
    /**
     * The priority of the status bar entry. Higher value means the item should be shown more to the left.
     */
    readonly priority?: number;
    /**
     * Defines the role and aria label to be used when the status bar entry is focused.
     */
    readonly accessibilityInformation?: {
        /**
         * The role of the status bar entry which defines how a screen reader interacts with it. More about aria roles can be found here https://w3c.github.io/aria/#widget_roles
         */
        readonly role?: string;
        /**
         * The aria label of the status bar entry. Defaults to the entry's text.
         */
        readonly label?: string;
    };
}
interface IRemoteHelp {
    /**
     * The url, or a command that returns the url, to your project's Getting Started page, or a walkthrough ID contributed by your project's extension
     */
    readonly getStarted?: string | {
        /**
         * The ID of a Get Started walkthrough to open.
         */
        id: string;
    };
    /**
     * The url, or a command that returns the url, to your project's documentation page
     */
    readonly documentation?: string;
    /**
     * The url, or a command that returns the url, to your project's feedback reporter
     */
    readonly feedback?: string;
    /**
     * The url, or a command that returns the url, to your project's issue reporter
     */
    readonly reportIssue?: string;
    /**
     * The url, or a command that returns the url, to your project's issues list
     */
    readonly issues?: string;
}
interface ITaskDefinitions {
    /**
     * The actual task type. Please note that types starting with a '$' are reserved for internal usage.
     */
    readonly type?: string;
    readonly required?: string[];
    /**
     * Additional properties of the task type
     */
    readonly properties?: {
        [k: string]: IJSONSchema;
    };
    readonly when?: string;
}
interface IIcon {
    /**
     * The description of the themable icon
     */
    readonly description: string;
    /**
     * The default of the icon. Either a reference to an extisting ThemeIcon or an icon in an icon font.
     */
    readonly default: string | {
        /**
         * The path of the icon font that defines the icon.
         */
        readonly fontPath: string;
        /**
         * The character for the icon in the icon font.
         */
        readonly fontCharacter: string;
    };
}
interface IDocumentationRefactoring {
    /**
     * Label for the documentation used in the UI.
     */
    readonly title: string;
    /**
     * When clause.
     */
    readonly when: string;
    /**
     * Command executed.
     */
    readonly command: string;
}
interface IDocumentation {
    /**
     * Contributed documentation for refactorings.
     */
    readonly refactoring?: IDocumentationRefactoring[];
}
interface ISubMenu {
    /**
     * Identifier of the submenu to display in this item.
     */
    readonly submenu: string;
    /**
     * Condition which must be true to show this item
     */
    readonly when?: string;
    /**
     * Group into which this item belongs
     */
    readonly group?: string;
}
interface ISubMenu {
    /**
     * Identifier of the menu to display as a submenu.
     */
    readonly id: string;
    /**
     * The label of the menu item which leads to this submenu.
     */
    readonly label: string;
    /**
     * (Optional) Icon which is used to represent the submenu in the UI. Either a file path, an object with file paths for dark and light themes, or a theme icon references, like `\$(zap)`
     */
    readonly icon?: string | {
        /**
         * Icon path when a light theme is used
         */
        readonly light?: string;
        /**
         * Icon path when a dark theme is used
         */
        readonly dark?: string;
    };
}
interface IResourceLabelFormatters {
    /**
     * URI scheme on which to match the formatter on. For example "file". Simple glob patterns are supported.
     */
    readonly scheme: string;
    /**
     * URI authority on which to match the formatter on. Simple glob patterns are supported.
     */
    readonly authority?: string;
    /**
     * Rules for formatting uri resource labels.
     */
    readonly formatting: {
        /**
         * Label rules to display. For example: myLabel:/${path}. ${path}, ${scheme}, ${authority} and ${authoritySuffix} are supported as variables.
         */
        readonly label?: string;
        /**
         * Separator to be used in the uri label display. '/' or '' as an example.
         */
        readonly separator?: string;
        /**
         * Controls whether `${path}` substitutions should have starting separator characters stripped.
         */
        readonly stripPathStartingSeparator?: boolean;
        /**
         * Controls if the start of the uri label should be tildified when possible.
         */
        readonly tildify?: boolean;
        /**
         * Suffix appended to the workspace label.
         */
        readonly workspaceSuffix?: string;
    };
}
interface ISemanticTokenTypes {
    /**
     * The identifier of the semantic token type
     */
    readonly id?: string;
    /**
     * The super type of the semantic token type
     */
    readonly superType?: string;
    /**
     * The description of the semantic token type
     */
    readonly description?: string;
}
interface ISemanticTokenModifiers {
    /**
     * The identifier of the semantic token modifier
     */
    readonly id?: string;
    /**
     * The description of the semantic token modifier
     */
    readonly description?: string;
}
interface ISemanticTokenScopes {
    /**
     * Lists the languge for which the defaults are.
     */
    readonly language?: string;
    /**
     * Maps a semantic token (described by semantic token selector) to one or more textMate scopes used to represent that token.
     */
    readonly scopes?: {
        [k: string]: string[];
    };
}
interface IBreakpoint {
    /**
     * Allow breakpoints for this language.
     */
    readonly language?: string;
    /**
     * Condition which must be true to enable breakpoints in this language. Consider matching this to the debugger when clause as appropriate.
     */
    readonly when?: string;
}
interface ITerminalQuickFix {
    /**
     * The ID of the quick fix provider
     */
    readonly id: string;
    /**
     * A regular expression or string to test the command line against
     */
    readonly commandLineMatcher: string;
    readonly outputMatcher: {
        /**
         * A regular expression or string to test the command line against
         */
        readonly lineMatcher: string;
        /**
         * Where the search should begin in the buffer
         */
        readonly anchor: 'top' | 'bottom';
        /**
         * The number of lines vertically from the anchor in the buffer to start matching against
         */
        readonly offset: number;
        /**
         * The number of rows to match against, this should be as small as possible for performance reasons
         */
        readonly length: number;
    };
    /**
     * The command exit result to match on
     */
    readonly commandExitResult: 'success' | 'error';
    /**
     * The kind of the resulting quick fix. This changes how the quick fix is presented. Defaults to `"fix"`.
     */
    readonly kind?: 'default' | 'explain';
}
interface IInteractiveSession {
    /**
     * Unique identifier for this Interactive Session provider.
     */
    readonly id: string;
    /**
     * Display name for this Interactive Session provider.
     */
    readonly label: string;
    /**
     * An icon for this Interactive Session provider.
     */
    readonly icon?: string;
    /**
     * A condition which must be true to enable this Interactive Session provider.
     */
    readonly when?: string;
}
interface NotebookPreload {
    /**
     * Type of the notebook.
     */
    readonly type: string;
    /**
     * Path to file loaded in the webview.
     */
    readonly entrypoint: string;
    /**
     * Paths to additional resources that should be allowed in the webview.
     */
    readonly localResourceRoots?: string[];
}
interface IViewsWelcome {
    readonly view: string;
    /**
     * Welcome content to be displayed. The format of the contents is a subset of Markdown, with support for links only.
     */
    readonly contents: string;
    /**
     * Condition when the welcome content should be displayed.
     */
    readonly when?: string;
    /**
     * Group to which this welcome content belongs. Proposed API.
     */
    readonly group?: string;
    /**
     * Condition when the welcome content buttons and command links should be enabled.
     */
    readonly enablement?: string;
}
interface INamedProblemPattern extends IProblemPattern {
    /**
     * The name of the problem pattern.
     */
    name: string;
    /**
     * A human readable label
     */
    label?: string;
}
interface ICheckedProblemPattern extends IProblemPattern {
    /**
    * The regular expression to find a problem in the console output of an
    * executed task.
    */
    regexp: string;
}
type MultiLineCheckedProblemPattern = ICheckedProblemPattern[];
interface INamedMultiLineCheckedProblemPattern {
    /**
     * The name of the problem pattern.
     */
    name: string;
    /**
     * A human readable label
     */
    label?: string;
    /**
     * The actual patterns
     */
    patterns: MultiLineCheckedProblemPattern;
}
type NamedProblemPatterns = (INamedProblemPattern | INamedMultiLineCheckedProblemPattern)[];
interface IProblemPattern {
    /**
    * The regular expression to find a problem in the console output of an
    * executed task.
    */
    regexp?: string;
    /**
    * Whether the pattern matches a whole file, or a location (file/line)
    *
    * The default is to match for a location. Only valid on the
    * first problem pattern in a multi line problem matcher.
    */
    kind?: string;
    /**
    * The match group index of the filename.
    * If omitted 1 is used.
    */
    file?: number;
    /**
    * The match group index of the problem's location. Valid location
    * patterns are: (line), (line,column) and (startLine,startColumn,endLine,endColumn).
    * If omitted the line and column properties are used.
    */
    location?: number;
    /**
    * The match group index of the problem's line in the source file.
    *
    * Defaults to 2.
    */
    line?: number;
    /**
    * The match group index of the problem's column in the source file.
    *
    * Defaults to 3.
    */
    column?: number;
    /**
    * The match group index of the problem's end line in the source file.
    *
    * Defaults to undefined. No end line is captured.
    */
    endLine?: number;
    /**
    * The match group index of the problem's end column in the source file.
    *
    * Defaults to undefined. No end column is captured.
    */
    endColumn?: number;
    /**
    * The match group index of the problem's severity.
    *
    * Defaults to undefined. In this case the problem matcher's severity
    * is used.
    */
    severity?: number;
    /**
    * The match group index of the problem's code.
    *
    * Defaults to undefined. No code is captured.
    */
    code?: number;
    /**
    * The match group index of the message. If omitted it defaults
    * to 4 if location is specified. Otherwise it defaults to 5.
    */
    message?: number;
    /**
    * Specifies if the last pattern in a multi line problem matcher should
    * loop as long as it does match a line consequently. Only valid on the
    * last problem pattern in a multi line problem matcher.
    */
    loop?: boolean;
}
/**
* A watching pattern
*/
interface IWatchingPattern {
    /**
    * The actual regular expression
    */
    regexp?: string;
    /**
    * The match group index of the filename. If provided the expression
    * is matched for that file only.
    */
    file?: number;
}
/**
* A description to track the start and end of a watching task.
*/
interface IBackgroundMonitor {
    /**
    * If set to true the watcher is in active mode when the task
    * starts. This is equals of issuing a line that matches the
    * beginsPattern.
    */
    activeOnStart?: boolean;
    /**
    * If matched in the output the start of a watching task is signaled.
    */
    beginsPattern?: string | IWatchingPattern;
    /**
    * If matched in the output the end of a watching task is signaled.
    */
    endsPattern?: string | IWatchingPattern;
}
interface INamedProblemMatcher {
    /**
    * This name can be used to refer to the
    * problem matcher from within a task.
    */
    name: string;
    /**
     * A human readable label.
     */
    label?: string;
    /**
     * The name of a base problem matcher to use. If specified the
     * base problem matcher will be used as a template and properties
     * specified here will replace properties of the base problem
     * matcher
     */
    base?: string;
    /**
     * The owner of the produced VSCode problem. This is typically
     * the identifier of a VSCode language service if the problems are
     * to be merged with the one produced by the language service
     * or a generated internal id. Defaults to the generated internal id.
     */
    owner?: string;
    /**
     * A human-readable string describing the source of this problem.
     * E.g. 'typescript' or 'super lint'.
     */
    source?: string;
    /**
    * Specifies to which kind of documents the problems found by this
    * matcher are applied. Valid values are:
    *
    *   "allDocuments": problems found in all documents are applied.
    *   "openDocuments": problems found in documents that are open
    *   are applied.
    *   "closedDocuments": problems found in closed documents are
    *   applied.
    */
    applyTo?: string;
    /**
    * The severity of the VSCode problem produced by this problem matcher.
    *
    * Valid values are:
    *   "error": to produce errors.
    *   "warning": to produce warnings.
    *   "info": to produce infos.
    *
    * The value is used if a pattern doesn't specify a severity match group.
    * Defaults to "error" if omitted.
    */
    severity?: string;
    /**
    * Defines how filename reported in a problem pattern
    * should be read. Valid values are:
    *  - "absolute": the filename is always treated absolute.
    *  - "relative": the filename is always treated relative to
    *    the current working directory. This is the default.
    *  - ["relative", "path value"]: the filename is always
    *    treated relative to the given path value.
    *  - "autodetect": the filename is treated relative to
    *    the current workspace directory, and if the file
    *    does not exist, it is treated as absolute.
    *  - ["autodetect", "path value"]: the filename is treated
    *    relative to the given path value, and if it does not
    *    exist, it is treated as absolute.
    *  - ["search", { include?: "" | []; exclude?: "" | [] }]: The filename
    *    needs to be searched under the directories named by the "include"
    *    property and their nested subdirectories. With "exclude" property
    *    present, the directories should be removed from the search. When
    *    `include` is not unprovided, the current workspace directory should
    *    be used as the default.
    */
    fileLocation?: string | string[] | ['search', ISearchFileLocationArgs];
    /**
    * The name of a predefined problem pattern, the inline definition
    * of a problem pattern or an array of problem patterns to match
    * problems spread over multiple lines.
    */
    pattern?: string | IProblemPattern | IProblemPattern[];
    /**
    * A regular expression signaling that a watched tasks begins executing
    * triggered through file watching.
    */
    watchedTaskBeginsRegExp?: string;
    /**
    * A regular expression signaling that a watched tasks ends executing.
    */
    watchedTaskEndsRegExp?: string;
    /**
     * @deprecated Use background instead.
     */
    watching?: IBackgroundMonitor;
    background?: IBackgroundMonitor;
}
type ISearchFileLocationArgs = {
    include?: string | string[];
    exclude?: string | string[];
};
interface ITypescriptServerPlugin {
    /**
     * Name of the plugin as listed in the package.json.
     */
    name: string;
    /**
     * Should the plugin be loaded when using workspace versions of TypeScript?
     */
    enableForWorkspaceTypeScriptVersions: boolean;
}
interface IHtmlLanguageParticipant {
    /**
     * The id of the language that participates with HTML language server.
     */
    languageId: string;
    /**
     * Whether the language participates with HTML auto insertions. If not specified, defaults to <code>true</code>.
     */
    autoInsert: boolean;
}
interface IExtensionContributions {
    /**
     * Contributes terminal functionality.
     */
    readonly terminal?: ITerminal;
    /**
     * Contributes commands to the command palette.
     */
    readonly commands?: ICommand[];
    /**
     * Contributes configuration settings.
     */
    readonly configuration?: IConfiguration | IConfiguration[];
    /**
     * Contributes debug adapters.
     */
    readonly debuggers?: IDebugger[];
    /**
     * Contributes breakpoints.
     */
    readonly breakpoints?: IBreakpoint[];
    /**
     * Contributes textmate tokenizers.
     */
    readonly grammars?: IGrammar[];
    /**
     * Contributes json schema configuration.
     */
    readonly jsonValidation?: IJSONValidation[];
    /**
     * Contributes keybindings.
     */
    readonly keybindings?: IKeyBinding[];
    /**
     * Contributes language declarations.
     */
    readonly languages?: ILanguage[];
    /**
     * Contributes menu items to the editor
     */
    readonly menus?: {
        [context: string]: IMenu[];
    };
    /**
     * Contributes submenu items to the editor
     */
    readonly submenus?: ISubMenu[];
    /**
     * Contributes snippets.
     */
    readonly snippets?: ISnippet[];
    /**
     * Contributes textmate color themes.
     */
    readonly themes?: IColorTheme[];
    /**
     * Contributes file icon themes.
     */
    readonly iconThemes?: IIconTheme[];
    /**
     * Contributes product icon themes.
     */
    readonly productIconThemes?: IProductTheme[];
    /**
     * Contributes views containers to the editor
     */
    readonly viewsContainers?: {
        [location: string]: IViewContainer[];
    };
    /**
     * Contributes views to the editor
     */
    readonly views?: {
        [location: string]: IView[];
    };
    /**
     * Contributes extension defined themable colors
     */
    readonly colors?: IColor[];
    /**
     * Contributes localizations to the editor
     */
    readonly localizations?: ILocalizationContribution[];
    /**
     * Contributed custom editors.
     */
    readonly customEditors?: readonly IWebviewEditor[];
    readonly codeActions?: readonly ICodeActionContribution[];
    /**
     * Contributes authentication
     */
    readonly authentication?: IAuthenticationContribution[];
    /**
     * Contribute walkthroughs to help users getting started with your extension.
     */
    readonly walkthroughs?: IWalkthrough[];
    readonly startEntries?: IStartEntry[];
    /**
     * Contributes notebook document provider.
     */
    readonly notebooks?: INotebookEntry[];
    /**
     * Contributes notebook output renderer provider.
     */
    readonly notebookRenderer?: INotebookRendererContribution[];
    readonly debugVisualizers?: IDebugVisualizationContribution[];
    readonly chatParticipants?: ReadonlyArray<{
        id: string;
    }>;
    /**
     * Contributes notebook preloads.
     */
    readonly notebookPreload?: NotebookPreload[];
    /**
     * Contributes items to the status bar.
     */
    readonly statusBarItems?: IStatusBarItem[];
    /**
     * Contributes help information for Remote
     */
    readonly remoteHelp?: IRemoteHelp;
    /**
     * Contributes task kinds
     */
    readonly taskDefinitions?: ITaskDefinitions[];
    /**
     * Contributes extension defined themable icons
     */
    readonly icons?: {
        [id: string]: IIcon;
    };
    /**
     * Contributed documentation.
     */
    readonly documentation?: IDocumentation;
    /**
     * Contributes resource label formatting rules.
     */
    readonly resourceLabelFormatters?: IResourceLabelFormatters[];
    readonly configurationDefaults?: {
        [id: string]: any;
    };
    /**
     * Contributes semantic token types.
     */
    readonly semanticTokenTypes?: ISemanticTokenTypes[];
    /**
     * Contributes semantic token modifiers.
     */
    readonly semanticTokenModifiers?: ISemanticTokenModifiers[];
    /**
     * Contributes semantic token scope maps.
     */
    readonly semanticTokenScopes?: ISemanticTokenScopes[];
    /**
     * Contributes terminal quick fixes.
     */
    readonly terminalQuickFixes?: ITerminalQuickFix[];
    /**
     * Contributes an Interactive Session provider
     */
    readonly interactiveSession?: IInteractiveSession[];
    /**
     * Contributed views welcome content. Welcome content will be rendered in tree based views whenever they have no meaningful content to display, ie. the File Explorer when no folder is open. Such content is useful as in-product documentation to drive users to use certain features before they are available. A good example would be a `Clone Repository` button in the File Explorer welcome view.
     */
    readonly viewsWelcome?: IViewsWelcome[];
    /**
     * Contributes problem matchers
     */
    readonly problemMatchers?: INamedProblemMatcher[];
    /**
     * Contributes problem patterns
     */
    readonly problemPatterns?: NamedProblemPatterns;
    /**
     * Contributed TypeScript server plugins.
     */
    readonly typescriptServerPlugins?: ITypescriptServerPlugin[];
    /**
     * A list of languages that participate with the HTML language server.
     */
    readonly htmlLanguageParticipants?: IHtmlLanguageParticipant[];
    readonly html?: {
        customData?: string[];
    };
    readonly css?: {
        customData?: string[];
    };
}
interface IExtensionCapabilities {
    readonly virtualWorkspaces?: ExtensionVirtualWorkspaceSupport;
    readonly untrustedWorkspaces?: ExtensionUntrustedWorkspaceSupport;
}
type LimitedWorkspaceSupportType = 'limited';
type ExtensionUntrustedWorkspaceSupportType = boolean | LimitedWorkspaceSupportType;
type ExtensionUntrustedWorkspaceSupport = {
    supported: true;
} | {
    supported: false;
    description: string;
} | {
    supported: LimitedWorkspaceSupportType;
    description: string;
    restrictedConfigurations?: string[];
};
type ExtensionVirtualWorkspaceSupportType = boolean | LimitedWorkspaceSupportType;
type ExtensionVirtualWorkspaceSupport = boolean | {
    supported: true;
} | {
    supported: false | LimitedWorkspaceSupportType;
    description: string;
};
interface IExtensionIdentifier {
    id: string;
    uuid?: string;
}
interface IRelaxedExtensionManifest {
    name: string;
    displayName?: string;
    publisher: string;
    version: string;
    engines: {
        readonly vscode: string;
    };
    description?: string;
    main?: string;
    browser?: string;
    preview?: boolean;
    l10n?: string;
    icon?: string;
    categories?: string[];
    keywords?: string[];
    activationEvents?: string[];
    extensionDependencies?: string[];
    extensionPack?: string[];
    extensionKind?: ExtensionKind | ExtensionKind[];
    contributes?: IExtensionContributions;
    repository?: {
        url: string;
    };
    bugs?: {
        url: string;
    };
    enabledApiProposals?: readonly string[];
    api?: string;
    scripts?: {
        [key: string]: string;
    };
    capabilities?: IExtensionCapabilities;
}
type IExtensionManifest = Readonly<IRelaxedExtensionManifest>;
declare const enum ExtensionType {
    System = 0,
    User = 1
}
declare const enum TargetPlatform {
    WIN32_X64 = "win32-x64",
    WIN32_ARM64 = "win32-arm64",
    LINUX_X64 = "linux-x64",
    LINUX_ARM64 = "linux-arm64",
    LINUX_ARMHF = "linux-armhf",
    ALPINE_X64 = "alpine-x64",
    ALPINE_ARM64 = "alpine-arm64",
    DARWIN_X64 = "darwin-x64",
    DARWIN_ARM64 = "darwin-arm64",
    WEB = "web",
    UNIVERSAL = "universal",
    UNKNOWN = "unknown",
    UNDEFINED = "undefined"
}
interface IExtension {
    readonly type: ExtensionType;
    readonly isBuiltin: boolean;
    readonly identifier: IExtensionIdentifier;
    readonly manifest: IExtensionManifest;
    readonly location: URI;
    readonly targetPlatform: TargetPlatform;
    readonly publisherDisplayName?: string;
    readonly readmeUrl?: URI;
    readonly changelogUrl?: URI;
    readonly isValid: boolean;
    readonly validations: readonly [Severity, string][];
}
/**
 * **!Do not construct directly!**
 *
 * **!Only static methods because it gets serialized!**
 *
 * This represents the "canonical" version for an extension identifier. Extension ids
 * have to be case-insensitive (due to the marketplace), but we must ensure case
 * preservation because the extension API is already public at this time.
 *
 * For example, given an extension with the publisher `"Hello"` and the name `"World"`,
 * its canonical extension identifier is `"Hello.World"`. This extension could be
 * referenced in some other extension's dependencies using the string `"hello.world"`.
 *
 * To make matters more complicated, an extension can optionally have an UUID. When two
 * extensions have the same UUID, they are considered equal even if their identifier is different.
 */
declare class ExtensionIdentifier {
    readonly value: string;
    /**
     * Do not use directly. This is public to avoid mangling and thus
     * allow compatibility between running from source and a built version.
     */
    readonly _lower: string;
    constructor(value: string);
    static equals(a: ExtensionIdentifier | string | null | undefined, b: ExtensionIdentifier | string | null | undefined): boolean;
    /**
     * Gives the value by which to index (for equality).
     */
    static toKey(id: ExtensionIdentifier | string): string;
}
declare class ExtensionIdentifierMap<T> {
    private readonly _map;
    clear(): void;
    delete(id: ExtensionIdentifier | string): void;
    get(id: ExtensionIdentifier | string): T | undefined;
    has(id: ExtensionIdentifier | string): boolean;
    set(id: ExtensionIdentifier | string, value: T): void;
    values(): IterableIterator<T>;
    forEach(callbackfn: (value: T, key: string, map: Map<string, T>) => void): void;
    [Symbol.iterator](): IterableIterator<[string, T]>;
}
interface IRelaxedExtensionDescription extends IRelaxedExtensionManifest {
    id?: string;
    identifier: ExtensionIdentifier;
    uuid?: string;
    publisherDisplayName?: string;
    targetPlatform: TargetPlatform;
    isBuiltin: boolean;
    isUserBuiltin: boolean;
    isUnderDevelopment: boolean;
    extensionLocation: URI;
}
type IExtensionDescription = Readonly<IRelaxedExtensionDescription>;

export { ExtensionIdentifier, ExtensionIdentifierMap, ExtensionType, type ExtensionUntrustedWorkspaceSupport, type ExtensionUntrustedWorkspaceSupportType, type ExtensionVirtualWorkspaceSupport, type ExtensionVirtualWorkspaceSupportType, type IAuthenticationContribution, type IBackgroundMonitor, type IBreakpoint, type ICheckedProblemPattern, type ICodeActionContribution, type ICodeActionContributionAction, type IColor, type IColorTheme, type ICommand, type IConfiguration, type IDebugVisualizationContribution, type IDebugger, type IDocumentation, type IDocumentationRefactoring, type IExtension, type IExtensionCapabilities, type IExtensionContributions, type IExtensionDescription, type IExtensionIdentifier, type IExtensionManifest, type IGrammar, type IHtmlLanguageParticipant, type IIcon, type IIconTheme, type IInteractiveSession, type IJSONValidation, type IKeyBinding, type ILanguage, type ILocalizationContribution, type IMenu, type INamedMultiLineCheckedProblemPattern, type INamedProblemMatcher, type INamedProblemPattern, type INotebookEntry, type INotebookRendererContribution, type IProblemPattern, type IProductTheme, type IRelaxedExtensionDescription, type IRelaxedExtensionManifest, type IRemoteHelp, type ISearchFileLocationArgs, type ISemanticTokenModifiers, type ISemanticTokenScopes, type ISemanticTokenTypes, type ISnippet, type IStartEntry, type IStatusBarItem, type ISubMenu, type ITaskDefinitions, type ITerminal, type ITerminalQuickFix, type ITranslation, type ITypescriptServerPlugin, type IView, type IViewContainer, type IViewsWelcome, type IWalkthrough, type IWalkthroughStep, type IWatchingPattern, type LimitedWorkspaceSupportType, type MultiLineCheckedProblemPattern, type NamedProblemPatterns, type NotebookPreload, TargetPlatform };
