import { Event } from '../../../base/common/event.js';
import { IDisposable, Disposable } from '../../../base/common/lifecycle.js';
import { URI } from '../../../base/common/uri.js';

declare enum LogLevel {
    Off = 0,
    Trace = 1,
    Debug = 2,
    Info = 3,
    Warning = 4,
    Error = 5
}
interface ILogger extends IDisposable {
    onDidChangeLogLevel: Event<LogLevel>;
    getLevel(): LogLevel;
    setLevel(level: LogLevel): void;
    trace(message: string, ...args: any[]): void;
    debug(message: string, ...args: any[]): void;
    info(message: string, ...args: any[]): void;
    warn(message: string, ...args: any[]): void;
    error(message: string | Error, ...args: any[]): void;
    /**
     * An operation to flush the contents. Can be synchronous.
     */
    flush(): void;
}
interface ILoggerOptions {
    /**
     * Id of the logger.
     */
    id?: string;
    /**
     * Name of the logger.
     */
    name?: string;
    /**
     * Do not create rotating files if max size exceeds.
     */
    donotRotate?: boolean;
    /**
     * Do not use formatters.
     */
    donotUseFormatters?: boolean;
    /**
     * When to log. Set to `always` to log always.
     */
    logLevel?: 'always' | LogLevel;
    /**
     * Whether the log should be hidden from the user.
     */
    hidden?: boolean;
    /**
     * Condition which must be true to show this logger
     */
    when?: string;
    /**
     * Id of the extension that created this logger.
     */
    extensionId?: string;
}
interface ILoggerResource {
    readonly resource: URI;
    readonly id: string;
    readonly name?: string;
    readonly logLevel?: LogLevel;
    readonly hidden?: boolean;
    readonly when?: string;
    readonly extensionId?: string;
}
type DidChangeLoggersEvent = {
    readonly added: Iterable<ILoggerResource>;
    readonly removed: Iterable<ILoggerResource>;
};
declare abstract class AbstractLogger extends Disposable implements ILogger {
    private level;
    private readonly _onDidChangeLogLevel;
    readonly onDidChangeLogLevel: Event<LogLevel>;
    setLevel(level: LogLevel): void;
    getLevel(): LogLevel;
    protected checkLogLevel(level: LogLevel): boolean;
    abstract trace(message: string, ...args: any[]): void;
    abstract debug(message: string, ...args: any[]): void;
    abstract info(message: string, ...args: any[]): void;
    abstract warn(message: string, ...args: any[]): void;
    abstract error(message: string | Error, ...args: any[]): void;
    abstract flush(): void;
}
declare class ConsoleLogger extends AbstractLogger implements ILogger {
    private readonly useColors;
    constructor(logLevel?: LogLevel, useColors?: boolean);
    trace(message: string, ...args: any[]): void;
    debug(message: string, ...args: any[]): void;
    info(message: string, ...args: any[]): void;
    warn(message: string | Error, ...args: any[]): void;
    error(message: string, ...args: any[]): void;
    flush(): void;
}

export { AbstractLogger, ConsoleLogger, type DidChangeLoggersEvent, type ILogger, type ILoggerOptions, type ILoggerResource, LogLevel };
