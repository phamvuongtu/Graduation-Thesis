import { ServiceIdentifier } from '../../instantiation/common/instantiation.js';
import { Event } from '../../../base/common/event.js';
import { DisposableStore } from '../../../base/common/lifecycle.js';
import { StorageValue } from '../../../base/parts/storage/common/storage.js';
import { IUserDataProfile } from '../../userDataProfile/common/userDataProfile.js';
import { IAnyWorkspaceIdentifier } from '../../workspace/common/workspace.js';
import { StorageScope, IWorkspaceStorageValueChangeEvent, IProfileStorageValueChangeEvent, IApplicationStorageValueChangeEvent, IStorageValueChangeEvent, IStorageTargetChangeEvent, IWillSaveStateEvent, StorageTarget, IStorageEntry, WillSaveStateReason } from './storage.js';

declare const IStorageService: ServiceIdentifier<IStorageService>;
interface IStorageService {
    readonly _serviceBrand: undefined;
    /**
    * Emitted whenever data is updated or deleted on the given
    * scope and optional key.
    *
    * @param scope the `StorageScope` to listen to changes
    * @param key the optional key to filter for or all keys of
    * the scope if `undefined`
    */
    onDidChangeValue(scope: StorageScope.WORKSPACE, key: string | undefined, disposable: DisposableStore): Event<IWorkspaceStorageValueChangeEvent>;
    onDidChangeValue(scope: StorageScope.PROFILE, key: string | undefined, disposable: DisposableStore): Event<IProfileStorageValueChangeEvent>;
    onDidChangeValue(scope: StorageScope.APPLICATION, key: string | undefined, disposable: DisposableStore): Event<IApplicationStorageValueChangeEvent>;
    onDidChangeValue(scope: StorageScope, key: string | undefined, disposable: DisposableStore): Event<IStorageValueChangeEvent>;
    /**
    * Emitted whenever target of a storage entry changes.
    */
    readonly onDidChangeTarget: Event<IStorageTargetChangeEvent>;
    /**
    * Emitted when the storage is about to persist. This is the right time
    * to persist data to ensure it is stored before the application shuts
    * down.
    *
    * The will save state event allows to optionally ask for the reason of
    * saving the state, e.g. to find out if the state is saved due to a
    * shutdown.
    *
    * Note: this event may be fired many times, not only on shutdown to prevent
    * loss of state in situations where the shutdown is not sufficient to
    * persist the data properly.
    */
    readonly onWillSaveState: Event<IWillSaveStateEvent>;
    /**
    * Retrieve an element stored with the given key from storage. Use
    * the provided `defaultValue` if the element is `null` or `undefined`.
    *
    * @param scope allows to define the scope of the storage operation
    * to either the current workspace only, all workspaces or all profiles.
    */
    get(key: string, scope: StorageScope, fallbackValue: string): string;
    get(key: string, scope: StorageScope, fallbackValue?: string): string | undefined;
    /**
    * Retrieve an element stored with the given key from storage. Use
    * the provided `defaultValue` if the element is `null` or `undefined`.
    * The element will be converted to a `boolean`.
    *
    * @param scope allows to define the scope of the storage operation
    * to either the current workspace only, all workspaces or all profiles.
    */
    getBoolean(key: string, scope: StorageScope, fallbackValue: boolean): boolean;
    getBoolean(key: string, scope: StorageScope, fallbackValue?: boolean): boolean | undefined;
    /**
    * Retrieve an element stored with the given key from storage. Use
    * the provided `defaultValue` if the element is `null` or `undefined`.
    * The element will be converted to a `number` using `parseInt` with a
    * base of `10`.
    *
    * @param scope allows to define the scope of the storage operation
    * to either the current workspace only, all workspaces or all profiles.
    */
    getNumber(key: string, scope: StorageScope, fallbackValue: number): number;
    getNumber(key: string, scope: StorageScope, fallbackValue?: number): number | undefined;
    /**
    * Retrieve an element stored with the given key from storage. Use
    * the provided `defaultValue` if the element is `null` or `undefined`.
    * The element will be converted to a `object` using `JSON.parse`.
    *
    * @param scope allows to define the scope of the storage operation
    * to either the current workspace only, all workspaces or all profiles.
    */
    getObject<T extends object>(key: string, scope: StorageScope, fallbackValue: T): T;
    getObject<T extends object>(key: string, scope: StorageScope, fallbackValue?: T): T | undefined;
    /**
    * Store a value under the given key to storage. The value will be
    * converted to a `string`. Storing either `undefined` or `null` will
    * remove the entry under the key.
    *
    * @param scope allows to define the scope of the storage operation
    * to either the current workspace only, all workspaces or all profiles.
    *
    * @param target allows to define the target of the storage operation
    * to either the current machine or user.
    */
    store(key: string, value: StorageValue, scope: StorageScope, target: StorageTarget): void;
    /**
    * Allows to store multiple values in a bulk operation. Events will only
    * be emitted when all values have been stored.
    *
    * @param external a hint to indicate the source of the operation is external,
    * such as settings sync or profile changes.
    */
    storeAll(entries: Array<IStorageEntry>, external: boolean): void;
    /**
    * Delete an element stored under the provided key from storage.
    *
    * The scope argument allows to define the scope of the storage
    * operation to either the current workspace only, all workspaces
    * or all profiles.
    */
    remove(key: string, scope: StorageScope): void;
    /**
    * Returns all the keys used in the storage for the provided `scope`
    * and `target`.
    *
    * Note: this will NOT return all keys stored in the storage layer.
    * Some keys may not have an associated `StorageTarget` and thus
    * will be excluded from the results.
    *
    * @param scope allows to define the scope for the keys
    * to either the current workspace only, all workspaces or all profiles.
    *
    * @param target allows to define the target for the keys
    * to either the current machine or user.
    */
    keys(scope: StorageScope, target: StorageTarget): string[];
    /**
    * Log the contents of the storage to the console.
    */
    log(): void;
    /**
    * Returns true if the storage service handles the provided scope.
    */
    hasScope(scope: IAnyWorkspaceIdentifier | IUserDataProfile): boolean;
    /**
    * Switch storage to another workspace or profile. Optionally preserve the
    * current data to the new storage.
    */
    switch(to: IAnyWorkspaceIdentifier | IUserDataProfile, preserveData: boolean): Promise<void>;
    /**
    * Whether the storage for the given scope was created during this session or
    * existed before.
    */
    isNew(scope: StorageScope): boolean;
    /**
    * Attempts to reduce the DB size via optimization commands if supported.
    */
    optimize(scope: StorageScope): Promise<void>;
    /**
    * Allows to flush state, e.g. in cases where a shutdown is
    * imminent. This will send out the `onWillSaveState` to ask
    * everyone for latest state.
    *
    * @returns a `Promise` that can be awaited on when all updates
    * to the underlying storage have been flushed.
    */
    flush(reason?: WillSaveStateReason): Promise<void>;
}

export { IStorageService };
