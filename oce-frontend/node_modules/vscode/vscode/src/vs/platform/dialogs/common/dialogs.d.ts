import { ThemeIcon } from '../../../base/common/themables.js';
import { IMarkdownString } from '../../../base/common/htmlContent.js';
import Severity from '../../../base/common/severity.js';
import { URI } from '../../../base/common/uri.js';
import { ITelemetryData } from '../../telemetry/common/telemetry.js';

interface IDialogArgs {
    readonly confirmArgs?: IConfirmDialogArgs;
    readonly inputArgs?: IInputDialogArgs;
    readonly promptArgs?: IPromptDialogArgs;
}
interface IBaseDialogOptions {
    readonly type?: Severity | DialogType;
    readonly title?: string;
    readonly message: string;
    readonly detail?: string;
    readonly checkbox?: ICheckbox;
    /**
     * Allows to enforce use of custom dialog even in native environments.
     */
    readonly custom?: boolean | ICustomDialogOptions;
}
interface IConfirmDialogArgs {
    readonly confirmation: IConfirmation;
}
interface IConfirmation extends IBaseDialogOptions {
    /**
     * If not provided, defaults to `Yes`.
     */
    readonly primaryButton?: string;
    /**
     * If not provided, defaults to `Cancel`.
     */
    readonly cancelButton?: string;
}
interface IConfirmationResult extends ICheckboxResult {
    /**
     * Will be true if the dialog was confirmed with the primary button pressed.
     */
    readonly confirmed: boolean;
}
interface IInputDialogArgs {
    readonly input: IInput;
}
interface IInput extends IConfirmation {
    readonly inputs: IInputElement[];
    /**
     * If not provided, defaults to `Ok`.
     */
    readonly primaryButton?: string;
}
interface IInputElement {
    readonly type?: 'text' | 'password';
    readonly value?: string;
    readonly placeholder?: string;
}
interface IInputResult extends IConfirmationResult {
    /**
     * Values for the input fields as provided by the user or `undefined` if none.
     */
    readonly values?: string[];
}
interface IPromptDialogArgs {
    readonly prompt: IPrompt<unknown>;
}
interface IPromptBaseButton<T> {
    /**
     * @returns the result of the prompt button will be returned
     * as result from the `prompt()` call.
     */
    run(checkbox: ICheckboxResult): T | Promise<T>;
}
interface IPromptButton<T> extends IPromptBaseButton<T> {
    readonly label: string;
}
interface IPromptCancelButton<T> extends IPromptBaseButton<T> {
    /**
     * The cancel button to show in the prompt. Defaults to
     * `Cancel` if not provided.
     */
    readonly label?: string;
}
interface IPrompt<T> extends IBaseDialogOptions {
    /**
     * The buttons to show in the prompt. Defaults to `OK`
     * if no buttons or cancel button is provided.
     */
    readonly buttons?: IPromptButton<T>[];
    /**
     * The cancel button to show in the prompt. Defaults to
     * `Cancel` if set to `true`.
     */
    readonly cancelButton?: IPromptCancelButton<T> | true | string;
}
interface IPromptWithCustomCancel<T> extends IPrompt<T> {
    readonly cancelButton: IPromptCancelButton<T>;
}
interface IPromptWithDefaultCancel<T> extends IPrompt<T> {
    readonly cancelButton: true | string;
}
interface IPromptResult<T> extends ICheckboxResult {
    /**
     * The result of the `IPromptButton` that was pressed or `undefined` if none.
     */
    readonly result?: T;
}
interface IPromptResultWithCancel<T> extends IPromptResult<T> {
    readonly result: T;
}
interface IAsyncPromptResult<T> extends ICheckboxResult {
    /**
     * The result of the `IPromptButton` that was pressed or `undefined` if none.
     */
    readonly result?: Promise<T>;
}
type IDialogResult = IConfirmationResult | IInputResult | IAsyncPromptResult<unknown>;
type DialogType = 'none' | 'info' | 'error' | 'question' | 'warning';
interface ICheckbox {
    readonly label: string;
    readonly checked?: boolean;
}
interface ICheckboxResult {
    /**
     * This will only be defined if the confirmation was created
     * with the checkbox option defined.
     */
    readonly checkboxChecked?: boolean;
}
interface IPickAndOpenOptions {
    readonly forceNewWindow?: boolean;
    defaultUri?: URI;
    readonly telemetryExtraData?: ITelemetryData;
    availableFileSystems?: string[];
    remoteAuthority?: string | null;
}
interface FileFilter {
    readonly extensions: string[];
    readonly name: string;
}
interface ISaveDialogOptions {
    /**
     * A human-readable string for the dialog title
     */
    title?: string;
    /**
     * The resource the dialog shows when opened.
     */
    defaultUri?: URI;
    /**
     * A set of file filters that are used by the dialog. Each entry is a human readable label,
     * like "TypeScript", and an array of extensions.
     */
    filters?: FileFilter[];
    /**
     * A human-readable string for the ok button
     */
    readonly saveLabel?: string;
    /**
     * Specifies a list of schemas for the file systems the user can save to. If not specified, uses the schema of the defaultURI or, if also not specified,
     * the schema of the current window.
     */
    availableFileSystems?: readonly string[];
}
interface IOpenDialogOptions {
    /**
     * A human-readable string for the dialog title
     */
    readonly title?: string;
    /**
     * The resource the dialog shows when opened.
     */
    defaultUri?: URI;
    /**
     * A human-readable string for the open button.
     */
    readonly openLabel?: string;
    /**
     * Allow to select files, defaults to `true`.
     */
    canSelectFiles?: boolean;
    /**
     * Allow to select folders, defaults to `false`.
     */
    canSelectFolders?: boolean;
    /**
     * Allow to select many files or folders.
     */
    readonly canSelectMany?: boolean;
    /**
     * A set of file filters that are used by the dialog. Each entry is a human readable label,
     * like "TypeScript", and an array of extensions.
     */
    filters?: FileFilter[];
    /**
     * Specifies a list of schemas for the file systems the user can load from. If not specified, uses the schema of the defaultURI or, if also not available,
     * the schema of the current window.
     */
    availableFileSystems?: readonly string[];
}
interface ICustomDialogOptions {
    readonly buttonDetails?: string[];
    readonly markdownDetails?: ICustomDialogMarkdown[];
    readonly classes?: string[];
    readonly icon?: ThemeIcon;
    readonly disableCloseAction?: boolean;
}
interface ICustomDialogMarkdown {
    readonly markdown: IMarkdownString;
    readonly classes?: string[];
}
/**
 * A handler to bring up modal dialogs.
 */
interface IDialogHandler {
    /**
     * Ask the user for confirmation with a modal dialog.
     */
    confirm(confirmation: IConfirmation): Promise<IConfirmationResult>;
    /**
     * Prompt the user with a modal dialog.
     */
    prompt<T>(prompt: IPrompt<T>): Promise<IAsyncPromptResult<T>>;
    /**
     * Present a modal dialog to the user asking for input.
     */
    input(input: IInput): Promise<IInputResult>;
    /**
     * Present the about dialog to the user.
     */
    about(): Promise<void>;
}
declare const enum ConfirmResult {
    SAVE = 0,
    DONT_SAVE = 1,
    CANCEL = 2
}

export { ConfirmResult, type DialogType, type FileFilter, type IAsyncPromptResult, type IBaseDialogOptions, type ICheckbox, type ICheckboxResult, type IConfirmDialogArgs, type IConfirmation, type IConfirmationResult, type ICustomDialogMarkdown, type ICustomDialogOptions, type IDialogArgs, type IDialogHandler, type IDialogResult, type IInput, type IInputDialogArgs, type IInputElement, type IInputResult, type IOpenDialogOptions, type IPickAndOpenOptions, type IPrompt, type IPromptBaseButton, type IPromptButton, type IPromptCancelButton, type IPromptDialogArgs, type IPromptResult, type IPromptResultWithCancel, type IPromptWithCustomCancel, type IPromptWithDefaultCancel, type ISaveDialogOptions };
