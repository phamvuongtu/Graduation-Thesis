import { Event } from '../../../base/common/event.js';
import { IJSONSchema } from '../../../base/common/jsonSchema.js';
import { IDisposable } from '../../../base/common/lifecycle.js';
import { TypeConstraint } from '../../../base/common/types.js';
import { ILocalizedString } from '../../action/common/action.js';
import { ServicesAccessor } from '../../instantiation/common/instantiation.js';

interface ICommandEvent {
    commandId: string;
    args: any[];
}
type ICommandsMap = Map<string, ICommand>;
interface ICommandHandler {
    (accessor: ServicesAccessor, ...args: any[]): void;
}
interface ICommand {
    id: string;
    handler: ICommandHandler;
    metadata?: ICommandMetadata | null;
}
interface ICommandMetadata {
    /**
     * NOTE: Please use an ILocalizedString. string is in the type for backcompat for now.
     * A short summary of what the command does. This will be used in:
     * - API commands
     * - when showing keybindings that have no other UX
     * - when searching for commands in the Command Palette
     */
    readonly description: ILocalizedString | string;
    readonly args?: ReadonlyArray<{
        readonly name: string;
        readonly isOptional?: boolean;
        readonly description?: string;
        readonly constraint?: TypeConstraint;
        readonly schema?: IJSONSchema;
    }>;
    readonly returns?: string;
}
interface ICommandRegistry {
    onDidRegisterCommand: Event<string>;
    registerCommand(id: string, command: ICommandHandler): IDisposable;
    registerCommand(command: ICommand): IDisposable;
    registerCommandAlias(oldId: string, newId: string): IDisposable;
    getCommand(id: string): ICommand | undefined;
    getCommands(): ICommandsMap;
}
declare const CommandsRegistry: ICommandRegistry;

export { CommandsRegistry, type ICommand, type ICommandEvent, type ICommandHandler, type ICommandMetadata, type ICommandRegistry, type ICommandsMap };
