import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';
import { Emitter } from '../../../base/common/event.js';
import { MainContext } from './extHost.protocol.js';
import { Disposable } from './extHostTypes.js';
import { ExtensionIdentifier } from '../../../platform/extensions/common/extensions.js';
import { INTERNAL_AUTH_PROVIDER_PREFIX } from '../../services/authentication/common/authentication.js';
import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';
import { IExtHostRpcService } from './extHostRpcService.js';
const IExtHostAuthentication = ( createDecorator('IExtHostAuthentication'));
let ExtHostAuthentication = class ExtHostAuthentication {
    constructor(extHostRpc) {
        this._authenticationProviders = ( new Map());
        this._onDidChangeSessions = ( new Emitter());
        this.onDidChangeSessions = this._onDidChangeSessions.event;
        this._getSessionTaskSingler = ( new TaskSingler());
        this._getSessionsTaskSingler = ( new TaskSingler());
        this._proxy = ( extHostRpc.getProxy(MainContext.MainThreadAuthentication));
    }
    async getSession(requestingExtension, providerId, scopes, options = {}) {
        const extensionId = ExtensionIdentifier.toKey(requestingExtension.identifier);
        const sortedScopes = [...scopes].sort().join(' ');
        return await this._getSessionTaskSingler.getOrCreate(`${extensionId} ${providerId} ${sortedScopes}`, async () => {
            await this._proxy.$ensureProvider(providerId);
            const extensionName = requestingExtension.displayName || requestingExtension.name;
            return this._proxy.$getSession(providerId, scopes, extensionId, extensionName, options);
        });
    }
    async getSessions(requestingExtension, providerId, scopes) {
        const extensionId = ExtensionIdentifier.toKey(requestingExtension.identifier);
        const sortedScopes = [...scopes].sort().join(' ');
        return await this._getSessionsTaskSingler.getOrCreate(`${extensionId} ${sortedScopes}`, async () => {
            await this._proxy.$ensureProvider(providerId);
            const extensionName = requestingExtension.displayName || requestingExtension.name;
            return this._proxy.$getSessions(providerId, scopes, extensionId, extensionName);
        });
    }
    async removeSession(providerId, sessionId) {
        const providerData = this._authenticationProviders.get(providerId);
        if (!providerData) {
            return this._proxy.$removeSession(providerId, sessionId);
        }
        return providerData.provider.removeSession(sessionId);
    }
    registerAuthenticationProvider(id, label, provider, options) {
        if (this._authenticationProviders.get(id)) {
            throw ( new Error(`An authentication provider with id '${id}' is already registered.`));
        }
        this._authenticationProviders.set(id, { label, provider, options: options ?? { supportsMultipleAccounts: false } });
        const listener = provider.onDidChangeSessions(e => this._proxy.$sendDidChangeSessions(id, e));
        this._proxy.$registerAuthenticationProvider(id, label, options?.supportsMultipleAccounts ?? false);
        return ( new Disposable(() => {
            listener.dispose();
            this._authenticationProviders.delete(id);
            this._proxy.$unregisterAuthenticationProvider(id);
        }));
    }
    $createSession(providerId, scopes, options) {
        const providerData = this._authenticationProviders.get(providerId);
        if (providerData) {
            return Promise.resolve(providerData.provider.createSession(scopes, options));
        }
        throw ( new Error(`Unable to find authentication provider with handle: ${providerId}`));
    }
    $removeSession(providerId, sessionId) {
        const providerData = this._authenticationProviders.get(providerId);
        if (providerData) {
            return Promise.resolve(providerData.provider.removeSession(sessionId));
        }
        throw ( new Error(`Unable to find authentication provider with handle: ${providerId}`));
    }
    $getSessions(providerId, scopes) {
        const providerData = this._authenticationProviders.get(providerId);
        if (providerData) {
            return Promise.resolve(providerData.provider.getSessions(scopes));
        }
        throw ( new Error(`Unable to find authentication provider with handle: ${providerId}`));
    }
    $onDidChangeAuthenticationSessions(id, label) {
        if (!id.startsWith(INTERNAL_AUTH_PROVIDER_PREFIX)) {
            this._onDidChangeSessions.fire({ provider: { id, label } });
        }
        return Promise.resolve();
    }
};
ExtHostAuthentication = ( __decorate([
    ( __param(0, IExtHostRpcService))
], ExtHostAuthentication));
class TaskSingler {
    constructor() {
        this._inFlightPromises = ( new Map());
    }
    getOrCreate(key, promiseFactory) {
        const inFlight = this._inFlightPromises.get(key);
        if (inFlight) {
            return inFlight;
        }
        const promise = promiseFactory().finally(() => this._inFlightPromises.delete(key));
        this._inFlightPromises.set(key, promise);
        return promise;
    }
}
export { ExtHostAuthentication, IExtHostAuthentication };
