import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';
import { RunOnceScheduler } from '../../../base/common/async.js';
import { VSBuffer } from '../../../base/common/buffer.js';
import { CancellationToken, CancellationTokenSource } from '../../../base/common/cancellation.js';
import { Emitter, Event } from '../../../base/common/event.js';
import { createSingleCallFunction } from '../../../base/common/functional.js';
import { hash } from '../../../base/common/hash.js';
import { Disposable, toDisposable, DisposableStore } from '../../../base/common/lifecycle.js';
import { isDefined } from '../../../base/common/types.js';
import { generateUuid } from '../../../base/common/uuid.js';
import { ILogService } from '../../../platform/log/common/log.service.js';
import { MainContext } from './extHost.protocol.js';
import { IExtHostRpcService } from './extHostRpcService.js';
import { toItemFromContext, ExtHostTestItemCollection, TestItemImpl, TestItemRootImpl } from './extHostTestItem.js';
import { TestMessage, TestCoverage, TestResults, TestTag, location, TestItem, Range } from './extHostTypeConverters.js';
import { TestRunProfileKind, TestRunRequest } from './extHostTypes.js';
import { TestId } from '../../contrib/testing/common/testId.js';
import { InvalidTestItemError } from '../../contrib/testing/common/testItemCollection.js';
import { TestsDiffOp, isStartControllerTests, AbstractIncrementalTestCollection } from '../../contrib/testing/common/testTypes.js';
let ExtHostTesting = class ExtHostTesting extends Disposable {
    constructor(rpc, logService, commands, editors) {
        super();
        this.editors = editors;
        this.resultsChangedEmitter = this._register(( new Emitter()));
        this.controllers = ( new Map());
        this.defaultProfilesChangedEmitter = this._register(( new Emitter()));
        this.onResultsChanged = this.resultsChangedEmitter.event;
        this.results = [];
        this.proxy = ( rpc.getProxy(MainContext.MainThreadTesting));
        this.observer = ( new TestObservers(this.proxy));
        this.runTracker = ( new TestRunCoordinator(this.proxy, logService));
        commands.registerArgumentProcessor({
            processArgument: arg => {
                switch (arg?.$mid) {
                    case 16 : {
                        const cast = arg;
                        const targetTest = cast.tests[cast.tests.length - 1].item.extId;
                        const controller = this.controllers.get(TestId.root(targetTest));
                        return controller?.collection.tree.get(targetTest)?.actual ?? toItemFromContext(arg);
                    }
                    case 18 : {
                        const { test, message } = arg;
                        const extId = test.item.extId;
                        return {
                            test: this.controllers.get(TestId.root(extId))?.collection.tree.get(extId)?.actual
                                ?? toItemFromContext({ $mid: 16 , tests: [test] }),
                            message: TestMessage.to(message),
                        };
                    }
                    default: return arg;
                }
            }
        });
        commands.registerCommand(false, 'testing.getExplorerSelection', async () => {
            const inner = await commands.executeCommand("_testing.getExplorerSelection" );
            const lookup = (i) => {
                const controller = this.controllers.get(TestId.root(i));
                if (!controller) {
                    return undefined;
                }
                return TestId.isRoot(i) ? controller.controller : controller.collection.tree.get(i)?.actual;
            };
            return {
                include: inner?.include.map(lookup).filter(isDefined) || [],
                exclude: inner?.exclude.map(lookup).filter(isDefined) || [],
            };
        });
    }
    createTestController(extension, controllerId, label, refreshHandler) {
        if (( this.controllers.has(controllerId))) {
            throw ( new Error(`Attempt to insert a duplicate controller with ID "${controllerId}"`));
        }
        const disposable = ( new DisposableStore());
        const collection = disposable.add(( new ExtHostTestItemCollection(controllerId, label, this.editors)));
        collection.root.label = label;
        const profiles = ( new Map());
        const activeProfiles = ( new Set());
        const proxy = this.proxy;
        const controller = {
            items: collection.root.children,
            get label() {
                return label;
            },
            set label(value) {
                label = value;
                collection.root.label = value;
                proxy.$updateController(controllerId, { label });
            },
            get refreshHandler() {
                return refreshHandler;
            },
            set refreshHandler(value) {
                refreshHandler = value;
                proxy.$updateController(controllerId, { canRefresh: !!value });
            },
            get id() {
                return controllerId;
            },
            createRunProfile: (label, group, runHandler, isDefault, tag, supportsContinuousRun) => {
                let profileId = hash(label);
                while (( profiles.has(profileId))) {
                    profileId++;
                }
                return ( new TestRunProfileImpl(
                    this.proxy,
                    profiles,
                    activeProfiles,
                    this.defaultProfilesChangedEmitter.event,
                    controllerId,
                    profileId,
                    label,
                    group,
                    runHandler,
                    isDefault,
                    tag,
                    supportsContinuousRun
                ));
            },
            createTestItem(id, label, uri) {
                return ( new TestItemImpl(controllerId, id, label, uri));
            },
            createTestRun: (request, name, persist = true) => {
                return this.runTracker.createTestRun(controllerId, collection, request, name, persist);
            },
            invalidateTestResults: items => {
                if (items === undefined) {
                    this.proxy.$markTestRetired(undefined);
                }
                else {
                    const itemsArr = items instanceof Array ? items : [items];
                    this.proxy.$markTestRetired(( itemsArr.map(i => ( TestId.fromExtHostTestItem(i, controllerId).toString()))));
                }
            },
            set resolveHandler(fn) {
                collection.resolveHandler = fn;
            },
            get resolveHandler() {
                return collection.resolveHandler;
            },
            dispose: () => {
                disposable.dispose();
            },
        };
        proxy.$registerTestController(controllerId, label, !!refreshHandler);
        disposable.add(toDisposable(() => proxy.$unregisterTestController(controllerId)));
        const info = { controller, collection, profiles, extension, activeProfiles };
        this.controllers.set(controllerId, info);
        disposable.add(toDisposable(() => this.controllers.delete(controllerId)));
        disposable.add(collection.onDidGenerateDiff(diff => proxy.$publishDiff(controllerId, ( diff.map(TestsDiffOp.serialize)))));
        return controller;
    }
    createTestObserver() {
        return this.observer.checkout();
    }
    async runTests(req, token = CancellationToken.None) {
        const profile = tryGetProfileFromTestRunReq(req);
        if (!profile) {
            throw ( new Error('The request passed to `vscode.test.runTests` must include a profile'));
        }
        const controller = this.controllers.get(profile.controllerId);
        if (!controller) {
            throw ( new Error('Controller not found'));
        }
        await this.proxy.$runTests({
            preserveFocus: req.preserveFocus ?? true,
            targets: [{
                    testIds: req.include?.map(t => ( TestId.fromExtHostTestItem(t, controller.collection.root.id).toString())) ?? [controller.collection.root.id],
                    profileGroup: profileGroupToBitset[profile.kind],
                    profileId: profile.profileId,
                    controllerId: profile.controllerId,
                }],
            exclude: req.exclude?.map(t => t.id),
        }, token);
    }
    $syncTests() {
        for (const { collection } of ( this.controllers.values())) {
            collection.flushDiff();
        }
        return Promise.resolve();
    }
    async $getCoverageDetails(coverageId, token) {
        const details = await this.runTracker.getCoverageDetails(coverageId, token);
        return details?.map(TestCoverage.fromDetails);
    }
    async $disposeRun(runId) {
        this.runTracker.disposeTestRun(runId);
    }
    $configureRunProfile(controllerId, profileId) {
        this.controllers.get(controllerId)?.profiles.get(profileId)?.configureHandler?.();
    }
    $setDefaultRunProfiles(profiles) {
        const evt = ( new Map());
        for (const [controllerId, profileIds] of Object.entries(profiles)) {
            const ctrl = this.controllers.get(controllerId);
            if (!ctrl) {
                continue;
            }
            const changes = ( new Map());
            const added = profileIds.filter(id => !( ctrl.activeProfiles.has(id)));
            const removed = [...ctrl.activeProfiles].filter(id => !profileIds.includes(id));
            for (const id of added) {
                changes.set(id, true);
                ctrl.activeProfiles.add(id);
            }
            for (const id of removed) {
                changes.set(id, false);
                ctrl.activeProfiles.delete(id);
            }
            if (changes.size) {
                evt.set(controllerId, changes);
            }
        }
        this.defaultProfilesChangedEmitter.fire(evt);
    }
    async $refreshTests(controllerId, token) {
        await this.controllers.get(controllerId)?.controller.refreshHandler?.(token);
    }
    $publishTestResults(results) {
        this.results = ( Object.freeze(( results
            .map(TestResults.to))
            .concat(this.results)
            .sort((a, b) => b.completedAt - a.completedAt)
            .slice(0, 32)));
        this.resultsChangedEmitter.fire();
    }
    async $expandTest(testId, levels) {
        const collection = this.controllers.get(TestId.fromString(testId).controllerId)?.collection;
        if (collection) {
            await collection.expand(testId, levels < 0 ? Infinity : levels);
            collection.flushDiff();
        }
    }
    $acceptDiff(diff) {
        this.observer.applyDiff(( diff.map(d => TestsDiffOp.deserialize({ asCanonicalUri: u => u }, d))));
    }
    async $runControllerTests(reqs, token) {
        return Promise.all(( reqs.map(req => this.runControllerTestRequest(req, false, token))));
    }
    async $startContinuousRun(reqs, token) {
        const cts = ( new CancellationTokenSource(token));
        const res = await Promise.all(( reqs.map(req => this.runControllerTestRequest(req, true, cts.token))));
        if (!token.isCancellationRequested && !( res.some(r => r.error))) {
            await ( new Promise(r => token.onCancellationRequested(r)));
        }
        cts.dispose(true);
        return res;
    }
    async runControllerTestRequest(req, isContinuous, token) {
        const lookup = this.controllers.get(req.controllerId);
        if (!lookup) {
            return {};
        }
        const { collection, profiles } = lookup;
        const profile = profiles.get(req.profileId);
        if (!profile) {
            return {};
        }
        const includeTests = ( req.testIds
            .map((testId) => collection.tree.get(testId)))
            .filter(isDefined);
        const excludeTests = ( req.excludeExtIds
            .map(id => lookup.collection.tree.get(id)))
            .filter(isDefined)
            .filter(exclude => ( includeTests.some(
            include => include.fullId.compare(exclude.fullId) === 2
        )));
        if (!includeTests.length) {
            return {};
        }
        const publicReq = ( new TestRunRequest(( includeTests.some(i => i.actual instanceof TestItemRootImpl)) ? undefined : ( includeTests.map(t => t.actual)), ( excludeTests.map(t => t.actual)), profile, isContinuous));
        const tracker = isStartControllerTests(req) && this.runTracker.prepareForMainThreadTestRun(publicReq, TestRunDto.fromInternal(req, lookup.collection), profile, token);
        try {
            await profile.runHandler(publicReq, token);
            return {};
        }
        catch (e) {
            return { error: String(e) };
        }
        finally {
            if (tracker) {
                if (tracker.hasRunningTasks && !token.isCancellationRequested) {
                    await Event.toPromise(tracker.onEnd);
                }
            }
        }
    }
    $cancelExtensionTestRun(runId) {
        if (runId === undefined) {
            this.runTracker.cancelAllRuns();
        }
        else {
            this.runTracker.cancelRunById(runId);
        }
    }
};
ExtHostTesting = ( __decorate([
    ( __param(0, IExtHostRpcService)),
    ( __param(1, ILogService))
], ExtHostTesting));
const RUN_CANCEL_DEADLINE = 10_000;
class TestRunTracker extends Disposable {
    get hasRunningTasks() {
        return this.running > 0;
    }
    get id() {
        return this.dto.id;
    }
    constructor(dto, proxy, logService, profile, parentToken) {
        super();
        this.dto = dto;
        this.proxy = proxy;
        this.logService = logService;
        this.profile = profile;
        this.state = 0 ;
        this.running = 0;
        this.tasks = ( new Map());
        this.sharedTestIds = ( new Set());
        this.endEmitter = this._register(( new Emitter()));
        this.publishedCoverage = ( new Map());
        this.onEnd = this.endEmitter.event;
        this.cts = this._register(( new CancellationTokenSource(parentToken)));
        const forciblyEnd = this._register(( new RunOnceScheduler(() => this.forciblyEndTasks(), RUN_CANCEL_DEADLINE)));
        this._register(this.cts.token.onCancellationRequested(() => forciblyEnd.schedule()));
        const didDisposeEmitter = ( new Emitter());
        this.onDidDispose = didDisposeEmitter.event;
        this._register(toDisposable(() => {
            didDisposeEmitter.fire();
            didDisposeEmitter.dispose();
        }));
    }
    cancel() {
        if (this.state === 0 ) {
            this.cts.cancel();
            this.state = 1 ;
        }
        else if (this.state === 1 ) {
            this.forciblyEndTasks();
        }
    }
    getCoverageDetails(id, token) {
        const [, taskId, covId] = TestId.fromString(id).path;
        const coverage = this.publishedCoverage.get(covId);
        if (!coverage) {
            return [];
        }
        const task = this.tasks.get(taskId);
        if (!task) {
            throw ( new Error('unreachable: run task was not found'));
        }
        return this.profile?.loadDetailedCoverage?.(task.run, coverage, token) ?? [];
    }
    createRun(name) {
        const runId = this.dto.id;
        const ctrlId = this.dto.controllerId;
        const taskId = generateUuid();
        const guardTestMutation = (fn) => (test, ...args) => {
            if (ended) {
                this.logService.warn(`Setting the state of test "${test.id}" is a no-op after the run ends.`);
                return;
            }
            if (!this.dto.isIncluded(test)) {
                return;
            }
            this.ensureTestIsKnown(test);
            fn(test, ...args);
        };
        const appendMessages = (test, messages) => {
            const converted = messages instanceof Array
                ? ( messages.map(TestMessage.from))
                : [TestMessage.from(messages)];
            if (test.uri && test.range) {
                const defaultLocation = { range: Range.from(test.range), uri: test.uri };
                for (const message of converted) {
                    message.location = message.location || defaultLocation;
                }
            }
            this.proxy.$appendTestMessagesInRun(runId, taskId, ( TestId.fromExtHostTestItem(test, ctrlId).toString()), converted);
        };
        let ended = false;
        const run = {
            isPersisted: this.dto.isPersisted,
            token: this.cts.token,
            name,
            onDidDispose: this.onDidDispose,
            addCoverage: coverage => {
                const uriStr = ( coverage.uri.toString());
                const id = ( ( new TestId([runId, taskId, uriStr])).toString());
                this.publishedCoverage.set(uriStr, coverage);
                this.proxy.$appendCoverage(runId, taskId, TestCoverage.fromFile(id, coverage));
            },
            enqueued: guardTestMutation(test => {
                this.proxy.$updateTestStateInRun(runId, taskId, ( TestId.fromExtHostTestItem(test, ctrlId).toString()), 1 );
            }),
            skipped: guardTestMutation(test => {
                this.proxy.$updateTestStateInRun(runId, taskId, ( TestId.fromExtHostTestItem(test, ctrlId).toString()), 5 );
            }),
            started: guardTestMutation(test => {
                this.proxy.$updateTestStateInRun(runId, taskId, ( TestId.fromExtHostTestItem(test, ctrlId).toString()), 2 );
            }),
            errored: guardTestMutation((test, messages, duration) => {
                appendMessages(test, messages);
                this.proxy.$updateTestStateInRun(runId, taskId, ( TestId.fromExtHostTestItem(test, ctrlId).toString()), 6 , duration);
            }),
            failed: guardTestMutation((test, messages, duration) => {
                appendMessages(test, messages);
                this.proxy.$updateTestStateInRun(runId, taskId, ( TestId.fromExtHostTestItem(test, ctrlId).toString()), 4 , duration);
            }),
            passed: guardTestMutation((test, duration) => {
                this.proxy.$updateTestStateInRun(runId, taskId, ( TestId.fromExtHostTestItem(test, this.dto.controllerId).toString()), 3 , duration);
            }),
            appendOutput: (output, location$1, test) => {
                if (ended) {
                    return;
                }
                if (test) {
                    if (this.dto.isIncluded(test)) {
                        this.ensureTestIsKnown(test);
                    }
                    else {
                        test = undefined;
                    }
                }
                this.proxy.$appendOutputToRun(runId, taskId, VSBuffer.fromString(output), location$1 && location.from(location$1), test && ( TestId.fromExtHostTestItem(test, ctrlId).toString()));
            },
            end: () => {
                if (ended) {
                    return;
                }
                ended = true;
                this.proxy.$finishedTestRunTask(runId, taskId);
                if (!--this.running) {
                    this.markEnded();
                }
            }
        };
        this.running++;
        this.tasks.set(taskId, { run });
        this.proxy.$startedTestRunTask(runId, { id: taskId, name, running: true });
        return run;
    }
    forciblyEndTasks() {
        for (const { run } of ( this.tasks.values())) {
            run.end();
        }
    }
    markEnded() {
        if (this.state !== 2 ) {
            this.state = 2 ;
            this.endEmitter.fire();
        }
    }
    ensureTestIsKnown(test) {
        if (!(test instanceof TestItemImpl)) {
            throw ( new InvalidTestItemError(test.id));
        }
        if (( this.sharedTestIds.has(( TestId.fromExtHostTestItem(test, this.dto.controllerId).toString())))) {
            return;
        }
        const chain = [];
        const root = this.dto.colllection.root;
        while (true) {
            const converted = TestItem.from(test);
            chain.unshift(converted);
            if (( this.sharedTestIds.has(converted.extId))) {
                break;
            }
            this.sharedTestIds.add(converted.extId);
            if (test === root) {
                break;
            }
            test = test.parent || root;
        }
        this.proxy.$addTestsToRun(this.dto.controllerId, this.dto.id, chain);
    }
    dispose() {
        this.markEnded();
        super.dispose();
    }
}
class TestRunCoordinator {
    get trackers() {
        return ( this.tracked.values());
    }
    constructor(proxy, logService) {
        this.proxy = proxy;
        this.logService = logService;
        this.tracked = ( new Map());
        this.trackedById = ( new Map());
    }
    getCoverageDetails(id, token) {
        const runId = TestId.root(id);
        return this.trackedById.get(runId)?.getCoverageDetails(id, token) || [];
    }
    disposeTestRun(runId) {
        this.trackedById.get(runId)?.dispose();
        this.trackedById.delete(runId);
        for (const [req, { id }] of this.tracked) {
            if (id === runId) {
                this.tracked.delete(req);
            }
        }
    }
    prepareForMainThreadTestRun(req, dto, profile, token) {
        return this.getTracker(req, dto, profile, token);
    }
    cancelRunById(runId) {
        this.trackedById.get(runId)?.cancel();
    }
    cancelAllRuns() {
        for (const tracker of ( this.tracked.values())) {
            tracker.cancel();
        }
    }
    createTestRun(controllerId, collection, request, name, persist) {
        const existing = this.tracked.get(request);
        if (existing) {
            return existing.createRun(name);
        }
        const dto = TestRunDto.fromPublic(controllerId, collection, request, persist);
        const profile = tryGetProfileFromTestRunReq(request);
        this.proxy.$startedExtensionTestRun({
            controllerId,
            continuous: !!request.continuous,
            profile: profile && { group: profileGroupToBitset[profile.kind], id: profile.profileId },
            exclude: request.exclude?.map(t => ( TestId.fromExtHostTestItem(t, collection.root.id).toString())) ?? [],
            id: dto.id,
            include: request.include?.map(t => ( TestId.fromExtHostTestItem(t, collection.root.id).toString())) ?? [collection.root.id],
            preserveFocus: request.preserveFocus ?? true,
            persist
        });
        const tracker = this.getTracker(request, dto, request.profile);
        Event.once(tracker.onEnd)(() => {
            this.proxy.$finishedExtensionTestRun(dto.id);
        });
        return tracker.createRun(name);
    }
    getTracker(req, dto, profile, token) {
        const tracker = ( new TestRunTracker(dto, this.proxy, this.logService, profile, token));
        this.tracked.set(req, tracker);
        this.trackedById.set(tracker.id, tracker);
        return tracker;
    }
}
const tryGetProfileFromTestRunReq = (request) => {
    if (!request.profile) {
        return undefined;
    }
    if (!(request.profile instanceof TestRunProfileImpl)) {
        throw ( new Error(
            `TestRunRequest.profile is not an instance created from TestController.createRunProfile`
        ));
    }
    return request.profile;
};
class TestRunDto {
    static fromPublic(controllerId, collection, request, persist) {
        return ( new TestRunDto(controllerId, generateUuid(), request.include?.map(t => ( TestId.fromExtHostTestItem(t, controllerId).toString())) ?? [controllerId], request.exclude?.map(t => ( TestId.fromExtHostTestItem(t, controllerId).toString())) ?? [], persist, collection));
    }
    static fromInternal(request, collection) {
        return ( new TestRunDto(
            request.controllerId,
            request.runId,
            request.testIds,
            request.excludeExtIds,
            true,
            collection
        ));
    }
    constructor(controllerId, id, include, exclude, isPersisted, colllection) {
        this.controllerId = controllerId;
        this.id = id;
        this.isPersisted = isPersisted;
        this.colllection = colllection;
        this.includePrefix = ( include.map(id => id + "\0" ));
        this.excludePrefix = ( exclude.map(id => id + "\0" ));
    }
    isIncluded(test) {
        const id = ( TestId.fromExtHostTestItem(test, this.controllerId).toString()) + "\0" ;
        for (const prefix of this.excludePrefix) {
            if (id === prefix || id.startsWith(prefix)) {
                return false;
            }
        }
        for (const prefix of this.includePrefix) {
            if (id === prefix || id.startsWith(prefix)) {
                return true;
            }
        }
        return false;
    }
}
class MirroredChangeCollector {
    get isEmpty() {
        return this.added.size === 0 && this.removed.size === 0 && this.updated.size === 0;
    }
    constructor(emitter) {
        this.emitter = emitter;
        this.added = ( new Set());
        this.updated = ( new Set());
        this.removed = ( new Set());
        this.alreadyRemoved = ( new Set());
    }
    add(node) {
        this.added.add(node);
    }
    update(node) {
        Object.assign(node.revived, TestItem.toPlain(node.item));
        if (!( this.added.has(node))) {
            this.updated.add(node);
        }
    }
    remove(node) {
        if (( this.added.has(node))) {
            this.added.delete(node);
            return;
        }
        this.updated.delete(node);
        const parentId = TestId.parentId(node.item.extId);
        if (parentId && ( this.alreadyRemoved.has(( parentId.toString())))) {
            this.alreadyRemoved.add(node.item.extId);
            return;
        }
        this.removed.add(node);
    }
    getChangeEvent() {
        const { added, updated, removed } = this;
        return {
            get added() { return ( [...added].map(n => n.revived)); },
            get updated() { return ( [...updated].map(n => n.revived)); },
            get removed() { return ( [...removed].map(n => n.revived)); },
        };
    }
    complete() {
        if (!this.isEmpty) {
            this.emitter.fire(this.getChangeEvent());
        }
    }
}
class MirroredTestCollection extends AbstractIncrementalTestCollection {
    constructor() {
        super(...arguments);
        this.changeEmitter = ( new Emitter());
        this.onDidChangeTests = this.changeEmitter.event;
    }
    get rootTests() {
        return this.roots;
    }
    getMirroredTestDataById(itemId) {
        return this.items.get(itemId);
    }
    getMirroredTestDataByReference(item) {
        return this.items.get(item.id);
    }
    createItem(item, parent) {
        return {
            ...item,
            revived: TestItem.toPlain(item.item),
            depth: parent ? parent.depth + 1 : 0,
            children: ( new Set()),
        };
    }
    createChangeCollector() {
        return ( new MirroredChangeCollector(this.changeEmitter));
    }
}
class TestObservers {
    constructor(proxy) {
        this.proxy = proxy;
    }
    checkout() {
        if (!this.current) {
            this.current = this.createObserverData();
        }
        const current = this.current;
        current.observers++;
        return {
            onDidChangeTest: current.tests.onDidChangeTests,
            get tests() { return ( [...current.tests.rootTests].map(t => t.revived)); },
            dispose: createSingleCallFunction(() => {
                if (--current.observers === 0) {
                    this.proxy.$unsubscribeFromDiffs();
                    this.current = undefined;
                }
            }),
        };
    }
    getMirroredTestDataByReference(ref) {
        return this.current?.tests.getMirroredTestDataByReference(ref);
    }
    applyDiff(diff) {
        this.current?.tests.apply(diff);
    }
    createObserverData() {
        const tests = ( new MirroredTestCollection({ asCanonicalUri: u => u }));
        this.proxy.$subscribeToDiffs();
        return { observers: 0, tests, };
    }
}
const updateProfile = (impl, proxy, initial, update) => {
    if (initial) {
        Object.assign(initial, update);
    }
    else {
        proxy.$updateTestRunConfig(impl.controllerId, impl.profileId, update);
    }
};
class TestRunProfileImpl {
    #proxy;
    #activeProfiles;
    #onDidChangeDefaultProfiles;
    #initialPublish;
    #profiles;
    get label() {
        return this._label;
    }
    set label(label) {
        if (label !== this._label) {
            this._label = label;
            updateProfile(this, this.#proxy, this.#initialPublish, { label });
        }
    }
    get supportsContinuousRun() {
        return this._supportsContinuousRun;
    }
    set supportsContinuousRun(supports) {
        if (supports !== this._supportsContinuousRun) {
            this._supportsContinuousRun = supports;
            updateProfile(this, this.#proxy, this.#initialPublish, { supportsContinuousRun: supports });
        }
    }
    get isDefault() {
        return ( this.#activeProfiles.has(this.profileId));
    }
    set isDefault(isDefault) {
        if (isDefault !== this.isDefault) {
            if (isDefault) {
                this.#activeProfiles.add(this.profileId);
            }
            else {
                this.#activeProfiles.delete(this.profileId);
            }
            updateProfile(this, this.#proxy, this.#initialPublish, { isDefault });
        }
    }
    get tag() {
        return this._tag;
    }
    set tag(tag) {
        if (tag?.id !== this._tag?.id) {
            this._tag = tag;
            updateProfile(this, this.#proxy, this.#initialPublish, {
                tag: tag ? TestTag.namespace(this.controllerId, tag.id) : null,
            });
        }
    }
    get configureHandler() {
        return this._configureHandler;
    }
    set configureHandler(handler) {
        if (handler !== this._configureHandler) {
            this._configureHandler = handler;
            updateProfile(this, this.#proxy, this.#initialPublish, { hasConfigurationHandler: !!handler });
        }
    }
    get onDidChangeDefault() {
        return Event.chain(this.#onDidChangeDefaultProfiles, $ => ( $
            .map(ev => ev.get(this.controllerId)?.get(this.profileId)))
            .filter(isDefined));
    }
    constructor(proxy, profiles, activeProfiles, onDidChangeActiveProfiles, controllerId, profileId, _label, kind, runHandler, _isDefault = false, _tag = undefined, _supportsContinuousRun = false) {
        this.controllerId = controllerId;
        this.profileId = profileId;
        this._label = _label;
        this.kind = kind;
        this.runHandler = runHandler;
        this._tag = _tag;
        this._supportsContinuousRun = _supportsContinuousRun;
        this.#proxy = proxy;
        this.#profiles = profiles;
        this.#activeProfiles = activeProfiles;
        this.#onDidChangeDefaultProfiles = onDidChangeActiveProfiles;
        profiles.set(profileId, this);
        const groupBitset = profileGroupToBitset[kind];
        if (typeof groupBitset !== 'number') {
            throw ( new Error(`Unknown TestRunProfile.group ${kind}`));
        }
        if (_isDefault) {
            activeProfiles.add(profileId);
        }
        this.#initialPublish = {
            profileId: profileId,
            controllerId,
            tag: _tag ? TestTag.namespace(this.controllerId, _tag.id) : null,
            label: _label,
            group: groupBitset,
            isDefault: _isDefault,
            hasConfigurationHandler: false,
            supportsContinuousRun: _supportsContinuousRun,
        };
        queueMicrotask(() => {
            if (this.#initialPublish) {
                this.#proxy.$publishTestRunProfile(this.#initialPublish);
                this.#initialPublish = undefined;
            }
        });
    }
    dispose() {
        if (this.#profiles?.delete(this.profileId)) {
            this.#profiles = undefined;
            this.#proxy.$removeTestProfile(this.controllerId, this.profileId);
        }
        this.#initialPublish = undefined;
    }
}
const profileGroupToBitset = {
    [TestRunProfileKind.Coverage]: 8 ,
    [TestRunProfileKind.Debug]: 4 ,
    [TestRunProfileKind.Run]: 2 ,
};
export { ExtHostTesting, TestRunCoordinator, TestRunDto, TestRunProfileImpl };
