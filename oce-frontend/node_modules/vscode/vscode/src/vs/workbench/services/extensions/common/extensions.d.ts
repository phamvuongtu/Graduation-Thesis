import { ExtensionIdentifier, IExtensionDescription } from '../../../../platform/extensions/common/extensions.js';
import { Event } from '../../../../base/common/event.js';
import Severity from '../../../../base/common/severity.js';
import { IMessagePassingProtocol } from '../../../../base/parts/ipc/common/ipc.js';
import { ExtensionHostKind } from './extensionHostKind.js';
import { IExtensionDescriptionSnapshot, IExtensionDescriptionDelta } from './extensionHostProtocol.js';
import { ExtensionRunningLocation } from './extensionRunningLocation.js';

interface IMessage {
    type: Severity;
    message: string;
    extensionId: ExtensionIdentifier;
    extensionPointId: string;
}
interface IExtensionsStatus {
    id: ExtensionIdentifier;
    messages: IMessage[];
    activationStarted: boolean;
    activationTimes: ActivationTimes | undefined;
    runtimeErrors: Error[];
    runningLocation: ExtensionRunningLocation | null;
}
declare const enum ExtensionHostStartup {
    /**
     * The extension host should be launched immediately and doesn't require a `$startExtensionHost` call.
     */
    EagerAutoStart = 1,
    /**
     * The extension host should be launched immediately and needs a `$startExtensionHost` call.
     */
    EagerManualStart = 2,
    /**
     * The extension host should be launched lazily and only when it has extensions it needs to host. It needs a `$startExtensionHost` call.
     */
    Lazy = 3
}
interface IExtensionHost {
    readonly pid: number | null;
    readonly runningLocation: ExtensionRunningLocation;
    readonly remoteAuthority: string | null;
    readonly startup: ExtensionHostStartup;
    /**
     * A collection of extensions which includes information about which
     * extension will execute or is executing on this extension host.
     * **NOTE**: this will reflect extensions correctly only after `start()` resolves.
     */
    readonly extensions: ExtensionHostExtensions | null;
    readonly onExit: Event<[
        number,
        string | null
    ]>;
    start(): Promise<IMessagePassingProtocol>;
    getInspectPort(): {
        port: number;
        host: string;
    } | undefined;
    enableInspectPort(): Promise<boolean>;
    dispose(): void;
}
declare class ExtensionHostExtensions {
    private _versionId;
    private _allExtensions;
    private _myExtensions;
    private _myActivationEvents;
    get versionId(): number;
    get allExtensions(): IExtensionDescription[];
    get myExtensions(): ExtensionIdentifier[];
    constructor(versionId: number, allExtensions: readonly IExtensionDescription[], myExtensions: ExtensionIdentifier[]);
    toSnapshot(): IExtensionDescriptionSnapshot;
    set(versionId: number, allExtensions: IExtensionDescription[], myExtensions: ExtensionIdentifier[]): IExtensionDescriptionDelta;
    delta(extensionsDelta: IExtensionDescriptionDelta): IExtensionDescriptionDelta | null;
    containsExtension(extensionId: ExtensionIdentifier): boolean;
    containsActivationEvent(activationEvent: string): boolean;
    private _readMyActivationEvents;
}
interface ExtensionActivationReason {
    readonly startup: boolean;
    readonly extensionId: ExtensionIdentifier;
    readonly activationEvent: string;
}
declare class ActivationTimes {
    readonly codeLoadingTime: number;
    readonly activateCallTime: number;
    readonly activateResolvedTime: number;
    readonly activationReason: ExtensionActivationReason;
    constructor(codeLoadingTime: number, activateCallTime: number, activateResolvedTime: number, activationReason: ExtensionActivationReason);
}
declare class ExtensionPointContribution<T> {
    readonly description: IExtensionDescription;
    readonly value: T;
    constructor(description: IExtensionDescription, value: T);
}
interface IWillActivateEvent {
    readonly event: string;
    readonly activation: Promise<void>;
}
interface IResponsiveStateChangeEvent {
    extensionHostKind: ExtensionHostKind;
    isResponsive: boolean;
    /**
     * Return the inspect port or `0`. `0` means inspection is not possible.
     */
    getInspectListener(tryEnableInspector: boolean): Promise<{
        port: number;
        host: string;
    } | undefined>;
}
declare const enum ActivationKind {
    Normal = 0,
    Immediate = 1
}
interface WillStopExtensionHostsEvent {
    /**
     * A human readable reason for stopping the extension hosts
     * that e.g. can be shown in a confirmation dialog to the
     * user.
     */
    readonly reason: string;
    /**
     * Allows to veto the stopping of extension hosts. The veto can be a long running
     * operation.
     *
     * @param reason a human readable reason for vetoing the extension host stop in case
     * where the resolved `value: true`.
     */
    veto(value: boolean | Promise<boolean>, reason: string): void;
}

export { ActivationKind, ActivationTimes, type ExtensionActivationReason, ExtensionHostExtensions, ExtensionHostStartup, ExtensionPointContribution, type IExtensionHost, type IExtensionsStatus, type IMessage, type IResponsiveStateChangeEvent, type IWillActivateEvent, type WillStopExtensionHostsEvent };
