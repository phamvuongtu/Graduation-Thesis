import { localizeWithPath } from '../../../../nls.js';
import { Color } from '../../../../base/common/color.js';
import { isStringArray, isUndefinedOrNull, isString, isObject } from '../../../../base/common/types.js';
const _moduleId = "vs/workbench/services/preferences/common/preferencesValidation";
function canBeType(propTypes, ...types) {
    return (
         (types.some(t => propTypes.includes(t)))
    );
}
function isNullOrEmpty(value) {
    return value === '' || isUndefinedOrNull(value);
}
function createValidator(prop) {
    const type = Array.isArray(prop.type) ? prop.type : [prop.type];
    const isNullable = canBeType(type, 'null');
    const isNumeric = (canBeType(type, 'number') || canBeType(type, 'integer')) && (type.length === 1 || type.length === 2 && isNullable);
    const numericValidations = getNumericValidators(prop);
    const stringValidations = getStringValidators(prop);
    const arrayValidator = getArrayValidator(prop);
    const objectValidator = getObjectValidator(prop);
    return value => {
        if (isNullable && isNullOrEmpty(value)) {
            return '';
        }
        const errors = [];
        if (arrayValidator) {
            const err = arrayValidator(value);
            if (err) {
                errors.push(err);
            }
        }
        if (objectValidator) {
            const err = objectValidator(value);
            if (err) {
                errors.push(err);
            }
        }
        if (prop.type === 'boolean' && value !== true && value !== false) {
            errors.push(( localizeWithPath(_moduleId, 0, 'Incorrect type. Expected "boolean".')));
        }
        if (isNumeric) {
            if (isNullOrEmpty(value) || typeof value === 'boolean' || Array.isArray(value) || isNaN(+value)) {
                errors.push(( localizeWithPath(_moduleId, 1, "Value must be a number.")));
            }
            else {
                errors.push(...( (numericValidations.filter(validator => !validator.isValid(+value)).map(validator => validator.message))));
            }
        }
        if (prop.type === 'string') {
            if (prop.enum && !isStringArray(prop.enum)) {
                errors.push(( localizeWithPath(
                    _moduleId,
                    2,
                    'The enum options should be strings, but there is a non-string option. Please file an issue with the extension author.'
                )));
            }
            else if (!isString(value)) {
                errors.push(( localizeWithPath(_moduleId, 3, 'Incorrect type. Expected "string".')));
            }
            else {
                errors.push(...( (stringValidations.filter(validator => !validator.isValid(value)).map(validator => validator.message))));
            }
        }
        if (errors.length) {
            return prop.errorMessage ? [prop.errorMessage, ...errors].join(' ') : errors.join(' ');
        }
        return '';
    };
}
function getInvalidTypeError(value, type) {
    if (typeof type === 'undefined') {
        return;
    }
    const typeArr = Array.isArray(type) ? type : [type];
    if (!( (typeArr.some(_type => valueValidatesAsType(value, _type))))) {
        return ( localizeWithPath(
            _moduleId,
            4,
            "Setting has an invalid type, expected {0}. Fix in JSON.",
            JSON.stringify(type)
        ));
    }
    return;
}
function valueValidatesAsType(value, type) {
    const valueType = typeof value;
    if (type === 'boolean') {
        return valueType === 'boolean';
    }
    else if (type === 'object') {
        return value && !Array.isArray(value) && valueType === 'object';
    }
    else if (type === 'null') {
        return value === null;
    }
    else if (type === 'array') {
        return Array.isArray(value);
    }
    else if (type === 'string') {
        return valueType === 'string';
    }
    else if (type === 'number' || type === 'integer') {
        return valueType === 'number';
    }
    return true;
}
function toRegExp(pattern) {
    try {
        return (
             (new RegExp(pattern, 'u'))
        );
    }
    catch (e) {
        try {
            return (
                 (new RegExp(pattern))
            );
        }
        catch (e) {
            console.error(( localizeWithPath(
                _moduleId,
                5,
                "Error parsing the following regex both with and without the u flag:"
            )), pattern);
            return /.*/;
        }
    }
}
function getStringValidators(prop) {
    const uriRegex = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    let patternRegex;
    if (typeof prop.pattern === 'string') {
        patternRegex = toRegExp(prop.pattern);
    }
    return [
        {
            enabled: prop.maxLength !== undefined,
            isValid: ((value) => value.length <= prop.maxLength),
            message: ( localizeWithPath(
                _moduleId,
                6,
                "Value must be {0} or fewer characters long.",
                prop.maxLength
            ))
        },
        {
            enabled: prop.minLength !== undefined,
            isValid: ((value) => value.length >= prop.minLength),
            message: ( localizeWithPath(_moduleId, 7, "Value must be {0} or more characters long.", prop.minLength))
        },
        {
            enabled: patternRegex !== undefined,
            isValid: ((value) => patternRegex.test(value)),
            message: prop.patternErrorMessage || ( localizeWithPath(_moduleId, 8, "Value must match regex `{0}`.", prop.pattern))
        },
        {
            enabled: prop.format === 'color-hex',
            isValid: ((value) => Color.Format.CSS.parseHex(value)),
            message: ( localizeWithPath(
                _moduleId,
                9,
                "Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA."
            ))
        },
        {
            enabled: prop.format === 'uri' || prop.format === 'uri-reference',
            isValid: ((value) => !!value.length),
            message: ( localizeWithPath(_moduleId, 10, "URI expected."))
        },
        {
            enabled: prop.format === 'uri' || prop.format === 'uri-reference',
            isValid: ((value) => uriRegex.test(value)),
            message: ( localizeWithPath(_moduleId, 11, "URI is expected."))
        },
        {
            enabled: prop.format === 'uri',
            isValid: ((value) => {
                const matches = value.match(uriRegex);
                return !!(matches && matches[2]);
            }),
            message: ( localizeWithPath(_moduleId, 12, "URI with a scheme is expected."))
        },
        {
            enabled: prop.enum !== undefined,
            isValid: ((value) => {
                return prop.enum.includes(value);
            }),
            message: ( localizeWithPath(
                _moduleId,
                13,
                "Value is not accepted. Valid values: {0}.",
                prop.enum ? ( (prop.enum.map(key => `"${key}"`))).join(', ') : '[]'
            ))
        }
    ].filter(validation => validation.enabled);
}
function getNumericValidators(prop) {
    const type = Array.isArray(prop.type) ? prop.type : [prop.type];
    const isNullable = canBeType(type, 'null');
    const isIntegral = (canBeType(type, 'integer')) && (type.length === 1 || type.length === 2 && isNullable);
    const isNumeric = canBeType(type, 'number', 'integer') && (type.length === 1 || type.length === 2 && isNullable);
    if (!isNumeric) {
        return [];
    }
    let exclusiveMax;
    let exclusiveMin;
    if (typeof prop.exclusiveMaximum === 'boolean') {
        exclusiveMax = prop.exclusiveMaximum ? prop.maximum : undefined;
    }
    else {
        exclusiveMax = prop.exclusiveMaximum;
    }
    if (typeof prop.exclusiveMinimum === 'boolean') {
        exclusiveMin = prop.exclusiveMinimum ? prop.minimum : undefined;
    }
    else {
        exclusiveMin = prop.exclusiveMinimum;
    }
    return [
        {
            enabled: exclusiveMax !== undefined && (prop.maximum === undefined || exclusiveMax <= prop.maximum),
            isValid: ((value) => value < exclusiveMax),
            message: ( localizeWithPath(_moduleId, 14, "Value must be strictly less than {0}.", exclusiveMax))
        },
        {
            enabled: exclusiveMin !== undefined && (prop.minimum === undefined || exclusiveMin >= prop.minimum),
            isValid: ((value) => value > exclusiveMin),
            message: ( localizeWithPath(_moduleId, 15, "Value must be strictly greater than {0}.", exclusiveMin))
        },
        {
            enabled: prop.maximum !== undefined && (exclusiveMax === undefined || exclusiveMax > prop.maximum),
            isValid: ((value) => value <= prop.maximum),
            message: ( localizeWithPath(_moduleId, 16, "Value must be less than or equal to {0}.", prop.maximum))
        },
        {
            enabled: prop.minimum !== undefined && (exclusiveMin === undefined || exclusiveMin < prop.minimum),
            isValid: ((value) => value >= prop.minimum),
            message: ( localizeWithPath(_moduleId, 17, "Value must be greater than or equal to {0}.", prop.minimum))
        },
        {
            enabled: prop.multipleOf !== undefined,
            isValid: ((value) => value % prop.multipleOf === 0),
            message: ( localizeWithPath(_moduleId, 18, "Value must be a multiple of {0}.", prop.multipleOf))
        },
        {
            enabled: isIntegral,
            isValid: ((value) => value % 1 === 0),
            message: ( localizeWithPath(_moduleId, 19, "Value must be an integer."))
        },
    ].filter(validation => validation.enabled);
}
function getArrayValidator(prop) {
    if (prop.type === 'array' && prop.items && !Array.isArray(prop.items)) {
        const propItems = prop.items;
        if (propItems && !Array.isArray(propItems.type)) {
            const withQuotes = (s) => `'` + s + `'`;
            return value => {
                if (!value) {
                    return null;
                }
                let message = '';
                if (!Array.isArray(value)) {
                    message += ( localizeWithPath(_moduleId, 20, 'Incorrect type. Expected an array.'));
                    message += '\n';
                    return message;
                }
                const arrayValue = value;
                if (prop.uniqueItems) {
                    if (( (new Set(arrayValue))).size < arrayValue.length) {
                        message += ( localizeWithPath(_moduleId, 21, 'Array has duplicate items'));
                        message += '\n';
                    }
                }
                if (prop.minItems && arrayValue.length < prop.minItems) {
                    message += ( localizeWithPath(_moduleId, 22, 'Array must have at least {0} items', prop.minItems));
                    message += '\n';
                }
                if (prop.maxItems && arrayValue.length > prop.maxItems) {
                    message += ( localizeWithPath(_moduleId, 23, 'Array must have at most {0} items', prop.maxItems));
                    message += '\n';
                }
                if (propItems.type === 'string') {
                    if (!isStringArray(arrayValue)) {
                        message += ( localizeWithPath(_moduleId, 24, 'Incorrect type. Expected a string array.'));
                        message += '\n';
                        return message;
                    }
                    if (typeof propItems.pattern === 'string') {
                        const patternRegex = toRegExp(propItems.pattern);
                        arrayValue.forEach(v => {
                            if (!patternRegex.test(v)) {
                                message +=
                                    propItems.patternErrorMessage ||
                                        ( localizeWithPath(
                                            _moduleId,
                                            25,
                                            'Value {0} must match regex {1}.',
                                            withQuotes(v),
                                            withQuotes(propItems.pattern)
                                        ));
                            }
                        });
                    }
                    const propItemsEnum = propItems.enum;
                    if (propItemsEnum) {
                        arrayValue.forEach(v => {
                            if (propItemsEnum.indexOf(v) === -1) {
                                message += ( localizeWithPath(
                                    _moduleId,
                                    26,
                                    'Value {0} is not one of {1}',
                                    withQuotes(v),
                                    '[' + ( (propItemsEnum.map(withQuotes))).join(', ') + ']'
                                ));
                                message += '\n';
                            }
                        });
                    }
                }
                else if (propItems.type === 'integer' || propItems.type === 'number') {
                    arrayValue.forEach(v => {
                        const errorMessage = getErrorsForSchema(propItems, v);
                        if (errorMessage) {
                            message += `${v}: ${errorMessage}\n`;
                        }
                    });
                }
                return message;
            };
        }
    }
    return null;
}
function getObjectValidator(prop) {
    if (prop.type === 'object') {
        const { properties, patternProperties, additionalProperties } = prop;
        return value => {
            if (!value) {
                return null;
            }
            const errors = [];
            if (!isObject(value)) {
                errors.push(( localizeWithPath(_moduleId, 27, 'Incorrect type. Expected an object.')));
            }
            else {
                ( (Object.keys(value))).forEach((key) => {
                    const data = value[key];
                    if (properties && key in properties) {
                        const errorMessage = getErrorsForSchema(properties[key], data);
                        if (errorMessage) {
                            errors.push(`${key}: ${errorMessage}\n`);
                        }
                        return;
                    }
                    if (patternProperties) {
                        for (const pattern in patternProperties) {
                            if (RegExp(pattern).test(key)) {
                                const errorMessage = getErrorsForSchema(patternProperties[pattern], data);
                                if (errorMessage) {
                                    errors.push(`${key}: ${errorMessage}\n`);
                                }
                                return;
                            }
                        }
                    }
                    if (additionalProperties === false) {
                        errors.push(( localizeWithPath(_moduleId, 28, 'Property {0} is not allowed.\n', key)));
                    }
                    else if (typeof additionalProperties === 'object') {
                        const errorMessage = getErrorsForSchema(additionalProperties, data);
                        if (errorMessage) {
                            errors.push(`${key}: ${errorMessage}\n`);
                        }
                    }
                });
            }
            if (errors.length) {
                return prop.errorMessage ? [prop.errorMessage, ...errors].join(' ') : errors.join(' ');
            }
            return '';
        };
    }
    return null;
}
function getErrorsForSchema(propertySchema, data) {
    const validator = createValidator(propertySchema);
    const errorMessage = validator(data);
    return errorMessage;
}
export { createValidator, getInvalidTypeError };
