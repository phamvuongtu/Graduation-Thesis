import { ServiceIdentifier } from '../../../../platform/instantiation/common/instantiation.js';
import { URI } from '../../../../base/common/uri.js';
import { IDisposable } from '../../../../base/common/lifecycle.js';
import { IRevertOptions } from '../../../common/editor.js';
import { ReadableStream } from '../../../../base/common/stream.js';
import { IFileStatWithMetadata } from '../../../../platform/files/common/files.js';
import { ITextSnapshot } from '../../../../editor/common/model.js';
import { VSBufferReadable, VSBuffer, VSBufferReadableStream } from '../../../../base/common/buffer.js';
import { IUntitledTextEditorModelManager } from '../../untitled/common/untitledTextEditorService.js';
import { IFileOperationUndoRedoInfo } from '../../workingCopy/common/workingCopyFileService.js';
import { ITextFileEditorModelManager, IResourceEncodings, ITextFileSaveOptions, ITextFileSaveAsOptions, IReadTextFileOptions, ITextFileContent, ITextFileStreamContent, IWriteTextFileOptions, IReadTextFileEncodingOptions } from './textfiles.js';

declare const ITextFileService: ServiceIdentifier<ITextFileService>;
interface ITextFileService extends IDisposable {
    readonly _serviceBrand: undefined;
    /**
    * Access to the manager of text file editor models providing further
    * methods to work with them.
    */
    readonly files: ITextFileEditorModelManager;
    /**
    * Access to the manager of untitled text editor models providing further
    * methods to work with them.
    */
    readonly untitled: IUntitledTextEditorModelManager;
    /**
    * Helper to determine encoding for resources.
    */
    readonly encoding: IResourceEncodings;
    /**
    * A resource is dirty if it has unsaved changes or is an untitled file not yet saved.
    *
    * @param resource the resource to check for being dirty
    */
    isDirty(resource: URI): boolean;
    /**
    * Saves the resource.
    *
    * @param resource the resource to save
    * @param options optional save options
    * @return Path of the saved resource or undefined if canceled.
    */
    save(resource: URI, options?: ITextFileSaveOptions): Promise<URI | undefined>;
    /**
    * Saves the provided resource asking the user for a file name or using the provided one.
    *
    * @param resource the resource to save as.
    * @param targetResource the optional target to save to.
    * @param options optional save options
    * @return Path of the saved resource or undefined if canceled.
    */
    saveAs(resource: URI, targetResource?: URI, options?: ITextFileSaveAsOptions): Promise<URI | undefined>;
    /**
    * Reverts the provided resource.
    *
    * @param resource the resource of the file to revert.
    * @param force to force revert even when the file is not dirty
    */
    revert(resource: URI, options?: IRevertOptions): Promise<void>;
    /**
    * Read the contents of a file identified by the resource.
    */
    read(resource: URI, options?: IReadTextFileOptions): Promise<ITextFileContent>;
    /**
    * Read the contents of a file identified by the resource as stream.
    */
    readStream(resource: URI, options?: IReadTextFileOptions): Promise<ITextFileStreamContent>;
    /**
    * Update a file with given contents.
    */
    write(resource: URI, value: string | ITextSnapshot, options?: IWriteTextFileOptions): Promise<IFileStatWithMetadata>;
    /**
    * Create files. If the file exists it will be overwritten with the contents if
    * the options enable to overwrite.
    */
    create(operations: {
        resource: URI;
        value?: string | ITextSnapshot;
        options?: {
            overwrite?: boolean;
        };
    }[], undoInfo?: IFileOperationUndoRedoInfo): Promise<readonly IFileStatWithMetadata[]>;
    /**
    * Returns the readable that uses the appropriate encoding. This method should
    * be used whenever a `string` or `ITextSnapshot` is being persisted to the
    * file system.
    */
    getEncodedReadable(resource: URI, value: ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBufferReadable>;
    getEncodedReadable(resource: URI, value: string, options?: IWriteTextFileOptions): Promise<VSBuffer>;
    getEncodedReadable(resource: URI, value?: ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBufferReadable | undefined>;
    getEncodedReadable(resource: URI, value?: string, options?: IWriteTextFileOptions): Promise<VSBuffer | undefined>;
    getEncodedReadable(resource: URI, value?: string | ITextSnapshot, options?: IWriteTextFileOptions): Promise<VSBuffer | VSBufferReadable | undefined>;
    /**
    * Returns a stream of strings that uses the appropriate encoding. This method should
    * be used whenever a `VSBufferReadableStream` is being loaded from the file system.
    *
    * Will throw an error if `acceptTextOnly: true` for resources that seem to be binary.
    */
    getDecodedStream(resource: URI, value: VSBufferReadableStream, options?: IReadTextFileEncodingOptions): Promise<ReadableStream<string>>;
}

export { ITextFileService };
