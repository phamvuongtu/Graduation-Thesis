import { __decorate, __param } from '../../../../../external/tslib/tslib.es6.js';
import { localizeWithPath } from '../../nls.js';
import { Extensions as Extensions$1 } from '../../platform/configuration/common/configurationRegistry.js';
import { Registry } from '../../platform/registry/common/platform.js';
import { IWorkspaceContextService } from '../../platform/workspace/common/workspace.service.js';
import { IConfigurationService } from '../../platform/configuration/common/configuration.service.js';
import { Disposable } from '../../base/common/lifecycle.js';
import { Emitter } from '../../base/common/event.js';
import { IRemoteAgentService } from '../services/remote/common/remoteAgentService.service.js';
import { isWindows } from '../../base/common/platform.js';
import { equals } from '../../base/common/objects.js';
import { DeferredPromise } from '../../base/common/async.js';
const _moduleId = "vs/workbench/common/configuration";
const applicationConfigurationNodeBase = ( (Object.freeze({
    'id': 'application',
    'order': 100,
    'title': ( localizeWithPath(_moduleId, 0, "Application")),
    'type': 'object'
})));
const workbenchConfigurationNodeBase = ( (Object.freeze({
    'id': 'workbench',
    'order': 7,
    'title': ( localizeWithPath(_moduleId, 1, "Workbench")),
    'type': 'object',
})));
const securityConfigurationNodeBase = ( (Object.freeze({
    'id': 'security',
    'scope': 1 ,
    'title': ( localizeWithPath(_moduleId, 2, "Security")),
    'type': 'object',
    'order': 7
})));
const problemsConfigurationNodeBase = ( (Object.freeze({
    'id': 'problems',
    'title': ( localizeWithPath(_moduleId, 3, "Problems")),
    'type': 'object',
    'order': 101
})));
const Extensions = {
    ConfigurationMigration: 'base.contributions.configuration.migration'
};
class ConfigurationMigrationRegistry {
    constructor() {
        this.migrations = [];
        this._onDidRegisterConfigurationMigrations = ( (new Emitter()));
        this.onDidRegisterConfigurationMigration = this._onDidRegisterConfigurationMigrations.event;
    }
    registerConfigurationMigrations(configurationMigrations) {
        this.migrations.push(...configurationMigrations);
    }
}
const configurationMigrationRegistry = ( (new ConfigurationMigrationRegistry()));
Registry.add(Extensions.ConfigurationMigration, configurationMigrationRegistry);
let ConfigurationMigrationWorkbenchContribution = class ConfigurationMigrationWorkbenchContribution extends Disposable {
    static { this.ID = 'workbench.contrib.configurationMigration'; }
    constructor(configurationService, workspaceService) {
        super();
        this.configurationService = configurationService;
        this.workspaceService = workspaceService;
        this._register(this.workspaceService.onDidChangeWorkspaceFolders(async (e) => {
            for (const folder of e.added) {
                await this.migrateConfigurationsForFolder(folder, configurationMigrationRegistry.migrations);
            }
        }));
        this.migrateConfigurations(configurationMigrationRegistry.migrations);
        this._register(configurationMigrationRegistry.onDidRegisterConfigurationMigration(migration => this.migrateConfigurations(migration)));
    }
    async migrateConfigurations(migrations) {
        await this.migrateConfigurationsForFolder(undefined, migrations);
        for (const folder of this.workspaceService.getWorkspace().folders) {
            await this.migrateConfigurationsForFolder(folder, migrations);
        }
    }
    async migrateConfigurationsForFolder(folder, migrations) {
        await Promise.all([( (migrations.map(
            migration => this.migrateConfigurationsForFolderAndOverride(migration, folder?.uri)
        )))]);
    }
    async migrateConfigurationsForFolderAndOverride(migration, resource) {
        const inspectData = this.configurationService.inspect(migration.key, { resource });
        const targetPairs = this.workspaceService.getWorkbenchState() === 3  ? [
            ['user', 2 ],
            ['userLocal', 3 ],
            ['userRemote', 4 ],
            ['workspace', 5 ],
            ['workspaceFolder', 6 ],
        ] : [
            ['user', 2 ],
            ['userLocal', 3 ],
            ['userRemote', 4 ],
            ['workspace', 5 ],
        ];
        for (const [dataKey, target] of targetPairs) {
            const inspectValue = inspectData[dataKey];
            if (!inspectValue) {
                continue;
            }
            const migrationValues = [];
            if (inspectValue.value !== undefined) {
                const keyValuePairs = await this.runMigration(migration, dataKey, inspectValue.value, resource, undefined);
                for (const keyValuePair of keyValuePairs ?? []) {
                    migrationValues.push([keyValuePair, []]);
                }
            }
            for (const { identifiers, value } of inspectValue.overrides ?? []) {
                if (value !== undefined) {
                    const keyValuePairs = await this.runMigration(migration, dataKey, value, resource, identifiers);
                    for (const keyValuePair of keyValuePairs ?? []) {
                        migrationValues.push([keyValuePair, identifiers]);
                    }
                }
            }
            if (migrationValues.length) {
                await Promise.allSettled(( (migrationValues.map(
                    async ([[key, value], overrideIdentifiers]) => this.configurationService.updateValue(key, value.value, { resource, overrideIdentifiers }, target)
                ))));
            }
        }
    }
    async runMigration(migration, dataKey, value, resource, overrideIdentifiers) {
        const valueAccessor = (key) => {
            const inspectData = this.configurationService.inspect(key, { resource });
            const inspectValue = inspectData[dataKey];
            if (!inspectValue) {
                return undefined;
            }
            if (!overrideIdentifiers) {
                return inspectValue.value;
            }
            return inspectValue.overrides?.find(({ identifiers }) => equals(identifiers, overrideIdentifiers))?.value;
        };
        const result = await migration.migrateFn(value, valueAccessor);
        return Array.isArray(result) ? result : [[migration.key, result]];
    }
};
ConfigurationMigrationWorkbenchContribution = ( (__decorate([
    ( (__param(0, IConfigurationService))),
    ( (__param(1, IWorkspaceContextService)))
], ConfigurationMigrationWorkbenchContribution)));
let DynamicWorkbenchSecurityConfiguration = class DynamicWorkbenchSecurityConfiguration extends Disposable {
    static { this.ID = 'workbench.contrib.dynamicWorkbenchSecurityConfiguration'; }
    constructor(remoteAgentService) {
        super();
        this.remoteAgentService = remoteAgentService;
        this._ready = ( (new DeferredPromise()));
        this.ready = this._ready.p;
        this.create();
    }
    async create() {
        try {
            await this.doCreate();
        }
        finally {
            this._ready.complete();
        }
    }
    async doCreate() {
        if (!isWindows) {
            const remoteEnvironment = await this.remoteAgentService.getEnvironment();
            if (remoteEnvironment?.os !== 1 ) {
                return;
            }
        }
        const registry = ( (Registry.as(Extensions$1.Configuration)));
        registry.registerConfiguration({
            ...securityConfigurationNodeBase,
            'properties': {
                'security.allowedUNCHosts': {
                    'type': 'array',
                    'items': {
                        'type': 'string',
                        'pattern': '^[^\\\\]+$',
                        'patternErrorMessage': ( localizeWithPath(_moduleId, 4, 'UNC host names must not contain backslashes.'))
                    },
                    'default': [],
                    'markdownDescription': ( localizeWithPath(
                        _moduleId,
                        5,
                        'A set of UNC host names (without leading or trailing backslash, for example `192.168.0.1` or `my-server`) to allow without user confirmation. If a UNC host is being accessed that is not allowed via this setting or has not been acknowledged via user confirmation, an error will occur and the operation stopped. A restart is required when changing this setting. Find out more about this setting at https://aka.ms/vscode-windows-unc.'
                    )),
                    'scope': 2
                },
                'security.restrictUNCAccess': {
                    'type': 'boolean',
                    'default': true,
                    'markdownDescription': ( localizeWithPath(
                        _moduleId,
                        6,
                        'If enabled, only allows access to UNC host names that are allowed by the `#security.allowedUNCHosts#` setting or after user confirmation. Find out more about this setting at https://aka.ms/vscode-windows-unc.'
                    )),
                    'scope': 2
                }
            }
        });
    }
};
DynamicWorkbenchSecurityConfiguration = ( (__decorate([
    ( (__param(0, IRemoteAgentService)))
], DynamicWorkbenchSecurityConfiguration)));
export { ConfigurationMigrationWorkbenchContribution, DynamicWorkbenchSecurityConfiguration, Extensions, applicationConfigurationNodeBase, problemsConfigurationNodeBase, securityConfigurationNodeBase, workbenchConfigurationNodeBase };
