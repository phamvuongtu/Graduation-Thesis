import { IDisposable } from '../../base/common/lifecycle.js';
import { URI } from '../../base/common/uri.js';
import { Event } from '../../base/common/event.js';
import { MarkdownString } from '../../base/common/htmlContent.js';
import { ThemeIcon } from '../../base/common/themables.js';
import '../../editor/editor.api.js';
import { SyncDescriptor } from '../../platform/instantiation/common/descriptors.js';
import { ContextKeyExpression } from '../../platform/contextkey/common/contextkey.js';
import { ExtensionIdentifier } from '../../platform/extensions/common/extensions.js';
import Severity from '../../base/common/severity.js';
import { IKeybindings } from '../../platform/keybinding/common/keybindingsRegistry.js';
import { IProgressIndicator } from '../../platform/progress/common/progress.js';
import { ILocalizedString } from '../../platform/action/common/action.js';

declare const enum ViewContainerLocation {
    Sidebar = 0,
    Panel = 1,
    AuxiliaryBar = 2
}
type OpenCommandActionDescriptor = {
    readonly id: string;
    readonly title?: ILocalizedString | string;
    readonly mnemonicTitle?: string;
    readonly order?: number;
    readonly keybindings?: IKeybindings & {
        when?: ContextKeyExpression;
    };
};
/**
 * View Container Contexts
 */
interface IViewContainerDescriptor {
    /**
     * The id of the view container
     */
    readonly id: string;
    /**
     * The title of the view container
     */
    readonly title: ILocalizedString;
    /**
     * Icon representation of the View container
     */
    readonly icon?: ThemeIcon | URI;
    /**
     * Order of the view container.
     */
    readonly order?: number;
    /**
     * IViewPaneContainer Ctor to instantiate
     */
    readonly ctorDescriptor: SyncDescriptor<IViewPaneContainer>;
    /**
     * Descriptor for open view container command
     * If not provided, view container info (id, title) is used.
     *
     * Note: To prevent registering open command, use `doNotRegisterOpenCommand` flag while registering the view container
     */
    readonly openCommandActionDescriptor?: OpenCommandActionDescriptor;
    /**
     * Storage id to use to store the view container state.
     * If not provided, it will be derived.
     */
    readonly storageId?: string;
    /**
     * If enabled, view container is not shown if it has no active views.
     */
    readonly hideIfEmpty?: boolean;
    /**
     * Id of the extension that contributed the view container
     */
    readonly extensionId?: ExtensionIdentifier;
    readonly alwaysUseContainerInfo?: boolean;
    readonly viewOrderDelegate?: ViewOrderDelegate;
    readonly rejectAddedViews?: boolean;
    requestedIndex?: number;
}
interface IViewContainersRegistry {
    /**
     * An event that is triggered when a view container is registered.
     */
    readonly onDidRegister: Event<{
        viewContainer: ViewContainer;
        viewContainerLocation: ViewContainerLocation;
    }>;
    /**
     * An event that is triggered when a view container is deregistered.
     */
    readonly onDidDeregister: Event<{
        viewContainer: ViewContainer;
        viewContainerLocation: ViewContainerLocation;
    }>;
    /**
     * All registered view containers
     */
    readonly all: ViewContainer[];
    /**
     * Registers a view container to given location.
     * No op if a view container is already registered.
     *
     * @param viewContainerDescriptor descriptor of view container
     * @param location location of the view container
     *
     * @returns the registered ViewContainer.
     */
    registerViewContainer(viewContainerDescriptor: IViewContainerDescriptor, location: ViewContainerLocation, options?: {
        isDefault?: boolean;
        doNotRegisterOpenCommand?: boolean;
    }): ViewContainer;
    /**
     * Deregisters the given view container
     * No op if the view container is not registered
     */
    deregisterViewContainer(viewContainer: ViewContainer): void;
    /**
     * Returns the view container with given id.
     *
     * @returns the view container with given id.
     */
    get(id: string): ViewContainer | undefined;
    /**
     * Returns all view containers in the given location
     */
    getViewContainers(location: ViewContainerLocation): ViewContainer[];
    /**
     * Returns the view container location
     */
    getViewContainerLocation(container: ViewContainer): ViewContainerLocation;
    /**
     * Return the default view container from the given location
     */
    getDefaultViewContainer(location: ViewContainerLocation): ViewContainer | undefined;
}
interface ViewOrderDelegate {
    getOrder(group?: string): number | undefined;
}
interface ViewContainer extends IViewContainerDescriptor {
}
interface IViewDescriptor {
    readonly type?: string;
    readonly id: string;
    readonly name: ILocalizedString;
    readonly ctorDescriptor: SyncDescriptor<IView>;
    readonly when?: ContextKeyExpression;
    readonly order?: number;
    readonly weight?: number;
    readonly collapsed?: boolean;
    readonly canToggleVisibility?: boolean;
    readonly canMoveView?: boolean;
    readonly containerIcon?: ThemeIcon | URI;
    readonly containerTitle?: string;
    readonly singleViewPaneContainerTitle?: string;
    readonly hideByDefault?: boolean;
    readonly workspace?: boolean;
    readonly focusCommand?: {
        id: string;
        keybindings?: IKeybindings;
    };
    readonly group?: string;
    readonly remoteAuthority?: string | string[];
    readonly virtualWorkspace?: string;
    readonly openCommandActionDescriptor?: OpenCommandActionDescriptor;
    readonly accessibilityHelpContent?: MarkdownString;
}
interface IViewDescriptorRef {
    viewDescriptor: IViewDescriptor;
    index: number;
}
interface IAddedViewDescriptorRef extends IViewDescriptorRef {
    collapsed: boolean;
    size?: number;
}
interface IViewContainerModel {
    readonly viewContainer: ViewContainer;
    readonly title: string;
    readonly icon: ThemeIcon | URI | undefined;
    readonly keybindingId: string | undefined;
    readonly onDidChangeContainerInfo: Event<{
        title?: boolean;
        icon?: boolean;
        keybindingId?: boolean;
        badgeEnablement?: boolean;
    }>;
    readonly allViewDescriptors: ReadonlyArray<IViewDescriptor>;
    readonly onDidChangeAllViewDescriptors: Event<{
        added: ReadonlyArray<IViewDescriptor>;
        removed: ReadonlyArray<IViewDescriptor>;
    }>;
    readonly activeViewDescriptors: ReadonlyArray<IViewDescriptor>;
    readonly onDidChangeActiveViewDescriptors: Event<{
        added: ReadonlyArray<IViewDescriptor>;
        removed: ReadonlyArray<IViewDescriptor>;
    }>;
    readonly visibleViewDescriptors: ReadonlyArray<IViewDescriptor>;
    readonly onDidAddVisibleViewDescriptors: Event<IAddedViewDescriptorRef[]>;
    readonly onDidRemoveVisibleViewDescriptors: Event<IViewDescriptorRef[]>;
    readonly onDidMoveVisibleViewDescriptors: Event<{
        from: IViewDescriptorRef;
        to: IViewDescriptorRef;
    }>;
    isVisible(id: string): boolean;
    setVisible(id: string, visible: boolean): void;
    isCollapsed(id: string): boolean;
    setCollapsed(id: string, collapsed: boolean): void;
    getSize(id: string): number | undefined;
    setSizes(newSizes: readonly {
        id: string;
        size: number;
    }[]): void;
    move(from: string, to: string): void;
}
interface IViewContentDescriptor {
    readonly content: string;
    readonly when?: ContextKeyExpression | 'default';
    readonly group?: string;
    readonly order?: number;
    readonly precondition?: ContextKeyExpression | undefined;
}
interface IViewsRegistry {
    readonly onViewsRegistered: Event<{
        views: IViewDescriptor[];
        viewContainer: ViewContainer;
    }[]>;
    readonly onViewsDeregistered: Event<{
        views: IViewDescriptor[];
        viewContainer: ViewContainer;
    }>;
    readonly onDidChangeContainer: Event<{
        views: IViewDescriptor[];
        from: ViewContainer;
        to: ViewContainer;
    }>;
    registerViews(views: IViewDescriptor[], viewContainer: ViewContainer): void;
    registerViews2(views: {
        views: IViewDescriptor[];
        viewContainer: ViewContainer;
    }[]): void;
    deregisterViews(views: IViewDescriptor[], viewContainer: ViewContainer): void;
    moveViews(views: IViewDescriptor[], viewContainer: ViewContainer): void;
    getViews(viewContainer: ViewContainer): IViewDescriptor[];
    getView(id: string): IViewDescriptor | null;
    getViewContainer(id: string): ViewContainer | null;
    readonly onDidChangeViewWelcomeContent: Event<string>;
    registerViewWelcomeContent(id: string, viewContent: IViewContentDescriptor): IDisposable;
    registerViewWelcomeContent2<TKey>(id: string, viewContentMap: Map<TKey, IViewContentDescriptor>): Map<TKey, IDisposable>;
    getViewWelcomeContent(id: string): IViewContentDescriptor[];
}
interface IView {
    readonly id: string;
    focus(): void;
    isVisible(): boolean;
    isBodyVisible(): boolean;
    setExpanded(expanded: boolean): boolean;
    getProgressIndicator(): IProgressIndicator | undefined;
}
declare enum ViewVisibilityState {
    Default = 0,
    Expand = 1
}
interface IEditableData {
    validationMessage: (value: string) => {
        content: string;
        severity: Severity;
    } | null;
    placeholder?: string | null;
    startingValue?: string | null;
    onFinish: (value: string, success: boolean) => Promise<void>;
}
interface IViewPaneContainer {
    onDidAddViews: Event<IView[]>;
    onDidRemoveViews: Event<IView[]>;
    onDidChangeViewVisibility: Event<IView>;
    readonly views: IView[];
    setVisible(visible: boolean): void;
    isVisible(): boolean;
    focus(): void;
    getActionsContext(): unknown;
    getView(viewId: string): IView | undefined;
    toggleViewVisibility(viewId: string): void;
}

export { type IAddedViewDescriptorRef, type IEditableData, type IView, type IViewContainerDescriptor, type IViewContainerModel, type IViewContainersRegistry, type IViewContentDescriptor, type IViewDescriptor, type IViewDescriptorRef, type IViewPaneContainer, type IViewsRegistry, type ViewContainer, ViewContainerLocation, ViewVisibilityState };
