import { __decorate, __param } from '../../../../../external/tslib/tslib.es6.js';
import { DisposableStore } from '../../base/common/lifecycle.js';
import { localizeWithPath } from '../../nls.js';
import { RawContextKey } from '../../platform/contextkey/common/contextkey.js';
import { IContextKeyService } from '../../platform/contextkey/common/contextkey.service.js';
import { isEqual, basename, dirname, extname } from '../../base/common/resources.js';
import { ILanguageService } from '../../editor/common/languages/language.js';
import { IFileService } from '../../platform/files/common/files.service.js';
import { IModelService } from '../../editor/common/services/model.js';
import { Schemas } from '../../base/common/network.js';
import { DEFAULT_EDITOR_ASSOCIATION } from './editor.js';
import { isLinux } from '../../base/common/platform.js';
var ResourceContextKey_1;
const _moduleId = "vs/workbench/common/contextkeys";
const WorkbenchStateContext = ( (new RawContextKey('workbenchState', undefined, { type: 'string', description: ( localizeWithPath(
    _moduleId,
    0,
    "The kind of workspace opened in the window, either 'empty' (no workspace), 'folder' (single folder) or 'workspace' (multi-root workspace)"
)) })));
const WorkspaceFolderCountContext = ( (new RawContextKey('workspaceFolderCount', 0, ( localizeWithPath(_moduleId, 1, "The number of root folders in the workspace")))));
const OpenFolderWorkspaceSupportContext = ( (new RawContextKey('openFolderWorkspaceSupport', true, true)));
const EnterMultiRootWorkspaceSupportContext = ( (new RawContextKey('enterMultiRootWorkspaceSupport', true, true)));
const EmptyWorkspaceSupportContext = ( (new RawContextKey('emptyWorkspaceSupport', true, true)));
const DirtyWorkingCopiesContext = ( (new RawContextKey('dirtyWorkingCopies', false, ( localizeWithPath(_moduleId, 2, "Whether there are any working copies with unsaved changes")))));
const RemoteNameContext = ( (new RawContextKey('remoteName', '', ( localizeWithPath(
    _moduleId,
    3,
    "The name of the remote the window is connected to or an empty string if not connected to any remote"
)))));
const VirtualWorkspaceContext = ( (new RawContextKey('virtualWorkspace', '', ( localizeWithPath(
    _moduleId,
    4,
    "The scheme of the current workspace is from a virtual file system or an empty string."
)))));
const TemporaryWorkspaceContext = ( (new RawContextKey('temporaryWorkspace', false, ( localizeWithPath(
    _moduleId,
    5,
    "The scheme of the current workspace is from a temporary file system."
)))));
const IsMainWindowFullscreenContext = ( (new RawContextKey('isFullscreen', false, ( localizeWithPath(_moduleId, 6, "Whether the main window is in fullscreen mode")))));
const IsAuxiliaryWindowFocusedContext = ( (new RawContextKey('isAuxiliaryWindowFocusedContext', false, ( localizeWithPath(_moduleId, 7, "Whether an auxiliary window is focused")))));
const HasWebFileSystemAccess = ( (new RawContextKey('hasWebFileSystemAccess', false, true)));
const EmbedderIdentifierContext = ( (new RawContextKey('embedderIdentifier', undefined, ( localizeWithPath(
    _moduleId,
    8,
    'The identifier of the embedder according to the product service, if one is defined'
)))));
const ActiveEditorDirtyContext = ( (new RawContextKey('activeEditorIsDirty', false, ( localizeWithPath(_moduleId, 9, "Whether the active editor has unsaved changes")))));
const ActiveEditorPinnedContext = ( (new RawContextKey('activeEditorIsNotPreview', false, ( localizeWithPath(_moduleId, 10, "Whether the active editor is not in preview mode")))));
const ActiveEditorFirstInGroupContext = ( (new RawContextKey('activeEditorIsFirstInGroup', false, ( localizeWithPath(_moduleId, 11, "Whether the active editor is the first one in its group")))));
const ActiveEditorLastInGroupContext = ( (new RawContextKey('activeEditorIsLastInGroup', false, ( localizeWithPath(_moduleId, 12, "Whether the active editor is the last one in its group")))));
const ActiveEditorStickyContext = ( (new RawContextKey('activeEditorIsPinned', false, ( localizeWithPath(_moduleId, 13, "Whether the active editor is pinned")))));
const ActiveEditorReadonlyContext = ( (new RawContextKey('activeEditorIsReadonly', false, ( localizeWithPath(_moduleId, 14, "Whether the active editor is read-only")))));
const ActiveCompareEditorCanSwapContext = ( (new RawContextKey('activeCompareEditorCanSwap', false, ( localizeWithPath(_moduleId, 15, "Whether the active compare editor can swap sides")))));
const ActiveEditorCanToggleReadonlyContext = ( (new RawContextKey('activeEditorCanToggleReadonly', true, ( localizeWithPath(
    _moduleId,
    16,
    "Whether the active editor can toggle between being read-only or writeable"
)))));
const ActiveEditorCanRevertContext = ( (new RawContextKey('activeEditorCanRevert', false, ( localizeWithPath(_moduleId, 17, "Whether the active editor can revert")))));
const ActiveEditorCanSplitInGroupContext = ( (new RawContextKey('activeEditorCanSplitInGroup', true)));
const ActiveEditorContext = ( (new RawContextKey('activeEditor', null, { type: 'string', description: ( localizeWithPath(_moduleId, 18, "The identifier of the active editor")) })));
const ActiveEditorAvailableEditorIdsContext = ( (new RawContextKey('activeEditorAvailableEditorIds', '', ( localizeWithPath(
    _moduleId,
    19,
    "The available editor identifiers that are usable for the active editor"
)))));
const TextCompareEditorVisibleContext = ( (new RawContextKey('textCompareEditorVisible', false, ( localizeWithPath(_moduleId, 20, "Whether a text compare editor is visible")))));
const TextCompareEditorActiveContext = ( (new RawContextKey('textCompareEditorActive', false, ( localizeWithPath(_moduleId, 21, "Whether a text compare editor is active")))));
const SideBySideEditorActiveContext = ( (new RawContextKey('sideBySideEditorActive', false, ( localizeWithPath(_moduleId, 22, "Whether a side by side editor is active")))));
const EditorGroupEditorsCountContext = ( (new RawContextKey('groupEditorsCount', 0, ( localizeWithPath(_moduleId, 23, "The number of opened editor groups")))));
const ActiveEditorGroupEmptyContext = ( (new RawContextKey('activeEditorGroupEmpty', false, ( localizeWithPath(_moduleId, 24, "Whether the active editor group is empty")))));
const ActiveEditorGroupIndexContext = ( (new RawContextKey('activeEditorGroupIndex', 0, ( localizeWithPath(_moduleId, 25, "The index of the active editor group")))));
const ActiveEditorGroupLastContext = ( (new RawContextKey('activeEditorGroupLast', false, ( localizeWithPath(_moduleId, 26, "Whether the active editor group is the last group")))));
const ActiveEditorGroupLockedContext = ( (new RawContextKey('activeEditorGroupLocked', false, ( localizeWithPath(_moduleId, 27, "Whether the active editor group is locked")))));
const MultipleEditorGroupsContext = ( (new RawContextKey('multipleEditorGroups', false, ( localizeWithPath(_moduleId, 28, "Whether there are multiple editor groups opened")))));
const EditorPartMultipleEditorGroupsContext = ( (new RawContextKey('editorPartMultipleEditorGroups', false, ( localizeWithPath(
    _moduleId,
    29,
    "Whether there are multiple editor groups opened in an editor part"
)))));
const EditorPartMaximizedEditorGroupContext = ( (new RawContextKey('editorPartMaximizedEditorGroup', false, ( localizeWithPath(_moduleId, 30, "Editor Part has a maximized group")))));
const IsAuxiliaryEditorPartContext = ( (new RawContextKey('isAuxiliaryEditorPart', false, ( localizeWithPath(_moduleId, 31, "Editor Part is in an auxiliary window")))));
const EditorsVisibleContext = ( (new RawContextKey('editorIsOpen', false, ( localizeWithPath(_moduleId, 32, "Whether an editor is open")))));
const InEditorZenModeContext = ( (new RawContextKey('inZenMode', false, ( localizeWithPath(_moduleId, 33, "Whether Zen mode is enabled")))));
const IsMainEditorCenteredLayoutContext = ( (new RawContextKey('isCenteredLayout', false, ( localizeWithPath(_moduleId, 34, "Whether centered layout is enabled for the main editor")))));
const SplitEditorsVertically = ( (new RawContextKey('splitEditorsVertically', false, ( localizeWithPath(_moduleId, 35, "Whether editors split vertically")))));
const MainEditorAreaVisibleContext = ( (new RawContextKey('mainEditorAreaVisible', true, ( localizeWithPath(_moduleId, 36, "Whether the editor area in the main window is visible")))));
const EditorTabsVisibleContext = ( (new RawContextKey('editorTabsVisible', true, ( localizeWithPath(_moduleId, 37, "Whether editor tabs are visible")))));
const SideBarVisibleContext = ( (new RawContextKey('sideBarVisible', false, ( localizeWithPath(_moduleId, 38, "Whether the sidebar is visible")))));
const SidebarFocusContext = ( (new RawContextKey('sideBarFocus', false, ( localizeWithPath(_moduleId, 39, "Whether the sidebar has keyboard focus")))));
const ActiveViewletContext = ( (new RawContextKey('activeViewlet', '', ( localizeWithPath(_moduleId, 40, "The identifier of the active viewlet")))));
const StatusBarFocused = ( (new RawContextKey('statusBarFocused', false, ( localizeWithPath(_moduleId, 41, "Whether the status bar has keyboard focus")))));
const TitleBarStyleContext = ( (new RawContextKey('titleBarStyle', isLinux ? 'native' : 'custom', ( localizeWithPath(_moduleId, 42, "Style of the window title bar")))));
const TitleBarVisibleContext = ( (new RawContextKey('titleBarVisible', false, ( localizeWithPath(_moduleId, 43, "Whether the title bar is visible")))));
const BannerFocused = ( (new RawContextKey('bannerFocused', false, ( localizeWithPath(_moduleId, 44, "Whether the banner has keyboard focus")))));
const NotificationFocusedContext = ( (new RawContextKey('notificationFocus', true, ( localizeWithPath(_moduleId, 45, "Whether a notification has keyboard focus")))));
const NotificationsCenterVisibleContext = ( (new RawContextKey('notificationCenterVisible', false, ( localizeWithPath(_moduleId, 46, "Whether the notifications center is visible")))));
const NotificationsToastsVisibleContext = ( (new RawContextKey('notificationToastsVisible', false, ( localizeWithPath(_moduleId, 47, "Whether a notification toast is visible")))));
const ActiveAuxiliaryContext = ( (new RawContextKey('activeAuxiliary', '', ( localizeWithPath(_moduleId, 48, "The identifier of the active auxiliary panel")))));
const AuxiliaryBarFocusContext = ( (new RawContextKey('auxiliaryBarFocus', false, ( localizeWithPath(_moduleId, 49, "Whether the auxiliary bar has keyboard focus")))));
const AuxiliaryBarVisibleContext = ( (new RawContextKey('auxiliaryBarVisible', false, ( localizeWithPath(_moduleId, 50, "Whether the auxiliary bar is visible")))));
const ActivePanelContext = ( (new RawContextKey('activePanel', '', ( localizeWithPath(_moduleId, 51, "The identifier of the active panel")))));
const PanelFocusContext = ( (new RawContextKey('panelFocus', false, ( localizeWithPath(_moduleId, 52, "Whether the panel has keyboard focus")))));
const PanelPositionContext = ( (new RawContextKey('panelPosition', 'bottom', ( localizeWithPath(_moduleId, 53, "The position of the panel, always 'bottom'")))));
const PanelAlignmentContext = ( (new RawContextKey('panelAlignment', 'center', ( localizeWithPath(
    _moduleId,
    54,
    "The alignment of the panel, either 'center', 'left', 'right' or 'justify'"
)))));
const PanelVisibleContext = ( (new RawContextKey('panelVisible', false, ( localizeWithPath(_moduleId, 55, "Whether the panel is visible")))));
const PanelMaximizedContext = ( (new RawContextKey('panelMaximized', false, ( localizeWithPath(_moduleId, 56, "Whether the panel is maximized")))));
const FocusedViewContext = ( (new RawContextKey('focusedView', '', ( localizeWithPath(_moduleId, 57, "The identifier of the view that has keyboard focus")))));
function getVisbileViewContextKey(viewId) { return `view.${viewId}.visible`; }
let ResourceContextKey = class ResourceContextKey {
    static { ResourceContextKey_1 = this; }
    static { this.Scheme = ( (new RawContextKey('resourceScheme', undefined, { type: 'string', description: ( localizeWithPath(_moduleId, 58, "The scheme of the resource")) }))); }
    static { this.Filename = ( (new RawContextKey(
        'resourceFilename',
        undefined,
        { type: 'string', description: ( localizeWithPath(_moduleId, 59, "The file name of the resource")) }
    ))); }
    static { this.Dirname = ( (new RawContextKey(
        'resourceDirname',
        undefined,
        { type: 'string', description: ( localizeWithPath(_moduleId, 60, "The folder name the resource is contained in")) }
    ))); }
    static { this.Path = ( (new RawContextKey('resourcePath', undefined, { type: 'string', description: ( localizeWithPath(_moduleId, 61, "The full path of the resource")) }))); }
    static { this.LangId = ( (new RawContextKey('resourceLangId', undefined, { type: 'string', description: ( localizeWithPath(_moduleId, 62, "The language identifier of the resource")) }))); }
    static { this.Resource = ( (new RawContextKey('resource', undefined, { type: 'URI', description: ( localizeWithPath(_moduleId, 63, "The full value of the resource including scheme and path")) }))); }
    static { this.Extension = ( (new RawContextKey(
        'resourceExtname',
        undefined,
        { type: 'string', description: ( localizeWithPath(_moduleId, 64, "The extension name of the resource")) }
    ))); }
    static { this.HasResource = ( (new RawContextKey('resourceSet', undefined, { type: 'boolean', description: ( localizeWithPath(_moduleId, 65, "Whether a resource is present or not")) }))); }
    static { this.IsFileSystemResource = ( (new RawContextKey(
        'isFileSystemResource',
        undefined,
        { type: 'boolean', description: ( localizeWithPath(_moduleId, 66, "Whether the resource is backed by a file system provider")) }
    ))); }
    constructor(_contextKeyService, _fileService, _languageService, _modelService) {
        this._contextKeyService = _contextKeyService;
        this._fileService = _fileService;
        this._languageService = _languageService;
        this._modelService = _modelService;
        this._disposables = ( (new DisposableStore()));
        this._schemeKey = ResourceContextKey_1.Scheme.bindTo(this._contextKeyService);
        this._filenameKey = ResourceContextKey_1.Filename.bindTo(this._contextKeyService);
        this._dirnameKey = ResourceContextKey_1.Dirname.bindTo(this._contextKeyService);
        this._pathKey = ResourceContextKey_1.Path.bindTo(this._contextKeyService);
        this._langIdKey = ResourceContextKey_1.LangId.bindTo(this._contextKeyService);
        this._resourceKey = ResourceContextKey_1.Resource.bindTo(this._contextKeyService);
        this._extensionKey = ResourceContextKey_1.Extension.bindTo(this._contextKeyService);
        this._hasResource = ResourceContextKey_1.HasResource.bindTo(this._contextKeyService);
        this._isFileSystemResource = ResourceContextKey_1.IsFileSystemResource.bindTo(this._contextKeyService);
        this._disposables.add(_fileService.onDidChangeFileSystemProviderRegistrations(() => {
            const resource = this.get();
            this._isFileSystemResource.set(Boolean(resource && _fileService.hasProvider(resource)));
        }));
        this._disposables.add(_modelService.onModelAdded(model => {
            if (isEqual(model.uri, this.get())) {
                this._setLangId();
            }
        }));
        this._disposables.add(_modelService.onModelLanguageChanged(e => {
            if (isEqual(e.model.uri, this.get())) {
                this._setLangId();
            }
        }));
    }
    dispose() {
        this._disposables.dispose();
    }
    _setLangId() {
        const value = this.get();
        if (!value) {
            this._langIdKey.set(null);
            return;
        }
        const langId = this._modelService.getModel(value)?.getLanguageId() ?? this._languageService.guessLanguageIdByFilepathOrFirstLine(value);
        this._langIdKey.set(langId);
    }
    set(value) {
        value = value ?? undefined;
        if (isEqual(this._value, value)) {
            return;
        }
        this._value = value;
        this._contextKeyService.bufferChangeEvents(() => {
            this._resourceKey.set(value ? ( (value.toString())) : null);
            this._schemeKey.set(value ? value.scheme : null);
            this._filenameKey.set(value ? basename(value) : null);
            this._dirnameKey.set(value ? this.uriToPath(dirname(value)) : null);
            this._pathKey.set(value ? this.uriToPath(value) : null);
            this._setLangId();
            this._extensionKey.set(value ? extname(value) : null);
            this._hasResource.set(Boolean(value));
            this._isFileSystemResource.set(value ? this._fileService.hasProvider(value) : false);
        });
    }
    uriToPath(uri) {
        if (uri.scheme === Schemas.file) {
            return uri.fsPath;
        }
        return uri.path;
    }
    reset() {
        this._value = undefined;
        this._contextKeyService.bufferChangeEvents(() => {
            this._resourceKey.reset();
            this._schemeKey.reset();
            this._filenameKey.reset();
            this._dirnameKey.reset();
            this._pathKey.reset();
            this._langIdKey.reset();
            this._extensionKey.reset();
            this._hasResource.reset();
            this._isFileSystemResource.reset();
        });
    }
    get() {
        return this._value;
    }
};
ResourceContextKey = ResourceContextKey_1 = ( (__decorate([
    ( (__param(0, IContextKeyService))),
    ( (__param(1, IFileService))),
    ( (__param(2, ILanguageService))),
    ( (__param(3, IModelService)))
], ResourceContextKey)));
function applyAvailableEditorIds(contextKey, editor, editorResolverService) {
    if (!editor) {
        contextKey.set('');
        return;
    }
    const editorResource = editor.resource;
    const editors = editorResource ? ( (editorResolverService.getEditors(editorResource).map(editor => editor.id))) : [];
    if (editorResource?.scheme === Schemas.untitled && editor.editorId !== DEFAULT_EDITOR_ASSOCIATION.id) {
        contextKey.set('');
    }
    else {
        contextKey.set(editors.join(','));
    }
}
export { ActiveAuxiliaryContext, ActiveCompareEditorCanSwapContext, ActiveEditorAvailableEditorIdsContext, ActiveEditorCanRevertContext, ActiveEditorCanSplitInGroupContext, ActiveEditorCanToggleReadonlyContext, ActiveEditorContext, ActiveEditorDirtyContext, ActiveEditorFirstInGroupContext, ActiveEditorGroupEmptyContext, ActiveEditorGroupIndexContext, ActiveEditorGroupLastContext, ActiveEditorGroupLockedContext, ActiveEditorLastInGroupContext, ActiveEditorPinnedContext, ActiveEditorReadonlyContext, ActiveEditorStickyContext, ActivePanelContext, ActiveViewletContext, AuxiliaryBarFocusContext, AuxiliaryBarVisibleContext, BannerFocused, DirtyWorkingCopiesContext, EditorGroupEditorsCountContext, EditorPartMaximizedEditorGroupContext, EditorPartMultipleEditorGroupsContext, EditorTabsVisibleContext, EditorsVisibleContext, EmbedderIdentifierContext, EmptyWorkspaceSupportContext, EnterMultiRootWorkspaceSupportContext, FocusedViewContext, HasWebFileSystemAccess, InEditorZenModeContext, IsAuxiliaryEditorPartContext, IsAuxiliaryWindowFocusedContext, IsMainEditorCenteredLayoutContext, IsMainWindowFullscreenContext, MainEditorAreaVisibleContext, MultipleEditorGroupsContext, NotificationFocusedContext, NotificationsCenterVisibleContext, NotificationsToastsVisibleContext, OpenFolderWorkspaceSupportContext, PanelAlignmentContext, PanelFocusContext, PanelMaximizedContext, PanelPositionContext, PanelVisibleContext, RemoteNameContext, ResourceContextKey, SideBarVisibleContext, SideBySideEditorActiveContext, SidebarFocusContext, SplitEditorsVertically, StatusBarFocused, TemporaryWorkspaceContext, TextCompareEditorActiveContext, TextCompareEditorVisibleContext, TitleBarStyleContext, TitleBarVisibleContext, VirtualWorkspaceContext, WorkbenchStateContext, WorkspaceFolderCountContext, applyAvailableEditorIds, getVisbileViewContextKey };
