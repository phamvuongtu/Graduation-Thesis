import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { Disposable } from '../../../../base/common/lifecycle.js';
import { ResourceMap } from '../../../../base/common/map.js';
import { Schemas } from '../../../../base/common/network.js';
import { URI } from '../../../../base/common/uri.js';
import { Range } from '../../../../editor/common/core/range.js';
import { ILanguageService } from '../../../../editor/common/languages/language.js';
import { ITextModelService } from '../../../../editor/common/services/resolverService.js';
import { isResponseVM } from './chatViewModel.js';
import { extractVulnerabilitiesFromText } from './annotations.js';
let CodeBlockModelCollection = class CodeBlockModelCollection extends Disposable {
    constructor(languageService, textModelService) {
        super();
        this.languageService = languageService;
        this.textModelService = textModelService;
        this._models = ( new ResourceMap());
    }
    dispose() {
        super.dispose();
        this.clear();
    }
    get(sessionId, chat, codeBlockIndex) {
        const uri = this.getUri(sessionId, chat, codeBlockIndex);
        const entry = this._models.get(uri);
        if (!entry) {
            return;
        }
        return { model: entry.model.then(ref => ref.object), vulns: entry.vulns };
    }
    getOrCreate(sessionId, chat, codeBlockIndex) {
        const existing = this.get(sessionId, chat, codeBlockIndex);
        if (existing) {
            return existing;
        }
        const uri = this.getUri(sessionId, chat, codeBlockIndex);
        const ref = this.textModelService.createModelReference(uri);
        this._models.set(uri, { model: ref, vulns: [] });
        return { model: ref.then(ref => ref.object), vulns: [] };
    }
    clear() {
        this._models.forEach(async (entry) => (await entry.model).dispose());
        this._models.clear();
    }
    async update(sessionId, chat, codeBlockIndex, content) {
        const entry = this.getOrCreate(sessionId, chat, codeBlockIndex);
        const extractedVulns = extractVulnerabilitiesFromText(content.text);
        const newText = extractedVulns.newText;
        this.setVulns(sessionId, chat, codeBlockIndex, extractedVulns.vulnerabilities);
        const textModel = (await entry.model).textEditorModel;
        if (content.languageId) {
            const vscodeLanguageId = this.languageService.getLanguageIdByLanguageName(content.languageId);
            if (vscodeLanguageId && vscodeLanguageId !== textModel.getLanguageId()) {
                textModel.setLanguage(vscodeLanguageId);
            }
        }
        const currentText = textModel.getValue(1 );
        if (newText === currentText) {
            return;
        }
        if (newText.startsWith(currentText)) {
            const text = newText.slice(currentText.length);
            const lastLine = textModel.getLineCount();
            const lastCol = textModel.getLineMaxColumn(lastLine);
            textModel.applyEdits([{ range: ( new Range(lastLine, lastCol, lastLine, lastCol)), text }]);
        }
        else {
            textModel.setValue(newText);
        }
    }
    setVulns(sessionId, chat, codeBlockIndex, vulnerabilities) {
        const uri = this.getUri(sessionId, chat, codeBlockIndex);
        const entry = this._models.get(uri);
        if (entry) {
            entry.vulns = vulnerabilities;
        }
    }
    getUri(sessionId, chat, index) {
        const metadata = this.getUriMetaData(chat);
        return ( URI.from({
            scheme: Schemas.vscodeChatCodeBlock,
            authority: sessionId,
            path: `/${chat.id}/${index}`,
            fragment: metadata ? JSON.stringify(metadata) : undefined,
        }));
    }
    getUriMetaData(chat) {
        if (!isResponseVM(chat)) {
            return undefined;
        }
        return {
            references: ( chat.contentReferences.map(ref => {
                const uriOrLocation = 'variableName' in ref.reference ?
                    ref.reference.value :
                    ref.reference;
                if (!uriOrLocation) {
                    return;
                }
                if (URI.isUri(uriOrLocation)) {
                    return {
                        uri: uriOrLocation.toJSON()
                    };
                }
                return {
                    uri: uriOrLocation.uri.toJSON(),
                    range: uriOrLocation.range,
                };
            }))
        };
    }
};
CodeBlockModelCollection = ( __decorate([
    ( __param(0, ILanguageService)),
    ( __param(1, ITextModelService))
], CodeBlockModelCollection));
export { CodeBlockModelCollection };
