import { Mimes } from '../../../../../base/common/mime.js';
import { URI } from '../../../../../base/common/uri.js';
import { EditorContextKeys } from '../../../../../editor/common/editorContextKeys.js';
import { ILanguageService } from '../../../../../editor/common/languages/language.js';
import { getIconClasses } from '../../../../../editor/common/services/getIconClasses.js';
import { IModelService } from '../../../../../editor/common/services/model.js';
import { localizeWithPath, localize2WithPath } from '../../../../../nls.js';
import { registerAction2, MenuId } from '../../../../../platform/actions/common/actions.js';
import { IConfigurationService } from '../../../../../platform/configuration/common/configuration.service.js';
import { ContextKeyExpr } from '../../../../../platform/contextkey/common/contextkey.js';
import { InputFocusedContextKey, InputFocusedContext } from '../../../../../platform/contextkey/common/contextkeys.js';
import { IDialogService } from '../../../../../platform/dialogs/common/dialogs.service.js';
import { IInstantiationService } from '../../../../../platform/instantiation/common/instantiation.js';
import { INotificationService } from '../../../../../platform/notification/common/notification.service.js';
import { IQuickInputService } from '../../../../../platform/quickinput/common/quickInput.service.js';
import { InlineChatController } from '../../../inlineChat/browser/inlineChatController.js';
import { CTX_INLINE_CHAT_FOCUSED } from '../../../inlineChat/common/inlineChat.js';
import { runDeleteAction, changeCellToKind } from './cellOperations.js';
import { NotebookCellAction, CELL_TITLE_CELL_GROUP_ID, findTargetCellEditor, NOTEBOOK_EDITOR_WIDGET_ACTION_WEIGHT, executeNotebookCondition, CELL_TITLE_OUTPUT_GROUP_ID, NotebookAction } from './coreActions.js';
import { NotebookIndentUsingTabs, NotebookIndentUsingSpaces, NotebookChangeTabDisplaySize, NotebookIndentationToTabsAction, NotebookIndentationToSpacesAction } from './notebookIndentationActions.js';
import { QUIT_EDIT_CELL_COMMAND_ID, CellEditState, CHANGE_CELL_LANGUAGE, DETECT_CELL_LANGUAGE, getNotebookEditorFromEditorPane } from '../notebookBrowser.js';
import { CellKind, NotebookCellExecutionState, NotebookSetting } from '../../common/notebookCommon.js';
import { NOTEBOOK_CELL_LIST_FOCUSED, NOTEBOOK_EDITOR_EDITABLE, NOTEBOOK_OUTPUT_INPUT_FOCUSED, NOTEBOOK_CELL_TYPE, NOTEBOOK_CELL_MARKDOWN_EDIT_MODE, NOTEBOOK_CELL_EDITABLE, NOTEBOOK_EDITOR_FOCUSED, NOTEBOOK_OUTPUT_FOCUSED, NOTEBOOK_CELL_HAS_OUTPUTS, NOTEBOOK_USE_CONSOLIDATED_OUTPUT_BUTTON, NOTEBOOK_HAS_OUTPUTS, NOTEBOOK_IS_ACTIVE_EDITOR } from '../../common/notebookContextKeys.js';
import { INotebookExecutionStateService } from '../../common/notebookExecutionStateService.service.js';
import { INotebookKernelService } from '../../common/notebookKernelService.service.js';
import { IEditorService } from '../../../../services/editor/common/editorService.service.js';
import { ILanguageDetectionService } from '../../../../services/languageDetection/common/languageDetectionWorkerService.service.js';
import { editIcon, stopEditIcon, deleteCellIcon, clearIcon } from '../notebookIcons.js';
const _moduleId = "vs/workbench/contrib/notebook/browser/controller/editActions";
const CLEAR_ALL_CELLS_OUTPUTS_COMMAND_ID = 'notebook.clearAllCellsOutputs';
const EDIT_CELL_COMMAND_ID = 'notebook.cell.edit';
const DELETE_CELL_COMMAND_ID = 'notebook.cell.delete';
const CLEAR_CELL_OUTPUTS_COMMAND_ID = 'notebook.cell.clearOutputs';
const SELECT_NOTEBOOK_INDENTATION_ID = 'notebook.selectIndentation';
registerAction2(class EditCellAction extends NotebookCellAction {
    constructor() {
        super({
            id: EDIT_CELL_COMMAND_ID,
            title: ( localizeWithPath(_moduleId, 0, "Edit Cell")),
            keybinding: {
                when: ( (ContextKeyExpr.and(
                    NOTEBOOK_CELL_LIST_FOCUSED,
                    ContextKeyExpr.not(InputFocusedContextKey),
                     (NOTEBOOK_EDITOR_EDITABLE.isEqualTo(true)),
                     (EditorContextKeys.hoverFocused.toNegated()),
                     (NOTEBOOK_OUTPUT_INPUT_FOCUSED.toNegated())
                ))),
                primary: 3 ,
                weight: 200
            },
            menu: {
                id: MenuId.NotebookCellTitle,
                when: ( (ContextKeyExpr.and(
                     (NOTEBOOK_EDITOR_EDITABLE.isEqualTo(true)),
                     (NOTEBOOK_CELL_TYPE.isEqualTo('markup')),
                     (NOTEBOOK_CELL_MARKDOWN_EDIT_MODE.toNegated()),
                    NOTEBOOK_CELL_EDITABLE
                ))),
                order: 0 ,
                group: CELL_TITLE_CELL_GROUP_ID
            },
            icon: editIcon,
        });
    }
    async runWithContext(accessor, context) {
        if (!context.notebookEditor.hasModel() || context.notebookEditor.isReadOnly) {
            return;
        }
        await context.notebookEditor.focusNotebookCell(context.cell, 'editor');
        const foundEditor = context.cell ? findTargetCellEditor(context, context.cell) : undefined;
        if (foundEditor && foundEditor.hasTextFocus() && InlineChatController.get(foundEditor)?.getWidgetPosition()?.lineNumber === foundEditor.getPosition()?.lineNumber) {
            InlineChatController.get(foundEditor)?.focus();
        }
    }
});
const quitEditCondition = ( (ContextKeyExpr.and(
    NOTEBOOK_EDITOR_FOCUSED,
    InputFocusedContext,
     (CTX_INLINE_CHAT_FOCUSED.toNegated())
)));
registerAction2(class QuitEditCellAction extends NotebookCellAction {
    constructor() {
        super({
            id: QUIT_EDIT_CELL_COMMAND_ID,
            title: ( localizeWithPath(_moduleId, 1, "Stop Editing Cell")),
            menu: {
                id: MenuId.NotebookCellTitle,
                when: ( (ContextKeyExpr.and(
                     (NOTEBOOK_CELL_TYPE.isEqualTo('markup')),
                    NOTEBOOK_CELL_MARKDOWN_EDIT_MODE,
                    NOTEBOOK_CELL_EDITABLE
                ))),
                order: 3 ,
                group: CELL_TITLE_CELL_GROUP_ID
            },
            icon: stopEditIcon,
            keybinding: [
                {
                    when: ( (ContextKeyExpr.and(
                        quitEditCondition,
                         (EditorContextKeys.hoverVisible.toNegated()),
                         (EditorContextKeys.hasNonEmptySelection.toNegated()),
                         (EditorContextKeys.hasMultipleSelections.toNegated())
                    ))),
                    primary: 9 ,
                    weight: NOTEBOOK_EDITOR_WIDGET_ACTION_WEIGHT - 5
                },
                {
                    when: ( (ContextKeyExpr.and(NOTEBOOK_EDITOR_FOCUSED, NOTEBOOK_OUTPUT_FOCUSED))),
                    primary: 9 ,
                    weight: 200  + 5
                },
                {
                    when: ( (ContextKeyExpr.and(quitEditCondition,  (NOTEBOOK_CELL_TYPE.isEqualTo('markup'))))),
                    primary: 256  | 3 ,
                    win: {
                        primary: 2048  | 512  | 3
                    },
                    weight: NOTEBOOK_EDITOR_WIDGET_ACTION_WEIGHT - 5
                },
            ]
        });
    }
    async runWithContext(accessor, context) {
        if (context.cell.cellKind === CellKind.Markup) {
            context.cell.updateEditState(CellEditState.Preview, QUIT_EDIT_CELL_COMMAND_ID);
        }
        await context.notebookEditor.focusNotebookCell(context.cell, 'container', { skipReveal: true });
    }
});
registerAction2(class DeleteCellAction extends NotebookCellAction {
    constructor() {
        super({
            id: DELETE_CELL_COMMAND_ID,
            title: ( localizeWithPath(_moduleId, 2, "Delete Cell")),
            keybinding: {
                primary: 20 ,
                mac: {
                    primary: 2048  | 1
                },
                when: ( (ContextKeyExpr.and(
                    NOTEBOOK_EDITOR_FOCUSED,
                    ContextKeyExpr.not(InputFocusedContextKey),
                     (NOTEBOOK_OUTPUT_INPUT_FOCUSED.toNegated())
                ))),
                weight: 200
            },
            menu: [
                {
                    id: MenuId.NotebookCellDelete,
                    when: NOTEBOOK_EDITOR_EDITABLE,
                    group: CELL_TITLE_CELL_GROUP_ID
                },
                {
                    id: MenuId.InteractiveCellDelete,
                    group: CELL_TITLE_CELL_GROUP_ID
                }
            ],
            icon: deleteCellIcon
        });
    }
    async runWithContext(accessor, context) {
        if (!context.notebookEditor.hasModel()) {
            return;
        }
        let confirmation;
        const notebookExecutionStateService = accessor.get(INotebookExecutionStateService);
        const runState = notebookExecutionStateService.getCellExecution(context.cell.uri)?.state;
        const configService = accessor.get(IConfigurationService);
        if (runState === NotebookCellExecutionState.Executing && configService.getValue(NotebookSetting.confirmDeleteRunningCell)) {
            const dialogService = accessor.get(IDialogService);
            const primaryButton = ( localizeWithPath(_moduleId, 3, "Delete"));
            confirmation = await dialogService.confirm({
                type: 'question',
                message: ( localizeWithPath(_moduleId, 4, "This cell is running, are you sure you want to delete it?")),
                primaryButton: primaryButton,
                checkbox: {
                    label: ( localizeWithPath(_moduleId, 5, "Do not ask me again"))
                }
            });
        }
        else {
            confirmation = { confirmed: true };
        }
        if (!confirmation.confirmed) {
            return;
        }
        if (confirmation.checkboxChecked === true) {
            await configService.updateValue(NotebookSetting.confirmDeleteRunningCell, false);
        }
        runDeleteAction(context.notebookEditor, context.cell);
    }
});
registerAction2(class ClearCellOutputsAction extends NotebookCellAction {
    constructor() {
        super({
            id: CLEAR_CELL_OUTPUTS_COMMAND_ID,
            title: ( localizeWithPath(_moduleId, 6, 'Clear Cell Outputs')),
            menu: [
                {
                    id: MenuId.NotebookCellTitle,
                    when: ( (ContextKeyExpr.and(
                         (NOTEBOOK_CELL_TYPE.isEqualTo('code')),
                        executeNotebookCondition,
                        NOTEBOOK_CELL_HAS_OUTPUTS,
                        NOTEBOOK_EDITOR_EDITABLE,
                        NOTEBOOK_CELL_EDITABLE,
                         (NOTEBOOK_USE_CONSOLIDATED_OUTPUT_BUTTON.toNegated())
                    ))),
                    order: 5 ,
                    group: CELL_TITLE_OUTPUT_GROUP_ID
                },
                {
                    id: MenuId.NotebookOutputToolbar,
                    when: ( (ContextKeyExpr.and(
                        NOTEBOOK_CELL_HAS_OUTPUTS,
                        NOTEBOOK_EDITOR_EDITABLE,
                        NOTEBOOK_CELL_EDITABLE
                    )))
                },
            ],
            keybinding: {
                when: ( (ContextKeyExpr.and(
                    NOTEBOOK_EDITOR_FOCUSED,
                    ContextKeyExpr.not(InputFocusedContextKey),
                    NOTEBOOK_CELL_HAS_OUTPUTS,
                    NOTEBOOK_EDITOR_EDITABLE,
                    NOTEBOOK_CELL_EDITABLE
                ))),
                primary: 512  | 20 ,
                weight: 200
            },
            icon: clearIcon
        });
    }
    async runWithContext(accessor, context) {
        const notebookExecutionStateService = accessor.get(INotebookExecutionStateService);
        const editor = context.notebookEditor;
        if (!editor.hasModel() || !editor.textModel.length) {
            return;
        }
        const cell = context.cell;
        const index = editor.textModel.cells.indexOf(cell.model);
        if (index < 0) {
            return;
        }
        const computeUndoRedo = !editor.isReadOnly;
        editor.textModel.applyEdits([{ editType: 2 , index, outputs: [] }], true, undefined, () => undefined, undefined, computeUndoRedo);
        const runState = notebookExecutionStateService.getCellExecution(context.cell.uri)?.state;
        if (runState !== NotebookCellExecutionState.Executing) {
            context.notebookEditor.textModel.applyEdits([{
                    editType: 9 , index, internalMetadata: {
                        runStartTime: null,
                        runStartTimeAdjustment: null,
                        runEndTime: null,
                        executionOrder: null,
                        lastRunSuccess: null
                    }
                }], true, undefined, () => undefined, undefined, computeUndoRedo);
        }
    }
});
registerAction2(class ClearAllCellOutputsAction extends NotebookAction {
    constructor() {
        super({
            id: CLEAR_ALL_CELLS_OUTPUTS_COMMAND_ID,
            title: ( localizeWithPath(_moduleId, 7, 'Clear All Outputs')),
            precondition: NOTEBOOK_HAS_OUTPUTS,
            menu: [
                {
                    id: MenuId.EditorTitle,
                    when: ( (ContextKeyExpr.and(
                        NOTEBOOK_IS_ACTIVE_EDITOR,
                         (ContextKeyExpr.notEquals('config.notebook.globalToolbar', true))
                    ))),
                    group: 'navigation',
                    order: 0
                },
                {
                    id: MenuId.NotebookToolbar,
                    when: ( (ContextKeyExpr.and(
                        executeNotebookCondition,
                         (ContextKeyExpr.equals('config.notebook.globalToolbar', true))
                    ))),
                    group: 'navigation/execute',
                    order: 10
                }
            ],
            icon: clearIcon
        });
    }
    async runWithContext(accessor, context) {
        const notebookExecutionStateService = accessor.get(INotebookExecutionStateService);
        const editor = context.notebookEditor;
        if (!editor.hasModel() || !editor.textModel.length) {
            return;
        }
        const computeUndoRedo = !editor.isReadOnly;
        editor.textModel.applyEdits(( (editor.textModel.cells.map((cell, index) => ({
            editType: 2 , index, outputs: []
        })))), true, undefined, () => undefined, undefined, computeUndoRedo);
        const clearExecutionMetadataEdits = ( (editor.textModel.cells.map((cell, index) => {
            const runState = notebookExecutionStateService.getCellExecution(cell.uri)?.state;
            if (runState !== NotebookCellExecutionState.Executing) {
                return {
                    editType: 9 , index, internalMetadata: {
                        runStartTime: null,
                        runStartTimeAdjustment: null,
                        runEndTime: null,
                        executionOrder: null,
                        lastRunSuccess: null
                    }
                };
            }
            else {
                return undefined;
            }
        }))).filter(edit => !!edit);
        if (clearExecutionMetadataEdits.length) {
            context.notebookEditor.textModel.applyEdits(clearExecutionMetadataEdits, true, undefined, () => undefined, undefined, computeUndoRedo);
        }
    }
});
registerAction2(class ChangeCellLanguageAction extends NotebookCellAction {
    constructor() {
        super({
            id: CHANGE_CELL_LANGUAGE,
            title: ( localizeWithPath(_moduleId, 8, 'Change Cell Language')),
            metadata: {
                description: ( localizeWithPath(_moduleId, 8, 'Change Cell Language')),
                args: [
                    {
                        name: 'range',
                        description: 'The cell range',
                        schema: {
                            'type': 'object',
                            'required': ['start', 'end'],
                            'properties': {
                                'start': {
                                    'type': 'number'
                                },
                                'end': {
                                    'type': 'number'
                                }
                            }
                        }
                    },
                    {
                        name: 'language',
                        description: 'The target cell language',
                        schema: {
                            'type': 'string'
                        }
                    }
                ]
            }
        });
    }
    getCellContextFromArgs(accessor, context, ...additionalArgs) {
        if (!context || typeof context.start !== 'number' || typeof context.end !== 'number' || context.start >= context.end) {
            return;
        }
        const language = additionalArgs.length && typeof additionalArgs[0] === 'string' ? additionalArgs[0] : undefined;
        const activeEditorContext = this.getEditorContextFromArgsOrActive(accessor);
        if (!activeEditorContext || !activeEditorContext.notebookEditor.hasModel() || context.start >= activeEditorContext.notebookEditor.getLength()) {
            return;
        }
        return {
            notebookEditor: activeEditorContext.notebookEditor,
            cell: activeEditorContext.notebookEditor.cellAt(context.start),
            language
        };
    }
    async runWithContext(accessor, context) {
        if (context.language) {
            await this.setLanguage(context, context.language);
        }
        else {
            await this.showLanguagePicker(accessor, context);
        }
    }
    async showLanguagePicker(accessor, context) {
        const topItems = [];
        const mainItems = [];
        const languageService = accessor.get(ILanguageService);
        const modelService = accessor.get(IModelService);
        const quickInputService = accessor.get(IQuickInputService);
        const languageDetectionService = accessor.get(ILanguageDetectionService);
        const kernelService = accessor.get(INotebookKernelService);
        let languages = context.notebookEditor.activeKernel?.supportedLanguages;
        if (!languages) {
            const matchResult = kernelService.getMatchingKernel(context.notebookEditor.textModel);
            const allSupportedLanguages = matchResult.all.flatMap(kernel => kernel.supportedLanguages);
            languages = allSupportedLanguages.length > 0 ? allSupportedLanguages : languageService.getRegisteredLanguageIds();
        }
        const providerLanguages = ( (new Set([
            ...languages,
            'markdown'
        ])));
        providerLanguages.forEach(languageId => {
            let description;
            if (context.cell.cellKind === CellKind.Markup ? (languageId === 'markdown') : (languageId === context.cell.language)) {
                description = ( localizeWithPath(_moduleId, 9, "({0}) - Current Language", languageId));
            }
            else {
                description = ( localizeWithPath(_moduleId, 10, "({0})", languageId));
            }
            const languageName = languageService.getLanguageName(languageId);
            if (!languageName) {
                return;
            }
            const item = {
                label: languageName,
                iconClasses: getIconClasses(modelService, languageService, this.getFakeResource(languageName, languageService)),
                description,
                languageId
            };
            if (languageId === 'markdown' || languageId === context.cell.language) {
                topItems.push(item);
            }
            else {
                mainItems.push(item);
            }
        });
        mainItems.sort((a, b) => {
            return a.description.localeCompare(b.description);
        });
        const autoDetectMode = {
            label: ( localizeWithPath(_moduleId, 11, "Auto Detect"))
        };
        const picks = [
            autoDetectMode,
            { type: 'separator', label: ( localizeWithPath(_moduleId, 12, "languages (identifier)")) },
            ...topItems,
            { type: 'separator' },
            ...mainItems
        ];
        const selection = await quickInputService.pick(picks, { placeHolder: ( localizeWithPath(_moduleId, 13, "Select Language Mode")) });
        const languageId = selection === autoDetectMode
            ? await languageDetectionService.detectLanguage(context.cell.uri)
            : selection?.languageId;
        if (languageId) {
            await this.setLanguage(context, languageId);
        }
    }
    async setLanguage(context, languageId) {
        await setCellToLanguage(languageId, context);
    }
    getFakeResource(lang, languageService) {
        let fakeResource;
        const languageId = languageService.getLanguageIdByLanguageName(lang);
        if (languageId) {
            const extensions = languageService.getExtensions(languageId);
            if (extensions.length) {
                fakeResource = URI.file(extensions[0]);
            }
            else {
                const filenames = languageService.getFilenames(languageId);
                if (filenames.length) {
                    fakeResource = URI.file(filenames[0]);
                }
            }
        }
        return fakeResource;
    }
});
registerAction2(class DetectCellLanguageAction extends NotebookCellAction {
    constructor() {
        super({
            id: DETECT_CELL_LANGUAGE,
            title: ( localize2WithPath(_moduleId, 14, "Accept Detected Language for Cell")),
            f1: true,
            precondition: ( (ContextKeyExpr.and(NOTEBOOK_EDITOR_EDITABLE, NOTEBOOK_CELL_EDITABLE))),
            keybinding: { primary: 34  | 512  | 1024 , weight: 200  }
        });
    }
    async runWithContext(accessor, context) {
        const languageDetectionService = accessor.get(ILanguageDetectionService);
        const notificationService = accessor.get(INotificationService);
        const kernelService = accessor.get(INotebookKernelService);
        const kernel = kernelService.getSelectedOrSuggestedKernel(context.notebookEditor.textModel);
        const providerLanguages = [...(kernel?.supportedLanguages ?? [])];
        providerLanguages.push('markdown');
        const detection = await languageDetectionService.detectLanguage(context.cell.uri, providerLanguages);
        if (detection) {
            setCellToLanguage(detection, context);
        }
        else {
            notificationService.warn(( localizeWithPath(_moduleId, 15, "Unable to detect cell language")));
        }
    }
});
async function setCellToLanguage(languageId, context) {
    if (languageId === 'markdown' && context.cell?.language !== 'markdown') {
        const idx = context.notebookEditor.getCellIndex(context.cell);
        await changeCellToKind(CellKind.Markup, { cell: context.cell, notebookEditor: context.notebookEditor, ui: true }, 'markdown', Mimes.markdown);
        const newCell = context.notebookEditor.cellAt(idx);
        if (newCell) {
            await context.notebookEditor.focusNotebookCell(newCell, 'editor');
        }
    }
    else if (languageId !== 'markdown' && context.cell?.cellKind === CellKind.Markup) {
        await changeCellToKind(CellKind.Code, { cell: context.cell, notebookEditor: context.notebookEditor, ui: true }, languageId);
    }
    else {
        const index = context.notebookEditor.textModel.cells.indexOf(context.cell.model);
        context.notebookEditor.textModel.applyEdits([{ editType: 4 , index, language: languageId }], true, undefined, () => undefined, undefined, !context.notebookEditor.isReadOnly);
    }
}
registerAction2(class SelectNotebookIndentation extends NotebookAction {
    constructor() {
        super({
            id: SELECT_NOTEBOOK_INDENTATION_ID,
            title: ( localize2WithPath(_moduleId, 16, 'Select Indentation')),
            f1: true,
            precondition: ( (ContextKeyExpr.and(
                NOTEBOOK_IS_ACTIVE_EDITOR,
                NOTEBOOK_EDITOR_EDITABLE,
                NOTEBOOK_CELL_EDITABLE
            ))),
        });
    }
    async runWithContext(accessor, context) {
        await this.showNotebookIndentationPicker(accessor, context);
    }
    async showNotebookIndentationPicker(accessor, context) {
        const quickInputService = accessor.get(IQuickInputService);
        const editorService = accessor.get(IEditorService);
        const instantiationService = accessor.get(IInstantiationService);
        const activeNotebook = getNotebookEditorFromEditorPane(editorService.activeEditorPane);
        if (!activeNotebook || activeNotebook.isDisposed) {
            return quickInputService.pick([{ label: ( localizeWithPath(_moduleId, 17, "No notebook editor active at this time")) }]);
        }
        if (activeNotebook.isReadOnly) {
            return quickInputService.pick([{ label: ( localizeWithPath(_moduleId, 18, "The active notebook editor is read-only.")) }]);
        }
        const picks = ( ([
            (
            (new NotebookIndentUsingTabs())),
            (
            (new NotebookIndentUsingSpaces())),
            (
            (new NotebookChangeTabDisplaySize())),
            (
            (new NotebookIndentationToTabsAction())),
            (
            (new NotebookIndentationToSpacesAction()))
        ].map(item => {
            return {
                id: item.desc.id,
                label: ( (item.desc.title.toString())),
                run: () => {
                    instantiationService.invokeFunction(item.run);
                }
            };
        })));
        picks.splice(3, 0, { type: 'separator', label: ( localizeWithPath(_moduleId, 19, "convert file")) });
        picks.unshift({ type: 'separator', label: ( localizeWithPath(_moduleId, 20, "change view")) });
        const action = await quickInputService.pick(picks, { placeHolder: ( localizeWithPath(_moduleId, 21, "Select Action")), matchOnDetail: true });
        if (!action) {
            return;
        }
        action.run();
        context.notebookEditor.focus();
        return;
    }
});
export { CLEAR_CELL_OUTPUTS_COMMAND_ID, SELECT_NOTEBOOK_INDENTATION_ID };
