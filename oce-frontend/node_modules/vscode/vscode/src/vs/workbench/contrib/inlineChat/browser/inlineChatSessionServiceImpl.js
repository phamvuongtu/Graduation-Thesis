import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { coalesceInPlace, isNonEmptyArray } from '../../../../base/common/arrays.js';
import { raceCancellation } from '../../../../base/common/async.js';
import { CancellationError } from '../../../../base/common/errors.js';
import { Emitter, Event } from '../../../../base/common/event.js';
import { MarkdownString } from '../../../../base/common/htmlContent.js';
import { Iterable } from '../../../../base/common/iterator.js';
import { DisposableStore, DisposableMap, MutableDisposable, toDisposable } from '../../../../base/common/lifecycle.js';
import { LRUCache } from '../../../../base/common/map.js';
import { Schemas } from '../../../../base/common/network.js';
import { generateUuid } from '../../../../base/common/uuid.js';
import { Range } from '../../../../editor/common/core/range.js';
import { createTextBufferFactoryFromSnapshot } from '../../../../editor/common/model/textModel.js';
import { IEditorWorkerService } from '../../../../editor/common/services/editorWorker.js';
import { IModelService } from '../../../../editor/common/services/model.js';
import { ITextModelService } from '../../../../editor/common/services/resolverService.js';
import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';
import { ILogService } from '../../../../platform/log/common/log.service.js';
import { Progress } from '../../../../platform/progress/common/progress.js';
import { ITelemetryService } from '../../../../platform/telemetry/common/telemetry.service.js';
import { DEFAULT_EDITOR_ASSOCIATION } from '../../../common/editor.js';
import { ChatAgentLocation } from '../../chat/common/chatAgents.js';
import { IChatAgentService } from '../../chat/common/chatAgents.service.js';
import { InteractiveSessionVoteDirection } from '../../chat/common/chatService.js';
import { IChatService } from '../../chat/common/chatService.service.js';
import { IInlineChatService } from '../common/inlineChat.service.js';
import { IEditorService } from '../../../services/editor/common/editorService.service.js';
import { UntitledTextEditorInput } from '../../../services/untitled/common/untitledTextEditorInput.js';
import { ErrorResponse, ReplyResponse, SessionExchange, Session, SessionWholeRange, HunkData, StashedSession, EmptyResponse } from './inlineChatSession.js';
import { IChatVariablesService } from '../../chat/common/chatVariables.service.js';
import { nullExtensionDescription } from '../../../services/extensions/common/extensions.js';
import { Codicon } from '../../../../base/common/codicons.js';
import { isEqual } from '../../../../base/common/resources.js';
let BridgeAgent = class BridgeAgent {
    constructor(_data, _sessions, _postLastResponse, _instaService) {
        this._data = _data;
        this._sessions = _sessions;
        this._postLastResponse = _postLastResponse;
        this._instaService = _instaService;
    }
    _findSessionDataByRequest(request) {
        let data;
        for (const candidate of ( this._sessions.values())) {
            if (candidate.session.chatModel.sessionId === request.sessionId) {
                data = candidate;
                break;
            }
        }
        return data;
    }
    async invoke(request, progress, _history, token) {
        if (token.isCancellationRequested) {
            return {};
        }
        const data = this._findSessionDataByRequest(request);
        if (!data) {
            throw ( new Error('FAILED to find session'));
        }
        const { session } = data;
        if (!session.lastInput) {
            throw ( new Error('FAILED to find last input'));
        }
        const inlineChatContextValue = request.variables.variables.find(candidate => candidate.name === _inlineChatContext)?.values[0];
        const inlineChatContext = typeof inlineChatContextValue?.value === 'string' && JSON.parse(inlineChatContextValue.value);
        const modelAltVersionIdNow = session.textModelN.getAlternativeVersionId();
        const progressEdits = [];
        const inlineRequest = {
            requestId: request.requestId,
            prompt: request.message,
            attempt: request.attempt ?? 0,
            withIntentDetection: request.enableCommandDetection ?? true,
            live: session.editMode !== "preview" ,
            previewDocument: session.textModelN.uri,
            selection: inlineChatContext.selection,
            wholeRange: inlineChatContext.wholeRange
        };
        const inlineProgress = ( new Progress(data => {
            if (data.slashCommand && !inlineRequest.prompt.startsWith('/')) {
                const command = this._data.slashCommands.find(c => c.name === data.slashCommand);
                progress({ kind: 'agentDetection', agentId: this._data.id, command });
            }
            if (data.markdownFragment) {
                progress({ kind: 'markdownContent', content: ( new MarkdownString(data.markdownFragment)) });
            }
            if (isNonEmptyArray(data.edits)) {
                progressEdits.push(data.edits);
                progress({ kind: 'textEdit', uri: session.textModelN.uri, edits: data.edits });
            }
        }));
        let result;
        let response;
        try {
            result = await data.session.provider.provideResponse(session.session, inlineRequest, inlineProgress, token);
            if (result) {
                if (result.message) {
                    inlineProgress.report({ markdownFragment: result.message.value });
                }
                if (Array.isArray(result.edits)) {
                    inlineProgress.report({ edits: result.edits });
                }
                const markdownContents = result.message ?? ( new MarkdownString('', { supportThemeIcons: true, supportHtml: true, isTrusted: false }));
                const chatModelRequest = session.chatModel.getRequests().find(candidate => candidate.id === request.requestId);
                response = this._instaService.createInstance(ReplyResponse, result, markdownContents, session.textModelN.uri, modelAltVersionIdNow, progressEdits, request.requestId, chatModelRequest?.response);
            }
            else {
                response = ( new EmptyResponse());
            }
        }
        catch (e) {
            response = ( new ErrorResponse(e));
        }
        this._postLastResponse({ id: request.requestId, response });
        return {
            metadata: {
                inlineChatResponse: result
            }
        };
    }
    async provideFollowups(request, result, history, token) {
        if (!result.metadata?.inlineChatResponse) {
            return [];
        }
        const data = this._findSessionDataByRequest(request);
        if (!data) {
            return [];
        }
        const inlineFollowups = await data.session.provider.provideFollowups?.(data.session.session, result.metadata?.inlineChatResponse, token);
        if (!inlineFollowups) {
            return [];
        }
        const chatFollowups = ( inlineFollowups.map(f => {
            if (f.kind === 'reply') {
                return {
                    kind: 'reply',
                    message: f.message,
                    agentId: request.agentId,
                    title: f.title,
                    tooltip: f.tooltip,
                };
            }
            else {
                return undefined;
            }
        }));
        coalesceInPlace(chatFollowups);
        return chatFollowups;
    }
    provideWelcomeMessage(location, token) {
        return [];
    }
    async provideSampleQuestions(location, token) {
        await ( new Promise(resolve => setTimeout(resolve, 10)));
        for (const [, data] of this._sessions) {
            if (data.session.session.input && data.editor.hasWidgetFocus()) {
                return [{
                        kind: 'reply',
                        agentId: _bridgeAgentId,
                        message: data.session.session.input,
                    }];
            }
        }
        return [];
    }
};
BridgeAgent = ( __decorate([
    ( __param(3, IInstantiationService))
], BridgeAgent));
class InlineChatError extends Error {
    static { this.code = 'InlineChatError'; }
    constructor(message) {
        super(message);
        this.name = InlineChatError.code;
    }
}
const _bridgeAgentId = 'brigde.editor';
const _inlineChatContext = '_inlineChatContext';
const _inlineChatDocument = '_inlineChatDocument';
class InlineChatContext {
    static { this.variableName = '_inlineChatContext'; }
    constructor(uri, selection, wholeRange) {
        this.uri = uri;
        this.selection = selection;
        this.wholeRange = wholeRange;
    }
}
let InlineChatSessionServiceImpl = class InlineChatSessionServiceImpl {
    constructor(_inlineChatService, _telemetryService, _modelService, _textModelService, _editorWorkerService, _logService, _instaService, _editorService, _chatService, _chatAgentService, chatVariableService) {
        this._inlineChatService = _inlineChatService;
        this._telemetryService = _telemetryService;
        this._modelService = _modelService;
        this._textModelService = _textModelService;
        this._editorWorkerService = _editorWorkerService;
        this._logService = _logService;
        this._instaService = _instaService;
        this._editorService = _editorService;
        this._chatService = _chatService;
        this._chatAgentService = _chatAgentService;
        this._store = ( new DisposableStore());
        this._onWillStartSession = this._store.add(( new Emitter()));
        this.onWillStartSession = this._onWillStartSession.event;
        this._onDidMoveSession = this._store.add(( new Emitter()));
        this.onDidMoveSession = this._onDidMoveSession.event;
        this._onDidEndSession = this._store.add(( new Emitter()));
        this.onDidEndSession = this._onDidEndSession.event;
        this._onDidStashSession = this._store.add(( new Emitter()));
        this.onDidStashSession = this._onDidStashSession.event;
        this._sessions = ( new Map());
        this._keyComputers = ( new Map());
        this._recordings = [];
        this._lastResponsesFromBridgeAgent = ( new LRUCache(5));
        const fakeProviders = this._store.add(( new DisposableMap()));
        this._store.add(this._chatAgentService.onDidChangeAgents(() => {
            const providersNow = ( new Set());
            for (const agent of this._chatAgentService.getActivatedAgents()) {
                if (agent.id === _bridgeAgentId) {
                    continue;
                }
                if (!agent.locations.includes(ChatAgentLocation.Editor) || !agent.isDefault) {
                    continue;
                }
                providersNow.add(agent.id);
                if (!( fakeProviders.has(agent.id))) {
                    fakeProviders.set(agent.id, _inlineChatService.addProvider(_instaService.createInstance(AgentInlineChatProvider, agent)));
                    this._logService.debug(`ADDED inline chat provider for agent ${agent.id}`);
                }
            }
            for (const [id] of fakeProviders) {
                if (!( providersNow.has(id))) {
                    fakeProviders.deleteAndDispose(id);
                    this._logService.debug(`REMOVED inline chat provider for agent ${id}`);
                }
            }
        }));
        const addOrRemoveBridgeAgent = () => {
            const that = this;
            const agentData = {
                id: _bridgeAgentId,
                name: 'editor',
                extensionId: nullExtensionDescription.identifier,
                extensionPublisherDisplayName: '',
                extensionDisplayName: '',
                extensionPublisherId: '',
                isDefault: true,
                locations: [ChatAgentLocation.Editor],
                get slashCommands() {
                    let candidate;
                    for (const data of ( that._sessions.values())) {
                        if (data.editor.hasWidgetFocus()) {
                            candidate = data.session;
                            break;
                        }
                    }
                    if (!candidate || !candidate.session.slashCommands) {
                        return [];
                    }
                    return ( candidate.session.slashCommands.map(c => {
                        return {
                            name: c.command,
                            description: c.detail ?? '',
                        };
                    }));
                },
                defaultImplicitVariables: [_inlineChatContext],
                metadata: {
                    isSticky: false,
                    themeIcon: Codicon.copilot,
                },
            };
            let otherEditorAgent;
            let myEditorAgent;
            for (const candidate of this._chatAgentService.getActivatedAgents()) {
                if (!myEditorAgent && candidate.id === agentData.id) {
                    myEditorAgent = candidate;
                }
                else if (!otherEditorAgent && candidate.isDefault && candidate.locations.includes(ChatAgentLocation.Editor)) {
                    otherEditorAgent = candidate;
                }
            }
            if (otherEditorAgent) {
                bridgeStore.clear();
                _logService.debug(`REMOVED bridge agent "${agentData.id}", found "${otherEditorAgent.id}"`);
            }
            else if (!myEditorAgent) {
                bridgeStore.value = this._chatAgentService.registerDynamicAgent(agentData, this._instaService.createInstance(BridgeAgent, agentData, this._sessions, data => {
                    this._lastResponsesFromBridgeAgent.set(data.id, data.response);
                }));
                _logService.debug(`ADDED bridge agent "${agentData.id}"`);
            }
        };
        this._store.add(this._chatAgentService.onDidChangeAgents(() => addOrRemoveBridgeAgent()));
        const bridgeStore = this._store.add(( new MutableDisposable()));
        addOrRemoveBridgeAgent();
        this._store.add(chatVariableService.registerVariable({ name: _inlineChatContext, description: '', hidden: true }, async (_message, _arg, model) => {
            for (const [, data] of this._sessions) {
                if (data.session.chatModel === model) {
                    return [{
                            level: 'full',
                            value: JSON.stringify(( new InlineChatContext(
                                data.session.textModelN.uri,
                                data.editor.getSelection(),
                                data.session.wholeRange.trackedInitialRange
                            )))
                        }];
                }
            }
            return undefined;
        }));
        this._store.add(chatVariableService.registerVariable({ name: _inlineChatDocument, description: '', hidden: true }, async (_message, _arg, model) => {
            for (const [, data] of this._sessions) {
                if (data.session.chatModel === model) {
                    return [{ level: 'full', value: data.session.textModelN.uri }];
                }
            }
            return undefined;
        }));
    }
    dispose() {
        this._store.dispose();
        this._sessions.forEach(x => x.store.dispose());
        this._sessions.clear();
    }
    async createSession(editor, options, token) {
        const agent = this._chatAgentService.getDefaultAgent(ChatAgentLocation.Editor);
        let provider;
        if (agent) {
            for (const candidate of this._inlineChatService.getAllProvider()) {
                if (candidate instanceof AgentInlineChatProvider && candidate.agent === agent) {
                    provider = candidate;
                    break;
                }
            }
        }
        if (!provider) {
            provider = Iterable.first(this._inlineChatService.getAllProvider());
        }
        if (!provider) {
            this._logService.trace('[IE] NO provider found');
            return undefined;
        }
        this._onWillStartSession.fire(editor);
        const textModel = editor.getModel();
        const selection = editor.getSelection();
        let rawSession;
        try {
            rawSession = await raceCancellation(Promise.resolve(provider.prepareInlineChatSession(textModel, selection, token)), token);
        }
        catch (error) {
            this._logService.error('[IE] FAILED to prepare session', provider.extensionId);
            this._logService.error(error);
            throw ( new InlineChatError(error?.message || 'Failed to prepare session'));
        }
        if (!rawSession) {
            this._logService.trace('[IE] NO session', provider.extensionId);
            return undefined;
        }
        const store = ( new DisposableStore());
        this._logService.trace(`[IE] creating NEW session for ${editor.getId()}, ${provider.extensionId}`);
        const chatModel = this._chatService.startSession(ChatAgentLocation.Editor, token);
        if (!chatModel) {
            this._logService.trace('[IE] NO chatModel found');
            return undefined;
        }
        store.add(toDisposable(() => {
            this._chatService.clearSession(chatModel.sessionId);
            chatModel.dispose();
        }));
        const lastResponseListener = store.add(( new MutableDisposable()));
        store.add(chatModel.onDidChange(e => {
            if (e.kind !== 'addRequest' || !e.request.response) {
                return;
            }
            const modelAltVersionIdNow = textModel.getAlternativeVersionId();
            const { response } = e.request;
            lastResponseListener.value = response.onDidChange(() => {
                if (!response.isComplete) {
                    return;
                }
                lastResponseListener.clear();
                let inlineResponse;
                if (response.agent?.id === _bridgeAgentId) {
                    inlineResponse = this._lastResponsesFromBridgeAgent.get(response.requestId) ?? ( new ErrorResponse(( new Error('Missing Response'))));
                    this._lastResponsesFromBridgeAgent.delete(response.requestId);
                }
                else {
                    if (response.isCanceled) {
                        inlineResponse = ( new ErrorResponse(( new CancellationError())));
                    }
                    else if (response.result?.errorDetails) {
                        inlineResponse = ( new ErrorResponse(( new Error(response.result.errorDetails.message))));
                    }
                    else if (response.response.value.length === 0) {
                        inlineResponse = ( new EmptyResponse());
                    }
                    else {
                        const markdownContent = ( new MarkdownString());
                        const raw = {
                            id: Math.random(),
                            type: "bulkEdit" ,
                            message: markdownContent,
                            edits: { edits: [] },
                        };
                        for (const item of response.response.value) {
                            if (item.kind === 'markdownContent') {
                                markdownContent.value += item.content.value;
                            }
                            else if (item.kind === 'textEditGroup') {
                                for (const group of item.edits) {
                                    for (const edit of group) {
                                        raw.edits.edits.push({
                                            resource: item.uri,
                                            textEdit: edit,
                                            versionId: undefined
                                        });
                                    }
                                }
                            }
                        }
                        inlineResponse = this._instaService.createInstance(ReplyResponse, raw, markdownContent, session.textModelN.uri, modelAltVersionIdNow, [], e.request.id, e.request.response);
                    }
                }
                session.addExchange(( new SessionExchange(session.lastInput, inlineResponse)));
                if (inlineResponse instanceof ReplyResponse && inlineResponse.untitledTextModel) {
                    this._textModelService.createModelReference(inlineResponse.untitledTextModel.resource).then(ref => {
                        store.add(ref);
                    });
                }
            });
        }));
        store.add(this._chatService.onDidPerformUserAction(e => {
            if (e.sessionId !== chatModel.sessionId) {
                return;
            }
            const request = chatModel.getRequests().find(request => request.id === e.requestId);
            const candidate = request?.response?.result?.metadata?.inlineChatResponse;
            if (!candidate) {
                return;
            }
            let kind;
            if (e.action.kind === 'vote') {
                kind = e.action.direction === InteractiveSessionVoteDirection.Down ? 0  : 1 ;
            }
            else if (e.action.kind === 'bug') {
                kind = 4 ;
            }
            else if (e.action.kind === 'inlineChat') {
                kind = e.action.action === 'accepted' ? 3  : 2 ;
            }
            if (!kind) {
                return;
            }
            provider.handleInlineChatResponseFeedback?.(rawSession, candidate, kind);
        }));
        store.add(this._inlineChatService.onDidChangeProviders(e => {
            if (e.removed === provider) {
                this._logService.trace(`[IE] provider GONE for ${editor.getId()}, ${provider.extensionId}`);
                this._releaseSession(session, true);
            }
        }));
        const id = generateUuid();
        const targetUri = textModel.uri;
        store.add((await this._textModelService.createModelReference(textModel.uri)));
        const textModelN = textModel;
        const textModel0 = store.add(this._modelService.createModel(createTextBufferFactoryFromSnapshot(textModel.createSnapshot()), { languageId: textModel.getLanguageId(), onDidChange: Event.None }, targetUri.with({ scheme: Schemas.vscode, authority: 'inline-chat', path: '', query: ( ( new URLSearchParams({ id, 'textModel0': '' })).toString()) }), true));
        if (targetUri.scheme === Schemas.untitled) {
            store.add(this._editorService.onDidCloseEditor(() => {
                if (!this._editorService.isOpened({ resource: targetUri, typeId: UntitledTextEditorInput.ID, editorId: DEFAULT_EDITOR_ASSOCIATION.id })) {
                    this._releaseSession(session, true);
                }
            }));
        }
        let wholeRange = options.wholeRange;
        if (!wholeRange) {
            wholeRange = rawSession.wholeRange ? Range.lift(rawSession.wholeRange) : editor.getSelection();
        }
        if (token.isCancellationRequested) {
            store.dispose();
            return undefined;
        }
        const session = ( new Session(
            options.editMode,
            targetUri,
            textModel0,
            textModelN,
            provider,
            rawSession,
            store.add(( new SessionWholeRange(textModelN, wholeRange))),
            store.add(( new HunkData(this._editorWorkerService, textModel0, textModelN))),
            chatModel
        ));
        const key = this._key(editor, session.targetUri);
        if (( this._sessions.has(key))) {
            store.dispose();
            throw ( new Error(`Session already stored for ${key}`));
        }
        this._sessions.set(key, { session, editor, store });
        return session;
    }
    moveSession(session, target) {
        const newKey = this._key(target, session.targetUri);
        const existing = this._sessions.get(newKey);
        if (existing) {
            if (existing.session !== session) {
                throw ( new Error(`Cannot move session because the target editor already/still has one`));
            }
            else {
                return;
            }
        }
        let found = false;
        for (const [oldKey, data] of this._sessions) {
            if (data.session === session) {
                found = true;
                this._sessions.delete(oldKey);
                this._sessions.set(newKey, { ...data, editor: target });
                this._logService.trace(`[IE] did MOVE session for ${data.editor.getId()} to NEW EDITOR ${target.getId()}, ${session.provider.extensionId}`);
                this._onDidMoveSession.fire({ session, editor: target });
                break;
            }
        }
        if (!found) {
            throw ( new Error(`Cannot move session because it is not stored`));
        }
    }
    releaseSession(session) {
        this._releaseSession(session, false);
    }
    _releaseSession(session, byServer) {
        let tuple;
        for (const candidate of this._sessions) {
            if (candidate[1].session === session) {
                tuple = candidate;
                break;
            }
        }
        if (!tuple) {
            return;
        }
        this._keepRecording(session);
        this._telemetryService.publicLog2('interactiveEditor/session', session.asTelemetryData());
        const [key, value] = tuple;
        this._sessions.delete(key);
        this._logService.trace(`[IE] did RELEASED session for ${value.editor.getId()}, ${session.provider.extensionId}`);
        this._onDidEndSession.fire({ editor: value.editor, session, endedByExternalCause: byServer });
        value.store.dispose();
    }
    stashSession(session, editor, undoCancelEdits) {
        this._keepRecording(session);
        const result = this._instaService.createInstance(StashedSession, editor, session, undoCancelEdits);
        this._onDidStashSession.fire({ editor, session });
        this._logService.trace(`[IE] did STASH session for ${editor.getId()}, ${session.provider.extensionId}`);
        return result;
    }
    getCodeEditor(session) {
        for (const [, data] of this._sessions) {
            if (data.session === session) {
                return data.editor;
            }
        }
        throw ( new Error('session not found'));
    }
    getSession(editor, uri) {
        const key = this._key(editor, uri);
        return this._sessions.get(key)?.session;
    }
    _key(editor, uri) {
        const item = this._keyComputers.get(uri.scheme);
        return item
            ? item.getComparisonKey(editor, uri)
            : `${editor.getId()}@${( uri.toString())}`;
    }
    registerSessionKeyComputer(scheme, value) {
        this._keyComputers.set(scheme, value);
        return toDisposable(() => this._keyComputers.delete(scheme));
    }
    _keepRecording(session) {
        const newLen = this._recordings.unshift(session.asRecording());
        if (newLen > 5) {
            this._recordings.pop();
        }
    }
    recordings() {
        return this._recordings;
    }
};
InlineChatSessionServiceImpl = ( __decorate([
    ( __param(0, IInlineChatService)),
    ( __param(1, ITelemetryService)),
    ( __param(2, IModelService)),
    ( __param(3, ITextModelService)),
    ( __param(4, IEditorWorkerService)),
    ( __param(5, ILogService)),
    ( __param(6, IInstantiationService)),
    ( __param(7, IEditorService)),
    ( __param(8, IChatService)),
    ( __param(9, IChatAgentService)),
    ( __param(10, IChatVariablesService))
], InlineChatSessionServiceImpl));
let AgentInlineChatProvider = class AgentInlineChatProvider {
    constructor(agent, _chatAgentService) {
        this.agent = agent;
        this._chatAgentService = _chatAgentService;
        this.label = agent.name;
        this.extensionId = agent.extensionId;
        this.supportIssueReporting = agent.metadata.supportIssueReporting;
    }
    async prepareInlineChatSession(model, range, token) {
        return {
            id: Math.random(),
            wholeRange: ( new Range(
                range.selectionStartLineNumber,
                range.selectionStartColumn,
                range.positionLineNumber,
                range.positionColumn
            )),
            placeholder: this.agent.description,
            slashCommands: ( this.agent.slashCommands.map(agentCommand => {
                return {
                    command: agentCommand.name,
                    detail: agentCommand.description,
                    refer: agentCommand.name === 'explain'
                };
            }))
        };
    }
    async provideResponse(item, request, progress, token) {
        const workspaceEdit = { edits: [] };
        await this._chatAgentService.invokeAgent(this.agent.id, {
            sessionId: String(item.id),
            requestId: request.requestId,
            agentId: this.agent.id,
            message: request.prompt,
            location: ChatAgentLocation.Editor,
            variables: {
                variables: [{
                        name: InlineChatContext.variableName,
                        values: [{
                                level: 'full',
                                value: JSON.stringify(( new InlineChatContext(request.previewDocument, request.selection, request.wholeRange)))
                            }]
                    }]
            }
        }, part => {
            if (part.kind === 'markdownContent') {
                progress.report({ markdownFragment: part.content.value });
            }
            else if (part.kind === 'agentDetection') {
                progress.report({ slashCommand: part.command?.name });
            }
            else if (part.kind === 'textEdit') {
                if (isEqual(request.previewDocument, part.uri)) {
                    progress.report({ edits: part.edits });
                }
                else {
                    for (const textEdit of part.edits) {
                        workspaceEdit.edits.push({ resource: part.uri, textEdit, versionId: undefined });
                    }
                }
            }
        }, [], token);
        return {
            type: "bulkEdit" ,
            id: Math.random(),
            edits: workspaceEdit
        };
    }
};
AgentInlineChatProvider = ( __decorate([
    ( __param(1, IChatAgentService))
], AgentInlineChatProvider));
export { AgentInlineChatProvider, InlineChatError, InlineChatSessionServiceImpl };
