import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { h, trackFocus, getTotalHeight, reset, getActiveElement, Dimension } from '../../../../base/browser/dom.js';
import { renderLabelWithIcons } from '../../../../base/browser/ui/iconLabel/iconLabels.js';
import { ProgressBar } from '../../../../base/browser/ui/progressbar/progressbar.js';
import { Emitter, Event } from '../../../../base/common/event.js';
import { MarkdownString } from '../../../../base/common/htmlContent.js';
import { Lazy } from '../../../../base/common/lazy.js';
import { DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';
import { observableValue } from '../../../../base/common/observableInternal/base.js';
import { derived } from '../../../../base/common/observableInternal/derived.js';
import '../../../../base/common/observableInternal/autorun.js';
import { constObservable } from '../../../../base/common/observableInternal/utils.js';
import '../../../../base/common/cancellation.js';
import { isNonEmptyArray, tail } from '../../../../base/common/arrays.js';
import './media/inlineChat.css.js';
import { AccessibleDiffViewer } from '../../../../editor/browser/widget/diffEditor/components/accessibleDiffViewer.js';
import { EmbeddedDiffEditorWidget } from '../../../../editor/browser/widget/diffEditor/embeddedDiffEditorWidget.js';
import { LineRange } from '../../../../editor/common/core/lineRange.js';
import { DetailedLineRangeMapping, RangeMapping } from '../../../../editor/common/diff/rangeMapping.js';
import { ITextModelService } from '../../../../editor/common/services/resolverService.js';
import { localizeWithPath } from '../../../../nls.js';
import { IAccessibilityService } from '../../../../platform/accessibility/common/accessibility.service.js';
import { MenuWorkbenchButtonBar } from '../../../../platform/actions/browser/buttonbar.js';
import { MenuWorkbenchToolBar } from '../../../../platform/actions/browser/toolbar.js';
import { MenuId } from '../../../../platform/actions/common/actions.js';
import { IConfigurationService } from '../../../../platform/configuration/common/configuration.service.js';
import { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.service.js';
import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';
import { IKeybindingService } from '../../../../platform/keybinding/common/keybinding.service.js';
import { asCssVariableName, asCssVariable } from '../../../../platform/theme/common/colorUtils.js';
import '../../../../platform/theme/common/colors/baseColors.js';
import '../../../../platform/theme/common/colors/chartsColors.js';
import { editorForeground, editorBackground } from '../../../../platform/theme/common/colors/editorColors.js';
import { inputBackground } from '../../../../platform/theme/common/colors/inputColors.js';
import '../../../../platform/theme/common/colors/listColors.js';
import '../../../../platform/theme/common/colors/menuColors.js';
import '../../../../platform/theme/common/colors/minimapColors.js';
import '../../../../platform/theme/common/colors/miscColors.js';
import '../../../../platform/theme/common/colors/quickpickColors.js';
import '../../../../platform/theme/common/colors/searchColors.js';
import { IAccessibleViewService } from '../../accessibility/browser/accessibleView.service.js';
import { ChatFollowups } from '../../chat/browser/chatFollowups.js';
import { ChatModel } from '../../chat/common/chatModel.js';
import { isWelcomeVM, isRequestVM, isResponseVM } from '../../chat/common/chatViewModel.js';
import { inlineChatBackground, CTX_INLINE_CHAT_RESPONSE_FOCUSED, CTX_INLINE_CHAT_FOCUSED } from '../common/inlineChat.js';
import { ChatWidget } from '../../chat/browser/chatWidget.js';
import { chatRequestBackground } from '../../chat/common/chatColors.js';
import { Selection } from '../../../../editor/common/core/selection.js';
import { ChatAgentLocation } from '../../chat/common/chatAgents.js';
import { EditorExtensionsRegistry } from '../../../../editor/browser/editorExtensions.js';
import { SnippetController2 } from '../../../../editor/contrib/snippet/browser/snippetController2.js';
import { SuggestController } from '../../../../editor/contrib/suggest/browser/suggestController.js';
import { IChatService } from '../../chat/common/chatService.service.js';
import { getDefaultHoverDelegate } from '../../../../base/browser/ui/hover/hoverDelegateFactory.js';
import { ServiceCollection } from '../../../../platform/instantiation/common/serviceCollection.js';
import { IHoverService } from '../../../../platform/hover/browser/hover.service.js';
var HunkAccessibleDiffViewer_1;
const _moduleId = "vs/workbench/contrib/inlineChat/browser/inlineChatWidget";
let InlineChatWidget = class InlineChatWidget {
    constructor(location, options, _instantiationService, _contextKeyService, _keybindingService, _accessibilityService, _configurationService, _accessibleViewService, _textModelResolverService, _chatService, _hoverService) {
        this._instantiationService = _instantiationService;
        this._contextKeyService = _contextKeyService;
        this._keybindingService = _keybindingService;
        this._accessibilityService = _accessibilityService;
        this._configurationService = _configurationService;
        this._accessibleViewService = _accessibleViewService;
        this._textModelResolverService = _textModelResolverService;
        this._chatService = _chatService;
        this._hoverService = _hoverService;
        this._elements = h('div.inline-chat@root', [
            h('div.chat-widget@chatWidget'),
            h('div.progress@progress'),
            h('div.followUps.hidden@followUps'),
            h('div.previewDiff.hidden@previewDiff'),
            h('div.accessibleViewer@accessibleViewer'),
            h('div.status@status', [
                h('div.label.info.hidden@infoLabel'),
                h('div.actions.hidden@statusToolbar'),
                h('div.label.status.hidden@statusLabel'),
                h('div.actions.hidden@feedbackToolbar'),
            ]),
        ]);
        this._store = ( (new DisposableStore()));
        this._onDidChangeHeight = this._store.add(( (new Emitter())));
        this.onDidChangeHeight = Event.filter(this._onDidChangeHeight.event, _ => !this._isLayouting);
        this._onDidChangeInput = this._store.add(( (new Emitter())));
        this.onDidChangeInput = this._onDidChangeInput.event;
        this._isLayouting = false;
        this._followUpDisposables = this._store.add(( (new DisposableStore())));
        this._progressBar = ( (new ProgressBar(this._elements.progress)));
        this._store.add(this._progressBar);
        let allowRequests = false;
        const scopedInstaService = _instantiationService.createChild(( (new ServiceCollection([
            IContextKeyService,
            this._store.add(_contextKeyService.createScoped(this._elements.chatWidget))
        ]))));
        this._chatWidget = scopedInstaService.createInstance(ChatWidget, location, { resource: true }, {
            defaultElementHeight: 32,
            renderStyle: 'compact',
            renderInputOnTop: true,
            renderFollowups: true,
            supportsFileReferences: true,
            editorOverflowWidgetsDomNode: options.editorOverflowWidgetsDomNode,
            rendererOptions: options.rendererOptions,
            menus: {
                executeToolbar: options.inputMenuId,
                inputSideToolbar: options.widgetMenuId,
                telemetrySource: options.telemetrySource
            },
            filter: item => {
                if (isWelcomeVM(item)) {
                    return false;
                }
                if (isRequestVM(item)) {
                    return allowRequests;
                }
                return true;
            },
        }, {
            listForeground: editorForeground,
            listBackground: inlineChatBackground,
            inputEditorBackground: inputBackground,
            resultEditorBackground: editorBackground
        });
        this._chatWidget.render(this._elements.chatWidget);
        this._elements.chatWidget.style.setProperty(asCssVariableName(chatRequestBackground), asCssVariable(inlineChatBackground));
        this._chatWidget.setVisible(true);
        this._store.add(this._chatWidget);
        const viewModelListener = this._store.add(( (new MutableDisposable())));
        this._store.add(this._chatWidget.onDidChangeViewModel(() => {
            const model = this._chatWidget.viewModel;
            if (!model) {
                allowRequests = false;
                viewModelListener.clear();
                return;
            }
            const updateAllowRequestsFilter = () => {
                let requestCount = 0;
                for (const item of model.getItems()) {
                    if (isRequestVM(item)) {
                        if (++requestCount >= 2) {
                            break;
                        }
                    }
                }
                const newAllowRequest = requestCount >= 2;
                if (newAllowRequest !== allowRequests) {
                    allowRequests = newAllowRequest;
                    this._chatWidget.refilter();
                }
            };
            viewModelListener.value = model.onDidChange(updateAllowRequestsFilter);
        }));
        const viewModelStore = this._store.add(( (new DisposableStore())));
        this._store.add(this._chatWidget.onDidChangeViewModel(() => {
            viewModelStore.clear();
            const viewModel = this._chatWidget.viewModel;
            if (viewModel) {
                viewModelStore.add(viewModel.onDidChange(() => this._onDidChangeHeight.fire()));
            }
            this._onDidChangeHeight.fire();
        }));
        this._store.add(this.chatWidget.onDidChangeContentHeight(() => {
            this._onDidChangeHeight.fire();
        }));
        this._ctxResponseFocused = CTX_INLINE_CHAT_RESPONSE_FOCUSED.bindTo(this._contextKeyService);
        const tracker = this._store.add(trackFocus(this.domNode));
        this._store.add(tracker.onDidBlur(() => this._ctxResponseFocused.set(false)));
        this._store.add(tracker.onDidFocus(() => this._ctxResponseFocused.set(true)));
        this._ctxInputEditorFocused = CTX_INLINE_CHAT_FOCUSED.bindTo(_contextKeyService);
        this._store.add(this._chatWidget.inputEditor.onDidFocusEditorWidget(() => this._ctxInputEditorFocused.set(true)));
        this._store.add(this._chatWidget.inputEditor.onDidBlurEditorWidget(() => this._ctxInputEditorFocused.set(false)));
        const statusMenuId = options.statusMenuId instanceof MenuId ? options.statusMenuId : options.statusMenuId.menu;
        const statusMenuOptions = options.statusMenuId instanceof MenuId ? undefined : options.statusMenuId.options;
        const statusButtonBar = this._instantiationService.createInstance(MenuWorkbenchButtonBar, this._elements.statusToolbar, statusMenuId, statusMenuOptions);
        this._store.add(statusButtonBar.onDidChange(() => this._onDidChangeHeight.fire()));
        this._store.add(statusButtonBar);
        const workbenchToolbarOptions = {
            hiddenItemStrategy: -1 ,
            toolbarOptions: {
                primaryGroup: () => true,
                useSeparatorsInPrimaryActions: true
            }
        };
        if (options.feedbackMenuId) {
            const feedbackToolbar = this._instantiationService.createInstance(MenuWorkbenchToolBar, this._elements.feedbackToolbar, options.feedbackMenuId, { ...workbenchToolbarOptions, hiddenItemStrategy: 0  });
            this._store.add(feedbackToolbar.onDidChangeMenuItems(() => this._onDidChangeHeight.fire()));
            this._store.add(feedbackToolbar);
        }
        this._store.add(this._configurationService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration("accessibility.verbosity.inlineChat" )) {
                this._updateAriaLabel();
            }
        }));
        this._elements.root.tabIndex = 0;
        this._elements.followUps.tabIndex = 0;
        this._elements.statusLabel.tabIndex = 0;
        this._updateAriaLabel();
        this._store.add(this._hoverService.setupUpdatableHover(getDefaultHoverDelegate('element'), this._elements.statusLabel, () => {
            return this._elements.statusLabel.dataset['title'];
        }));
        this._store.add(this._chatService.onDidPerformUserAction(e => {
            if (e.sessionId === this._chatWidget.viewModel?.model.sessionId && e.action.kind === 'vote') {
                this.updateStatus('Thank you for your feedback!', { resetAfter: 1250 });
            }
        }));
        this._defaultChatModel = this._store.add(this._instantiationService.createInstance(ChatModel, undefined, ChatAgentLocation.Editor));
        this._defaultChatModel.startInitialize();
        this._defaultChatModel.initialize(undefined);
        this.setChatModel(this._defaultChatModel);
    }
    _updateAriaLabel() {
        this._elements.root.ariaLabel = this._accessibleViewService.getOpenAriaHint("accessibility.verbosity.inlineChat" );
        if (this._accessibilityService.isScreenReaderOptimized()) {
            let label = defaultAriaLabel;
            if (this._configurationService.getValue("accessibility.verbosity.inlineChat" )) {
                const kbLabel = this._keybindingService.lookupKeybinding("editor.action.accessibilityHelp" )?.getLabel();
                label = kbLabel
                    ? ( localizeWithPath(
                    _moduleId,
                    0,
                    "Inline Chat Input, Use {0} for Inline Chat Accessibility Help.",
                    kbLabel
                ))
                    : ( localizeWithPath(
                    _moduleId,
                    1,
                    "Inline Chat Input, Run the Inline Chat Accessibility Help command for more information."
                ));
            }
            this._chatWidget.inputEditor.updateOptions({ ariaLabel: label });
        }
    }
    dispose() {
        this._store.dispose();
    }
    get domNode() {
        return this._elements.root;
    }
    get chatWidget() {
        return this._chatWidget;
    }
    saveState() {
        this._chatWidget.saveState();
    }
    layout(widgetDim) {
        this._isLayouting = true;
        try {
            this._doLayout(widgetDim);
        }
        finally {
            this._isLayouting = false;
        }
    }
    _doLayout(dimension) {
        const extraHeight = this._getExtraHeight();
        const progressHeight = getTotalHeight(this._elements.progress);
        const followUpsHeight = getTotalHeight(this._elements.followUps);
        const statusHeight = getTotalHeight(this._elements.status);
        this._elements.root.style.height = `${dimension.height - extraHeight}px`;
        this._elements.root.style.width = `${dimension.width}px`;
        this._elements.progress.style.width = `${dimension.width}px`;
        this._chatWidget.layout(dimension.height - progressHeight - followUpsHeight - statusHeight - extraHeight, dimension.width);
    }
    get contentHeight() {
        const data = {
            followUpsHeight: getTotalHeight(this._elements.followUps),
            chatWidgetContentHeight: this._chatWidget.contentHeight,
            progressHeight: getTotalHeight(this._elements.progress),
            statusHeight: getTotalHeight(this._elements.status),
            extraHeight: this._getExtraHeight()
        };
        const result = data.progressHeight + data.chatWidgetContentHeight + data.followUpsHeight + data.statusHeight + data.extraHeight;
        return result;
    }
    get minHeight() {
        let maxWidgetHeight = 100;
        for (const item of this._chatWidget.viewModel?.getItems() ?? []) {
            if (isResponseVM(item) && ( (item.response.value.some(r => r.kind === 'textEditGroup' && !r.state?.applied)))) {
                maxWidgetHeight = 270;
                break;
            }
        }
        let value = this.contentHeight;
        value -= this._chatWidget.contentHeight;
        value += Math.min(maxWidgetHeight, this._chatWidget.contentHeight);
        return value;
    }
    _getExtraHeight() {
        return 12  + 2  + 12 ;
    }
    updateProgress(show) {
        if (show) {
            this._progressBar.show();
            this._progressBar.infinite();
        }
        else {
            this._progressBar.stop();
            this._progressBar.hide();
        }
    }
    get value() {
        return this._chatWidget.getInput();
    }
    set value(value) {
        this._chatWidget.setInput(value);
    }
    selectAll(includeSlashCommand = true) {
        let startColumn = 1;
        if (!includeSlashCommand) {
            const match = /^(\/\w+)\s*/.exec(this._chatWidget.inputEditor.getModel().getLineContent(1));
            if (match) {
                startColumn = match[1].length + 1;
            }
        }
        this._chatWidget.inputEditor.setSelection(( (new Selection(1, startColumn, Number.MAX_SAFE_INTEGER, 1))));
    }
    set placeholder(value) {
        this._chatWidget.setInputPlaceholder(value);
    }
    updateToolbar(show) {
        this._elements.statusToolbar.classList.toggle('hidden', !show);
        this._elements.feedbackToolbar.classList.toggle('hidden', !show);
        this._elements.status.classList.toggle('actions', show);
        this._elements.infoLabel.classList.toggle('hidden', show);
        this._onDidChangeHeight.fire();
    }
    async getCodeBlockInfo(codeBlockIndex) {
        const { viewModel } = this._chatWidget;
        if (!viewModel) {
            return undefined;
        }
        for (const item of viewModel.getItems()) {
            if (isResponseVM(item)) {
                return viewModel.codeBlockModelCollection.get(viewModel.sessionId, item, codeBlockIndex)?.model;
            }
        }
        return undefined;
    }
    get responseContent() {
        const requests = this._chatWidget.viewModel?.model.getRequests();
        if (!isNonEmptyArray(requests)) {
            return undefined;
        }
        return tail(requests)?.response?.response.asString();
    }
    get usesDefaultChatModel() {
        return this.getChatModel() === this._defaultChatModel;
    }
    getChatModel() {
        return this._chatWidget.viewModel?.model ?? this._defaultChatModel;
    }
    setChatModel(chatModel) {
        this._chatWidget.setModel(chatModel, { inputValue: undefined });
    }
    addToHistory(input) {
        if (this._chatWidget.viewModel?.model === this._defaultChatModel) {
            this._chatWidget.input.acceptInput(input);
        }
    }
    updateChatMessage(message, isIncomplete, isCodeBlockEditable) {
        if (!this._chatWidget.viewModel || this._chatWidget.viewModel.model !== this._defaultChatModel) {
            return;
        }
        const model = this._defaultChatModel;
        if (!message?.message.value) {
            for (const request of model.getRequests()) {
                model.removeRequest(request.id);
            }
            return;
        }
        const chatRequest = model.addRequest({ parts: [], text: '' }, { variables: [] }, 0);
        model.acceptResponseProgress(chatRequest, {
            kind: 'markdownContent',
            content: message.message
        });
        if (!isIncomplete) {
            model.completeResponse(chatRequest);
            return;
        }
        return {
            cancel: () => model.cancelRequest(chatRequest),
            complete: () => model.completeResponse(chatRequest),
            appendContent: (fragment) => {
                model.acceptResponseProgress(chatRequest, {
                    kind: 'markdownContent',
                    content: ( (new MarkdownString(fragment)))
                });
            }
        };
    }
    updateFollowUps(items, onFollowup) {
        this._followUpDisposables.clear();
        this._elements.followUps.classList.toggle('hidden', !items || items.length === 0);
        reset(this._elements.followUps);
        if (items && items.length > 0 && onFollowup) {
            this._followUpDisposables.add(this._instantiationService.createInstance(ChatFollowups, this._elements.followUps, items, ChatAgentLocation.Editor, undefined, onFollowup));
        }
        this._onDidChangeHeight.fire();
    }
    updateSlashCommands(commands) {
    }
    updateInfo(message) {
        this._elements.infoLabel.classList.toggle('hidden', !message);
        const renderedMessage = renderLabelWithIcons(message);
        reset(this._elements.infoLabel, ...renderedMessage);
        this._onDidChangeHeight.fire();
    }
    updateStatus(message, ops = {}) {
        const isTempMessage = typeof ops.resetAfter === 'number';
        if (isTempMessage && !this._elements.statusLabel.dataset['state']) {
            const statusLabel = this._elements.statusLabel.innerText;
            const title = this._elements.statusLabel.dataset['title'];
            const classes = Array.from(( (this._elements.statusLabel.classList.values())));
            setTimeout(() => {
                this.updateStatus(statusLabel, { classes, keepMessage: true, title });
            }, ops.resetAfter);
        }
        const renderedMessage = renderLabelWithIcons(message);
        reset(this._elements.statusLabel, ...renderedMessage);
        this._elements.statusLabel.className = `label status ${(ops.classes ?? []).join(' ')}`;
        this._elements.statusLabel.classList.toggle('hidden', !message);
        if (isTempMessage) {
            this._elements.statusLabel.dataset['state'] = 'temp';
        }
        else {
            delete this._elements.statusLabel.dataset['state'];
        }
        if (ops.title) {
            this._elements.statusLabel.dataset['title'] = ops.title;
        }
        else {
            delete this._elements.statusLabel.dataset['title'];
        }
        this._onDidChangeHeight.fire();
    }
    reset() {
        this._chatWidget.saveState();
        this.updateChatMessage(undefined);
        this.updateFollowUps(undefined);
        reset(this._elements.statusLabel);
        this._elements.statusLabel.classList.toggle('hidden', true);
        this._elements.statusToolbar.classList.add('hidden');
        this._elements.feedbackToolbar.classList.add('hidden');
        this.updateInfo('');
        this._elements.accessibleViewer.classList.toggle('hidden', true);
        this._onDidChangeHeight.fire();
    }
    focus() {
        this._chatWidget.focusInput();
    }
    hasFocus() {
        return this.domNode.contains(getActiveElement());
    }
};
InlineChatWidget = ( (__decorate([
    ( (__param(2, IInstantiationService))),
    ( (__param(3, IContextKeyService))),
    ( (__param(4, IKeybindingService))),
    ( (__param(5, IAccessibilityService))),
    ( (__param(6, IConfigurationService))),
    ( (__param(7, IAccessibleViewService))),
    ( (__param(8, ITextModelService))),
    ( (__param(9, IChatService))),
    ( (__param(10, IHoverService)))
], InlineChatWidget)));
const defaultAriaLabel = ( localizeWithPath(_moduleId, 2, "Inline Chat Input"));
const codeEditorWidgetOptions = {
    isSimpleWidget: true,
    contributions: EditorExtensionsRegistry.getSomeEditorContributions([
        SnippetController2.ID,
        SuggestController.ID
    ])
};
const _previewEditorEditorOptions = {
    scrollbar: { useShadows: false, alwaysConsumeMouseWheel: false, ignoreHorizontalScrollbarInContentHeight: true, },
    renderMarginRevertIcon: false,
    diffCodeLens: false,
    scrollBeyondLastLine: false,
    stickyScroll: { enabled: false },
    originalAriaLabel: ( localizeWithPath(_moduleId, 3, 'Original')),
    modifiedAriaLabel: ( localizeWithPath(_moduleId, 4, 'Modified')),
    diffAlgorithm: 'advanced',
    readOnly: true,
    isInEmbeddedEditor: true
};
let EditorBasedInlineChatWidget = class EditorBasedInlineChatWidget extends InlineChatWidget {
    constructor(_parentEditor, options, contextKeyService, keybindingService, instantiationService, accessibilityService, configurationService, accessibleViewService, textModelResolverService, chatService, hoverService) {
        super(ChatAgentLocation.Editor, { ...options, editorOverflowWidgetsDomNode: _parentEditor.getOverflowWidgetsDomNode() }, instantiationService, contextKeyService, keybindingService, accessibilityService, configurationService, accessibleViewService, textModelResolverService, chatService, hoverService);
        this._parentEditor = _parentEditor;
        this._accessibleViewer = this._store.add(( (new MutableDisposable())));
        this._previewDiffModel = this._store.add(( (new MutableDisposable())));
        this._previewDiffEditor = ( (new Lazy(
            () => this._store.add(instantiationService.createInstance(EmbeddedDiffEditorWidget, this._elements.previewDiff, {
                useInlineViewWhenSpaceIsLimited: false,
                ..._previewEditorEditorOptions,
                onlyShowAccessibleDiffViewer: accessibilityService.isScreenReaderOptimized(),
            }, { modifiedEditor: codeEditorWidgetOptions, originalEditor: codeEditorWidgetOptions }, _parentEditor))
        )));
    }
    get contentHeight() {
        let result = super.contentHeight;
        if (this._previewDiffEditor.hasValue && this._previewDiffEditor.value.getModel()) {
            result += 14 + Math.min(300, this._previewDiffEditor.value.getContentHeight());
        }
        if (this._accessibleViewer.value) {
            result += this._accessibleViewer.value.height;
        }
        return result;
    }
    _doLayout(dimension) {
        let newHeight = dimension.height;
        if (this._previewDiffEditor.hasValue) {
            const previewDiffDim = ( (new Dimension(
                dimension.width - 12,
                Math.min(300, this._previewDiffEditor.value.getContentHeight())
            )));
            this._elements.previewDiff.style.width = `${previewDiffDim.width}px`;
            this._elements.previewDiff.style.height = `${previewDiffDim.height}px`;
            this._previewDiffEditor.value.layout(previewDiffDim);
            newHeight -= previewDiffDim.height + 14;
        }
        if (this._accessibleViewer.value) {
            this._accessibleViewer.value.width = dimension.width - 12;
            newHeight -= this._accessibleViewer.value.height;
        }
        super._doLayout(dimension.with(undefined, newHeight));
        this._elements.root.style.height = `${dimension.height - this._getExtraHeight()}px`;
    }
    reset() {
        this.hideEditsPreview();
        this._accessibleViewer.clear();
        super.reset();
    }
    showAccessibleHunk(session, hunkData) {
        this._elements.accessibleViewer.classList.remove('hidden');
        this._accessibleViewer.clear();
        this._accessibleViewer.value = this._instantiationService.createInstance(HunkAccessibleDiffViewer, this._elements.accessibleViewer, session, hunkData, ( (new AccessibleHunk(this._parentEditor, session, hunkData))));
        this._onDidChangeHeight.fire();
    }
    showEditsPreview(hunks, textModel0, textModelN) {
        if (hunks.size === 0) {
            this.hideEditsPreview();
            return;
        }
        this._elements.previewDiff.classList.remove('hidden');
        this._previewDiffEditor.value.setModel({ original: textModel0, modified: textModelN });
        let originalLineRange;
        let modifiedLineRange;
        for (const item of hunks.getInfo()) {
            const [first0] = item.getRanges0();
            const [firstN] = item.getRangesN();
            originalLineRange = !originalLineRange ? LineRange.fromRangeInclusive(first0) : originalLineRange.join(LineRange.fromRangeInclusive(first0));
            modifiedLineRange = !modifiedLineRange ? LineRange.fromRangeInclusive(firstN) : modifiedLineRange.join(LineRange.fromRangeInclusive(firstN));
        }
        if (!originalLineRange || !modifiedLineRange) {
            this.hideEditsPreview();
            return;
        }
        const hiddenOriginal = LineRange.invert(originalLineRange, textModel0);
        const hiddenModified = LineRange.invert(modifiedLineRange, textModelN);
        this._previewDiffEditor.value.getOriginalEditor().setHiddenAreas(( (hiddenOriginal.map(lr => LineRange.asRange(lr, textModel0)))), 'diff-hidden');
        this._previewDiffEditor.value.getModifiedEditor().setHiddenAreas(( (hiddenModified.map(lr => LineRange.asRange(lr, textModelN)))), 'diff-hidden');
        this._previewDiffEditor.value.revealLine(modifiedLineRange.startLineNumber, 1 );
        this._onDidChangeHeight.fire();
    }
    hideEditsPreview() {
        this._elements.previewDiff.classList.add('hidden');
        if (this._previewDiffEditor.hasValue) {
            this._previewDiffEditor.value.setModel(null);
        }
        this._previewDiffModel.clear();
        this._onDidChangeHeight.fire();
    }
    showsAnyPreview() {
        return !this._elements.previewDiff.classList.contains('hidden');
    }
};
EditorBasedInlineChatWidget = ( (__decorate([
    ( (__param(2, IContextKeyService))),
    ( (__param(3, IKeybindingService))),
    ( (__param(4, IInstantiationService))),
    ( (__param(5, IAccessibilityService))),
    ( (__param(6, IConfigurationService))),
    ( (__param(7, IAccessibleViewService))),
    ( (__param(8, ITextModelService))),
    ( (__param(9, IChatService))),
    ( (__param(10, IHoverService)))
], EditorBasedInlineChatWidget)));
let HunkAccessibleDiffViewer = HunkAccessibleDiffViewer_1 = class HunkAccessibleDiffViewer extends AccessibleDiffViewer {
    set width(value) {
        this._width2.set(value, undefined);
    }
    constructor(parentNode, session, hunk, models, instantiationService) {
        const width = observableValue('width', 0);
        const diff = observableValue('diff', HunkAccessibleDiffViewer_1._asMapping(hunk));
        const diffs = derived(r => [diff.read(r)]);
        const lines = Math.min(10, 8 + diff.get().changedLineCount);
        const height = models.getModifiedOptions().get(67 ) * lines;
        super(parentNode, constObservable(true), () => { }, constObservable(false), width, constObservable(height), diffs, models, instantiationService);
        this.height = height;
        this._width2 = width;
        this._store.add(session.textModelN.onDidChangeContent(() => {
            diff.set(HunkAccessibleDiffViewer_1._asMapping(hunk), undefined);
        }));
    }
    static _asMapping(hunk) {
        const ranges0 = hunk.getRanges0();
        const rangesN = hunk.getRangesN();
        const originalLineRange = LineRange.fromRangeInclusive(ranges0[0]);
        const modifiedLineRange = LineRange.fromRangeInclusive(rangesN[0]);
        const innerChanges = [];
        for (let i = 1; i < ranges0.length; i++) {
            innerChanges.push(( (new RangeMapping(ranges0[i], rangesN[i]))));
        }
        return (
             (new DetailedLineRangeMapping(originalLineRange, modifiedLineRange, innerChanges))
        );
    }
};
HunkAccessibleDiffViewer = HunkAccessibleDiffViewer_1 = ( (__decorate([
    ( (__param(4, IInstantiationService)))
], HunkAccessibleDiffViewer)));
class AccessibleHunk {
    constructor(_editor, _session, _hunk) {
        this._editor = _editor;
        this._session = _session;
        this._hunk = _hunk;
    }
    getOriginalModel() {
        return this._session.textModel0;
    }
    getModifiedModel() {
        return this._session.textModelN;
    }
    getOriginalOptions() {
        return this._editor.getOptions();
    }
    getModifiedOptions() {
        return this._editor.getOptions();
    }
    originalReveal(range) {
    }
    modifiedReveal(range) {
        this._editor.revealRangeInCenterIfOutsideViewport(range || this._hunk.getRangesN()[0], 0 );
    }
    modifiedSetSelection(range) {
    }
    modifiedFocus() {
        this._editor.focus();
    }
    getModifiedPosition() {
        return this._hunk.getRangesN()[0].getStartPosition();
    }
}
export { EditorBasedInlineChatWidget, InlineChatWidget };
