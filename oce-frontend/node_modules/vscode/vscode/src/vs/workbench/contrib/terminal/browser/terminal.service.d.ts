import { ServiceIdentifier } from '../../../../platform/instantiation/common/instantiation.js';
import { Event, DynamicListEventMultiplexer, IDynamicListEventMultiplexer } from '../../../../base/common/event.js';
import { URI } from '../../../../base/common/uri.js';
import { TerminalCapability, ITerminalCapabilityImplMap } from '../../../../platform/terminal/common/capabilities/capabilities.js';
import { TerminalLocation, ITerminalBackend, ITerminalLaunchError, IShellLaunchConfig, ITerminalProfile } from '../../../../platform/terminal/common/terminal.js';
import { IEditableData } from '../../../common/views.js';
import { IStartExtensionTerminalRequest, ITerminalProcessExtHostProxy, IRemoteTerminalAttachTarget, ITerminalConfiguration, ITerminalFont } from '../common/terminal.js';
import { GroupIdentifier } from '../../../common/editor.js';
import { SIDE_GROUP_TYPE, ACTIVE_GROUP_TYPE, AUX_WINDOW_GROUP_TYPE } from '../../../services/editor/common/editorService.js';
import { ITerminalInstanceHost, ITerminalInstance, IDetachedTerminalInstance, TerminalConnectionState, ITerminalGroup, ICreateTerminalOptions, IDetachedXTermOptions, ITerminalLocationOptions, ITerminalServiceNativeDelegate } from './terminal.js';
import { IXtermCore } from './xterm-private.js';

declare const ITerminalService: ServiceIdentifier<ITerminalService>;
interface ITerminalService extends ITerminalInstanceHost {
    readonly _serviceBrand: undefined;
    /** Gets all terminal instances, including editor and terminal view (group) instances. */
    readonly instances: readonly ITerminalInstance[];
    /** Gets detached terminal instances created via {@link createDetachedXterm}. */
    readonly detachedInstances: Iterable<IDetachedTerminalInstance>;
    readonly defaultLocation: TerminalLocation;
    readonly isProcessSupportRegistered: boolean;
    readonly connectionState: TerminalConnectionState;
    readonly whenConnected: Promise<void>;
    /** The number of restored terminal groups on startup. */
    readonly restoredGroupCount: number;
    readonly onDidCreateInstance: Event<ITerminalInstance>;
    readonly onDidChangeInstanceDimensions: Event<ITerminalInstance>;
    readonly onDidRequestStartExtensionTerminal: Event<IStartExtensionTerminalRequest>;
    readonly onDidRegisterProcessSupport: Event<void>;
    readonly onDidChangeConnectionState: Event<void>;
    readonly onDidChangeActiveGroup: Event<ITerminalGroup | undefined>;
    readonly onAnyInstanceData: Event<{
        instance: ITerminalInstance;
        data: string;
    }>;
    readonly onAnyInstanceDataInput: Event<ITerminalInstance>;
    readonly onAnyInstanceIconChange: Event<{
        instance: ITerminalInstance;
        userInitiated: boolean;
    }>;
    readonly onAnyInstanceMaximumDimensionsChange: Event<ITerminalInstance>;
    readonly onAnyInstancePrimaryStatusChange: Event<ITerminalInstance>;
    readonly onAnyInstanceProcessIdReady: Event<ITerminalInstance>;
    readonly onAnyInstanceSelectionChange: Event<ITerminalInstance>;
    readonly onAnyInstanceTitleChange: Event<ITerminalInstance>;
    /**
    * Creates a terminal.
    * @param options The options to create the terminal with, when not specified the default
    * profile will be used at the default target.
    */
    createTerminal(options?: ICreateTerminalOptions): Promise<ITerminalInstance>;
    /**
    * Creates a detached xterm instance which is not attached to the DOM or
    * tracked as a terminal instance.
    * @params options The options to create the terminal with
    */
    createDetachedTerminal(options: IDetachedXTermOptions): Promise<IDetachedTerminalInstance>;
    /**
    * Creates a raw terminal instance, this should not be used outside of the terminal part.
    */
    getInstanceFromId(terminalId: number): ITerminalInstance | undefined;
    getInstanceFromIndex(terminalIndex: number): ITerminalInstance;
    /**
    * An owner of terminals might be created after reconnection has occurred,
    * so store them to be requested/adopted later
    */
    getReconnectedTerminals(reconnectionOwner: string): ITerminalInstance[] | undefined;
    getActiveOrCreateInstance(options?: {
        acceptsInput?: boolean;
    }): Promise<ITerminalInstance>;
    revealActiveTerminal(preserveFocus?: boolean): Promise<void>;
    moveToEditor(source: ITerminalInstance, group?: GroupIdentifier | SIDE_GROUP_TYPE | ACTIVE_GROUP_TYPE | AUX_WINDOW_GROUP_TYPE): void;
    moveIntoNewEditor(source: ITerminalInstance): void;
    moveToTerminalView(source: ITerminalInstance | URI): Promise<void>;
    getPrimaryBackend(): ITerminalBackend | undefined;
    /**
    * Fire the onActiveTabChanged event, this will trigger the terminal dropdown to be updated,
    * among other things.
    */
    refreshActiveGroup(): void;
    registerProcessSupport(isSupported: boolean): void;
    showProfileQuickPick(type: 'setDefault' | 'createInstance', cwd?: string | URI): Promise<ITerminalInstance | undefined>;
    setContainers(panelContainer: HTMLElement, terminalContainer: HTMLElement): void;
    requestStartExtensionTerminal(proxy: ITerminalProcessExtHostProxy, cols: number, rows: number): Promise<ITerminalLaunchError | undefined>;
    isAttachedToTerminal(remoteTerm: IRemoteTerminalAttachTarget): boolean;
    getEditableData(instance: ITerminalInstance): IEditableData | undefined;
    setEditable(instance: ITerminalInstance, data: IEditableData | null): void;
    isEditable(instance: ITerminalInstance | undefined): boolean;
    safeDisposeTerminal(instance: ITerminalInstance): Promise<void>;
    getDefaultInstanceHost(): ITerminalInstanceHost;
    getInstanceHost(target: ITerminalLocationOptions | undefined): Promise<ITerminalInstanceHost>;
    resolveLocation(location?: ITerminalLocationOptions): Promise<TerminalLocation | undefined>;
    setNativeDelegate(nativeCalls: ITerminalServiceNativeDelegate): void;
    getEditingTerminal(): ITerminalInstance | undefined;
    setEditingTerminal(instance: ITerminalInstance | undefined): void;
    /**
    * Creates an instance event listener that listens to all instances, dynamically adding new
    * instances and removing old instances as needed.
    * @param getEvent Maps the instance to the event.
    */
    createOnInstanceEvent<T>(getEvent: (instance: ITerminalInstance) => Event<T>): DynamicListEventMultiplexer<ITerminalInstance, T>;
    /**
    * Creates a capability event listener that listens to capabilities on all instances,
    * dynamically adding and removing instances and capabilities as needed.
    * @param capabilityId The capability type to listen to an event on.
    * @param getEvent Maps the capability to the event.
    */
    createOnInstanceCapabilityEvent<T extends TerminalCapability, K>(capabilityId: T, getEvent: (capability: ITerminalCapabilityImplMap[T]) => Event<K>): IDynamicListEventMultiplexer<{
        instance: ITerminalInstance;
        data: K;
    }>;
}
declare const ITerminalConfigurationService: ServiceIdentifier<ITerminalConfigurationService>;
/**
* A service that provides convenient access to the terminal configuration and derived values.
*/
interface ITerminalConfigurationService {
    readonly _serviceBrand: undefined;
    /**
    * A typed and partially validated representation of the terminal configuration.
    */
    readonly config: Readonly<ITerminalConfiguration>;
    /**
    * Fires when something within the terminal configuration changes.
    */
    readonly onConfigChanged: Event<void>;
    setPanelContainer(panelContainer: HTMLElement): void;
    configFontIsMonospace(): boolean;
    getFont(w: Window, xtermCore?: IXtermCore, excludeDimensions?: boolean): ITerminalFont;
}
declare const ITerminalInstanceService: ServiceIdentifier<ITerminalInstanceService>;
/**
* A service used to create instances or fetch backends, this services allows services that
* ITerminalService depends on to also create instances.
*
* **This service is intended to only be used within the terminal contrib.**
*/
interface ITerminalInstanceService {
    readonly _serviceBrand: undefined;
    /**
    * An event that's fired when a terminal instance is created.
    */
    onDidCreateInstance: Event<ITerminalInstance>;
    /**
    * Helper function to convert a shell launch config, a profile or undefined into its equivalent
    * shell launch config.
    * @param shellLaunchConfigOrProfile A shell launch config, a profile or undefined
    * @param cwd A cwd to override.
    */
    convertProfileToShellLaunchConfig(shellLaunchConfigOrProfile?: IShellLaunchConfig | ITerminalProfile, cwd?: string | URI): IShellLaunchConfig;
    /**
    * Create a new terminal instance.
    * @param launchConfig The shell launch config.
    * @param target The target of the terminal.
    */
    createInstance(launchConfig: IShellLaunchConfig, target: TerminalLocation): ITerminalInstance;
    /**
    * Gets the registered backend for a remote authority (undefined = local). This is a convenience
    * method to avoid using the more verbose fetching from the registry.
    * @param remoteAuthority The remote authority of the backend.
    */
    getBackend(remoteAuthority?: string): Promise<ITerminalBackend | undefined>;
    getRegisteredBackends(): IterableIterator<ITerminalBackend>;
    didRegisterBackend(remoteAuthority?: string): void;
}

export { ITerminalConfigurationService, ITerminalInstanceService, ITerminalService };
