import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { append, addStandardDisposableListener, addDisposableListener, $ as $$1, isMouseEvent, hide, show } from '../../../../base/browser/dom.js';
import { Gesture } from '../../../../base/browser/touch.js';
import { ActionBar } from '../../../../base/browser/ui/actionbar/actionbar.js';
import { getDefaultHoverDelegate } from '../../../../base/browser/ui/hover/hoverDelegateFactory.js';
import { IconLabel } from '../../../../base/browser/ui/iconLabel/iconLabel.js';
import { InputBox } from '../../../../base/browser/ui/inputbox/inputBox.js';
import { Action } from '../../../../base/common/actions.js';
import { equals } from '../../../../base/common/arrays.js';
import { RunOnceScheduler } from '../../../../base/common/async.js';
import { Codicon } from '../../../../base/common/codicons.js';
import { MarkdownString } from '../../../../base/common/htmlContent.js';
import { dispose } from '../../../../base/common/lifecycle.js';
import { basenameOrAuthority, dirname } from '../../../../base/common/resources.js';
import { ThemeIcon } from '../../../../base/common/themables.js';
import { isCodeEditor } from '../../../../editor/browser/editorBrowser.js';
import { ILanguageService } from '../../../../editor/common/languages/language.js';
import { localizeWithPath, localize2WithPath } from '../../../../nls.js';
import { createAndFillInActionBarActions, createAndFillInContextMenuActions } from '../../../../platform/actions/browser/menuEntryActionViewItem.js';
import { registerAction2, MenuId, Action2 } from '../../../../platform/actions/common/actions.js';
import { IMenuService } from '../../../../platform/actions/common/actions.service.js';
import { IConfigurationService } from '../../../../platform/configuration/common/configuration.service.js';
import { ContextKeyExpr } from '../../../../platform/contextkey/common/contextkey.js';
import { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.service.js';
import { IContextMenuService, IContextViewService } from '../../../../platform/contextview/browser/contextView.service.js';
import { IHoverService } from '../../../../platform/hover/browser/hover.service.js';
import { IInstantiationService } from '../../../../platform/instantiation/common/instantiation.js';
import { IKeybindingService } from '../../../../platform/keybinding/common/keybinding.service.js';
import { ILabelService } from '../../../../platform/label/common/label.service.js';
import { WorkbenchList } from '../../../../platform/list/browser/listService.js';
import { IOpenerService } from '../../../../platform/opener/common/opener.service.js';
import { IQuickInputService } from '../../../../platform/quickinput/common/quickInput.service.js';
import { ITelemetryService } from '../../../../platform/telemetry/common/telemetry.service.js';
import { defaultInputBoxStyles } from '../../../../platform/theme/browser/defaultStyles.js';
import { IThemeService } from '../../../../platform/theme/common/themeService.service.js';
import { ViewPane, ViewAction } from '../../../browser/parts/views/viewPane.js';
import { IViewDescriptorService } from '../../../common/views.service.js';
import { breakpoint, dataBreakpoint, functionBreakpoint, logBreakpoint, conditionalBreakpoint, debugBreakpointUnsupported, watchExpressionsAddFuncBreakpoint, watchExpressionsAddDataBreakpoint, breakpointsActivate, breakpointsRemoveAll } from './debugIcons.js';
import { CONTEXT_BREAKPOINT_ITEM_TYPE, CONTEXT_BREAKPOINT_ITEM_IS_DATA_BYTES, CONTEXT_BREAKPOINT_HAS_MODES, CONTEXT_BREAKPOINT_SUPPORTS_CONDITION, CONTEXT_BREAKPOINT_INPUT_FOCUSED, CONTEXT_BREAKPOINTS_FOCUSED, DEBUG_SCHEME, DebuggerString, BREAKPOINTS_VIEW_ID, CONTEXT_DEBUGGERS_AVAILABLE, CONTEXT_SET_DATA_BREAKPOINT_BYTES_SUPPORTED, CONTEXT_BREAKPOINTS_EXIST, CONTEXT_IN_DEBUG_MODE, BREAKPOINT_EDITOR_CONTRIBUTION_ID } from '../common/debug.js';
import { IDebugService } from '../common/debug.service.js';
import { Breakpoint, DataBreakpoint, FunctionBreakpoint, InstructionBreakpoint, ExceptionBreakpoint } from '../common/debugModel.js';
import { DisassemblyViewInput } from '../common/disassemblyViewInput.js';
import { SIDE_GROUP, ACTIVE_GROUP } from '../../../services/editor/common/editorService.js';
import { IEditorService } from '../../../services/editor/common/editorService.service.js';
import { INotificationService } from '../../../../platform/notification/common/notification.service.js';
var BreakpointsRenderer_1, FunctionBreakpointsRenderer_1, DataBreakpointsRenderer_1, InstructionBreakpointsRenderer_1;
const _moduleId = "vs/workbench/contrib/debug/browser/breakpointsView";
const $ = $$1;
function createCheckbox(disposables) {
    const checkbox = $('input');
    checkbox.type = 'checkbox';
    checkbox.tabIndex = -1;
    disposables.push(Gesture.ignoreTarget(checkbox));
    return checkbox;
}
const MAX_VISIBLE_BREAKPOINTS = 9;
function getExpandedBodySize(model, sessionId, countLimit) {
    const length = model.getBreakpoints().length + model.getExceptionBreakpointsForSession(sessionId).length + model.getFunctionBreakpoints().length + model.getDataBreakpoints().length + model.getInstructionBreakpoints().length;
    return Math.min(countLimit, length) * 22;
}
let BreakpointsView = class BreakpointsView extends ViewPane {
    constructor(options, contextMenuService, debugService, keybindingService, instantiationService, themeService, editorService, contextViewService, configurationService, viewDescriptorService, contextKeyService, openerService, telemetryService, labelService, menuService, hoverService, languageService) {
        super(options, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, instantiationService, openerService, themeService, telemetryService, hoverService);
        this.debugService = debugService;
        this.editorService = editorService;
        this.contextViewService = contextViewService;
        this.labelService = labelService;
        this.languageService = languageService;
        this.needsRefresh = false;
        this.needsStateChange = false;
        this.ignoreLayout = false;
        this.autoFocusedIndex = -1;
        this.menu = menuService.createMenu(MenuId.DebugBreakpointsContext, contextKeyService);
        this._register(this.menu);
        this.breakpointItemType = CONTEXT_BREAKPOINT_ITEM_TYPE.bindTo(contextKeyService);
        this.breakpointIsDataBytes = CONTEXT_BREAKPOINT_ITEM_IS_DATA_BYTES.bindTo(contextKeyService);
        this.breakpointHasMultipleModes = CONTEXT_BREAKPOINT_HAS_MODES.bindTo(contextKeyService);
        this.breakpointSupportsCondition = CONTEXT_BREAKPOINT_SUPPORTS_CONDITION.bindTo(contextKeyService);
        this.breakpointInputFocused = CONTEXT_BREAKPOINT_INPUT_FOCUSED.bindTo(contextKeyService);
        this._register(this.debugService.getModel().onDidChangeBreakpoints(() => this.onBreakpointsChange()));
        this._register(this.debugService.getViewModel().onDidFocusSession(() => this.onBreakpointsChange()));
        this._register(this.debugService.onDidChangeState(() => this.onStateChange()));
        this.hintDelayer = this._register(( (new RunOnceScheduler(() => this.updateBreakpointsHint(true), 4000))));
    }
    renderBody(container) {
        super.renderBody(container);
        this.element.classList.add('debug-pane');
        container.classList.add('debug-breakpoints');
        const delegate = ( (new BreakpointsDelegate(this)));
        this.list = this.instantiationService.createInstance(WorkbenchList, 'Breakpoints', container, delegate, [
            this.instantiationService.createInstance(BreakpointsRenderer, this.menu, this.breakpointHasMultipleModes, this.breakpointSupportsCondition, this.breakpointItemType),
            ( (new ExceptionBreakpointsRenderer(
            this.menu,
            this.breakpointHasMultipleModes,
            this.breakpointSupportsCondition,
            this.breakpointItemType,
            this.debugService,
            this.hoverService
        ))),
            ( (new ExceptionBreakpointInputRenderer(this, this.debugService, this.contextViewService))),
            this.instantiationService.createInstance(FunctionBreakpointsRenderer, this.menu, this.breakpointSupportsCondition, this.breakpointItemType),
            ( (new FunctionBreakpointInputRenderer(
            this,
            this.debugService,
            this.contextViewService,
            this.hoverService,
            this.labelService
        ))),
            this.instantiationService.createInstance(DataBreakpointsRenderer, this.menu, this.breakpointHasMultipleModes, this.breakpointSupportsCondition, this.breakpointItemType, this.breakpointIsDataBytes),
            ( (new DataBreakpointInputRenderer(
            this,
            this.debugService,
            this.contextViewService,
            this.hoverService,
            this.labelService
        ))),
            this.instantiationService.createInstance(InstructionBreakpointsRenderer),
        ], {
            identityProvider: { getId: (element) => element.getId() },
            multipleSelectionSupport: false,
            keyboardNavigationLabelProvider: { getKeyboardNavigationLabel: (e) => e },
            accessibilityProvider: ( (new BreakpointsAccessibilityProvider(this.debugService, this.labelService))),
            overrideStyles: this.getLocationBasedColors().listOverrideStyles
        });
        CONTEXT_BREAKPOINTS_FOCUSED.bindTo(this.list.contextKeyService);
        this._register(this.list.onContextMenu(this.onListContextMenu, this));
        this.list.onMouseMiddleClick(async ({ element }) => {
            if (element instanceof Breakpoint) {
                await this.debugService.removeBreakpoints(element.getId());
            }
            else if (element instanceof FunctionBreakpoint) {
                await this.debugService.removeFunctionBreakpoints(element.getId());
            }
            else if (element instanceof DataBreakpoint) {
                await this.debugService.removeDataBreakpoints(element.getId());
            }
            else if (element instanceof InstructionBreakpoint) {
                await this.debugService.removeInstructionBreakpoints(element.instructionReference, element.offset);
            }
        });
        this._register(this.list.onDidOpen(async (e) => {
            if (!e.element) {
                return;
            }
            if (isMouseEvent(e.browserEvent) && e.browserEvent.button === 1) {
                return;
            }
            if (e.element instanceof Breakpoint) {
                openBreakpointSource(e.element, e.sideBySide, e.editorOptions.preserveFocus || false, e.editorOptions.pinned || !e.editorOptions.preserveFocus, this.debugService, this.editorService);
            }
            if (e.element instanceof InstructionBreakpoint) {
                const disassemblyView = await this.editorService.openEditor(DisassemblyViewInput.instance);
                disassemblyView.goToInstructionAndOffset(e.element.instructionReference, e.element.offset, isMouseEvent(e.browserEvent) && e.browserEvent.detail === 2);
            }
            if (isMouseEvent(e.browserEvent) && e.browserEvent.detail === 2 && e.element instanceof FunctionBreakpoint && e.element !== this.inputBoxData?.breakpoint) {
                this.renderInputBox({ breakpoint: e.element, type: 'name' });
            }
        }));
        this.list.splice(0, this.list.length, this.elements);
        this._register(this.onDidChangeBodyVisibility(visible => {
            if (visible) {
                if (this.needsRefresh) {
                    this.onBreakpointsChange();
                }
                if (this.needsStateChange) {
                    this.onStateChange();
                }
            }
        }));
        const containerModel = this.viewDescriptorService.getViewContainerModel(this.viewDescriptorService.getViewContainerByViewId(this.id));
        this._register(containerModel.onDidChangeAllViewDescriptors(() => {
            this.updateSize();
        }));
    }
    renderHeaderTitle(container, title) {
        super.renderHeaderTitle(container, title);
        const iconLabelContainer = append(container, $('span.breakpoint-warning'));
        this.hintContainer = this._register(( (new IconLabel(iconLabelContainer, {
            supportIcons: true, hoverDelegate: {
                showHover: (options, focus) => this.hoverService.showHover({ content: options.content, target: this.hintContainer.element }, focus),
                delay: this.configurationService.getValue('workbench.hover.delay')
            }
        }))));
        hide(this.hintContainer.element);
    }
    focus() {
        super.focus();
        this.list?.domFocus();
    }
    renderInputBox(data) {
        this._inputBoxData = data;
        this.onBreakpointsChange();
        this._inputBoxData = undefined;
    }
    get inputBoxData() {
        return this._inputBoxData;
    }
    layoutBody(height, width) {
        if (this.ignoreLayout) {
            return;
        }
        super.layoutBody(height, width);
        this.list?.layout(height, width);
        try {
            this.ignoreLayout = true;
            this.updateSize();
        }
        finally {
            this.ignoreLayout = false;
        }
    }
    onListContextMenu(e) {
        const element = e.element;
        const type = element instanceof Breakpoint ? 'breakpoint' : element instanceof ExceptionBreakpoint ? 'exceptionBreakpoint' :
            element instanceof FunctionBreakpoint ? 'functionBreakpoint' : element instanceof DataBreakpoint ? 'dataBreakpoint' :
                element instanceof InstructionBreakpoint ? 'instructionBreakpoint' : undefined;
        this.breakpointItemType.set(type);
        const session = this.debugService.getViewModel().focusedSession;
        const conditionSupported = element instanceof ExceptionBreakpoint ? element.supportsCondition : (!session || !!session.capabilities.supportsConditionalBreakpoints);
        this.breakpointSupportsCondition.set(conditionSupported);
        this.breakpointIsDataBytes.set(element instanceof DataBreakpoint && element.src.type === 1 );
        const secondary = [];
        createAndFillInContextMenuActions(this.menu, { arg: e.element, shouldForwardArgs: false }, { primary: [], secondary }, 'inline');
        this.contextMenuService.showContextMenu({
            getAnchor: () => e.anchor,
            getActions: () => secondary,
            getActionsContext: () => element
        });
    }
    updateSize() {
        const containerModel = this.viewDescriptorService.getViewContainerModel(this.viewDescriptorService.getViewContainerByViewId(this.id));
        const sessionId = this.debugService.getViewModel().focusedSession?.getId();
        this.minimumBodySize = this.orientation === 0  ? getExpandedBodySize(this.debugService.getModel(), sessionId, MAX_VISIBLE_BREAKPOINTS) : 170;
        this.maximumBodySize = this.orientation === 0  && containerModel.visibleViewDescriptors.length > 1 ? getExpandedBodySize(this.debugService.getModel(), sessionId, Number.POSITIVE_INFINITY) : Number.POSITIVE_INFINITY;
    }
    updateBreakpointsHint(delayed = false) {
        if (!this.hintContainer) {
            return;
        }
        const currentType = this.debugService.getViewModel().focusedSession?.configuration.type;
        const dbg = currentType ? this.debugService.getAdapterManager().getDebugger(currentType) : undefined;
        const message = dbg?.strings?.[DebuggerString.UnverifiedBreakpoints];
        const debuggerHasUnverifiedBps = message && this.debugService.getModel().getBreakpoints().filter(bp => {
            if (bp.verified || !bp.enabled) {
                return false;
            }
            const langId = this.languageService.guessLanguageIdByFilepathOrFirstLine(bp.uri);
            return langId && dbg.interestedInLanguage(langId);
        });
        if (message && debuggerHasUnverifiedBps?.length && this.debugService.getModel().areBreakpointsActivated()) {
            if (delayed) {
                const mdown = ( (new MarkdownString(undefined, { isTrusted: true }))).appendMarkdown(message);
                this.hintContainer.setLabel('$(warning)', undefined, { title: { markdown: mdown, markdownNotSupportedFallback: message } });
                show(this.hintContainer.element);
            }
            else {
                this.hintDelayer.schedule();
            }
        }
        else {
            hide(this.hintContainer.element);
        }
    }
    onBreakpointsChange() {
        if (this.isBodyVisible()) {
            this.updateSize();
            if (this.list) {
                const lastFocusIndex = this.list.getFocus()[0];
                const needsRefocus = lastFocusIndex && !this.elements.includes(this.list.element(lastFocusIndex));
                this.list.splice(0, this.list.length, this.elements);
                this.needsRefresh = false;
                if (needsRefocus) {
                    this.list.focusNth(Math.min(lastFocusIndex, this.list.length - 1));
                }
            }
            this.updateBreakpointsHint();
        }
        else {
            this.needsRefresh = true;
        }
    }
    onStateChange() {
        if (this.isBodyVisible()) {
            this.needsStateChange = false;
            const thread = this.debugService.getViewModel().focusedThread;
            let found = false;
            if (thread && thread.stoppedDetails && thread.stoppedDetails.hitBreakpointIds && thread.stoppedDetails.hitBreakpointIds.length > 0) {
                const hitBreakpointIds = thread.stoppedDetails.hitBreakpointIds;
                const elements = this.elements;
                const index = elements.findIndex(e => {
                    const id = e.getIdFromAdapter(thread.session.getId());
                    return typeof id === 'number' && hitBreakpointIds.indexOf(id) !== -1;
                });
                if (index >= 0) {
                    this.list.setFocus([index]);
                    this.list.setSelection([index]);
                    found = true;
                    this.autoFocusedIndex = index;
                }
            }
            if (!found) {
                const focus = this.list.getFocus();
                const selection = this.list.getSelection();
                if (this.autoFocusedIndex >= 0 && equals(focus, selection) && focus.indexOf(this.autoFocusedIndex) >= 0) {
                    this.list.setFocus([]);
                    this.list.setSelection([]);
                }
                this.autoFocusedIndex = -1;
            }
            this.updateBreakpointsHint();
        }
        else {
            this.needsStateChange = true;
        }
    }
    get elements() {
        const model = this.debugService.getModel();
        const sessionId = this.debugService.getViewModel().focusedSession?.getId();
        const elements = model.getExceptionBreakpointsForSession(sessionId).concat(model.getFunctionBreakpoints()).concat(model.getDataBreakpoints()).concat(model.getBreakpoints()).concat(model.getInstructionBreakpoints());
        return elements;
    }
};
BreakpointsView = ( (__decorate([
    ( (__param(1, IContextMenuService))),
    ( (__param(2, IDebugService))),
    ( (__param(3, IKeybindingService))),
    ( (__param(4, IInstantiationService))),
    ( (__param(5, IThemeService))),
    ( (__param(6, IEditorService))),
    ( (__param(7, IContextViewService))),
    ( (__param(8, IConfigurationService))),
    ( (__param(9, IViewDescriptorService))),
    ( (__param(10, IContextKeyService))),
    ( (__param(11, IOpenerService))),
    ( (__param(12, ITelemetryService))),
    ( (__param(13, ILabelService))),
    ( (__param(14, IMenuService))),
    ( (__param(15, IHoverService))),
    ( (__param(16, ILanguageService)))
], BreakpointsView)));
class BreakpointsDelegate {
    constructor(view) {
        this.view = view;
    }
    getHeight(_element) {
        return 22;
    }
    getTemplateId(element) {
        if (element instanceof Breakpoint) {
            return BreakpointsRenderer.ID;
        }
        if (element instanceof FunctionBreakpoint) {
            const inputBoxBreakpoint = this.view.inputBoxData?.breakpoint;
            if (!element.name || (inputBoxBreakpoint && inputBoxBreakpoint.getId() === element.getId())) {
                return FunctionBreakpointInputRenderer.ID;
            }
            return FunctionBreakpointsRenderer.ID;
        }
        if (element instanceof ExceptionBreakpoint) {
            const inputBoxBreakpoint = this.view.inputBoxData?.breakpoint;
            if (inputBoxBreakpoint && inputBoxBreakpoint.getId() === element.getId()) {
                return ExceptionBreakpointInputRenderer.ID;
            }
            return ExceptionBreakpointsRenderer.ID;
        }
        if (element instanceof DataBreakpoint) {
            const inputBoxBreakpoint = this.view.inputBoxData?.breakpoint;
            if (inputBoxBreakpoint && inputBoxBreakpoint.getId() === element.getId()) {
                return DataBreakpointInputRenderer.ID;
            }
            return DataBreakpointsRenderer.ID;
        }
        if (element instanceof InstructionBreakpoint) {
            return InstructionBreakpointsRenderer.ID;
        }
        return '';
    }
}
const breakpointIdToActionBarDomeNode = ( (new Map()));
let BreakpointsRenderer = class BreakpointsRenderer {
    static { BreakpointsRenderer_1 = this; }
    constructor(menu, breakpointHasMultipleModes, breakpointSupportsCondition, breakpointItemType, debugService, hoverService, labelService) {
        this.menu = menu;
        this.breakpointHasMultipleModes = breakpointHasMultipleModes;
        this.breakpointSupportsCondition = breakpointSupportsCondition;
        this.breakpointItemType = breakpointItemType;
        this.debugService = debugService;
        this.hoverService = hoverService;
        this.labelService = labelService;
    }
    static { this.ID = 'breakpoints'; }
    get templateId() {
        return BreakpointsRenderer_1.ID;
    }
    renderTemplate(container) {
        const data = Object.create(null);
        data.toDispose = [];
        data.breakpoint = append(container, $('.breakpoint'));
        data.icon = $('.icon');
        data.checkbox = createCheckbox(data.toDispose);
        data.toDispose.push(addStandardDisposableListener(data.checkbox, 'change', (e) => {
            this.debugService.enableOrDisableBreakpoints(!data.context.enabled, data.context);
        }));
        append(data.breakpoint, data.icon);
        append(data.breakpoint, data.checkbox);
        data.name = append(data.breakpoint, $('span.name'));
        data.filePath = append(data.breakpoint, $('span.file-path'));
        data.actionBar = ( (new ActionBar(data.breakpoint)));
        data.toDispose.push(data.actionBar);
        const badgeContainer = append(data.breakpoint, $('.badge-container'));
        data.badge = append(badgeContainer, $('span.line-number.monaco-count-badge'));
        return data;
    }
    renderElement(breakpoint, index, data) {
        data.context = breakpoint;
        data.breakpoint.classList.toggle('disabled', !this.debugService.getModel().areBreakpointsActivated());
        data.name.textContent = basenameOrAuthority(breakpoint.uri);
        let badgeContent = ( (breakpoint.lineNumber.toString()));
        if (breakpoint.column) {
            badgeContent += `:${breakpoint.column}`;
        }
        if (breakpoint.modeLabel) {
            badgeContent = `${breakpoint.modeLabel}: ${badgeContent}`;
        }
        data.badge.textContent = badgeContent;
        data.filePath.textContent = this.labelService.getUriLabel(dirname(breakpoint.uri), { relative: true });
        data.checkbox.checked = breakpoint.enabled;
        const { message, icon } = getBreakpointMessageAndIcon(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), breakpoint, this.labelService, this.debugService.getModel());
        data.icon.className = ThemeIcon.asClassName(icon);
        data.toDispose.push(this.hoverService.setupUpdatableHover(getDefaultHoverDelegate('mouse'), data.breakpoint, breakpoint.message || message || ''));
        const debugActive = this.debugService.state === 3  || this.debugService.state === 2 ;
        if (debugActive && !breakpoint.verified) {
            data.breakpoint.classList.add('disabled');
        }
        const primary = [];
        const session = this.debugService.getViewModel().focusedSession;
        this.breakpointSupportsCondition.set(!session || !!session.capabilities.supportsConditionalBreakpoints);
        this.breakpointItemType.set('breakpoint');
        this.breakpointHasMultipleModes.set(this.debugService.getModel().getBreakpointModes('source').length > 1);
        createAndFillInActionBarActions(this.menu, { arg: breakpoint, shouldForwardArgs: true }, { primary, secondary: [] }, 'inline');
        data.actionBar.clear();
        data.actionBar.push(primary, { icon: true, label: false });
        breakpointIdToActionBarDomeNode.set(breakpoint.getId(), data.actionBar.domNode);
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
};
BreakpointsRenderer = BreakpointsRenderer_1 = ( (__decorate([
    ( (__param(4, IDebugService))),
    ( (__param(5, IHoverService))),
    ( (__param(6, ILabelService)))
], BreakpointsRenderer)));
class ExceptionBreakpointsRenderer {
    constructor(menu, breakpointHasMultipleModes, breakpointSupportsCondition, breakpointItemType, debugService, hoverService) {
        this.menu = menu;
        this.breakpointHasMultipleModes = breakpointHasMultipleModes;
        this.breakpointSupportsCondition = breakpointSupportsCondition;
        this.breakpointItemType = breakpointItemType;
        this.debugService = debugService;
        this.hoverService = hoverService;
    }
    static { this.ID = 'exceptionbreakpoints'; }
    get templateId() {
        return ExceptionBreakpointsRenderer.ID;
    }
    renderTemplate(container) {
        const data = Object.create(null);
        data.toDispose = [];
        data.breakpoint = append(container, $('.breakpoint'));
        data.checkbox = createCheckbox(data.toDispose);
        data.toDispose.push(addStandardDisposableListener(data.checkbox, 'change', (e) => {
            this.debugService.enableOrDisableBreakpoints(!data.context.enabled, data.context);
        }));
        append(data.breakpoint, data.checkbox);
        data.name = append(data.breakpoint, $('span.name'));
        data.condition = append(data.breakpoint, $('span.condition'));
        data.breakpoint.classList.add('exception');
        data.actionBar = ( (new ActionBar(data.breakpoint)));
        data.toDispose.push(data.actionBar);
        const badgeContainer = append(data.breakpoint, $('.badge-container'));
        data.badge = append(badgeContainer, $('span.line-number.monaco-count-badge'));
        return data;
    }
    renderElement(exceptionBreakpoint, index, data) {
        data.context = exceptionBreakpoint;
        data.name.textContent = exceptionBreakpoint.label || `${exceptionBreakpoint.filter} exceptions`;
        const exceptionBreakpointtitle = exceptionBreakpoint.verified ? (exceptionBreakpoint.description || data.name.textContent) : exceptionBreakpoint.message || ( localizeWithPath(_moduleId, 0, "Unverified Exception Breakpoint"));
        data.toDispose.push(this.hoverService.setupUpdatableHover(getDefaultHoverDelegate('mouse'), data.breakpoint, exceptionBreakpointtitle));
        data.breakpoint.classList.toggle('disabled', !exceptionBreakpoint.verified);
        data.checkbox.checked = exceptionBreakpoint.enabled;
        data.condition.textContent = exceptionBreakpoint.condition || '';
        data.toDispose.push(this.hoverService.setupUpdatableHover(getDefaultHoverDelegate('mouse'), data.condition, ( localizeWithPath(_moduleId, 1, "Expression condition: {0}", exceptionBreakpoint.condition))));
        if (exceptionBreakpoint.modeLabel) {
            data.badge.textContent = exceptionBreakpoint.modeLabel;
            data.badge.style.display = 'block';
        }
        else {
            data.badge.style.display = 'none';
        }
        const primary = [];
        this.breakpointSupportsCondition.set(exceptionBreakpoint.supportsCondition);
        this.breakpointItemType.set('exceptionBreakpoint');
        this.breakpointHasMultipleModes.set(this.debugService.getModel().getBreakpointModes('exception').length > 1);
        createAndFillInActionBarActions(this.menu, { arg: exceptionBreakpoint, shouldForwardArgs: true }, { primary, secondary: [] }, 'inline');
        data.actionBar.clear();
        data.actionBar.push(primary, { icon: true, label: false });
        breakpointIdToActionBarDomeNode.set(exceptionBreakpoint.getId(), data.actionBar.domNode);
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
}
let FunctionBreakpointsRenderer = class FunctionBreakpointsRenderer {
    static { FunctionBreakpointsRenderer_1 = this; }
    constructor(menu, breakpointSupportsCondition, breakpointItemType, debugService, hoverService, labelService) {
        this.menu = menu;
        this.breakpointSupportsCondition = breakpointSupportsCondition;
        this.breakpointItemType = breakpointItemType;
        this.debugService = debugService;
        this.hoverService = hoverService;
        this.labelService = labelService;
    }
    static { this.ID = 'functionbreakpoints'; }
    get templateId() {
        return FunctionBreakpointsRenderer_1.ID;
    }
    renderTemplate(container) {
        const data = Object.create(null);
        data.toDispose = [];
        data.breakpoint = append(container, $('.breakpoint'));
        data.icon = $('.icon');
        data.checkbox = createCheckbox(data.toDispose);
        data.toDispose.push(addStandardDisposableListener(data.checkbox, 'change', (e) => {
            this.debugService.enableOrDisableBreakpoints(!data.context.enabled, data.context);
        }));
        append(data.breakpoint, data.icon);
        append(data.breakpoint, data.checkbox);
        data.name = append(data.breakpoint, $('span.name'));
        data.condition = append(data.breakpoint, $('span.condition'));
        data.actionBar = ( (new ActionBar(data.breakpoint)));
        data.toDispose.push(data.actionBar);
        const badgeContainer = append(data.breakpoint, $('.badge-container'));
        data.badge = append(badgeContainer, $('span.line-number.monaco-count-badge'));
        return data;
    }
    renderElement(functionBreakpoint, _index, data) {
        data.context = functionBreakpoint;
        data.name.textContent = functionBreakpoint.name;
        const { icon, message } = getBreakpointMessageAndIcon(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), functionBreakpoint, this.labelService, this.debugService.getModel());
        data.icon.className = ThemeIcon.asClassName(icon);
        data.toDispose.push(this.hoverService.setupUpdatableHover(getDefaultHoverDelegate('mouse'), data.icon, message ? message : ''));
        data.checkbox.checked = functionBreakpoint.enabled;
        data.toDispose.push(this.hoverService.setupUpdatableHover(getDefaultHoverDelegate('mouse'), data.breakpoint, message ? message : ''));
        if (functionBreakpoint.condition && functionBreakpoint.hitCondition) {
            data.condition.textContent = ( localizeWithPath(
                _moduleId,
                2,
                "Condition: {0} | Hit Count: {1}",
                functionBreakpoint.condition,
                functionBreakpoint.hitCondition
            ));
        }
        else {
            data.condition.textContent = functionBreakpoint.condition || functionBreakpoint.hitCondition || '';
        }
        if (functionBreakpoint.modeLabel) {
            data.badge.textContent = functionBreakpoint.modeLabel;
            data.badge.style.display = 'block';
        }
        else {
            data.badge.style.display = 'none';
        }
        const session = this.debugService.getViewModel().focusedSession;
        data.breakpoint.classList.toggle('disabled', (session && !session.capabilities.supportsFunctionBreakpoints) || !this.debugService.getModel().areBreakpointsActivated());
        if (session && !session.capabilities.supportsFunctionBreakpoints) {
            data.toDispose.push(this.hoverService.setupUpdatableHover(getDefaultHoverDelegate('mouse'), data.breakpoint, ( localizeWithPath(_moduleId, 3, "Function breakpoints are not supported by this debug type"))));
        }
        const primary = [];
        this.breakpointSupportsCondition.set(!session || !!session.capabilities.supportsConditionalBreakpoints);
        this.breakpointItemType.set('functionBreakpoint');
        createAndFillInActionBarActions(this.menu, { arg: functionBreakpoint, shouldForwardArgs: true }, { primary, secondary: [] }, 'inline');
        data.actionBar.clear();
        data.actionBar.push(primary, { icon: true, label: false });
        breakpointIdToActionBarDomeNode.set(functionBreakpoint.getId(), data.actionBar.domNode);
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
};
FunctionBreakpointsRenderer = FunctionBreakpointsRenderer_1 = ( (__decorate([
    ( (__param(3, IDebugService))),
    ( (__param(4, IHoverService))),
    ( (__param(5, ILabelService)))
], FunctionBreakpointsRenderer)));
let DataBreakpointsRenderer = class DataBreakpointsRenderer {
    static { DataBreakpointsRenderer_1 = this; }
    constructor(menu, breakpointHasMultipleModes, breakpointSupportsCondition, breakpointItemType, breakpointIsDataBytes, debugService, hoverService, labelService) {
        this.menu = menu;
        this.breakpointHasMultipleModes = breakpointHasMultipleModes;
        this.breakpointSupportsCondition = breakpointSupportsCondition;
        this.breakpointItemType = breakpointItemType;
        this.breakpointIsDataBytes = breakpointIsDataBytes;
        this.debugService = debugService;
        this.hoverService = hoverService;
        this.labelService = labelService;
    }
    static { this.ID = 'databreakpoints'; }
    get templateId() {
        return DataBreakpointsRenderer_1.ID;
    }
    renderTemplate(container) {
        const data = Object.create(null);
        data.breakpoint = append(container, $('.breakpoint'));
        data.toDispose = [];
        data.icon = $('.icon');
        data.checkbox = createCheckbox(data.toDispose);
        data.toDispose.push(addStandardDisposableListener(data.checkbox, 'change', (e) => {
            this.debugService.enableOrDisableBreakpoints(!data.context.enabled, data.context);
        }));
        append(data.breakpoint, data.icon);
        append(data.breakpoint, data.checkbox);
        data.name = append(data.breakpoint, $('span.name'));
        data.accessType = append(data.breakpoint, $('span.access-type'));
        data.condition = append(data.breakpoint, $('span.condition'));
        data.actionBar = ( (new ActionBar(data.breakpoint)));
        data.toDispose.push(data.actionBar);
        const badgeContainer = append(data.breakpoint, $('.badge-container'));
        data.badge = append(badgeContainer, $('span.line-number.monaco-count-badge'));
        return data;
    }
    renderElement(dataBreakpoint, _index, data) {
        data.context = dataBreakpoint;
        data.name.textContent = dataBreakpoint.description;
        const { icon, message } = getBreakpointMessageAndIcon(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), dataBreakpoint, this.labelService, this.debugService.getModel());
        data.icon.className = ThemeIcon.asClassName(icon);
        data.toDispose.push(this.hoverService.setupUpdatableHover(getDefaultHoverDelegate('mouse'), data.icon, message ? message : ''));
        data.checkbox.checked = dataBreakpoint.enabled;
        data.toDispose.push(this.hoverService.setupUpdatableHover(getDefaultHoverDelegate('mouse'), data.breakpoint, message ? message : ''));
        if (dataBreakpoint.modeLabel) {
            data.badge.textContent = dataBreakpoint.modeLabel;
            data.badge.style.display = 'block';
        }
        else {
            data.badge.style.display = 'none';
        }
        const session = this.debugService.getViewModel().focusedSession;
        data.breakpoint.classList.toggle('disabled', (session && !session.capabilities.supportsDataBreakpoints) || !this.debugService.getModel().areBreakpointsActivated());
        if (session && !session.capabilities.supportsDataBreakpoints) {
            data.toDispose.push(this.hoverService.setupUpdatableHover(getDefaultHoverDelegate('mouse'), data.breakpoint, ( localizeWithPath(_moduleId, 4, "Data breakpoints are not supported by this debug type"))));
        }
        if (dataBreakpoint.accessType) {
            const accessType = dataBreakpoint.accessType === 'read' ? ( localizeWithPath(_moduleId, 5, "Read")) : dataBreakpoint.accessType === 'write' ? ( localizeWithPath(_moduleId, 6, "Write")) : ( localizeWithPath(_moduleId, 7, "Access"));
            data.accessType.textContent = accessType;
        }
        else {
            data.accessType.textContent = '';
        }
        if (dataBreakpoint.condition && dataBreakpoint.hitCondition) {
            data.condition.textContent = ( localizeWithPath(
                _moduleId,
                2,
                "Condition: {0} | Hit Count: {1}",
                dataBreakpoint.condition,
                dataBreakpoint.hitCondition
            ));
        }
        else {
            data.condition.textContent = dataBreakpoint.condition || dataBreakpoint.hitCondition || '';
        }
        const primary = [];
        this.breakpointSupportsCondition.set(!session || !!session.capabilities.supportsConditionalBreakpoints);
        this.breakpointHasMultipleModes.set(this.debugService.getModel().getBreakpointModes('data').length > 1);
        this.breakpointItemType.set('dataBreakpoint');
        this.breakpointIsDataBytes.set(dataBreakpoint.src.type === 1 );
        createAndFillInActionBarActions(this.menu, { arg: dataBreakpoint, shouldForwardArgs: true }, { primary, secondary: [] }, 'inline');
        data.actionBar.clear();
        data.actionBar.push(primary, { icon: true, label: false });
        breakpointIdToActionBarDomeNode.set(dataBreakpoint.getId(), data.actionBar.domNode);
        this.breakpointIsDataBytes.reset();
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
};
DataBreakpointsRenderer = DataBreakpointsRenderer_1 = ( (__decorate([
    ( (__param(5, IDebugService))),
    ( (__param(6, IHoverService))),
    ( (__param(7, ILabelService)))
], DataBreakpointsRenderer)));
let InstructionBreakpointsRenderer = class InstructionBreakpointsRenderer {
    static { InstructionBreakpointsRenderer_1 = this; }
    constructor(debugService, hoverService, labelService) {
        this.debugService = debugService;
        this.hoverService = hoverService;
        this.labelService = labelService;
    }
    static { this.ID = 'instructionBreakpoints'; }
    get templateId() {
        return InstructionBreakpointsRenderer_1.ID;
    }
    renderTemplate(container) {
        const data = Object.create(null);
        data.toDispose = [];
        data.breakpoint = append(container, $('.breakpoint'));
        data.icon = $('.icon');
        data.checkbox = createCheckbox(data.toDispose);
        data.toDispose.push(addStandardDisposableListener(data.checkbox, 'change', (e) => {
            this.debugService.enableOrDisableBreakpoints(!data.context.enabled, data.context);
        }));
        append(data.breakpoint, data.icon);
        append(data.breakpoint, data.checkbox);
        data.name = append(data.breakpoint, $('span.name'));
        data.address = append(data.breakpoint, $('span.file-path'));
        data.actionBar = ( (new ActionBar(data.breakpoint)));
        data.toDispose.push(data.actionBar);
        const badgeContainer = append(data.breakpoint, $('.badge-container'));
        data.badge = append(badgeContainer, $('span.line-number.monaco-count-badge'));
        return data;
    }
    renderElement(breakpoint, index, data) {
        data.context = breakpoint;
        data.breakpoint.classList.toggle('disabled', !this.debugService.getModel().areBreakpointsActivated());
        data.name.textContent = '0x' + ( (breakpoint.address.toString(16)));
        data.toDispose.push(this.hoverService.setupUpdatableHover(getDefaultHoverDelegate('mouse'), data.name, `Decimal address: breakpoint.address.toString()`));
        data.checkbox.checked = breakpoint.enabled;
        const { message, icon } = getBreakpointMessageAndIcon(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), breakpoint, this.labelService, this.debugService.getModel());
        data.icon.className = ThemeIcon.asClassName(icon);
        data.toDispose.push(this.hoverService.setupUpdatableHover(getDefaultHoverDelegate('mouse'), data.breakpoint, breakpoint.message || message || ''));
        const debugActive = this.debugService.state === 3  || this.debugService.state === 2 ;
        if (debugActive && !breakpoint.verified) {
            data.breakpoint.classList.add('disabled');
        }
        if (breakpoint.modeLabel) {
            data.badge.textContent = breakpoint.modeLabel;
            data.badge.style.display = 'block';
        }
        else {
            data.badge.style.display = 'none';
        }
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
};
InstructionBreakpointsRenderer = InstructionBreakpointsRenderer_1 = ( (__decorate([
    ( (__param(0, IDebugService))),
    ( (__param(1, IHoverService))),
    ( (__param(2, ILabelService)))
], InstructionBreakpointsRenderer)));
class FunctionBreakpointInputRenderer {
    constructor(view, debugService, contextViewService, hoverService, labelService) {
        this.view = view;
        this.debugService = debugService;
        this.contextViewService = contextViewService;
        this.hoverService = hoverService;
        this.labelService = labelService;
    }
    static { this.ID = 'functionbreakpointinput'; }
    get templateId() {
        return FunctionBreakpointInputRenderer.ID;
    }
    renderTemplate(container) {
        const template = Object.create(null);
        const toDispose = [];
        const breakpoint = append(container, $('.breakpoint'));
        template.icon = $('.icon');
        template.checkbox = createCheckbox(toDispose);
        append(breakpoint, template.icon);
        append(breakpoint, template.checkbox);
        this.view.breakpointInputFocused.set(true);
        const inputBoxContainer = append(breakpoint, $('.inputBoxContainer'));
        const inputBox = ( (new InputBox(
            inputBoxContainer,
            this.contextViewService,
            { inputBoxStyles: defaultInputBoxStyles }
        )));
        const wrapUp = (success) => {
            template.updating = true;
            try {
                this.view.breakpointInputFocused.set(false);
                const id = template.breakpoint.getId();
                if (success) {
                    if (template.type === 'name') {
                        this.debugService.updateFunctionBreakpoint(id, { name: inputBox.value });
                    }
                    if (template.type === 'condition') {
                        this.debugService.updateFunctionBreakpoint(id, { condition: inputBox.value });
                    }
                    if (template.type === 'hitCount') {
                        this.debugService.updateFunctionBreakpoint(id, { hitCondition: inputBox.value });
                    }
                }
                else {
                    if (template.type === 'name' && !template.breakpoint.name) {
                        this.debugService.removeFunctionBreakpoints(id);
                    }
                    else {
                        this.view.renderInputBox(undefined);
                    }
                }
            }
            finally {
                template.updating = false;
            }
        };
        toDispose.push(addStandardDisposableListener(inputBox.inputElement, 'keydown', (e) => {
            const isEscape = e.equals(9 );
            const isEnter = e.equals(3 );
            if (isEscape || isEnter) {
                e.preventDefault();
                e.stopPropagation();
                wrapUp(isEnter);
            }
        }));
        toDispose.push(addDisposableListener(inputBox.inputElement, 'blur', () => {
            if (!template.updating) {
                wrapUp(!!inputBox.value);
            }
        }));
        template.inputBox = inputBox;
        template.toDispose = toDispose;
        return template;
    }
    renderElement(functionBreakpoint, _index, data) {
        data.breakpoint = functionBreakpoint;
        data.type = this.view.inputBoxData?.type || 'name';
        const { icon, message } = getBreakpointMessageAndIcon(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), functionBreakpoint, this.labelService, this.debugService.getModel());
        data.icon.className = ThemeIcon.asClassName(icon);
        data.toDispose.push(this.hoverService.setupUpdatableHover(getDefaultHoverDelegate('mouse'), data.icon, message ? message : ''));
        data.checkbox.checked = functionBreakpoint.enabled;
        data.checkbox.disabled = true;
        data.inputBox.value = functionBreakpoint.name || '';
        let placeholder = ( localizeWithPath(_moduleId, 8, "Function to break on"));
        let ariaLabel = ( localizeWithPath(_moduleId, 9, "Type function breakpoint."));
        if (data.type === 'condition') {
            data.inputBox.value = functionBreakpoint.condition || '';
            placeholder = ( localizeWithPath(_moduleId, 10, "Break when expression evaluates to true"));
            ariaLabel = ( localizeWithPath(
                _moduleId,
                11,
                "Type expression. Function breakpoint will break when expression evaluates to true"
            ));
        }
        else if (data.type === 'hitCount') {
            data.inputBox.value = functionBreakpoint.hitCondition || '';
            placeholder = ( localizeWithPath(_moduleId, 12, "Break when hit count is met"));
            ariaLabel = ( localizeWithPath(
                _moduleId,
                13,
                "Type hit count. Function breakpoint will break when hit count is met."
            ));
        }
        data.inputBox.setAriaLabel(ariaLabel);
        data.inputBox.setPlaceHolder(placeholder);
        setTimeout(() => {
            data.inputBox.focus();
            data.inputBox.select();
        }, 0);
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
}
class DataBreakpointInputRenderer {
    constructor(view, debugService, contextViewService, hoverService, labelService) {
        this.view = view;
        this.debugService = debugService;
        this.contextViewService = contextViewService;
        this.hoverService = hoverService;
        this.labelService = labelService;
    }
    static { this.ID = 'databreakpointinput'; }
    get templateId() {
        return DataBreakpointInputRenderer.ID;
    }
    renderTemplate(container) {
        const template = Object.create(null);
        const toDispose = [];
        const breakpoint = append(container, $('.breakpoint'));
        template.icon = $('.icon');
        template.checkbox = createCheckbox(toDispose);
        append(breakpoint, template.icon);
        append(breakpoint, template.checkbox);
        this.view.breakpointInputFocused.set(true);
        const inputBoxContainer = append(breakpoint, $('.inputBoxContainer'));
        const inputBox = ( (new InputBox(
            inputBoxContainer,
            this.contextViewService,
            { inputBoxStyles: defaultInputBoxStyles }
        )));
        const wrapUp = (success) => {
            template.updating = true;
            try {
                this.view.breakpointInputFocused.set(false);
                const id = template.breakpoint.getId();
                if (success) {
                    if (template.type === 'condition') {
                        this.debugService.updateDataBreakpoint(id, { condition: inputBox.value });
                    }
                    if (template.type === 'hitCount') {
                        this.debugService.updateDataBreakpoint(id, { hitCondition: inputBox.value });
                    }
                }
                else {
                    this.view.renderInputBox(undefined);
                }
            }
            finally {
                template.updating = false;
            }
        };
        toDispose.push(addStandardDisposableListener(inputBox.inputElement, 'keydown', (e) => {
            const isEscape = e.equals(9 );
            const isEnter = e.equals(3 );
            if (isEscape || isEnter) {
                e.preventDefault();
                e.stopPropagation();
                wrapUp(isEnter);
            }
        }));
        toDispose.push(addDisposableListener(inputBox.inputElement, 'blur', () => {
            if (!template.updating) {
                wrapUp(!!inputBox.value);
            }
        }));
        template.inputBox = inputBox;
        template.toDispose = toDispose;
        return template;
    }
    renderElement(dataBreakpoint, _index, data) {
        data.breakpoint = dataBreakpoint;
        data.type = this.view.inputBoxData?.type || 'condition';
        const { icon, message } = getBreakpointMessageAndIcon(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), dataBreakpoint, this.labelService, this.debugService.getModel());
        data.icon.className = ThemeIcon.asClassName(icon);
        data.toDispose.push(this.hoverService.setupUpdatableHover(getDefaultHoverDelegate('mouse'), data.icon, message ?? ''));
        data.checkbox.checked = dataBreakpoint.enabled;
        data.checkbox.disabled = true;
        data.inputBox.value = '';
        let placeholder = '';
        let ariaLabel = '';
        if (data.type === 'condition') {
            data.inputBox.value = dataBreakpoint.condition || '';
            placeholder = ( localizeWithPath(_moduleId, 14, "Break when expression evaluates to true"));
            ariaLabel = ( localizeWithPath(
                _moduleId,
                15,
                "Type expression. Data breakpoint will break when expression evaluates to true"
            ));
        }
        else if (data.type === 'hitCount') {
            data.inputBox.value = dataBreakpoint.hitCondition || '';
            placeholder = ( localizeWithPath(_moduleId, 16, "Break when hit count is met"));
            ariaLabel = ( localizeWithPath(
                _moduleId,
                17,
                "Type hit count. Data breakpoint will break when hit count is met."
            ));
        }
        data.inputBox.setAriaLabel(ariaLabel);
        data.inputBox.setPlaceHolder(placeholder);
        setTimeout(() => {
            data.inputBox.focus();
            data.inputBox.select();
        }, 0);
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
}
class ExceptionBreakpointInputRenderer {
    constructor(view, debugService, contextViewService) {
        this.view = view;
        this.debugService = debugService;
        this.contextViewService = contextViewService;
    }
    static { this.ID = 'exceptionbreakpointinput'; }
    get templateId() {
        return ExceptionBreakpointInputRenderer.ID;
    }
    renderTemplate(container) {
        const template = Object.create(null);
        const toDispose = [];
        const breakpoint = append(container, $('.breakpoint'));
        breakpoint.classList.add('exception');
        template.checkbox = createCheckbox(toDispose);
        append(breakpoint, template.checkbox);
        this.view.breakpointInputFocused.set(true);
        const inputBoxContainer = append(breakpoint, $('.inputBoxContainer'));
        const inputBox = ( (new InputBox(inputBoxContainer, this.contextViewService, {
            ariaLabel: ( localizeWithPath(_moduleId, 18, "Type exception breakpoint condition")),
            inputBoxStyles: defaultInputBoxStyles
        })));
        const wrapUp = (success) => {
            this.view.breakpointInputFocused.set(false);
            let newCondition = template.breakpoint.condition;
            if (success) {
                newCondition = inputBox.value !== '' ? inputBox.value : undefined;
            }
            this.debugService.setExceptionBreakpointCondition(template.breakpoint, newCondition);
        };
        toDispose.push(addStandardDisposableListener(inputBox.inputElement, 'keydown', (e) => {
            const isEscape = e.equals(9 );
            const isEnter = e.equals(3 );
            if (isEscape || isEnter) {
                e.preventDefault();
                e.stopPropagation();
                wrapUp(isEnter);
            }
        }));
        toDispose.push(addDisposableListener(inputBox.inputElement, 'blur', () => {
            setTimeout(() => {
                wrapUp(true);
            });
        }));
        template.inputBox = inputBox;
        template.toDispose = toDispose;
        return template;
    }
    renderElement(exceptionBreakpoint, _index, data) {
        const placeHolder = exceptionBreakpoint.conditionDescription || ( localizeWithPath(_moduleId, 19, "Break when expression evaluates to true"));
        data.inputBox.setPlaceHolder(placeHolder);
        data.breakpoint = exceptionBreakpoint;
        data.checkbox.checked = exceptionBreakpoint.enabled;
        data.checkbox.disabled = true;
        data.inputBox.value = exceptionBreakpoint.condition || '';
        setTimeout(() => {
            data.inputBox.focus();
            data.inputBox.select();
        }, 0);
    }
    disposeTemplate(templateData) {
        dispose(templateData.toDispose);
    }
}
class BreakpointsAccessibilityProvider {
    constructor(debugService, labelService) {
        this.debugService = debugService;
        this.labelService = labelService;
    }
    getWidgetAriaLabel() {
        return ( localizeWithPath(_moduleId, 20, "Breakpoints"));
    }
    getRole() {
        return 'checkbox';
    }
    isChecked(breakpoint) {
        return breakpoint.enabled;
    }
    getAriaLabel(element) {
        if (element instanceof ExceptionBreakpoint) {
            return (
                 (element.toString())
            );
        }
        const { message } = getBreakpointMessageAndIcon(this.debugService.state, this.debugService.getModel().areBreakpointsActivated(), element, this.labelService, this.debugService.getModel());
        const toString = ( (element.toString()));
        return message ? `${toString}, ${message}` : toString;
    }
}
function openBreakpointSource(breakpoint, sideBySide, preserveFocus, pinned, debugService, editorService) {
    if (breakpoint.uri.scheme === DEBUG_SCHEME && debugService.state === 0 ) {
        return Promise.resolve(undefined);
    }
    const selection = breakpoint.endLineNumber ? {
        startLineNumber: breakpoint.lineNumber,
        endLineNumber: breakpoint.endLineNumber,
        startColumn: breakpoint.column || 1,
        endColumn: breakpoint.endColumn || 1073741824
    } : {
        startLineNumber: breakpoint.lineNumber,
        startColumn: breakpoint.column || 1,
        endLineNumber: breakpoint.lineNumber,
        endColumn: breakpoint.column || 1073741824
    };
    return editorService.openEditor({
        resource: breakpoint.uri,
        options: {
            preserveFocus,
            selection,
            revealIfOpened: true,
            selectionRevealType: 1 ,
            pinned
        }
    }, sideBySide ? SIDE_GROUP : ACTIVE_GROUP);
}
function getBreakpointMessageAndIcon(state, breakpointsActivated, breakpoint$1, labelService, debugModel) {
    const debugActive = state === 3  || state === 2 ;
    const breakpointIcon = breakpoint$1 instanceof DataBreakpoint ? dataBreakpoint : breakpoint$1 instanceof FunctionBreakpoint ? functionBreakpoint : breakpoint$1.logMessage ? logBreakpoint : breakpoint;
    if (!breakpoint$1.enabled || !breakpointsActivated) {
        return {
            icon: breakpointIcon.disabled,
            message: breakpoint$1.logMessage ? ( localizeWithPath(_moduleId, 21, "Disabled Logpoint")) : ( localizeWithPath(_moduleId, 22, "Disabled Breakpoint")),
        };
    }
    const appendMessage = (text) => {
        return ('message' in breakpoint$1 && breakpoint$1.message) ? text.concat(', ' + breakpoint$1.message) : text;
    };
    if (debugActive && breakpoint$1 instanceof Breakpoint && breakpoint$1.pending) {
        return {
            icon: breakpoint.pending
        };
    }
    if (debugActive && !breakpoint$1.verified) {
        return {
            icon: breakpointIcon.unverified,
            message: ('message' in breakpoint$1 && breakpoint$1.message) ? breakpoint$1.message : (breakpoint$1.logMessage ? ( localizeWithPath(_moduleId, 23, "Unverified Logpoint")) : ( localizeWithPath(_moduleId, 24, "Unverified Breakpoint"))),
            showAdapterUnverifiedMessage: true
        };
    }
    if (breakpoint$1 instanceof DataBreakpoint) {
        if (!breakpoint$1.supported) {
            return {
                icon: breakpointIcon.unverified,
                message: ( localizeWithPath(_moduleId, 25, "Data breakpoints not supported by this debug type")),
            };
        }
        return {
            icon: breakpointIcon.regular,
            message: breakpoint$1.message || ( localizeWithPath(_moduleId, 26, "Data Breakpoint"))
        };
    }
    if (breakpoint$1 instanceof FunctionBreakpoint) {
        if (!breakpoint$1.supported) {
            return {
                icon: breakpointIcon.unverified,
                message: ( localizeWithPath(_moduleId, 27, "Function breakpoints not supported by this debug type")),
            };
        }
        const messages = [];
        messages.push(breakpoint$1.message || ( localizeWithPath(_moduleId, 28, "Function Breakpoint")));
        if (breakpoint$1.condition) {
            messages.push(( localizeWithPath(_moduleId, 29, "Condition: {0}", breakpoint$1.condition)));
        }
        if (breakpoint$1.hitCondition) {
            messages.push(( localizeWithPath(_moduleId, 30, "Hit Count: {0}", breakpoint$1.hitCondition)));
        }
        return {
            icon: breakpointIcon.regular,
            message: appendMessage(messages.join('\n'))
        };
    }
    if (breakpoint$1 instanceof InstructionBreakpoint) {
        if (!breakpoint$1.supported) {
            return {
                icon: breakpointIcon.unverified,
                message: ( localizeWithPath(_moduleId, 31, "Instruction breakpoints not supported by this debug type")),
            };
        }
        const messages = [];
        if (breakpoint$1.message) {
            messages.push(breakpoint$1.message);
        }
        else if (breakpoint$1.instructionReference) {
            messages.push(( localizeWithPath(
                _moduleId,
                32,
                "Instruction breakpoint at address {0}",
                breakpoint$1.instructionReference
            )));
        }
        else {
            messages.push(( localizeWithPath(_moduleId, 33, "Instruction breakpoint")));
        }
        if (breakpoint$1.hitCondition) {
            messages.push(( localizeWithPath(_moduleId, 30, "Hit Count: {0}", breakpoint$1.hitCondition)));
        }
        return {
            icon: breakpointIcon.regular,
            message: appendMessage(messages.join('\n'))
        };
    }
    let triggeringBreakpoint;
    if (breakpoint$1 instanceof Breakpoint && breakpoint$1.triggeredBy) {
        triggeringBreakpoint = debugModel.getBreakpoints().find(bp => bp.getId() === breakpoint$1.triggeredBy);
    }
    if (breakpoint$1.logMessage || breakpoint$1.condition || breakpoint$1.hitCondition || triggeringBreakpoint) {
        const messages = [];
        let icon = breakpoint$1.logMessage ? logBreakpoint.regular : conditionalBreakpoint.regular;
        if (!breakpoint$1.supported) {
            icon = debugBreakpointUnsupported;
            messages.push(( localizeWithPath(
                _moduleId,
                34,
                "Breakpoints of this type are not supported by the debugger"
            )));
        }
        if (breakpoint$1.logMessage) {
            messages.push(( localizeWithPath(_moduleId, 35, "Log Message: {0}", breakpoint$1.logMessage)));
        }
        if (breakpoint$1.condition) {
            messages.push(( localizeWithPath(_moduleId, 29, "Condition: {0}", breakpoint$1.condition)));
        }
        if (breakpoint$1.hitCondition) {
            messages.push(( localizeWithPath(_moduleId, 30, "Hit Count: {0}", breakpoint$1.hitCondition)));
        }
        if (triggeringBreakpoint) {
            messages.push(( localizeWithPath(
                _moduleId,
                36,
                "Hit after breakpoint: {0}",
                `${labelService.getUriLabel(triggeringBreakpoint.uri, { relative: true })}: ${triggeringBreakpoint.lineNumber}`
            )));
        }
        return {
            icon,
            message: appendMessage(messages.join('\n'))
        };
    }
    const message = ('message' in breakpoint$1 && breakpoint$1.message) ? breakpoint$1.message : breakpoint$1 instanceof Breakpoint && labelService ? labelService.getUriLabel(breakpoint$1.uri) : ( localizeWithPath(_moduleId, 37, "Breakpoint"));
    return {
        icon: breakpointIcon.regular,
        message
    };
}
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.addFunctionBreakpointAction',
            title: {
                ...( localize2WithPath(_moduleId, 38, "Add Function Breakpoint")),
                mnemonicTitle: ( localizeWithPath(_moduleId, 39, "&&Function Breakpoint...")),
            },
            f1: true,
            icon: watchExpressionsAddFuncBreakpoint,
            menu: [{
                    id: MenuId.ViewTitle,
                    group: 'navigation',
                    order: 10,
                    when: ( (ContextKeyExpr.equals('view', BREAKPOINTS_VIEW_ID)))
                }, {
                    id: MenuId.MenubarNewBreakpointMenu,
                    group: '1_breakpoints',
                    order: 3,
                    when: CONTEXT_DEBUGGERS_AVAILABLE
                }]
        });
    }
    run(accessor) {
        const debugService = accessor.get(IDebugService);
        debugService.addFunctionBreakpoint();
    }
});
class MemoryBreakpointAction extends Action2 {
    async run(accessor, existingBreakpoint) {
        const debugService = accessor.get(IDebugService);
        const session = debugService.getViewModel().focusedSession;
        if (!session) {
            return;
        }
        let defaultValue = undefined;
        if (existingBreakpoint && existingBreakpoint.src.type === 1 ) {
            defaultValue = `${existingBreakpoint.src.address} + ${existingBreakpoint.src.bytes}`;
        }
        const quickInput = accessor.get(IQuickInputService);
        const notifications = accessor.get(INotificationService);
        const range = await this.getRange(quickInput, defaultValue);
        if (!range) {
            return;
        }
        let info;
        try {
            info = await session.dataBytesBreakpointInfo(range.address, range.bytes);
        }
        catch (e) {
            notifications.error(( localizeWithPath(
                _moduleId,
                40,
                "Failed to set data breakpoint at {0}: {1}",
                range.address,
                e.message
            )));
        }
        if (!info?.dataId) {
            return;
        }
        let accessType = 'write';
        if (info.accessTypes && info.accessTypes?.length > 1) {
            const accessTypes = ( (info.accessTypes.map(type => ({ label: type }))));
            const selectedAccessType = await quickInput.pick(accessTypes, { placeHolder: ( localizeWithPath(_moduleId, 41, "Select the access type to monitor")) });
            if (!selectedAccessType) {
                return;
            }
            accessType = selectedAccessType.label;
        }
        const src = { type: 1 , ...range };
        if (existingBreakpoint) {
            await debugService.removeDataBreakpoints(existingBreakpoint.getId());
        }
        await debugService.addDataBreakpoint({
            description: info.description,
            src,
            canPersist: true,
            accessTypes: info.accessTypes,
            accessType: accessType,
            initialSessionData: { session, dataId: info.dataId }
        });
    }
    getRange(quickInput, defaultValue) {
        return (
             (new Promise(resolve => {
                const input = quickInput.createInputBox();
                input.prompt = ( localizeWithPath(_moduleId, 42, "Enter a memory range in which to break"));
                input.placeholder = ( localizeWithPath(
                    _moduleId,
                    43,
                    'Absolute range (0x1234 - 0x1300) or range of bytes after an address (0x1234 + 0xff)'
                ));
                if (defaultValue) {
                    input.value = defaultValue;
                    input.valueSelection = [0, defaultValue.length];
                }
                input.onDidChangeValue(e => {
                    const err = this.parseAddress(e, false);
                    input.validationMessage = err?.error;
                });
                input.onDidAccept(() => {
                    const r = this.parseAddress(input.value, true);
                    if ('error' in r) {
                        input.validationMessage = r.error;
                    }
                    else {
                        resolve(r);
                    }
                    input.dispose();
                });
                input.onDidHide(() => {
                    resolve(undefined);
                    input.dispose();
                });
                input.ignoreFocusOut = true;
                input.show();
            }))
        );
    }
    parseAddress(range, isFinal) {
        const parts = /^(\S+)\s*(?:([+-])\s*(\S+))?/.exec(range);
        if (!parts) {
            return { error: ( localizeWithPath(
                _moduleId,
                44,
                'Address should be a range of numbers the form "[Start] - [End]" or "[Start] + [Bytes]"'
            )) };
        }
        const isNum = (e) => isFinal ? /^0x[0-9a-f]*|[0-9]*$/i.test(e) : /^0x[0-9a-f]+|[0-9]+$/i.test(e);
        const [, startStr, sign = '+', endStr = '1'] = parts;
        for (const n of [startStr, endStr]) {
            if (!isNum(n)) {
                return { error: ( localizeWithPath(
                    _moduleId,
                    45,
                    'Number must be a decimal integer or hex value starting with \"0x\", got {0}',
                    n
                )) };
            }
        }
        if (!isFinal) {
            return;
        }
        const start = BigInt(startStr);
        const end = BigInt(endStr);
        const address = `0x${( (start.toString(16)))}`;
        if (sign === '-') {
            return { address, bytes: Number(start - end) };
        }
        return { address, bytes: Number(end) };
    }
}
registerAction2(class extends MemoryBreakpointAction {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.addDataBreakpointOnAddress',
            title: {
                ...( localize2WithPath(_moduleId, 46, "Add Data Breakpoint at Address")),
                mnemonicTitle: ( localizeWithPath(_moduleId, 47, "&&Data Breakpoint...")),
            },
            f1: true,
            icon: watchExpressionsAddDataBreakpoint,
            menu: [{
                    id: MenuId.ViewTitle,
                    group: 'navigation',
                    order: 11,
                    when: ( (ContextKeyExpr.and(
                        CONTEXT_SET_DATA_BREAKPOINT_BYTES_SUPPORTED,
                         (ContextKeyExpr.equals('view', BREAKPOINTS_VIEW_ID))
                    )))
                }, {
                    id: MenuId.MenubarNewBreakpointMenu,
                    group: '1_breakpoints',
                    order: 4,
                    when: CONTEXT_SET_DATA_BREAKPOINT_BYTES_SUPPORTED
                }]
        });
    }
});
registerAction2(class extends MemoryBreakpointAction {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.editDataBreakpointOnAddress',
            title: ( localize2WithPath(_moduleId, 48, "Edit Address...")),
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    when: ( (ContextKeyExpr.and(
                        CONTEXT_SET_DATA_BREAKPOINT_BYTES_SUPPORTED,
                        CONTEXT_BREAKPOINT_ITEM_IS_DATA_BYTES
                    ))),
                    group: 'navigation',
                    order: 15,
                }]
        });
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.toggleBreakpointsActivatedAction',
            title: ( localize2WithPath(_moduleId, 49, 'Toggle Activate Breakpoints')),
            f1: true,
            icon: breakpointsActivate,
            menu: {
                id: MenuId.ViewTitle,
                group: 'navigation',
                order: 20,
                when: ( (ContextKeyExpr.equals('view', BREAKPOINTS_VIEW_ID)))
            }
        });
    }
    run(accessor) {
        const debugService = accessor.get(IDebugService);
        debugService.setBreakpointsActivated(!debugService.getModel().areBreakpointsActivated());
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.removeBreakpoint',
            title: ( localizeWithPath(_moduleId, 50, "Remove Breakpoint")),
            icon: Codicon.removeClose,
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: '3_modification',
                    order: 10,
                    when: ( (CONTEXT_BREAKPOINT_ITEM_TYPE.notEqualsTo('exceptionBreakpoint')))
                }, {
                    id: MenuId.DebugBreakpointsContext,
                    group: 'inline',
                    order: 20,
                    when: ( (CONTEXT_BREAKPOINT_ITEM_TYPE.notEqualsTo('exceptionBreakpoint')))
                }]
        });
    }
    async run(accessor, breakpoint) {
        const debugService = accessor.get(IDebugService);
        if (breakpoint instanceof Breakpoint) {
            await debugService.removeBreakpoints(breakpoint.getId());
        }
        else if (breakpoint instanceof FunctionBreakpoint) {
            await debugService.removeFunctionBreakpoints(breakpoint.getId());
        }
        else if (breakpoint instanceof DataBreakpoint) {
            await debugService.removeDataBreakpoints(breakpoint.getId());
        }
        else if (breakpoint instanceof InstructionBreakpoint) {
            await debugService.removeInstructionBreakpoints(breakpoint.instructionReference);
        }
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.removeAllBreakpoints',
            title: {
                ...( localize2WithPath(_moduleId, 51, "Remove All Breakpoints")),
                mnemonicTitle: ( localizeWithPath(_moduleId, 52, "Remove &&All Breakpoints")),
            },
            f1: true,
            icon: breakpointsRemoveAll,
            menu: [{
                    id: MenuId.ViewTitle,
                    group: 'navigation',
                    order: 30,
                    when: ( (ContextKeyExpr.equals('view', BREAKPOINTS_VIEW_ID)))
                }, {
                    id: MenuId.DebugBreakpointsContext,
                    group: '3_modification',
                    order: 20,
                    when: ( (ContextKeyExpr.and(
                        CONTEXT_BREAKPOINTS_EXIST,
                         (CONTEXT_BREAKPOINT_ITEM_TYPE.notEqualsTo('exceptionBreakpoint'))
                    )))
                }, {
                    id: MenuId.MenubarDebugMenu,
                    group: '5_breakpoints',
                    order: 3,
                    when: CONTEXT_DEBUGGERS_AVAILABLE
                }]
        });
    }
    run(accessor) {
        const debugService = accessor.get(IDebugService);
        debugService.removeBreakpoints();
        debugService.removeFunctionBreakpoints();
        debugService.removeDataBreakpoints();
        debugService.removeInstructionBreakpoints();
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.enableAllBreakpoints',
            title: {
                ...( localize2WithPath(_moduleId, 53, "Enable All Breakpoints")),
                mnemonicTitle: ( localizeWithPath(_moduleId, 54, "&&Enable All Breakpoints")),
            },
            f1: true,
            precondition: CONTEXT_DEBUGGERS_AVAILABLE,
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: 'z_commands',
                    order: 10,
                    when: ( (ContextKeyExpr.and(
                        CONTEXT_BREAKPOINTS_EXIST,
                         (CONTEXT_BREAKPOINT_ITEM_TYPE.notEqualsTo('exceptionBreakpoint'))
                    )))
                }, {
                    id: MenuId.MenubarDebugMenu,
                    group: '5_breakpoints',
                    order: 1,
                    when: CONTEXT_DEBUGGERS_AVAILABLE
                }]
        });
    }
    async run(accessor) {
        const debugService = accessor.get(IDebugService);
        await debugService.enableOrDisableBreakpoints(true);
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.disableAllBreakpoints',
            title: {
                ...( localize2WithPath(_moduleId, 55, "Disable All Breakpoints")),
                mnemonicTitle: ( localizeWithPath(_moduleId, 56, "Disable A&&ll Breakpoints")),
            },
            f1: true,
            precondition: CONTEXT_DEBUGGERS_AVAILABLE,
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: 'z_commands',
                    order: 20,
                    when: ( (ContextKeyExpr.and(
                        CONTEXT_BREAKPOINTS_EXIST,
                         (CONTEXT_BREAKPOINT_ITEM_TYPE.notEqualsTo('exceptionBreakpoint'))
                    )))
                }, {
                    id: MenuId.MenubarDebugMenu,
                    group: '5_breakpoints',
                    order: 2,
                    when: CONTEXT_DEBUGGERS_AVAILABLE
                }]
        });
    }
    async run(accessor) {
        const debugService = accessor.get(IDebugService);
        await debugService.enableOrDisableBreakpoints(false);
    }
});
registerAction2(class extends Action2 {
    constructor() {
        super({
            id: 'workbench.debug.viewlet.action.reapplyBreakpointsAction',
            title: ( localize2WithPath(_moduleId, 57, 'Reapply All Breakpoints')),
            f1: true,
            precondition: CONTEXT_IN_DEBUG_MODE,
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: 'z_commands',
                    order: 30,
                    when: ( (ContextKeyExpr.and(
                        CONTEXT_BREAKPOINTS_EXIST,
                         (CONTEXT_BREAKPOINT_ITEM_TYPE.notEqualsTo('exceptionBreakpoint'))
                    )))
                }]
        });
    }
    async run(accessor) {
        const debugService = accessor.get(IDebugService);
        await debugService.setBreakpointsActivated(true);
    }
});
registerAction2(class extends ViewAction {
    constructor() {
        super({
            id: 'debug.editBreakpoint',
            viewId: BREAKPOINTS_VIEW_ID,
            title: ( localizeWithPath(_moduleId, 58, "Edit Condition...")),
            icon: Codicon.edit,
            precondition: CONTEXT_BREAKPOINT_SUPPORTS_CONDITION,
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    when: ( (CONTEXT_BREAKPOINT_ITEM_TYPE.notEqualsTo('functionBreakpoint'))),
                    group: 'navigation',
                    order: 10
                }, {
                    id: MenuId.DebugBreakpointsContext,
                    group: 'inline',
                    order: 10
                }]
        });
    }
    async runInView(accessor, view, breakpoint) {
        const debugService = accessor.get(IDebugService);
        const editorService = accessor.get(IEditorService);
        if (breakpoint instanceof Breakpoint) {
            const editor = await openBreakpointSource(breakpoint, false, false, true, debugService, editorService);
            if (editor) {
                const codeEditor = editor.getControl();
                if (isCodeEditor(codeEditor)) {
                    codeEditor.getContribution(BREAKPOINT_EDITOR_CONTRIBUTION_ID)?.showBreakpointWidget(breakpoint.lineNumber, breakpoint.column);
                }
            }
        }
        else if (breakpoint instanceof FunctionBreakpoint) {
            const contextMenuService = accessor.get(IContextMenuService);
            const actions = [( (new Action('breakpoint.editCondition', ( localizeWithPath(_moduleId, 58, "Edit Condition...")), undefined, true, async () => view.renderInputBox({ breakpoint, type: 'condition' })))),
                ( (new Action('breakpoint.editCondition', ( localizeWithPath(_moduleId, 59, "Edit Hit Count...")), undefined, true, async () => view.renderInputBox({ breakpoint, type: 'hitCount' }))))];
            const domNode = breakpointIdToActionBarDomeNode.get(breakpoint.getId());
            if (domNode) {
                contextMenuService.showContextMenu({
                    getActions: () => actions,
                    getAnchor: () => domNode,
                    onHide: () => dispose(actions)
                });
            }
        }
        else {
            view.renderInputBox({ breakpoint, type: 'condition' });
        }
    }
});
registerAction2(class extends ViewAction {
    constructor() {
        super({
            id: 'debug.editFunctionBreakpoint',
            viewId: BREAKPOINTS_VIEW_ID,
            title: ( localizeWithPath(_moduleId, 60, "Edit Function Condition...")),
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: 'navigation',
                    order: 10,
                    when: ( (CONTEXT_BREAKPOINT_ITEM_TYPE.isEqualTo('functionBreakpoint')))
                }]
        });
    }
    runInView(_accessor, view, breakpoint) {
        view.renderInputBox({ breakpoint, type: 'name' });
    }
});
registerAction2(class extends ViewAction {
    constructor() {
        super({
            id: 'debug.editFunctionBreakpointHitCount',
            viewId: BREAKPOINTS_VIEW_ID,
            title: ( localizeWithPath(_moduleId, 59, "Edit Hit Count...")),
            precondition: CONTEXT_BREAKPOINT_SUPPORTS_CONDITION,
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: 'navigation',
                    order: 20,
                    when: ( (ContextKeyExpr.or(
                         (CONTEXT_BREAKPOINT_ITEM_TYPE.isEqualTo('functionBreakpoint')),
                         (CONTEXT_BREAKPOINT_ITEM_TYPE.isEqualTo('dataBreakpoint'))
                    )))
                }]
        });
    }
    runInView(_accessor, view, breakpoint) {
        view.renderInputBox({ breakpoint, type: 'hitCount' });
    }
});
registerAction2(class extends ViewAction {
    constructor() {
        super({
            id: 'debug.editBreakpointMode',
            viewId: BREAKPOINTS_VIEW_ID,
            title: ( localizeWithPath(_moduleId, 61, "Edit Mode...")),
            menu: [{
                    id: MenuId.DebugBreakpointsContext,
                    group: 'navigation',
                    order: 20,
                    when: ( (ContextKeyExpr.and(CONTEXT_BREAKPOINT_HAS_MODES,  (ContextKeyExpr.or(
                         (CONTEXT_BREAKPOINT_ITEM_TYPE.isEqualTo('breakpoint')),
                         (CONTEXT_BREAKPOINT_ITEM_TYPE.isEqualTo('exceptionBreakpoint')),
                         (CONTEXT_BREAKPOINT_ITEM_TYPE.isEqualTo('instructionBreakpoint'))
                    )))))
                }]
        });
    }
    async runInView(accessor, view, breakpoint) {
        const kind = breakpoint instanceof Breakpoint ? 'source' : breakpoint instanceof InstructionBreakpoint ? 'instruction' : 'exception';
        const debugService = accessor.get(IDebugService);
        const modes = debugService.getModel().getBreakpointModes(kind);
        const picked = await accessor.get(IQuickInputService).pick(( (modes.map(
            mode => ({ label: mode.label, description: mode.description, mode: mode.mode })
        ))), { placeHolder: ( localizeWithPath(_moduleId, 62, "Select Breakpoint Mode")) });
        if (!picked) {
            return;
        }
        if (kind === 'source') {
            const data = ( (new Map()));
            data.set(breakpoint.getId(), { mode: picked.mode, modeLabel: picked.label });
            debugService.updateBreakpoints(breakpoint.originalUri, data, false);
        }
        else if (breakpoint instanceof InstructionBreakpoint) {
            debugService.removeInstructionBreakpoints(breakpoint.instructionReference, breakpoint.offset);
            debugService.addInstructionBreakpoint({ ...breakpoint.toJSON(), mode: picked.mode, modeLabel: picked.label });
        }
        else if (breakpoint instanceof ExceptionBreakpoint) {
            breakpoint.mode = picked.mode;
            breakpoint.modeLabel = picked.label;
            debugService.setExceptionBreakpointCondition(breakpoint, breakpoint.condition);
        }
    }
});
export { BreakpointsView, getBreakpointMessageAndIcon, getExpandedBodySize, openBreakpointSource };
