import { KeyChord } from '../../../../../../base/common/keyCodes.js';
import { Mimes } from '../../../../../../base/common/mime.js';
import { IBulkEditService, ResourceTextEdit } from '../../../../../../editor/browser/services/bulkEditService.js';
import { localize2WithPath, localizeWithPath } from '../../../../../../nls.js';
import { registerAction2, MenuId } from '../../../../../../platform/actions/common/actions.js';
import { ContextKeyExpr } from '../../../../../../platform/contextkey/common/contextkey.js';
import { InputFocusedContext, InputFocusedContextKey } from '../../../../../../platform/contextkey/common/contextkeys.js';
import { ResourceNotebookCellEdit } from '../../../../bulkEdit/browser/bulkCellEdits.js';
import { moveCellRange, copyCellRange, computeCellLinesContents, joinCellsWithSurrounds, joinSelectedCells, changeCellToKind } from '../../controller/cellOperations.js';
import { NotebookCellAction, CELL_TITLE_CELL_GROUP_ID, NotebookMultiCellAction, parseMultiCellExecutionArgs, cellExecutionArgs, findTargetCellEditor } from '../../controller/coreActions.js';
import { CellFocusMode, EXPAND_CELL_INPUT_COMMAND_ID, EXPAND_CELL_OUTPUT_COMMAND_ID } from '../../notebookBrowser.js';
import { NOTEBOOK_EDITOR_FOCUSED, NOTEBOOK_EDITOR_EDITABLE, NOTEBOOK_CELL_EDITABLE, NOTEBOOK_CELL_INPUT_COLLAPSED, NOTEBOOK_OUTPUT_FOCUSED, NOTEBOOK_IS_ACTIVE_EDITOR, NOTEBOOK_CELL_TYPE, NOTEBOOK_CELL_LIST_FOCUSED, NOTEBOOK_CELL_OUTPUT_COLLAPSED, NOTEBOOK_CELL_HAS_OUTPUTS, NOTEBOOK_CELL_FOCUSED, NOTEBOOK_CELL_HAS_ERROR_DIAGNOSTICS, NOTEBOOK_CELL_EDITOR_FOCUSED } from '../../../common/notebookContextKeys.js';
import { moveUpIcon, moveDownIcon, splitCellIcon } from '../../notebookIcons.js';
import { NotebookSetting, CellKind } from '../../../common/notebookCommon.js';
import { INotificationService } from '../../../../../../platform/notification/common/notification.service.js';
import { EditorContextKeys } from '../../../../../../editor/common/editorContextKeys.js';
import { IConfigurationService } from '../../../../../../platform/configuration/common/configuration.service.js';
import { CodeCellViewModel } from '../../viewModel/codeCellViewModel.js';
import { Range } from '../../../../../../editor/common/core/range.js';
import { CodeActionController } from '../../../../../../editor/contrib/codeAction/browser/codeActionController.js';
import { CodeActionTriggerSource, CodeActionKind } from '../../../../../../editor/contrib/codeAction/common/types.js';
const _moduleId = "vs/workbench/contrib/notebook/browser/contrib/cellCommands/cellCommands";
const MOVE_CELL_UP_COMMAND_ID = 'notebook.cell.moveUp';
const MOVE_CELL_DOWN_COMMAND_ID = 'notebook.cell.moveDown';
const COPY_CELL_UP_COMMAND_ID = 'notebook.cell.copyUp';
const COPY_CELL_DOWN_COMMAND_ID = 'notebook.cell.copyDown';
registerAction2(class extends NotebookCellAction {
    constructor() {
        super({
            id: MOVE_CELL_UP_COMMAND_ID,
            title: ( localize2WithPath(_moduleId, 0, "Move Cell Up")),
            icon: moveUpIcon,
            keybinding: {
                primary: 512  | 16 ,
                when: ( (ContextKeyExpr.and(NOTEBOOK_EDITOR_FOCUSED,  (InputFocusedContext.toNegated())))),
                weight: 200
            },
            menu: {
                id: MenuId.NotebookCellTitle,
                when: ( (ContextKeyExpr.equals('config.notebook.dragAndDropEnabled', false))),
                group: "3_edit" ,
                order: 14
            }
        });
    }
    async runWithContext(accessor, context) {
        return moveCellRange(context, 'up');
    }
});
registerAction2(class extends NotebookCellAction {
    constructor() {
        super({
            id: MOVE_CELL_DOWN_COMMAND_ID,
            title: ( localize2WithPath(_moduleId, 1, "Move Cell Down")),
            icon: moveDownIcon,
            keybinding: {
                primary: 512  | 18 ,
                when: ( (ContextKeyExpr.and(NOTEBOOK_EDITOR_FOCUSED,  (InputFocusedContext.toNegated())))),
                weight: 200
            },
            menu: {
                id: MenuId.NotebookCellTitle,
                when: ( (ContextKeyExpr.equals('config.notebook.dragAndDropEnabled', false))),
                group: "3_edit" ,
                order: 14
            }
        });
    }
    async runWithContext(accessor, context) {
        return moveCellRange(context, 'down');
    }
});
registerAction2(class extends NotebookCellAction {
    constructor() {
        super({
            id: COPY_CELL_UP_COMMAND_ID,
            title: ( localize2WithPath(_moduleId, 2, "Copy Cell Up")),
            keybinding: {
                primary: 512  | 1024  | 16 ,
                when: ( (ContextKeyExpr.and(NOTEBOOK_EDITOR_FOCUSED,  (InputFocusedContext.toNegated())))),
                weight: 200
            }
        });
    }
    async runWithContext(accessor, context) {
        return copyCellRange(context, 'up');
    }
});
registerAction2(class extends NotebookCellAction {
    constructor() {
        super({
            id: COPY_CELL_DOWN_COMMAND_ID,
            title: ( localize2WithPath(_moduleId, 3, "Copy Cell Down")),
            keybinding: {
                primary: 512  | 1024  | 18 ,
                when: ( (ContextKeyExpr.and(NOTEBOOK_EDITOR_FOCUSED,  (InputFocusedContext.toNegated())))),
                weight: 200
            },
            menu: {
                id: MenuId.NotebookCellTitle,
                when: ( (ContextKeyExpr.and(NOTEBOOK_EDITOR_FOCUSED, NOTEBOOK_EDITOR_EDITABLE, NOTEBOOK_CELL_EDITABLE))),
                group: "3_edit" ,
                order: 13
            }
        });
    }
    async runWithContext(accessor, context) {
        return copyCellRange(context, 'down');
    }
});
const SPLIT_CELL_COMMAND_ID = 'notebook.cell.split';
const JOIN_SELECTED_CELLS_COMMAND_ID = 'notebook.cell.joinSelected';
const JOIN_CELL_ABOVE_COMMAND_ID = 'notebook.cell.joinAbove';
const JOIN_CELL_BELOW_COMMAND_ID = 'notebook.cell.joinBelow';
registerAction2(class extends NotebookCellAction {
    constructor() {
        super({
            id: SPLIT_CELL_COMMAND_ID,
            title: ( localize2WithPath(_moduleId, 4, "Split Cell")),
            menu: {
                id: MenuId.NotebookCellTitle,
                when: ( (ContextKeyExpr.and(
                    NOTEBOOK_EDITOR_EDITABLE,
                    NOTEBOOK_CELL_EDITABLE,
                     (NOTEBOOK_CELL_INPUT_COLLAPSED.toNegated())
                ))),
                order: 4 ,
                group: CELL_TITLE_CELL_GROUP_ID
            },
            icon: splitCellIcon,
            keybinding: {
                when: ( (ContextKeyExpr.and(
                    NOTEBOOK_EDITOR_FOCUSED,
                    NOTEBOOK_EDITOR_EDITABLE,
                    NOTEBOOK_CELL_EDITABLE,
                    EditorContextKeys.editorTextFocus
                ))),
                primary: KeyChord(2048  | 41 , 2048  | 1024  | 93 ),
                weight: 200
            },
        });
    }
    async runWithContext(accessor, context) {
        if (context.notebookEditor.isReadOnly) {
            return;
        }
        const bulkEditService = accessor.get(IBulkEditService);
        const cell = context.cell;
        const index = context.notebookEditor.getCellIndex(cell);
        const splitPoints = cell.focusMode === CellFocusMode.Container ? [{ lineNumber: 1, column: 1 }] : cell.getSelectionsStartPosition();
        if (splitPoints && splitPoints.length > 0) {
            await cell.resolveTextModel();
            if (!cell.hasModel()) {
                return;
            }
            const newLinesContents = computeCellLinesContents(cell, splitPoints);
            if (newLinesContents) {
                const language = cell.language;
                const kind = cell.cellKind;
                const mime = cell.mime;
                const textModel = await cell.resolveTextModel();
                await bulkEditService.apply([
                    ( (new ResourceTextEdit(
                    cell.uri,
                    { range: textModel.getFullModelRange(), text: newLinesContents[0] }
                ))),
                    ( (new ResourceNotebookCellEdit(context.notebookEditor.textModel.uri, {
                        editType: 1 ,
                        index: index + 1,
                        count: 0,
                        cells: ( (newLinesContents.slice(1).map(line => ({
                            cellKind: kind,
                            language,
                            mime,
                            source: line,
                            outputs: [],
                            metadata: {}
                        }))))
                    })))
                ], { quotableLabel: 'Split Notebook Cell' });
            }
        }
    }
});
registerAction2(class extends NotebookCellAction {
    constructor() {
        super({
            id: JOIN_CELL_ABOVE_COMMAND_ID,
            title: ( localize2WithPath(_moduleId, 5, "Join With Previous Cell")),
            keybinding: {
                when: NOTEBOOK_EDITOR_FOCUSED,
                primary: 256  | 512  | 1024  | 40 ,
                weight: 200
            },
            menu: {
                id: MenuId.NotebookCellTitle,
                when: ( (ContextKeyExpr.and(NOTEBOOK_EDITOR_FOCUSED, NOTEBOOK_EDITOR_EDITABLE))),
                group: "3_edit" ,
                order: 10
            }
        });
    }
    async runWithContext(accessor, context) {
        const bulkEditService = accessor.get(IBulkEditService);
        return joinCellsWithSurrounds(bulkEditService, context, 'above');
    }
});
registerAction2(class extends NotebookCellAction {
    constructor() {
        super({
            id: JOIN_CELL_BELOW_COMMAND_ID,
            title: ( localize2WithPath(_moduleId, 6, "Join With Next Cell")),
            keybinding: {
                when: NOTEBOOK_EDITOR_FOCUSED,
                primary: 256  | 512  | 40 ,
                weight: 200
            },
            menu: {
                id: MenuId.NotebookCellTitle,
                when: ( (ContextKeyExpr.and(NOTEBOOK_EDITOR_FOCUSED, NOTEBOOK_EDITOR_EDITABLE))),
                group: "3_edit" ,
                order: 11
            }
        });
    }
    async runWithContext(accessor, context) {
        const bulkEditService = accessor.get(IBulkEditService);
        return joinCellsWithSurrounds(bulkEditService, context, 'below');
    }
});
registerAction2(class extends NotebookCellAction {
    constructor() {
        super({
            id: JOIN_SELECTED_CELLS_COMMAND_ID,
            title: ( localize2WithPath(_moduleId, 7, "Join Selected Cells")),
            menu: {
                id: MenuId.NotebookCellTitle,
                when: ( (ContextKeyExpr.and(NOTEBOOK_EDITOR_FOCUSED, NOTEBOOK_EDITOR_EDITABLE))),
                group: "3_edit" ,
                order: 12
            }
        });
    }
    async runWithContext(accessor, context) {
        const bulkEditService = accessor.get(IBulkEditService);
        const notificationService = accessor.get(INotificationService);
        return joinSelectedCells(bulkEditService, notificationService, context);
    }
});
const CHANGE_CELL_TO_CODE_COMMAND_ID = 'notebook.cell.changeToCode';
const CHANGE_CELL_TO_MARKDOWN_COMMAND_ID = 'notebook.cell.changeToMarkdown';
registerAction2(class ChangeCellToCodeAction extends NotebookMultiCellAction {
    constructor() {
        super({
            id: CHANGE_CELL_TO_CODE_COMMAND_ID,
            title: ( localize2WithPath(_moduleId, 8, "Change Cell to Code")),
            keybinding: {
                when: ( (ContextKeyExpr.and(
                    NOTEBOOK_EDITOR_FOCUSED,
                    ContextKeyExpr.not(InputFocusedContextKey),
                     (NOTEBOOK_OUTPUT_FOCUSED.toNegated())
                ))),
                primary: 55 ,
                weight: 200
            },
            precondition: ( (ContextKeyExpr.and(
                NOTEBOOK_IS_ACTIVE_EDITOR,
                 (NOTEBOOK_CELL_TYPE.isEqualTo('markup'))
            ))),
            menu: {
                id: MenuId.NotebookCellTitle,
                when: ( (ContextKeyExpr.and(
                    NOTEBOOK_EDITOR_FOCUSED,
                    NOTEBOOK_EDITOR_EDITABLE,
                    NOTEBOOK_CELL_EDITABLE,
                     (NOTEBOOK_CELL_TYPE.isEqualTo('markup'))
                ))),
                group: "3_edit" ,
            }
        });
    }
    async runWithContext(accessor, context) {
        await changeCellToKind(CellKind.Code, context);
    }
});
registerAction2(class ChangeCellToMarkdownAction extends NotebookMultiCellAction {
    constructor() {
        super({
            id: CHANGE_CELL_TO_MARKDOWN_COMMAND_ID,
            title: ( localize2WithPath(_moduleId, 9, "Change Cell to Markdown")),
            keybinding: {
                when: ( (ContextKeyExpr.and(
                    NOTEBOOK_EDITOR_FOCUSED,
                    ContextKeyExpr.not(InputFocusedContextKey),
                     (NOTEBOOK_OUTPUT_FOCUSED.toNegated())
                ))),
                primary: 43 ,
                weight: 200
            },
            precondition: ( (ContextKeyExpr.and(
                NOTEBOOK_IS_ACTIVE_EDITOR,
                 (NOTEBOOK_CELL_TYPE.isEqualTo('code'))
            ))),
            menu: {
                id: MenuId.NotebookCellTitle,
                when: ( (ContextKeyExpr.and(
                    NOTEBOOK_EDITOR_FOCUSED,
                    NOTEBOOK_EDITOR_EDITABLE,
                    NOTEBOOK_CELL_EDITABLE,
                     (NOTEBOOK_CELL_TYPE.isEqualTo('code'))
                ))),
                group: "3_edit" ,
            }
        });
    }
    async runWithContext(accessor, context) {
        await changeCellToKind(CellKind.Markup, context, 'markdown', Mimes.markdown);
    }
});
const COLLAPSE_CELL_INPUT_COMMAND_ID = 'notebook.cell.collapseCellInput';
const COLLAPSE_CELL_OUTPUT_COMMAND_ID = 'notebook.cell.collapseCellOutput';
const COLLAPSE_ALL_CELL_INPUTS_COMMAND_ID = 'notebook.cell.collapseAllCellInputs';
const EXPAND_ALL_CELL_INPUTS_COMMAND_ID = 'notebook.cell.expandAllCellInputs';
const COLLAPSE_ALL_CELL_OUTPUTS_COMMAND_ID = 'notebook.cell.collapseAllCellOutputs';
const EXPAND_ALL_CELL_OUTPUTS_COMMAND_ID = 'notebook.cell.expandAllCellOutputs';
const TOGGLE_CELL_OUTPUTS_COMMAND_ID = 'notebook.cell.toggleOutputs';
const TOGGLE_CELL_OUTPUT_SCROLLING = 'notebook.cell.toggleOutputScrolling';
const OPEN_CELL_FAILURE_ACTIONS_COMMAND_ID = 'notebook.cell.openFailureActions';
registerAction2(class CollapseCellInputAction extends NotebookMultiCellAction {
    constructor() {
        super({
            id: COLLAPSE_CELL_INPUT_COMMAND_ID,
            title: ( localize2WithPath(_moduleId, 10, "Collapse Cell Input")),
            keybinding: {
                when: ( (ContextKeyExpr.and(
                    NOTEBOOK_CELL_LIST_FOCUSED,
                     (NOTEBOOK_CELL_INPUT_COLLAPSED.toNegated()),
                     (InputFocusedContext.toNegated())
                ))),
                primary: KeyChord(2048  | 41 , 2048  | 33 ),
                weight: 200
            }
        });
    }
    parseArgs(accessor, ...args) {
        return parseMultiCellExecutionArgs(accessor, ...args);
    }
    async runWithContext(accessor, context) {
        if (context.ui) {
            context.cell.isInputCollapsed = true;
        }
        else {
            context.selectedCells.forEach(cell => cell.isInputCollapsed = true);
        }
    }
});
registerAction2(class ExpandCellInputAction extends NotebookMultiCellAction {
    constructor() {
        super({
            id: EXPAND_CELL_INPUT_COMMAND_ID,
            title: ( localize2WithPath(_moduleId, 11, "Expand Cell Input")),
            keybinding: {
                when: ( (ContextKeyExpr.and(NOTEBOOK_CELL_LIST_FOCUSED, NOTEBOOK_CELL_INPUT_COLLAPSED))),
                primary: KeyChord(2048  | 41 , 2048  | 33 ),
                weight: 200
            }
        });
    }
    parseArgs(accessor, ...args) {
        return parseMultiCellExecutionArgs(accessor, ...args);
    }
    async runWithContext(accessor, context) {
        if (context.ui) {
            context.cell.isInputCollapsed = false;
        }
        else {
            context.selectedCells.forEach(cell => cell.isInputCollapsed = false);
        }
    }
});
registerAction2(class CollapseCellOutputAction extends NotebookMultiCellAction {
    constructor() {
        super({
            id: COLLAPSE_CELL_OUTPUT_COMMAND_ID,
            title: ( localize2WithPath(_moduleId, 12, "Collapse Cell Output")),
            keybinding: {
                when: ( (ContextKeyExpr.and(
                    NOTEBOOK_CELL_LIST_FOCUSED,
                     (NOTEBOOK_CELL_OUTPUT_COLLAPSED.toNegated()),
                     (InputFocusedContext.toNegated()),
                    NOTEBOOK_CELL_HAS_OUTPUTS
                ))),
                primary: KeyChord(2048  | 41 , 50 ),
                weight: 200
            }
        });
    }
    async runWithContext(accessor, context) {
        if (context.ui) {
            context.cell.isOutputCollapsed = true;
        }
        else {
            context.selectedCells.forEach(cell => cell.isOutputCollapsed = true);
        }
    }
});
registerAction2(class ExpandCellOuputAction extends NotebookMultiCellAction {
    constructor() {
        super({
            id: EXPAND_CELL_OUTPUT_COMMAND_ID,
            title: ( localize2WithPath(_moduleId, 13, "Expand Cell Output")),
            keybinding: {
                when: ( (ContextKeyExpr.and(NOTEBOOK_CELL_LIST_FOCUSED, NOTEBOOK_CELL_OUTPUT_COLLAPSED))),
                primary: KeyChord(2048  | 41 , 50 ),
                weight: 200
            }
        });
    }
    async runWithContext(accessor, context) {
        if (context.ui) {
            context.cell.isOutputCollapsed = false;
        }
        else {
            context.selectedCells.forEach(cell => cell.isOutputCollapsed = false);
        }
    }
});
registerAction2(class extends NotebookMultiCellAction {
    constructor() {
        super({
            id: TOGGLE_CELL_OUTPUTS_COMMAND_ID,
            precondition: NOTEBOOK_CELL_LIST_FOCUSED,
            title: ( localize2WithPath(_moduleId, 14, "Toggle Outputs")),
            metadata: {
                description: ( localizeWithPath(_moduleId, 14, "Toggle Outputs")),
                args: cellExecutionArgs
            }
        });
    }
    parseArgs(accessor, ...args) {
        return parseMultiCellExecutionArgs(accessor, ...args);
    }
    async runWithContext(accessor, context) {
        let cells = [];
        if (context.ui) {
            cells = [context.cell];
        }
        else if (context.selectedCells) {
            cells = context.selectedCells;
        }
        for (const cell of cells) {
            cell.isOutputCollapsed = !cell.isOutputCollapsed;
        }
    }
});
registerAction2(class CollapseAllCellInputsAction extends NotebookMultiCellAction {
    constructor() {
        super({
            id: COLLAPSE_ALL_CELL_INPUTS_COMMAND_ID,
            title: ( localize2WithPath(_moduleId, 15, "Collapse All Cell Inputs")),
            f1: true,
        });
    }
    async runWithContext(accessor, context) {
        forEachCell(context.notebookEditor, cell => cell.isInputCollapsed = true);
    }
});
registerAction2(class ExpandAllCellInputsAction extends NotebookMultiCellAction {
    constructor() {
        super({
            id: EXPAND_ALL_CELL_INPUTS_COMMAND_ID,
            title: ( localize2WithPath(_moduleId, 16, "Expand All Cell Inputs")),
            f1: true
        });
    }
    async runWithContext(accessor, context) {
        forEachCell(context.notebookEditor, cell => cell.isInputCollapsed = false);
    }
});
registerAction2(class CollapseAllCellOutputsAction extends NotebookMultiCellAction {
    constructor() {
        super({
            id: COLLAPSE_ALL_CELL_OUTPUTS_COMMAND_ID,
            title: ( localize2WithPath(_moduleId, 17, "Collapse All Cell Outputs")),
            f1: true,
        });
    }
    async runWithContext(accessor, context) {
        forEachCell(context.notebookEditor, cell => cell.isOutputCollapsed = true);
    }
});
registerAction2(class ExpandAllCellOutputsAction extends NotebookMultiCellAction {
    constructor() {
        super({
            id: EXPAND_ALL_CELL_OUTPUTS_COMMAND_ID,
            title: ( localize2WithPath(_moduleId, 18, "Expand All Cell Outputs")),
            f1: true
        });
    }
    async runWithContext(accessor, context) {
        forEachCell(context.notebookEditor, cell => cell.isOutputCollapsed = false);
    }
});
registerAction2(class ToggleCellOutputScrolling extends NotebookMultiCellAction {
    constructor() {
        super({
            id: TOGGLE_CELL_OUTPUT_SCROLLING,
            title: ( localize2WithPath(_moduleId, 19, "Toggle Scroll Cell Output")),
            keybinding: {
                when: ( (ContextKeyExpr.and(
                    NOTEBOOK_CELL_LIST_FOCUSED,
                     (InputFocusedContext.toNegated()),
                    NOTEBOOK_CELL_HAS_OUTPUTS
                ))),
                primary: KeyChord(2048  | 41 , 55 ),
                weight: 200
            }
        });
    }
    toggleOutputScrolling(viewModel, globalScrollSetting, collapsed) {
        const cellMetadata = viewModel.model.metadata;
        if (cellMetadata) {
            const currentlyEnabled = cellMetadata['scrollable'] !== undefined ? cellMetadata['scrollable'] : globalScrollSetting;
            const shouldEnableScrolling = collapsed || !currentlyEnabled;
            cellMetadata['scrollable'] = shouldEnableScrolling;
            viewModel.resetRenderer();
        }
    }
    async runWithContext(accessor, context) {
        const globalScrolling = accessor.get(IConfigurationService).getValue(NotebookSetting.outputScrolling);
        if (context.ui) {
            context.cell.outputsViewModels.forEach((viewModel) => {
                this.toggleOutputScrolling(viewModel, globalScrolling, context.cell.isOutputCollapsed);
            });
            context.cell.isOutputCollapsed = false;
        }
        else {
            context.selectedCells.forEach(cell => {
                cell.outputsViewModels.forEach((viewModel) => {
                    this.toggleOutputScrolling(viewModel, globalScrolling, cell.isOutputCollapsed);
                });
                cell.isOutputCollapsed = false;
            });
        }
    }
});
registerAction2(class ExpandAllCellOutputsAction extends NotebookCellAction {
    constructor() {
        super({
            id: OPEN_CELL_FAILURE_ACTIONS_COMMAND_ID,
            title: ( localize2WithPath(_moduleId, 20, "Show Cell Failure Actions")),
            precondition: ( (ContextKeyExpr.and(
                NOTEBOOK_CELL_FOCUSED,
                NOTEBOOK_CELL_HAS_ERROR_DIAGNOSTICS,
                 (NOTEBOOK_CELL_EDITOR_FOCUSED.toNegated())
            ))),
            f1: true,
            keybinding: {
                when: ( (ContextKeyExpr.and(
                    NOTEBOOK_CELL_FOCUSED,
                    NOTEBOOK_CELL_HAS_ERROR_DIAGNOSTICS,
                     (NOTEBOOK_CELL_EDITOR_FOCUSED.toNegated())
                ))),
                primary: 2048  | 89 ,
                weight: 200
            }
        });
    }
    async runWithContext(accessor, context) {
        if (context.cell instanceof CodeCellViewModel) {
            const error = context.cell.cellDiagnostics.ErrorDetails;
            if (error?.location) {
                const location = Range.lift({
                    startLineNumber: error.location.startLineNumber + 1,
                    startColumn: error.location.startColumn + 1,
                    endLineNumber: error.location.endLineNumber + 1,
                    endColumn: error.location.endColumn + 1
                });
                context.notebookEditor.setCellEditorSelection(context.cell, Range.lift(location));
                const editor = findTargetCellEditor(context, context.cell);
                if (editor) {
                    const controller = CodeActionController.get(editor);
                    controller?.manualTriggerAtCurrentPosition(( localizeWithPath(_moduleId, 21, "No code actions available")), CodeActionTriggerSource.Default, { include: CodeActionKind.QuickFix });
                }
            }
        }
    }
});
function forEachCell(editor, callback) {
    for (let i = 0; i < editor.getLength(); i++) {
        const cell = editor.cellAt(i);
        callback(cell, i);
    }
}
export { OPEN_CELL_FAILURE_ACTIONS_COMMAND_ID };
