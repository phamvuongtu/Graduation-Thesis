import { __decorate, __param } from '../../../../../../../../../external/tslib/tslib.es6.js';
import { getWindow, scheduleAtNextAnimationFrame, trackFocus, Dimension, WindowIntervalTimer } from '../../../../../../base/browser/dom.js';
import { disposableTimeout, createCancelablePromise, raceCancellationError, Queue } from '../../../../../../base/common/async.js';
import { CancellationTokenSource } from '../../../../../../base/common/cancellation.js';
import { Emitter, Event } from '../../../../../../base/common/event.js';
import { MarkdownString } from '../../../../../../base/common/htmlContent.js';
import { Disposable, DisposableStore, toDisposable } from '../../../../../../base/common/lifecycle.js';
import { LRUCache } from '../../../../../../base/common/map.js';
import { Schemas } from '../../../../../../base/common/network.js';
import { MovingAverage } from '../../../../../../base/common/numbers.js';
import { StopWatch } from '../../../../../../base/common/stopwatch.js';
import { assertType } from '../../../../../../base/common/types.js';
import { URI } from '../../../../../../base/common/uri.js';
import { generateUuid } from '../../../../../../base/common/uuid.js';
import { CodeEditorWidget } from '../../../../../../editor/browser/widget/codeEditor/codeEditorWidget.js';
import { Selection } from '../../../../../../editor/common/core/selection.js';
import { TextEdit } from '../../../../../../editor/common/languages.js';
import { ILanguageService } from '../../../../../../editor/common/languages/language.js';
import { IEditorWorkerService } from '../../../../../../editor/common/services/editorWorker.js';
import { IModelService } from '../../../../../../editor/common/services/model.js';
import { localizeWithPath } from '../../../../../../nls.js';
import { ICommandService } from '../../../../../../platform/commands/common/commands.service.js';
import { IContextKeyService } from '../../../../../../platform/contextkey/common/contextkey.service.js';
import { IInstantiationService } from '../../../../../../platform/instantiation/common/instantiation.js';
import { AsyncProgress } from '../../../../../../platform/progress/common/progress.js';
import { IStorageService } from '../../../../../../platform/storage/common/storage.service.js';
import { GeneratingPhrase } from '../../../../chat/browser/chat.js';
import { ChatAgentLocation } from '../../../../chat/common/chatAgents.js';
import { countWords } from '../../../../chat/common/chatWordCounter.js';
import { IInlineChatSavingService } from '../../../../inlineChat/browser/inlineChatSavingService.service.js';
import { SessionPrompt, ReplyResponse, SessionExchange, EmptyResponse, ErrorResponse } from '../../../../inlineChat/browser/inlineChatSession.js';
import { IInlineChatSessionService } from '../../../../inlineChat/browser/inlineChatSessionService.service.js';
import { InlineChatWidget } from '../../../../inlineChat/browser/inlineChatWidget.js';
import { performAsyncTextEdit, asProgressiveEdit } from '../../../../inlineChat/browser/utils.js';
import { CTX_INLINE_CHAT_LAST_RESPONSE_TYPE } from '../../../../inlineChat/common/inlineChat.js';
import { insertCell, runDeleteAction } from '../cellOperations.js';
import { CTX_NOTEBOOK_CHAT_HAS_ACTIVE_REQUEST, CTX_NOTEBOOK_CELL_CHAT_FOCUSED, CTX_NOTEBOOK_CHAT_USER_DID_EDIT, CTX_NOTEBOOK_CHAT_OUTER_FOCUS_POSITION, MENU_CELL_CHAT_INPUT, MENU_CELL_CHAT_WIDGET, MENU_CELL_CHAT_WIDGET_STATUS, MENU_CELL_CHAT_WIDGET_FEEDBACK } from './notebookChatContext.js';
import { registerNotebookContribution } from '../../notebookEditorExtensions.js';
import { CellKind } from '../../../common/notebookCommon.js';
import { NotebookExecutionType } from '../../../common/notebookExecutionStateService.js';
import { INotebookExecutionStateService } from '../../../common/notebookExecutionStateService.service.js';
var NotebookChatController_1;
const _moduleId = "vs/workbench/contrib/notebook/browser/controller/chat/notebookChatController";
class NotebookChatWidget extends Disposable {
    set afterModelPosition(afterModelPosition) {
        this.notebookViewZone.afterModelPosition = afterModelPosition;
    }
    get afterModelPosition() {
        return this.notebookViewZone.afterModelPosition;
    }
    set heightInPx(heightInPx) {
        this.notebookViewZone.heightInPx = heightInPx;
    }
    get heightInPx() {
        return this.notebookViewZone.heightInPx;
    }
    get editingCell() {
        return this._editingCell;
    }
    constructor(_notebookEditor, id, notebookViewZone, domNode, widgetContainer, inlineChatWidget, parentEditor, _languageService) {
        super();
        this._notebookEditor = _notebookEditor;
        this.id = id;
        this.notebookViewZone = notebookViewZone;
        this.domNode = domNode;
        this.widgetContainer = widgetContainer;
        this.inlineChatWidget = inlineChatWidget;
        this.parentEditor = parentEditor;
        this._languageService = _languageService;
        this._editingCell = null;
        this._register(inlineChatWidget.onDidChangeHeight(() => {
            this.heightInPx = inlineChatWidget.contentHeight;
            this._notebookEditor.changeViewZones(accessor => {
                accessor.layoutZone(id);
            });
            this._layoutWidget(inlineChatWidget, widgetContainer);
        }));
        this._layoutWidget(inlineChatWidget, widgetContainer);
    }
    restoreEditingCell(initEditingCell) {
        this._editingCell = initEditingCell;
        const decorationIds = this._notebookEditor.deltaCellDecorations([], [{
                handle: this._editingCell.handle,
                options: { className: 'nb-chatGenerationHighlight', outputClassName: 'nb-chatGenerationHighlight' }
            }]);
        this._register(toDisposable(() => {
            this._notebookEditor.deltaCellDecorations(decorationIds, []);
        }));
    }
    hasFocus() {
        return this.inlineChatWidget.hasFocus();
    }
    focus() {
        this.updateNotebookEditorFocusNSelections();
        this.inlineChatWidget.focus();
    }
    updateNotebookEditorFocusNSelections() {
        this._notebookEditor.focusContainer(true);
        this._notebookEditor.setFocus({ start: this.afterModelPosition, end: this.afterModelPosition });
        this._notebookEditor.setSelections([{
                start: this.afterModelPosition,
                end: this.afterModelPosition
            }]);
    }
    getEditingCell() {
        return this._editingCell;
    }
    async getOrCreateEditingCell() {
        if (this._editingCell) {
            const codeEditor = this._notebookEditor.codeEditors.find(ce => ce[0] === this._editingCell)?.[1];
            if (codeEditor?.hasModel()) {
                return {
                    cell: this._editingCell,
                    editor: codeEditor
                };
            }
            else {
                return undefined;
            }
        }
        if (!this._notebookEditor.hasModel()) {
            return undefined;
        }
        const widgetHasFocus = this.inlineChatWidget.hasFocus();
        this._editingCell = insertCell(this._languageService, this._notebookEditor, this.afterModelPosition, CellKind.Code, 'above');
        if (!this._editingCell) {
            return undefined;
        }
        await this._notebookEditor.revealFirstLineIfOutsideViewport(this._editingCell);
        const decorationIds = this._notebookEditor.deltaCellDecorations([], [{
                handle: this._editingCell.handle,
                options: { className: 'nb-chatGenerationHighlight', outputClassName: 'nb-chatGenerationHighlight' }
            }]);
        this._register(toDisposable(() => {
            this._notebookEditor.deltaCellDecorations(decorationIds, []);
        }));
        if (widgetHasFocus) {
            this.focus();
        }
        const codeEditor = this._notebookEditor.codeEditors.find(ce => ce[0] === this._editingCell)?.[1];
        if (codeEditor?.hasModel()) {
            return {
                cell: this._editingCell,
                editor: codeEditor
            };
        }
        return undefined;
    }
    async discardChange() {
        if (this._notebookEditor.hasModel() && this._editingCell) {
            runDeleteAction(this._notebookEditor, this._editingCell);
        }
    }
    _layoutWidget(inlineChatWidget, widgetContainer) {
        const layoutConfiguration = this._notebookEditor.notebookOptions.getLayoutConfiguration();
        const rightMargin = layoutConfiguration.cellRightMargin;
        const leftMargin = this._notebookEditor.notebookOptions.getCellEditorContainerLeftMargin();
        const maxWidth = 640;
        const width = Math.min(maxWidth, this._notebookEditor.getLayoutInfo().width - leftMargin - rightMargin);
        inlineChatWidget.layout(( (new Dimension(width, this.heightInPx))));
        inlineChatWidget.domNode.style.width = `${width}px`;
        widgetContainer.style.left = `${leftMargin}px`;
    }
    dispose() {
        this._notebookEditor.changeViewZones(accessor => {
            accessor.removeZone(this.id);
        });
        this.domNode.remove();
        super.dispose();
    }
}
class NotebookCellTextModelLikeId {
    static str(k) {
        return `${k.viewType}/${( (k.uri.toString()))}`;
    }
    static obj(s) {
        const idx = s.indexOf('/');
        return {
            viewType: s.substring(0, idx),
            uri: ( (URI.parse(s.substring(idx + 1))))
        };
    }
}
let NotebookChatController = class NotebookChatController extends Disposable {
    static { NotebookChatController_1 = this; }
    static { this.id = 'workbench.notebook.chatController'; }
    static { this.counter = 0; }
    static get(editor) {
        return editor.getContribution(NotebookChatController_1.id);
    }
    static { this._storageKey = 'inline-chat-history'; }
    static { this._promptHistory = []; }
    constructor(_notebookEditor, _instantiationService, _inlineChatSessionService, _contextKeyService, _commandService, _editorWorkerService, _inlineChatSavingService, _modelService, _languageService, _executionStateService, _storageService) {
        super();
        this._notebookEditor = _notebookEditor;
        this._instantiationService = _instantiationService;
        this._inlineChatSessionService = _inlineChatSessionService;
        this._contextKeyService = _contextKeyService;
        this._commandService = _commandService;
        this._editorWorkerService = _editorWorkerService;
        this._inlineChatSavingService = _inlineChatSavingService;
        this._modelService = _modelService;
        this._languageService = _languageService;
        this._executionStateService = _executionStateService;
        this._storageService = _storageService;
        this._historyOffset = -1;
        this._historyCandidate = '';
        this._promptCache = ( (new LRUCache(1000, 0.7)));
        this._onDidChangePromptCache = this._register(( (new Emitter())));
        this.onDidChangePromptCache = this._onDidChangePromptCache.event;
        this._userEditingDisposables = this._register(( (new DisposableStore())));
        this._widgetDisposableStore = this._register(( (new DisposableStore())));
        this._ctxHasActiveRequest = CTX_NOTEBOOK_CHAT_HAS_ACTIVE_REQUEST.bindTo(this._contextKeyService);
        this._ctxCellWidgetFocused = CTX_NOTEBOOK_CELL_CHAT_FOCUSED.bindTo(this._contextKeyService);
        this._ctxLastResponseType = CTX_INLINE_CHAT_LAST_RESPONSE_TYPE.bindTo(this._contextKeyService);
        this._ctxUserDidEdit = CTX_NOTEBOOK_CHAT_USER_DID_EDIT.bindTo(this._contextKeyService);
        this._ctxOuterFocusPosition = CTX_NOTEBOOK_CHAT_OUTER_FOCUS_POSITION.bindTo(this._contextKeyService);
        this._registerFocusTracker();
        NotebookChatController_1._promptHistory = JSON.parse(this._storageService.get(NotebookChatController_1._storageKey, 0 , '[]'));
        this._historyUpdate = (prompt) => {
            const idx = NotebookChatController_1._promptHistory.indexOf(prompt);
            if (idx >= 0) {
                NotebookChatController_1._promptHistory.splice(idx, 1);
            }
            NotebookChatController_1._promptHistory.unshift(prompt);
            this._historyOffset = -1;
            this._historyCandidate = '';
            this._storageService.store(NotebookChatController_1._storageKey, JSON.stringify(NotebookChatController_1._promptHistory), 0 , 0 );
        };
    }
    _registerFocusTracker() {
        this._register(this._notebookEditor.onDidChangeFocus(() => {
            if (!this._widget) {
                this._ctxOuterFocusPosition.set('');
                return;
            }
            const widgetIndex = this._widget.afterModelPosition;
            const focus = this._notebookEditor.getFocus().start;
            if (focus + 1 === widgetIndex) {
                this._ctxOuterFocusPosition.set('above');
            }
            else if (focus === widgetIndex) {
                this._ctxOuterFocusPosition.set('below');
            }
            else {
                this._ctxOuterFocusPosition.set('');
            }
        }));
    }
    run(index, input, autoSend) {
        if (this._widget) {
            if (this._widget.afterModelPosition !== index) {
                const window = getWindow(this._widget.domNode);
                this._disposeWidget();
                scheduleAtNextAnimationFrame(window, () => {
                    this._createWidget(index, input, autoSend, undefined);
                });
            }
            return;
        }
        this._createWidget(index, input, autoSend, undefined);
    }
    restore(editingCell, input) {
        if (!this._notebookEditor.hasModel()) {
            return;
        }
        const index = this._notebookEditor.textModel.cells.indexOf(editingCell.model);
        if (index < 0) {
            return;
        }
        if (this._widget) {
            if (this._widget.afterModelPosition !== index) {
                this._disposeWidget();
                const window = getWindow(this._widget.domNode);
                scheduleAtNextAnimationFrame(window, () => {
                    this._createWidget(index, input, false, editingCell);
                });
            }
            return;
        }
        this._createWidget(index, input, false, editingCell);
    }
    _disposeWidget() {
        this._widget?.dispose();
        this._widget = undefined;
        this._widgetDisposableStore.clear();
        this._historyOffset = -1;
        this._historyCandidate = '';
    }
    _createWidget(index, input, autoSend, initEditingCell) {
        if (!this._notebookEditor.hasModel()) {
            return;
        }
        this._widgetDisposableStore.clear();
        const viewZoneContainer = document.createElement('div');
        viewZoneContainer.classList.add('monaco-editor');
        const widgetContainer = document.createElement('div');
        widgetContainer.style.position = 'absolute';
        viewZoneContainer.appendChild(widgetContainer);
        this._focusTracker = this._widgetDisposableStore.add(trackFocus(viewZoneContainer));
        this._widgetDisposableStore.add(this._focusTracker.onDidFocus(() => {
            this._updateNotebookEditorFocusNSelections();
        }));
        const fakeParentEditorElement = document.createElement('div');
        const fakeParentEditor = this._widgetDisposableStore.add(this._instantiationService.createInstance(CodeEditorWidget, fakeParentEditorElement, {}, { isSimpleWidget: true }));
        const inputBoxFragment = `notebook-chat-input-${NotebookChatController_1.counter++}`;
        const notebookUri = this._notebookEditor.textModel.uri;
        const inputUri = notebookUri.with({ scheme: Schemas.untitled, fragment: inputBoxFragment });
        const result = this._modelService.createModel('', null, inputUri, false);
        fakeParentEditor.setModel(result);
        const inlineChatWidget = this._widgetDisposableStore.add(this._instantiationService.createInstance(InlineChatWidget, ChatAgentLocation.Notebook, {
            telemetrySource: 'notebook-generate-cell',
            inputMenuId: MENU_CELL_CHAT_INPUT,
            widgetMenuId: MENU_CELL_CHAT_WIDGET,
            statusMenuId: MENU_CELL_CHAT_WIDGET_STATUS,
            feedbackMenuId: MENU_CELL_CHAT_WIDGET_FEEDBACK
        }));
        inlineChatWidget.placeholder = ( localizeWithPath(_moduleId, 0, "Ask a question"));
        inlineChatWidget.updateInfo(( localizeWithPath(_moduleId, 1, "AI-generated code may be incorrect")));
        widgetContainer.appendChild(inlineChatWidget.domNode);
        this._widgetDisposableStore.add(inlineChatWidget.onDidChangeInput(() => {
            this._warmupRequestCts?.dispose(true);
            this._warmupRequestCts = undefined;
        }));
        this._notebookEditor.changeViewZones(accessor => {
            const notebookViewZone = {
                afterModelPosition: index,
                heightInPx: 80,
                domNode: viewZoneContainer
            };
            const id = accessor.addZone(notebookViewZone);
            this._scrollWidgetIntoView(index);
            this._widget = ( (new NotebookChatWidget(
                this._notebookEditor,
                id,
                notebookViewZone,
                viewZoneContainer,
                widgetContainer,
                inlineChatWidget,
                fakeParentEditor,
                this._languageService
            )));
            if (initEditingCell) {
                this._widget.restoreEditingCell(initEditingCell);
                this._updateUserEditingState();
            }
            this._ctxCellWidgetFocused.set(true);
            disposableTimeout(() => {
                this._focusWidget();
            }, 0, this._store);
            this._sessionCtor = createCancelablePromise(async (token) => {
                if (fakeParentEditor.hasModel()) {
                    await this._startSession(fakeParentEditor, token);
                    this._warmupRequestCts = ( (new CancellationTokenSource()));
                    this._startInitialFolowups(fakeParentEditor, this._warmupRequestCts.token);
                    if (this._widget) {
                        this._widget.inlineChatWidget.placeholder = this._activeSession?.session.placeholder ?? ( localizeWithPath(_moduleId, 0, "Ask a question"));
                        this._widget.inlineChatWidget.updateInfo(this._activeSession?.session.message ?? ( localizeWithPath(_moduleId, 1, "AI-generated code may be incorrect")));
                        this._widget.inlineChatWidget.updateSlashCommands(this._activeSession?.session.slashCommands ?? []);
                        this._focusWidget();
                    }
                    if (this._widget && input) {
                        this._widget.inlineChatWidget.value = input;
                        if (autoSend) {
                            this.acceptInput();
                        }
                    }
                }
            });
        });
    }
    _scrollWidgetIntoView(index) {
        if (index === 0 || this._notebookEditor.getLength() === 0) {
            this._notebookEditor.revealOffsetInCenterIfOutsideViewport(0);
        }
        else {
            const previousCell = this._notebookEditor.cellAt(Math.min(index - 1, this._notebookEditor.getLength() - 1));
            if (previousCell) {
                const cellTop = this._notebookEditor.getAbsoluteTopOfElement(previousCell);
                const cellHeight = this._notebookEditor.getHeightOfElement(previousCell);
                this._notebookEditor.revealOffsetInCenterIfOutsideViewport(cellTop + cellHeight + 48 );
            }
        }
    }
    _focusWidget() {
        if (!this._widget) {
            return;
        }
        this._updateNotebookEditorFocusNSelections();
        this._widget.focus();
    }
    _updateNotebookEditorFocusNSelections() {
        if (!this._widget) {
            return;
        }
        this._widget.updateNotebookEditorFocusNSelections();
    }
    async acceptInput() {
        assertType(this._widget);
        await this._sessionCtor;
        assertType(this._activeSession);
        this._warmupRequestCts?.dispose(true);
        this._warmupRequestCts = undefined;
        this._activeSession.addInput(( (new SessionPrompt(this._widget.inlineChatWidget.value))));
        assertType(this._activeSession.lastInput);
        const value = this._activeSession.lastInput.value;
        this._historyUpdate(value);
        const editor = this._widget.parentEditor;
        const model = editor.getModel();
        if (!editor.hasModel() || !model) {
            return;
        }
        if (this._widget.editingCell && this._widget.editingCell.textBuffer.getLength() > 0) {
            const ref = await this._widget.editingCell.resolveTextModel();
            ref.setValue('');
        }
        const editingCellIndex = this._widget.editingCell ? this._notebookEditor.getCellIndex(this._widget.editingCell) : undefined;
        if (editingCellIndex !== undefined) {
            this._notebookEditor.setSelections([{
                    start: editingCellIndex,
                    end: editingCellIndex + 1
                }]);
        }
        else {
            this._notebookEditor.setSelections([{
                    start: this._widget.afterModelPosition,
                    end: this._widget.afterModelPosition
                }]);
        }
        this._ctxHasActiveRequest.set(true);
        this._widget.inlineChatWidget.updateSlashCommands(this._activeSession.session.slashCommands ?? []);
        this._widget?.inlineChatWidget.updateProgress(true);
        const request = {
            requestId: generateUuid(),
            prompt: value,
            attempt: 0,
            selection: { selectionStartLineNumber: 1, selectionStartColumn: 1, positionLineNumber: 1, positionColumn: 1 },
            wholeRange: { startLineNumber: 1, startColumn: 1, endLineNumber: 1, endColumn: 1 },
            live: true,
            previewDocument: model.uri,
            withIntentDetection: true,
        };
        this._activeRequestCts?.cancel();
        this._activeRequestCts = ( (new CancellationTokenSource()));
        const progressEdits = [];
        const progressiveEditsQueue = ( (new Queue()));
        const progressiveEditsClock = StopWatch.create();
        const progressiveEditsAvgDuration = ( (new MovingAverage()));
        const progressiveEditsCts = ( (new CancellationTokenSource(this._activeRequestCts.token)));
        let progressiveChatResponse;
        const progress = ( (new AsyncProgress(async (data) => {
            if (this._activeRequestCts?.token.isCancellationRequested) {
                return;
            }
            if (data.message) {
                this._widget?.inlineChatWidget.updateToolbar(false);
                this._widget?.inlineChatWidget.updateInfo(data.message);
            }
            if (data.edits?.length) {
                if (!request.live) {
                    throw ( (new Error('Progress in NOT supported in non-live mode')));
                }
                progressEdits.push(data.edits);
                progressiveEditsAvgDuration.update(progressiveEditsClock.elapsed());
                progressiveEditsClock.reset();
                progressiveEditsQueue.queue(async () => {
                    await this._makeChanges(data.edits, data.editsShouldBeInstant
                        ? undefined
                        : { duration: progressiveEditsAvgDuration.value, token: progressiveEditsCts.token });
                });
            }
            if (data.markdownFragment) {
                if (!progressiveChatResponse) {
                    const message = {
                        message: ( (new MarkdownString(
                            data.markdownFragment,
                            { supportThemeIcons: true, supportHtml: true, isTrusted: false }
                        ))),
                        requestId: request.requestId,
                    };
                    progressiveChatResponse = this._widget?.inlineChatWidget.updateChatMessage(message, true);
                }
                else {
                    progressiveChatResponse.appendContent(data.markdownFragment);
                }
            }
        })));
        const task = this._activeSession.provider.provideResponse(this._activeSession.session, request, progress, this._activeRequestCts.token);
        let response;
        try {
            this._widget?.inlineChatWidget.updateChatMessage(undefined);
            this._widget?.inlineChatWidget.updateFollowUps(undefined);
            this._widget?.inlineChatWidget.updateProgress(true);
            this._widget?.inlineChatWidget.updateInfo(!this._activeSession.lastExchange ? GeneratingPhrase + '\u2026' : '');
            this._ctxHasActiveRequest.set(true);
            const reply = await raceCancellationError(Promise.resolve(task), this._activeRequestCts.token);
            if (progressiveEditsQueue.size > 0) {
                await Event.toPromise(progressiveEditsQueue.onDrained);
            }
            await progress.drain();
            if (!reply) {
                response = ( (new EmptyResponse()));
            }
            else {
                const markdownContents = ( (new MarkdownString('', { supportThemeIcons: true, supportHtml: true, isTrusted: false })));
                const replyResponse = response = this._instantiationService.createInstance(ReplyResponse, reply, markdownContents, this._activeSession.textModelN.uri, this._activeSession.textModelN.getAlternativeVersionId(), progressEdits, request.requestId, undefined);
                for (let i = progressEdits.length; i < replyResponse.allLocalEdits.length; i++) {
                    await this._makeChanges(replyResponse.allLocalEdits[i], undefined);
                }
                if (this._activeSession?.provider.provideFollowups) {
                    const followupCts = ( (new CancellationTokenSource()));
                    const followups = await this._activeSession.provider.provideFollowups(this._activeSession.session, replyResponse.raw, followupCts.token);
                    if (followups && this._widget) {
                        const widget = this._widget;
                        widget.inlineChatWidget.updateFollowUps(followups, async (followup) => {
                            if (followup.kind === 'reply') {
                                widget.inlineChatWidget.value = followup.message;
                                this.acceptInput();
                            }
                            else {
                                await this.acceptSession();
                                this._commandService.executeCommand(followup.commandId, ...(followup.args ?? []));
                            }
                        });
                    }
                }
                this._userEditingDisposables.clear();
                const editingCell = this._widget.getEditingCell();
                if (editingCell) {
                    this._userEditingDisposables.add(editingCell.model.onDidChangeContent(() => this._updateUserEditingState()));
                    this._userEditingDisposables.add(editingCell.model.onDidChangeLanguage(() => this._updateUserEditingState()));
                    this._userEditingDisposables.add(editingCell.model.onDidChangeMetadata(() => this._updateUserEditingState()));
                    this._userEditingDisposables.add(editingCell.model.onDidChangeInternalMetadata(() => this._updateUserEditingState()));
                    this._userEditingDisposables.add(editingCell.model.onDidChangeOutputs(() => this._updateUserEditingState()));
                    this._userEditingDisposables.add(this._executionStateService.onDidChangeExecution(e => {
                        if (e.type === NotebookExecutionType.cell && e.affectsCell(editingCell.uri)) {
                            this._updateUserEditingState();
                        }
                    }));
                }
            }
        }
        catch (e) {
            response = ( (new ErrorResponse(e)));
        }
        finally {
            this._ctxHasActiveRequest.set(false);
            this._widget?.inlineChatWidget.updateProgress(false);
            this._widget?.inlineChatWidget.updateInfo('');
            this._widget?.inlineChatWidget.updateToolbar(true);
        }
        this._ctxHasActiveRequest.set(false);
        this._widget?.inlineChatWidget.updateProgress(false);
        this._widget?.inlineChatWidget.updateInfo('');
        this._widget?.inlineChatWidget.updateToolbar(true);
        this._activeSession?.addExchange(( (new SessionExchange(this._activeSession.lastInput, response))));
        this._ctxLastResponseType.set(response instanceof ReplyResponse ? response.raw.type : undefined);
    }
    async _startSession(editor, token) {
        if (this._activeSession) {
            this._inlineChatSessionService.releaseSession(this._activeSession);
        }
        const session = await this._inlineChatSessionService.createSession(editor, { editMode: "live"  }, token);
        if (!session) {
            return;
        }
        this._activeSession = session;
        this._strategy = ( (new EditStrategy(session)));
    }
    async _startInitialFolowups(editor, token) {
        if (!this._activeSession || !this._activeSession.provider.provideFollowups) {
            return;
        }
        const request = {
            requestId: generateUuid(),
            prompt: '',
            attempt: 0,
            selection: { selectionStartLineNumber: 1, selectionStartColumn: 1, positionLineNumber: 1, positionColumn: 1 },
            wholeRange: { startLineNumber: 1, startColumn: 1, endLineNumber: 1, endColumn: 1 },
            live: true,
            previewDocument: editor.getModel().uri,
            withIntentDetection: true
        };
        const progress = ( (new AsyncProgress(async (data) => { })));
        const task = this._activeSession.provider.provideResponse(this._activeSession.session, request, progress, token);
        const reply = await raceCancellationError(Promise.resolve(task), token);
        if (token.isCancellationRequested) {
            return;
        }
        if (!reply) {
            return;
        }
        const markdownContents = ( (new MarkdownString('', { supportThemeIcons: true, supportHtml: true, isTrusted: false })));
        const response = this._instantiationService.createInstance(ReplyResponse, reply, markdownContents, this._activeSession.textModelN.uri, this._activeSession.textModelN.getAlternativeVersionId(), [], request.requestId, undefined);
        const followups = await this._activeSession.provider.provideFollowups(this._activeSession.session, response.raw, token);
        if (followups && this._widget) {
            const widget = this._widget;
            widget.inlineChatWidget.updateFollowUps(followups, async (followup) => {
                if (followup.kind === 'reply') {
                    widget.inlineChatWidget.value = followup.message;
                    this.acceptInput();
                }
                else {
                    await this.acceptSession();
                    this._commandService.executeCommand(followup.commandId, ...(followup.args ?? []));
                }
            });
        }
    }
    async _makeChanges(edits, opts) {
        assertType(this._activeSession);
        assertType(this._strategy);
        assertType(this._widget);
        const editingCell = await this._widget.getOrCreateEditingCell();
        if (!editingCell) {
            return;
        }
        const editor = editingCell.editor;
        const moreMinimalEdits = await this._editorWorkerService.computeMoreMinimalEdits(editor.getModel().uri, edits);
        if (moreMinimalEdits?.length === 0) {
            return;
        }
        const actualEdits = !opts && moreMinimalEdits ? moreMinimalEdits : edits;
        const editOperations = ( (actualEdits.map(TextEdit.asEditOperation)));
        this._inlineChatSavingService.markChanged(this._activeSession);
        try {
            this._activeSession.wholeRange.trackEdits(editOperations);
            if (opts) {
                await this._strategy.makeProgressiveChanges(editor, editOperations, opts);
            }
            else {
                await this._strategy.makeChanges(editor, editOperations);
            }
        }
        finally {
        }
    }
    _updateUserEditingState() {
        this._ctxUserDidEdit.set(true);
    }
    async acceptSession() {
        assertType(this._activeSession);
        assertType(this._strategy);
        const editor = this._widget?.parentEditor;
        if (!editor?.hasModel()) {
            return;
        }
        const editingCell = this._widget?.getEditingCell();
        if (editingCell && this._notebookEditor.hasModel() && this._activeSession.lastInput) {
            const cellId = NotebookCellTextModelLikeId.str({ uri: editingCell.uri, viewType: this._notebookEditor.textModel.viewType });
            const prompt = this._activeSession.lastInput.value;
            this._promptCache.set(cellId, prompt);
            this._onDidChangePromptCache.fire({ cell: editingCell.uri });
        }
        try {
            await this._strategy.apply(editor);
            this._inlineChatSessionService.releaseSession(this._activeSession);
        }
        catch (_err) { }
        this.dismiss(false);
    }
    async focusAbove() {
        if (!this._widget) {
            return;
        }
        const index = this._widget.afterModelPosition;
        const prev = index - 1;
        if (prev < 0) {
            return;
        }
        const cell = this._notebookEditor.cellAt(prev);
        if (!cell) {
            return;
        }
        await this._notebookEditor.focusNotebookCell(cell, 'editor');
    }
    async focusNext() {
        if (!this._widget) {
            return;
        }
        const index = this._widget.afterModelPosition;
        const cell = this._notebookEditor.cellAt(index);
        if (!cell) {
            return;
        }
        await this._notebookEditor.focusNotebookCell(cell, 'editor');
    }
    hasFocus() {
        return this._widget?.hasFocus() ?? false;
    }
    focus() {
        this._focusWidget();
    }
    focusNearestWidget(index, direction) {
        switch (direction) {
            case 'above':
                if (this._widget?.afterModelPosition === index) {
                    this._focusWidget();
                }
                break;
            case 'below':
                if (this._widget?.afterModelPosition === index + 1) {
                    this._focusWidget();
                }
                break;
        }
    }
    populateHistory(up) {
        if (!this._widget) {
            return;
        }
        const len = NotebookChatController_1._promptHistory.length;
        if (len === 0) {
            return;
        }
        if (this._historyOffset === -1) {
            this._historyCandidate = this._widget.inlineChatWidget.value;
        }
        const newIdx = this._historyOffset + (up ? 1 : -1);
        if (newIdx >= len) {
            return;
        }
        let entry;
        if (newIdx < 0) {
            entry = this._historyCandidate;
            this._historyOffset = -1;
        }
        else {
            entry = NotebookChatController_1._promptHistory[newIdx];
            this._historyOffset = newIdx;
        }
        this._widget.inlineChatWidget.value = entry;
        this._widget.inlineChatWidget.selectAll();
    }
    async cancelCurrentRequest(discard) {
        if (discard) {
            this._strategy?.cancel();
        }
        this._activeRequestCts?.cancel();
    }
    getEditingCell() {
        return this._widget?.getEditingCell();
    }
    discard() {
        this._strategy?.cancel();
        this._activeRequestCts?.cancel();
        this._widget?.discardChange();
        this.dismiss(true);
    }
    async feedbackLast(kind) {
        if (this._activeSession?.lastExchange && this._activeSession.lastExchange.response instanceof ReplyResponse) {
            this._activeSession.provider.handleInlineChatResponseFeedback?.(this._activeSession.session, this._activeSession.lastExchange.response.raw, kind);
            this._widget?.inlineChatWidget.updateStatus('Thank you for your feedback!', { resetAfter: 1250 });
        }
    }
    dismiss(discard) {
        const widget = this._widget;
        const widgetIndex = widget?.afterModelPosition;
        const currentFocus = this._notebookEditor.getFocus();
        const isWidgetFocused = currentFocus.start === widgetIndex && currentFocus.end === widgetIndex;
        if (widget && isWidgetFocused) {
            const editingCell = widget.getEditingCell();
            const shouldFocusEditingCell = editingCell && !discard;
            const shouldFocusTopCell = widgetIndex === 0 && this._notebookEditor.getLength() > 0;
            const shouldFocusAboveCell = widgetIndex !== 0 && this._notebookEditor.cellAt(widgetIndex - 1);
            if (shouldFocusEditingCell) {
                this._notebookEditor.focusNotebookCell(editingCell, 'container');
            }
            else if (shouldFocusTopCell) {
                this._notebookEditor.focusNotebookCell(this._notebookEditor.cellAt(0), 'container');
            }
            else if (shouldFocusAboveCell) {
                this._notebookEditor.focusNotebookCell(this._notebookEditor.cellAt(widgetIndex - 1), 'container');
            }
        }
        this._ctxCellWidgetFocused.set(false);
        this._ctxUserDidEdit.set(false);
        this._sessionCtor?.cancel();
        this._sessionCtor = undefined;
        this._widget?.dispose();
        this._widget = undefined;
        this._widgetDisposableStore.clear();
    }
    isCellGeneratedByChat(cell) {
        if (!this._notebookEditor.hasModel()) {
            return false;
        }
        const cellId = NotebookCellTextModelLikeId.str({ uri: cell.uri, viewType: this._notebookEditor.textModel.viewType });
        return (
             (this._promptCache.has(cellId))
        );
    }
    getPromptFromCache(cell) {
        if (!this._notebookEditor.hasModel()) {
            return undefined;
        }
        const cellId = NotebookCellTextModelLikeId.str({ uri: cell.uri, viewType: this._notebookEditor.textModel.viewType });
        return this._promptCache.get(cellId);
    }
    dispose() {
        this.dismiss(false);
        super.dispose();
    }
};
NotebookChatController = NotebookChatController_1 = ( (__decorate([
    ( (__param(1, IInstantiationService))),
    ( (__param(2, IInlineChatSessionService))),
    ( (__param(3, IContextKeyService))),
    ( (__param(4, ICommandService))),
    ( (__param(5, IEditorWorkerService))),
    ( (__param(6, IInlineChatSavingService))),
    ( (__param(7, IModelService))),
    ( (__param(8, ILanguageService))),
    ( (__param(9, INotebookExecutionStateService))),
    ( (__param(10, IStorageService)))
], NotebookChatController)));
class EditStrategy {
    constructor(_session) {
        this._session = _session;
        this._editCount = 0;
    }
    async makeProgressiveChanges(editor, edits, opts) {
        if (++this._editCount === 1) {
            editor.pushUndoStop();
        }
        const durationInSec = opts.duration / 1000;
        for (const edit of edits) {
            const wordCount = countWords(edit.text ?? '');
            const speed = wordCount / durationInSec;
            await performAsyncTextEdit(editor.getModel(), asProgressiveEdit(( (new WindowIntervalTimer())), edit, speed, opts.token));
        }
    }
    async makeChanges(editor, edits) {
        const cursorStateComputerAndInlineDiffCollection = (undoEdits) => {
            let last = null;
            for (const edit of undoEdits) {
                last = !last || last.isBefore(edit.range.getEndPosition()) ? edit.range.getEndPosition() : last;
            }
            return last && [Selection.fromPositions(last)];
        };
        if (++this._editCount === 1) {
            editor.pushUndoStop();
        }
        editor.executeEdits('inline-chat-live', edits, cursorStateComputerAndInlineDiffCollection);
    }
    async apply(editor) {
        if (this._editCount > 0) {
            editor.pushUndoStop();
        }
        if (!(this._session.lastExchange?.response instanceof ReplyResponse)) {
            return;
        }
        const { untitledTextModel } = this._session.lastExchange.response;
        if (untitledTextModel && !untitledTextModel.isDisposed() && untitledTextModel.isDirty()) {
            await untitledTextModel.save({ reason: 1  });
        }
    }
    async cancel() {
        const { textModelN: modelN, textModelNAltVersion, textModelNSnapshotAltVersion } = this._session;
        if (modelN.isDisposed()) {
            return;
        }
        const targetAltVersion = textModelNSnapshotAltVersion ?? textModelNAltVersion;
        while (targetAltVersion < modelN.getAlternativeVersionId() && modelN.canUndo()) {
            modelN.undo();
        }
    }
    createSnapshot() {
        if (this._session && !this._session.textModel0.equalsTextBuffer(this._session.textModelN.getTextBuffer())) {
            this._session.createSnapshot();
        }
    }
}
registerNotebookContribution(NotebookChatController.id, NotebookChatController);
export { EditStrategy, NotebookChatController };
