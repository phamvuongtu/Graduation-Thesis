import { getLeadingWhitespace } from '../../../base/common/strings.js';
import { IndentAction } from './languageConfiguration.js';
import { createScopedLineTokens } from './supports.js';
import { getScopedLineTokens } from './languageConfigurationRegistry.js';
function getPrecedingValidLine(model, lineNumber, indentRulesSupport) {
    const languageId = model.tokenization.getLanguageIdAtPosition(lineNumber, 0);
    if (lineNumber > 1) {
        let lastLineNumber;
        let resultLineNumber = -1;
        for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {
            if (model.tokenization.getLanguageIdAtPosition(lastLineNumber, 0) !== languageId) {
                return resultLineNumber;
            }
            const text = model.getLineContent(lastLineNumber);
            if (indentRulesSupport.shouldIgnore(text) || /^\s+$/.test(text) || text === '') {
                resultLineNumber = lastLineNumber;
                continue;
            }
            return lastLineNumber;
        }
    }
    return -1;
}
function getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = true, languageConfigurationService) {
    if (autoIndent < 4 ) {
        return null;
    }
    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.tokenization.getLanguageId()).indentRulesSupport;
    if (!indentRulesSupport) {
        return null;
    }
    if (lineNumber <= 1) {
        return {
            indentation: '',
            action: null
        };
    }
    for (let priorLineNumber = lineNumber - 1; priorLineNumber > 0; priorLineNumber--) {
        if (model.getLineContent(priorLineNumber) !== '') {
            break;
        }
        if (priorLineNumber === 1) {
            return {
                indentation: '',
                action: null
            };
        }
    }
    const precedingUnIgnoredLine = getPrecedingValidLine(model, lineNumber, indentRulesSupport);
    if (precedingUnIgnoredLine < 0) {
        return null;
    }
    else if (precedingUnIgnoredLine < 1) {
        return {
            indentation: '',
            action: null
        };
    }
    const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);
    if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {
        return {
            indentation: getLeadingWhitespace(precedingUnIgnoredLineContent),
            action: IndentAction.Indent,
            line: precedingUnIgnoredLine
        };
    }
    else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {
        return {
            indentation: getLeadingWhitespace(precedingUnIgnoredLineContent),
            action: null,
            line: precedingUnIgnoredLine
        };
    }
    else {
        if (precedingUnIgnoredLine === 1) {
            return {
                indentation: getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),
                action: null,
                line: precedingUnIgnoredLine
            };
        }
        const previousLine = precedingUnIgnoredLine - 1;
        const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));
        if (!(previousLineIndentMetadata & (1  | 2 )) &&
            (previousLineIndentMetadata & 4 )) {
            let stopLine = 0;
            for (let i = previousLine - 1; i > 0; i--) {
                if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {
                    continue;
                }
                stopLine = i;
                break;
            }
            return {
                indentation: getLeadingWhitespace(model.getLineContent(stopLine + 1)),
                action: null,
                line: stopLine + 1
            };
        }
        if (honorIntentialIndent) {
            return {
                indentation: getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),
                action: null,
                line: precedingUnIgnoredLine
            };
        }
        else {
            for (let i = precedingUnIgnoredLine; i > 0; i--) {
                const lineContent = model.getLineContent(i);
                if (indentRulesSupport.shouldIncrease(lineContent)) {
                    return {
                        indentation: getLeadingWhitespace(lineContent),
                        action: IndentAction.Indent,
                        line: i
                    };
                }
                else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {
                    let stopLine = 0;
                    for (let j = i - 1; j > 0; j--) {
                        if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {
                            continue;
                        }
                        stopLine = j;
                        break;
                    }
                    return {
                        indentation: getLeadingWhitespace(model.getLineContent(stopLine + 1)),
                        action: null,
                        line: stopLine + 1
                    };
                }
                else if (indentRulesSupport.shouldDecrease(lineContent)) {
                    return {
                        indentation: getLeadingWhitespace(lineContent),
                        action: null,
                        line: i
                    };
                }
            }
            return {
                indentation: getLeadingWhitespace(model.getLineContent(1)),
                action: null,
                line: 1
            };
        }
    }
}
function getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter, languageConfigurationService) {
    if (autoIndent < 4 ) {
        return null;
    }
    const richEditSupport = languageConfigurationService.getLanguageConfiguration(languageId);
    if (!richEditSupport) {
        return null;
    }
    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(languageId).indentRulesSupport;
    if (!indentRulesSupport) {
        return null;
    }
    const indent = getInheritIndentForLine(autoIndent, virtualModel, lineNumber, undefined, languageConfigurationService);
    const lineContent = virtualModel.getLineContent(lineNumber);
    if (indent) {
        const inheritLine = indent.line;
        if (inheritLine !== undefined) {
            let shouldApplyEnterRules = true;
            for (let inBetweenLine = inheritLine; inBetweenLine < lineNumber - 1; inBetweenLine++) {
                if (!/^\s*$/.test(virtualModel.getLineContent(inBetweenLine))) {
                    shouldApplyEnterRules = false;
                    break;
                }
            }
            if (shouldApplyEnterRules) {
                const enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');
                if (enterResult) {
                    let indentation = getLeadingWhitespace(virtualModel.getLineContent(inheritLine));
                    if (enterResult.removeText) {
                        indentation = indentation.substring(0, indentation.length - enterResult.removeText);
                    }
                    if ((enterResult.indentAction === IndentAction.Indent) ||
                        (enterResult.indentAction === IndentAction.IndentOutdent)) {
                        indentation = indentConverter.shiftIndent(indentation);
                    }
                    else if (enterResult.indentAction === IndentAction.Outdent) {
                        indentation = indentConverter.unshiftIndent(indentation);
                    }
                    if (indentRulesSupport.shouldDecrease(lineContent)) {
                        indentation = indentConverter.unshiftIndent(indentation);
                    }
                    if (enterResult.appendText) {
                        indentation += enterResult.appendText;
                    }
                    return getLeadingWhitespace(indentation);
                }
            }
        }
        if (indentRulesSupport.shouldDecrease(lineContent)) {
            if (indent.action === IndentAction.Indent) {
                return indent.indentation;
            }
            else {
                return indentConverter.unshiftIndent(indent.indentation);
            }
        }
        else {
            if (indent.action === IndentAction.Indent) {
                return indentConverter.shiftIndent(indent.indentation);
            }
            else {
                return indent.indentation;
            }
        }
    }
    return null;
}
function getIndentForEnter(autoIndent, model, range, indentConverter, languageConfigurationService) {
    if (autoIndent < 4 ) {
        return null;
    }
    model.tokenization.forceTokenization(range.startLineNumber);
    const lineTokens = model.tokenization.getLineTokens(range.startLineNumber);
    const scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);
    const scopedLineText = scopedLineTokens.getLineContent();
    let embeddedLanguage = false;
    let beforeEnterText;
    if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {
        embeddedLanguage = true;
        beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);
    }
    else {
        beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);
    }
    let afterEnterText;
    if (range.isEmpty()) {
        afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);
    }
    else {
        const endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);
        afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);
    }
    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).indentRulesSupport;
    if (!indentRulesSupport) {
        return null;
    }
    const beforeEnterResult = beforeEnterText;
    const beforeEnterIndent = getLeadingWhitespace(beforeEnterText);
    const virtualModel = {
        tokenization: {
            getLineTokens: (lineNumber) => {
                return model.tokenization.getLineTokens(lineNumber);
            },
            getLanguageId: () => {
                return model.getLanguageId();
            },
            getLanguageIdAtPosition: (lineNumber, column) => {
                return model.getLanguageIdAtPosition(lineNumber, column);
            },
        },
        getLineContent: (lineNumber) => {
            if (lineNumber === range.startLineNumber) {
                return beforeEnterResult;
            }
            else {
                return model.getLineContent(lineNumber);
            }
        }
    };
    const currentLineIndent = getLeadingWhitespace(lineTokens.getLineContent());
    const afterEnterAction = getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1, undefined, languageConfigurationService);
    if (!afterEnterAction) {
        const beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;
        return {
            beforeEnter: beforeEnter,
            afterEnter: beforeEnter
        };
    }
    let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;
    if (afterEnterAction.action === IndentAction.Indent) {
        afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);
    }
    if (indentRulesSupport.shouldDecrease(afterEnterText)) {
        afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);
    }
    return {
        beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,
        afterEnter: afterEnterIndent
    };
}
function getIndentActionForType(autoIndent, model, range, ch, indentConverter, languageConfigurationService) {
    if (autoIndent < 4 ) {
        return null;
    }
    const scopedLineTokens = getScopedLineTokens(model, range.startLineNumber, range.startColumn);
    if (scopedLineTokens.firstCharOffset) {
        return null;
    }
    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(scopedLineTokens.languageId).indentRulesSupport;
    if (!indentRulesSupport) {
        return null;
    }
    const scopedLineText = scopedLineTokens.getLineContent();
    const beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);
    let afterTypeText;
    if (range.isEmpty()) {
        afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);
    }
    else {
        const endScopedLineTokens = getScopedLineTokens(model, range.endLineNumber, range.endColumn);
        afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);
    }
    if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {
        const r = getInheritIndentForLine(autoIndent, model, range.startLineNumber, false, languageConfigurationService);
        if (!r) {
            return null;
        }
        let indentation = r.indentation;
        if (r.action !== IndentAction.Indent) {
            indentation = indentConverter.unshiftIndent(indentation);
        }
        return indentation;
    }
    return null;
}
function getIndentMetadata(model, lineNumber, languageConfigurationService) {
    const indentRulesSupport = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).indentRulesSupport;
    if (!indentRulesSupport) {
        return null;
    }
    if (lineNumber < 1 || lineNumber > model.getLineCount()) {
        return null;
    }
    return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));
}
export { getGoodIndentForLine, getIndentActionForType, getIndentForEnter, getIndentMetadata, getInheritIndentForLine };
