import { registerEditorCommand, registerEditorAction, EditorCommand, EditorAction } from '../../../browser/editorExtensions.js';
import { ReplaceCommand } from '../../../common/commands/replaceCommand.js';
import { EditorOptions } from '../../../common/config/editorOptions.js';
import { CursorState } from '../../../common/cursorCommon.js';
import { WordOperations } from '../../../common/cursor/cursorWordOperations.js';
import { getMapForWordSeparators } from '../../../common/core/wordCharacterClassifier.js';
import { Position } from '../../../common/core/position.js';
import { Range } from '../../../common/core/range.js';
import { Selection } from '../../../common/core/selection.js';
import { EditorContextKeys } from '../../../common/editorContextKeys.js';
import { ILanguageConfigurationService } from '../../../common/languages/languageConfigurationRegistry.js';
import { localizeWithPath } from '../../../../nls.js';
import { CONTEXT_ACCESSIBILITY_MODE_ENABLED } from '../../../../platform/accessibility/common/accessibility.js';
import { ContextKeyExpr } from '../../../../platform/contextkey/common/contextkey.js';
import { IsWindowsContext } from '../../../../platform/contextkey/common/contextkeys.js';
const _moduleId = "vs/editor/contrib/wordOperations/browser/wordOperations";
class MoveWordCommand extends EditorCommand {
    constructor(opts) {
        super(opts);
        this._inSelectionMode = opts.inSelectionMode;
        this._wordNavigationType = opts.wordNavigationType;
    }
    runEditorCommand(accessor, editor, args) {
        if (!editor.hasModel()) {
            return;
        }
        const wordSeparators = getMapForWordSeparators(editor.getOption(131 ), editor.getOption(130 ));
        const model = editor.getModel();
        const selections = editor.getSelections();
        const result = ( (selections.map((sel) => {
            const inPosition = ( (new Position(sel.positionLineNumber, sel.positionColumn)));
            const outPosition = this._move(wordSeparators, model, inPosition, this._wordNavigationType);
            return this._moveTo(sel, outPosition, this._inSelectionMode);
        })));
        model.pushStackElement();
        editor._getViewModel().setCursorStates('moveWordCommand', 3 , ( (result.map(r => CursorState.fromModelSelection(r)))));
        if (result.length === 1) {
            const pos = ( (new Position(result[0].positionLineNumber, result[0].positionColumn)));
            editor.revealPosition(pos, 0 );
        }
    }
    _moveTo(from, to, inSelectionMode) {
        if (inSelectionMode) {
            return (
                 (new Selection(
                    from.selectionStartLineNumber,
                    from.selectionStartColumn,
                    to.lineNumber,
                    to.column
                ))
            );
        }
        else {
            return (
                 (new Selection(to.lineNumber, to.column, to.lineNumber, to.column))
            );
        }
    }
}
class WordLeftCommand extends MoveWordCommand {
    _move(wordSeparators, model, position, wordNavigationType) {
        return WordOperations.moveWordLeft(wordSeparators, model, position, wordNavigationType);
    }
}
class WordRightCommand extends MoveWordCommand {
    _move(wordSeparators, model, position, wordNavigationType) {
        return WordOperations.moveWordRight(wordSeparators, model, position, wordNavigationType);
    }
}
class CursorWordStartLeft extends WordLeftCommand {
    constructor() {
        super({
            inSelectionMode: false,
            wordNavigationType: 0 ,
            id: 'cursorWordStartLeft',
            precondition: undefined
        });
    }
}
class CursorWordEndLeft extends WordLeftCommand {
    constructor() {
        super({
            inSelectionMode: false,
            wordNavigationType: 2 ,
            id: 'cursorWordEndLeft',
            precondition: undefined
        });
    }
}
class CursorWordLeft extends WordLeftCommand {
    constructor() {
        super({
            inSelectionMode: false,
            wordNavigationType: 1 ,
            id: 'cursorWordLeft',
            precondition: undefined,
            kbOpts: {
                kbExpr: ( (ContextKeyExpr.and(
                    EditorContextKeys.textInputFocus,
                    ( (ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)))?.negate()
                ))),
                primary: 2048  | 15 ,
                mac: { primary: 512  | 15  },
                weight: 100
            }
        });
    }
}
class CursorWordStartLeftSelect extends WordLeftCommand {
    constructor() {
        super({
            inSelectionMode: true,
            wordNavigationType: 0 ,
            id: 'cursorWordStartLeftSelect',
            precondition: undefined
        });
    }
}
class CursorWordEndLeftSelect extends WordLeftCommand {
    constructor() {
        super({
            inSelectionMode: true,
            wordNavigationType: 2 ,
            id: 'cursorWordEndLeftSelect',
            precondition: undefined
        });
    }
}
class CursorWordLeftSelect extends WordLeftCommand {
    constructor() {
        super({
            inSelectionMode: true,
            wordNavigationType: 1 ,
            id: 'cursorWordLeftSelect',
            precondition: undefined,
            kbOpts: {
                kbExpr: ( (ContextKeyExpr.and(
                    EditorContextKeys.textInputFocus,
                    ( (ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)))?.negate()
                ))),
                primary: 2048  | 1024  | 15 ,
                mac: { primary: 512  | 1024  | 15  },
                weight: 100
            }
        });
    }
}
class CursorWordAccessibilityLeft extends WordLeftCommand {
    constructor() {
        super({
            inSelectionMode: false,
            wordNavigationType: 3 ,
            id: 'cursorWordAccessibilityLeft',
            precondition: undefined
        });
    }
    _move(wordCharacterClassifier, model, position, wordNavigationType) {
        return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue, wordCharacterClassifier.intlSegmenterLocales), model, position, wordNavigationType);
    }
}
class CursorWordAccessibilityLeftSelect extends WordLeftCommand {
    constructor() {
        super({
            inSelectionMode: true,
            wordNavigationType: 3 ,
            id: 'cursorWordAccessibilityLeftSelect',
            precondition: undefined
        });
    }
    _move(wordCharacterClassifier, model, position, wordNavigationType) {
        return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue, wordCharacterClassifier.intlSegmenterLocales), model, position, wordNavigationType);
    }
}
class CursorWordStartRight extends WordRightCommand {
    constructor() {
        super({
            inSelectionMode: false,
            wordNavigationType: 0 ,
            id: 'cursorWordStartRight',
            precondition: undefined
        });
    }
}
class CursorWordEndRight extends WordRightCommand {
    constructor() {
        super({
            inSelectionMode: false,
            wordNavigationType: 2 ,
            id: 'cursorWordEndRight',
            precondition: undefined,
            kbOpts: {
                kbExpr: ( (ContextKeyExpr.and(
                    EditorContextKeys.textInputFocus,
                    ( (ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)))?.negate()
                ))),
                primary: 2048  | 17 ,
                mac: { primary: 512  | 17  },
                weight: 100
            }
        });
    }
}
class CursorWordRight extends WordRightCommand {
    constructor() {
        super({
            inSelectionMode: false,
            wordNavigationType: 2 ,
            id: 'cursorWordRight',
            precondition: undefined
        });
    }
}
class CursorWordStartRightSelect extends WordRightCommand {
    constructor() {
        super({
            inSelectionMode: true,
            wordNavigationType: 0 ,
            id: 'cursorWordStartRightSelect',
            precondition: undefined
        });
    }
}
class CursorWordEndRightSelect extends WordRightCommand {
    constructor() {
        super({
            inSelectionMode: true,
            wordNavigationType: 2 ,
            id: 'cursorWordEndRightSelect',
            precondition: undefined,
            kbOpts: {
                kbExpr: ( (ContextKeyExpr.and(
                    EditorContextKeys.textInputFocus,
                    ( (ContextKeyExpr.and(CONTEXT_ACCESSIBILITY_MODE_ENABLED, IsWindowsContext)))?.negate()
                ))),
                primary: 2048  | 1024  | 17 ,
                mac: { primary: 512  | 1024  | 17  },
                weight: 100
            }
        });
    }
}
class CursorWordRightSelect extends WordRightCommand {
    constructor() {
        super({
            inSelectionMode: true,
            wordNavigationType: 2 ,
            id: 'cursorWordRightSelect',
            precondition: undefined
        });
    }
}
class CursorWordAccessibilityRight extends WordRightCommand {
    constructor() {
        super({
            inSelectionMode: false,
            wordNavigationType: 3 ,
            id: 'cursorWordAccessibilityRight',
            precondition: undefined
        });
    }
    _move(wordCharacterClassifier, model, position, wordNavigationType) {
        return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue, wordCharacterClassifier.intlSegmenterLocales), model, position, wordNavigationType);
    }
}
class CursorWordAccessibilityRightSelect extends WordRightCommand {
    constructor() {
        super({
            inSelectionMode: true,
            wordNavigationType: 3 ,
            id: 'cursorWordAccessibilityRightSelect',
            precondition: undefined
        });
    }
    _move(wordCharacterClassifier, model, position, wordNavigationType) {
        return super._move(getMapForWordSeparators(EditorOptions.wordSeparators.defaultValue, wordCharacterClassifier.intlSegmenterLocales), model, position, wordNavigationType);
    }
}
class DeleteWordCommand extends EditorCommand {
    constructor(opts) {
        super(opts);
        this._whitespaceHeuristics = opts.whitespaceHeuristics;
        this._wordNavigationType = opts.wordNavigationType;
    }
    runEditorCommand(accessor, editor, args) {
        const languageConfigurationService = accessor.get(ILanguageConfigurationService);
        if (!editor.hasModel()) {
            return;
        }
        const wordSeparators = getMapForWordSeparators(editor.getOption(131 ), editor.getOption(130 ));
        const model = editor.getModel();
        const selections = editor.getSelections();
        const autoClosingBrackets = editor.getOption(6 );
        const autoClosingQuotes = editor.getOption(11 );
        const autoClosingPairs = languageConfigurationService.getLanguageConfiguration(model.getLanguageId()).getAutoClosingPairs();
        const viewModel = editor._getViewModel();
        const commands = ( (selections.map((sel) => {
            const deleteRange = this._delete({
                wordSeparators,
                model,
                selection: sel,
                whitespaceHeuristics: this._whitespaceHeuristics,
                autoClosingDelete: editor.getOption(9 ),
                autoClosingBrackets,
                autoClosingQuotes,
                autoClosingPairs,
                autoClosedCharacters: viewModel.getCursorAutoClosedCharacters(),
            }, this._wordNavigationType);
            return (
                 (new ReplaceCommand(deleteRange, ''))
            );
        })));
        editor.pushUndoStop();
        editor.executeCommands(this.id, commands);
        editor.pushUndoStop();
    }
}
class DeleteWordLeftCommand extends DeleteWordCommand {
    _delete(ctx, wordNavigationType) {
        const r = WordOperations.deleteWordLeft(ctx, wordNavigationType);
        if (r) {
            return r;
        }
        return (
             (new Range(1, 1, 1, 1))
        );
    }
}
class DeleteWordRightCommand extends DeleteWordCommand {
    _delete(ctx, wordNavigationType) {
        const r = WordOperations.deleteWordRight(ctx, wordNavigationType);
        if (r) {
            return r;
        }
        const lineCount = ctx.model.getLineCount();
        const maxColumn = ctx.model.getLineMaxColumn(lineCount);
        return (
             (new Range(lineCount, maxColumn, lineCount, maxColumn))
        );
    }
}
class DeleteWordStartLeft extends DeleteWordLeftCommand {
    constructor() {
        super({
            whitespaceHeuristics: false,
            wordNavigationType: 0 ,
            id: 'deleteWordStartLeft',
            precondition: EditorContextKeys.writable
        });
    }
}
class DeleteWordEndLeft extends DeleteWordLeftCommand {
    constructor() {
        super({
            whitespaceHeuristics: false,
            wordNavigationType: 2 ,
            id: 'deleteWordEndLeft',
            precondition: EditorContextKeys.writable
        });
    }
}
class DeleteWordLeft extends DeleteWordLeftCommand {
    constructor() {
        super({
            whitespaceHeuristics: true,
            wordNavigationType: 0 ,
            id: 'deleteWordLeft',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.textInputFocus,
                primary: 2048  | 1 ,
                mac: { primary: 512  | 1  },
                weight: 100
            }
        });
    }
}
class DeleteWordStartRight extends DeleteWordRightCommand {
    constructor() {
        super({
            whitespaceHeuristics: false,
            wordNavigationType: 0 ,
            id: 'deleteWordStartRight',
            precondition: EditorContextKeys.writable
        });
    }
}
class DeleteWordEndRight extends DeleteWordRightCommand {
    constructor() {
        super({
            whitespaceHeuristics: false,
            wordNavigationType: 2 ,
            id: 'deleteWordEndRight',
            precondition: EditorContextKeys.writable
        });
    }
}
class DeleteWordRight extends DeleteWordRightCommand {
    constructor() {
        super({
            whitespaceHeuristics: true,
            wordNavigationType: 2 ,
            id: 'deleteWordRight',
            precondition: EditorContextKeys.writable,
            kbOpts: {
                kbExpr: EditorContextKeys.textInputFocus,
                primary: 2048  | 20 ,
                mac: { primary: 512  | 20  },
                weight: 100
            }
        });
    }
}
class DeleteInsideWord extends EditorAction {
    constructor() {
        super({
            id: 'deleteInsideWord',
            precondition: EditorContextKeys.writable,
            label: ( localizeWithPath(_moduleId, 0, "Delete Word")),
            alias: 'Delete Word'
        });
    }
    run(accessor, editor, args) {
        if (!editor.hasModel()) {
            return;
        }
        const wordSeparators = getMapForWordSeparators(editor.getOption(131 ), editor.getOption(130 ));
        const model = editor.getModel();
        const selections = editor.getSelections();
        const commands = ( (selections.map((sel) => {
            const deleteRange = WordOperations.deleteInsideWord(wordSeparators, model, sel);
            return (
                 (new ReplaceCommand(deleteRange, ''))
            );
        })));
        editor.pushUndoStop();
        editor.executeCommands(this.id, commands);
        editor.pushUndoStop();
    }
}
registerEditorCommand(( (new CursorWordStartLeft())));
registerEditorCommand(( (new CursorWordEndLeft())));
registerEditorCommand(( (new CursorWordLeft())));
registerEditorCommand(( (new CursorWordStartLeftSelect())));
registerEditorCommand(( (new CursorWordEndLeftSelect())));
registerEditorCommand(( (new CursorWordLeftSelect())));
registerEditorCommand(( (new CursorWordStartRight())));
registerEditorCommand(( (new CursorWordEndRight())));
registerEditorCommand(( (new CursorWordRight())));
registerEditorCommand(( (new CursorWordStartRightSelect())));
registerEditorCommand(( (new CursorWordEndRightSelect())));
registerEditorCommand(( (new CursorWordRightSelect())));
registerEditorCommand(( (new CursorWordAccessibilityLeft())));
registerEditorCommand(( (new CursorWordAccessibilityLeftSelect())));
registerEditorCommand(( (new CursorWordAccessibilityRight())));
registerEditorCommand(( (new CursorWordAccessibilityRightSelect())));
registerEditorCommand(( (new DeleteWordStartLeft())));
registerEditorCommand(( (new DeleteWordEndLeft())));
registerEditorCommand(( (new DeleteWordLeft())));
registerEditorCommand(( (new DeleteWordStartRight())));
registerEditorCommand(( (new DeleteWordEndRight())));
registerEditorCommand(( (new DeleteWordRight())));
registerEditorAction(DeleteInsideWord);
export { CursorWordAccessibilityLeft, CursorWordAccessibilityLeftSelect, CursorWordAccessibilityRight, CursorWordAccessibilityRightSelect, CursorWordEndLeft, CursorWordEndLeftSelect, CursorWordEndRight, CursorWordEndRightSelect, CursorWordLeft, CursorWordLeftSelect, CursorWordRight, CursorWordRightSelect, CursorWordStartLeft, CursorWordStartLeftSelect, CursorWordStartRight, CursorWordStartRightSelect, DeleteInsideWord, DeleteWordCommand, DeleteWordEndLeft, DeleteWordEndRight, DeleteWordLeft, DeleteWordLeftCommand, DeleteWordRight, DeleteWordRightCommand, DeleteWordStartLeft, DeleteWordStartRight, MoveWordCommand, WordLeftCommand, WordRightCommand };
