import { RunOnceScheduler, createCancelableAsyncIterable } from '../../../../base/common/async.js';
import { onUnexpectedError } from '../../../../base/common/errors.js';
import { Emitter } from '../../../../base/common/event.js';
import { Disposable } from '../../../../base/common/lifecycle.js';
class HoverResult {
    constructor(value, isComplete, hasLoadingMessage) {
        this.value = value;
        this.isComplete = isComplete;
        this.hasLoadingMessage = hasLoadingMessage;
    }
}
class HoverOperation extends Disposable {
    constructor(_editor, _computer) {
        super();
        this._editor = _editor;
        this._computer = _computer;
        this._onResult = this._register(( new Emitter()));
        this.onResult = this._onResult.event;
        this._firstWaitScheduler = this._register(( new RunOnceScheduler(() => this._triggerAsyncComputation(), 0)));
        this._secondWaitScheduler = this._register(( new RunOnceScheduler(() => this._triggerSyncComputation(), 0)));
        this._loadingMessageScheduler = this._register(( new RunOnceScheduler(() => this._triggerLoadingMessage(), 0)));
        this._state = 0 ;
        this._asyncIterable = null;
        this._asyncIterableDone = false;
        this._result = [];
    }
    dispose() {
        if (this._asyncIterable) {
            this._asyncIterable.cancel();
            this._asyncIterable = null;
        }
        super.dispose();
    }
    get _hoverTime() {
        return this._editor.getOption(60 ).delay;
    }
    get _firstWaitTime() {
        return this._hoverTime / 2;
    }
    get _secondWaitTime() {
        return this._hoverTime - this._firstWaitTime;
    }
    get _loadingMessageTime() {
        return 3 * this._hoverTime;
    }
    _setState(state, fireResult = true) {
        this._state = state;
        if (fireResult) {
            this._fireResult();
        }
    }
    _triggerAsyncComputation() {
        this._setState(2 );
        this._secondWaitScheduler.schedule(this._secondWaitTime);
        if (this._computer.computeAsync) {
            this._asyncIterableDone = false;
            this._asyncIterable = createCancelableAsyncIterable(token => this._computer.computeAsync(token));
            (async () => {
                try {
                    for await (const item of this._asyncIterable) {
                        if (item) {
                            this._result.push(item);
                            this._fireResult();
                        }
                    }
                    this._asyncIterableDone = true;
                    if (this._state === 3  || this._state === 4 ) {
                        this._setState(0 );
                    }
                }
                catch (e) {
                    onUnexpectedError(e);
                }
            })();
        }
        else {
            this._asyncIterableDone = true;
        }
    }
    _triggerSyncComputation() {
        if (this._computer.computeSync) {
            this._result = this._result.concat(this._computer.computeSync());
        }
        this._setState(this._asyncIterableDone ? 0  : 3 );
    }
    _triggerLoadingMessage() {
        if (this._state === 3 ) {
            this._setState(4 );
        }
    }
    _fireResult() {
        if (this._state === 1  || this._state === 2 ) {
            return;
        }
        const isComplete = ((this._state === 0) );
        const hasLoadingMessage = ((this._state === 4) );
        this._onResult.fire(( new HoverResult(this._result.slice(0), isComplete, hasLoadingMessage)));
    }
    start(mode) {
        if (mode === 0 ) {
            if (this._state === 0 ) {
                this._setState(1 );
                this._firstWaitScheduler.schedule(this._firstWaitTime);
                this._loadingMessageScheduler.schedule(this._loadingMessageTime);
            }
        }
        else {
            switch (this._state) {
                case 0 :
                    this._triggerAsyncComputation();
                    this._secondWaitScheduler.cancel();
                    this._triggerSyncComputation();
                    break;
                case 2 :
                    this._secondWaitScheduler.cancel();
                    this._triggerSyncComputation();
                    break;
            }
        }
    }
    cancel() {
        this._firstWaitScheduler.cancel();
        this._secondWaitScheduler.cancel();
        this._loadingMessageScheduler.cancel();
        if (this._asyncIterable) {
            this._asyncIterable.cancel();
            this._asyncIterable = null;
        }
        this._result = [];
        this._setState(0 , false);
    }
}
export { HoverOperation, HoverResult };
