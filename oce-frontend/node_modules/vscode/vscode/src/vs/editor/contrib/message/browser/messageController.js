import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { renderMarkdown } from '../../../../base/browser/markdownRenderer.js';
import { alert } from '../../../../base/browser/ui/aria/aria.js';
import { Event } from '../../../../base/common/event.js';
import { isMarkdownString } from '../../../../base/common/htmlContent.js';
import { MutableDisposable, DisposableStore } from '../../../../base/common/lifecycle.js';
import './messageController.css.js';
import { registerEditorCommand, registerEditorContribution, EditorCommand } from '../../../browser/editorExtensions.js';
import { Range } from '../../../common/core/range.js';
import { openLinkFromMarkdown } from '../../../browser/widget/markdownRenderer/browser/markdownRenderer.js';
import { localizeWithPath } from '../../../../nls.js';
import { RawContextKey } from '../../../../platform/contextkey/common/contextkey.js';
import { IContextKeyService } from '../../../../platform/contextkey/common/contextkey.service.js';
import { IOpenerService } from '../../../../platform/opener/common/opener.service.js';
import { isAncestor, getActiveElement, addDisposableListener, EventType } from '../../../../base/browser/dom.js';
var MessageController_1;
const _moduleId = "vs/editor/contrib/message/browser/messageController";
let MessageController = class MessageController {
    static { MessageController_1 = this; }
    static { this.ID = 'editor.contrib.messageController'; }
    static { this.MESSAGE_VISIBLE = ( (new RawContextKey('messageVisible', false, ( localizeWithPath(_moduleId, 0, 'Whether the editor is currently showing an inline message'))))); }
    static get(editor) {
        return editor.getContribution(MessageController_1.ID);
    }
    constructor(editor, contextKeyService, _openerService) {
        this._openerService = _openerService;
        this._messageWidget = ( (new MutableDisposable()));
        this._messageListeners = ( (new DisposableStore()));
        this._mouseOverMessage = false;
        this._editor = editor;
        this._visible = MessageController_1.MESSAGE_VISIBLE.bindTo(contextKeyService);
    }
    dispose() {
        this._message?.dispose();
        this._messageListeners.dispose();
        this._messageWidget.dispose();
        this._visible.reset();
    }
    isVisible() {
        return this._visible.get();
    }
    showMessage(message, position) {
        alert(isMarkdownString(message) ? message.value : message);
        this._visible.set(true);
        this._messageWidget.clear();
        this._messageListeners.clear();
        this._message = isMarkdownString(message) ? renderMarkdown(message, {
            actionHandler: {
                callback: (url) => {
                    this.closeMessage();
                    openLinkFromMarkdown(this._openerService, url, isMarkdownString(message) ? message.isTrusted : undefined);
                },
                disposables: this._messageListeners
            },
        }) : undefined;
        this._messageWidget.value = ( (new MessageWidget(
            this._editor,
            position,
            typeof message === 'string' ? message : this._message.element
        )));
        this._messageListeners.add(Event.debounce(this._editor.onDidBlurEditorText, (last, event) => event, 0)(() => {
            if (this._mouseOverMessage) {
                return;
            }
            if (this._messageWidget.value && isAncestor(getActiveElement(), this._messageWidget.value.getDomNode())) {
                return;
            }
            this.closeMessage();
        }));
        this._messageListeners.add(this._editor.onDidChangeCursorPosition(() => this.closeMessage()));
        this._messageListeners.add(this._editor.onDidDispose(() => this.closeMessage()));
        this._messageListeners.add(this._editor.onDidChangeModel(() => this.closeMessage()));
        this._messageListeners.add(addDisposableListener(this._messageWidget.value.getDomNode(), EventType.MOUSE_ENTER, () => this._mouseOverMessage = true, true));
        this._messageListeners.add(addDisposableListener(this._messageWidget.value.getDomNode(), EventType.MOUSE_LEAVE, () => this._mouseOverMessage = false, true));
        let bounds;
        this._messageListeners.add(this._editor.onMouseMove(e => {
            if (!e.target.position) {
                return;
            }
            if (!bounds) {
                bounds = ( (new Range(position.lineNumber - 3, 1, e.target.position.lineNumber + 3, 1)));
            }
            else if (!bounds.containsPosition(e.target.position)) {
                this.closeMessage();
            }
        }));
    }
    closeMessage() {
        this._visible.reset();
        this._messageListeners.clear();
        if (this._messageWidget.value) {
            this._messageListeners.add(MessageWidget.fadeOut(this._messageWidget.value));
        }
    }
};
MessageController = MessageController_1 = ( (__decorate([
    ( (__param(1, IContextKeyService))),
    ( (__param(2, IOpenerService)))
], MessageController)));
const MessageCommand = EditorCommand.bindToContribution(MessageController.get);
registerEditorCommand(( (new MessageCommand({
    id: 'leaveEditorMessage',
    precondition: MessageController.MESSAGE_VISIBLE,
    handler: c => c.closeMessage(),
    kbOpts: {
        weight: 100  + 30,
        primary: 9
    }
}))));
class MessageWidget {
    static fadeOut(messageWidget) {
        const dispose = () => {
            messageWidget.dispose();
            clearTimeout(handle);
            messageWidget.getDomNode().removeEventListener('animationend', dispose);
        };
        const handle = setTimeout(dispose, 110);
        messageWidget.getDomNode().addEventListener('animationend', dispose);
        messageWidget.getDomNode().classList.add('fadeOut');
        return { dispose };
    }
    constructor(editor, { lineNumber, column }, text) {
        this.allowEditorOverflow = true;
        this.suppressMouseDown = false;
        this._editor = editor;
        this._editor.revealLinesInCenterIfOutsideViewport(lineNumber, lineNumber, 0 );
        this._position = { lineNumber, column };
        this._domNode = document.createElement('div');
        this._domNode.classList.add('monaco-editor-overlaymessage');
        this._domNode.style.marginLeft = '-6px';
        const anchorTop = document.createElement('div');
        anchorTop.classList.add('anchor', 'top');
        this._domNode.appendChild(anchorTop);
        const message = document.createElement('div');
        if (typeof text === 'string') {
            message.classList.add('message');
            message.textContent = text;
        }
        else {
            text.classList.add('message');
            message.appendChild(text);
        }
        this._domNode.appendChild(message);
        const anchorBottom = document.createElement('div');
        anchorBottom.classList.add('anchor', 'below');
        this._domNode.appendChild(anchorBottom);
        this._editor.addContentWidget(this);
        this._domNode.classList.add('fadeIn');
    }
    dispose() {
        this._editor.removeContentWidget(this);
    }
    getId() {
        return 'messageoverlay';
    }
    getDomNode() {
        return this._domNode;
    }
    getPosition() {
        return {
            position: this._position,
            preference: [
                1 ,
                2 ,
            ],
            positionAffinity: 1 ,
        };
    }
    afterRender(position) {
        this._domNode.classList.toggle('below', position === 2 );
    }
}
registerEditorContribution(MessageController.ID, MessageController, 4 );
export { MessageController };
