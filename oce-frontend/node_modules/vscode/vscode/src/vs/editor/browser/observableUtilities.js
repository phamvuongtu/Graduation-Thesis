import { DisposableStore } from '../../base/common/lifecycle.js';
import '../../base/common/arrays.js';
import { derivedOpts } from '../../base/common/observableInternal/derived.js';
import { autorunOpts } from '../../base/common/observableInternal/autorun.js';
import { observableFromEvent } from '../../base/common/observableInternal/utils.js';
import '../../base/common/cancellation.js';
import { Position } from '../common/core/position.js';
function obsCodeEditor(editor) {
    return ObservableCodeEditor.get(editor);
}
class ObservableCodeEditor {
    static { this._map = ( new Map()); }
    static get(editor) {
        let result = ObservableCodeEditor._map.get(editor);
        if (!result) {
            result = ( new ObservableCodeEditor(editor));
            ObservableCodeEditor._map.set(editor, result);
            const d = editor.onDidDispose(() => {
                ObservableCodeEditor._map.delete(editor);
                d.dispose();
            });
        }
        return result;
    }
    constructor(editor) {
        this.editor = editor;
        this.model = observableFromEvent(this.editor.onDidChangeModel, () => this.editor.getModel());
        this.value = observableFromEvent(this.editor.onDidChangeModelContent, () => this.editor.getValue());
        this.valueIsEmpty = observableFromEvent(this.editor.onDidChangeModelContent, () => this.editor.getModel()?.getValueLength() === 0);
        this.selections = observableFromEvent(this.editor.onDidChangeCursorSelection, () => this.editor.getSelections());
        this.cursorPosition = derivedOpts({ owner: this, equalsFn: Position.equals }, reader => this.selections.read(reader)?.[0]?.getPosition() ?? null);
        this.isFocused = observableFromEvent(e => {
            const d1 = this.editor.onDidFocusEditorWidget(e);
            const d2 = this.editor.onDidBlurEditorWidget(e);
            return {
                dispose() {
                    d1.dispose();
                    d2.dispose();
                }
            };
        }, () => this.editor.hasWidgetFocus());
    }
    setDecorations(decorations) {
        const d = ( new DisposableStore());
        const decorationsCollection = this.editor.createDecorationsCollection();
        d.add(autorunOpts({ owner: this, debugName: () => `Apply decorations from ${decorations.debugName}` }, reader => {
            const d = decorations.read(reader);
            decorationsCollection.set(d);
        }));
        d.add({
            dispose: () => {
                decorationsCollection.clear();
            }
        });
        return d;
    }
}
export { obsCodeEditor };
