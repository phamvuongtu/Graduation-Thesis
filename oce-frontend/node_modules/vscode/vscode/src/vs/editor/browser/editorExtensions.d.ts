import { ICodeEditor, IDiffEditor } from './editorBrowser.js';
import { IEditorContribution } from '../common/editorCommon.js';
import '../editor.api.js';
import { IDisposable } from '../../base/common/lifecycle.js';
import { ThemeIcon } from '../../base/common/themables.js';
import { ContextKeyExpression } from '../../platform/contextkey/common/contextkey.js';
import { ICommandMetadata } from '../../platform/commands/common/commands.js';
import { BrandedService, ServicesAccessor as ServicesAccessor$1 } from '../../platform/instantiation/common/instantiation.js';
import { MenuId } from '../../platform/actions/common/actions.js';
import { IKeybindings } from '../../platform/keybinding/common/keybindingsRegistry.js';

type ServicesAccessor = ServicesAccessor$1;
declare const enum EditorContributionInstantiation {
    /**
     * The contribution is created eagerly when the {@linkcode ICodeEditor} is instantiated.
     * Only Eager contributions can participate in saving or restoring of view state.
     */
    Eager = 0,
    /**
     * The contribution is created at the latest 50ms after the first render after attaching a text model.
     * If the contribution is explicitly requested via `getContribution`, it will be instantiated sooner.
     * If there is idle time available, it will be instantiated sooner.
     */
    AfterFirstRender = 1,
    /**
     * The contribution is created before the editor emits events produced by user interaction (mouse events, keyboard events).
     * If the contribution is explicitly requested via `getContribution`, it will be instantiated sooner.
     * If there is idle time available, it will be instantiated sooner.
     */
    BeforeFirstInteraction = 2,
    /**
     * The contribution is created when there is idle time available, at the latest 5000ms after the editor creation.
     * If the contribution is explicitly requested via `getContribution`, it will be instantiated sooner.
     */
    Eventually = 3,
    /**
     * The contribution is created only when explicitly requested via `getContribution`.
     */
    Lazy = 4
}
interface ICommandKeybindingsOptions extends IKeybindings {
    kbExpr?: ContextKeyExpression | null;
    weight: number;
    /**
     * the default keybinding arguments
     */
    args?: any;
}
interface ICommandMenuOptions {
    menuId: MenuId;
    group: string;
    order: number;
    when?: ContextKeyExpression;
    title: string;
    icon?: ThemeIcon;
}
interface ICommandOptions {
    id: string;
    precondition: ContextKeyExpression | undefined;
    kbOpts?: ICommandKeybindingsOptions | ICommandKeybindingsOptions[];
    metadata?: ICommandMetadata;
    menuOpts?: ICommandMenuOptions | ICommandMenuOptions[];
}
declare abstract class Command {
    readonly id: string;
    readonly precondition: ContextKeyExpression | undefined;
    private readonly _kbOpts;
    private readonly _menuOpts;
    readonly metadata: ICommandMetadata | undefined;
    constructor(opts: ICommandOptions);
    register(): void;
    private _registerMenuItem;
    abstract runCommand(accessor: ServicesAccessor, args: any): void | Promise<void>;
}
interface IContributionCommandOptions<T> extends ICommandOptions {
    handler: (controller: T, args: any) => void;
}
interface EditorControllerCommand<T extends IEditorContribution> {
    new (opts: IContributionCommandOptions<T>): EditorCommand;
}
declare abstract class EditorCommand extends Command {
    /**
     * Create a command class that is bound to a certain editor contribution.
     */
    static bindToContribution<T extends IEditorContribution>(controllerGetter: (editor: ICodeEditor) => T | null): EditorControllerCommand<T>;
    static runEditorCommand(accessor: ServicesAccessor, args: any, precondition: ContextKeyExpression | undefined, runner: (accessor: ServicesAccessor | null, editor: ICodeEditor, args: any) => void | Promise<void>): void | Promise<void>;
    runCommand(accessor: ServicesAccessor, args: any): void | Promise<void>;
    abstract runEditorCommand(accessor: ServicesAccessor | null, editor: ICodeEditor, args: any): void | Promise<void>;
}
interface IEditorActionContextMenuOptions {
    group: string;
    order: number;
    when?: ContextKeyExpression;
    menuId?: MenuId;
}
interface IActionOptions extends ICommandOptions {
    label: string;
    alias: string;
    contextMenuOpts?: IEditorActionContextMenuOptions | IEditorActionContextMenuOptions[];
}
declare abstract class EditorAction extends EditorCommand {
    private static convertOptions;
    readonly label: string;
    readonly alias: string;
    constructor(opts: IActionOptions);
    runEditorCommand(accessor: ServicesAccessor, editor: ICodeEditor, args: any): void | Promise<void>;
    protected reportTelemetry(accessor: ServicesAccessor, editor: ICodeEditor): void;
    abstract run(accessor: ServicesAccessor, editor: ICodeEditor, args: any): void | Promise<void>;
}
type EditorActionImplementation = (accessor: ServicesAccessor, editor: ICodeEditor, args: any) => boolean | Promise<void>;
declare class MultiEditorAction extends EditorAction {
    private readonly _implementations;
    /**
     * A higher priority gets to be looked at first
     */
    addImplementation(priority: number, implementation: EditorActionImplementation): IDisposable;
    run(accessor: ServicesAccessor, editor: ICodeEditor, args: any): void | Promise<void>;
}
declare function registerEditorAction<T extends EditorAction>(ctor: {
    new (): T;
}): T;
declare function registerMultiEditorAction<T extends MultiEditorAction>(action: T): T;
/**
 * Registers an editor contribution. Editor contributions have a lifecycle which is bound
 * to a specific code editor instance.
 */
declare function registerEditorContribution<Services extends BrandedService[]>(id: string, ctor: {
    new (editor: ICodeEditor, ...services: Services): IEditorContribution;
}, instantiation: EditorContributionInstantiation): void;
/**
 * Registers a diff editor contribution. Diff editor contributions have a lifecycle which
 * is bound to a specific diff editor instance.
 */
declare function registerDiffEditorContribution<Services extends BrandedService[]>(id: string, ctor: {
    new (editor: IDiffEditor, ...services: Services): IEditorContribution;
}): void;

export { Command, EditorAction, type EditorActionImplementation, EditorCommand, EditorContributionInstantiation, type EditorControllerCommand, type IActionOptions, type ICommandKeybindingsOptions, type ICommandMenuOptions, type ICommandOptions, type IContributionCommandOptions, type IEditorActionContextMenuOptions, MultiEditorAction, type ServicesAccessor, registerDiffEditorContribution, registerEditorAction, registerEditorContribution, registerMultiEditorAction };
