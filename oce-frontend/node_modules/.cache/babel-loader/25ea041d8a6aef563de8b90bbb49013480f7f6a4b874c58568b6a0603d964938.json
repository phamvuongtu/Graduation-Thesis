{"ast":null,"code":"var _a, _b, _c;\nfunction getOrSet(map, key, value) {\n  let result = map.get(key);\n  if (result === undefined) {\n    result = value;\n    map.set(key, result);\n  }\n  return result;\n}\nclass ResourceMapEntry {\n  constructor(uri, value) {\n    this.uri = uri;\n    this.value = value;\n  }\n}\nfunction isEntries(arg) {\n  return Array.isArray(arg);\n}\nclass ResourceMap {\n  static {\n    this.defaultToKey = resource => resource.toString();\n  }\n  constructor(arg, toKey) {\n    this[_a] = 'ResourceMap';\n    if (arg instanceof ResourceMap) {\n      this.map = new Map(arg.map);\n      this.toKey = toKey ?? ResourceMap.defaultToKey;\n    } else if (isEntries(arg)) {\n      this.map = new Map();\n      this.toKey = toKey ?? ResourceMap.defaultToKey;\n      for (const [resource, value] of arg) {\n        this.set(resource, value);\n      }\n    } else {\n      this.map = new Map();\n      this.toKey = arg ?? ResourceMap.defaultToKey;\n    }\n  }\n  set(resource, value) {\n    this.map.set(this.toKey(resource), new ResourceMapEntry(resource, value));\n    return this;\n  }\n  get(resource) {\n    return this.map.get(this.toKey(resource))?.value;\n  }\n  has(resource) {\n    return this.map.has(this.toKey(resource));\n  }\n  get size() {\n    return this.map.size;\n  }\n  clear() {\n    this.map.clear();\n  }\n  delete(resource) {\n    return this.map.delete(this.toKey(resource));\n  }\n  forEach(clb, thisArg) {\n    if (typeof thisArg !== 'undefined') {\n      clb = clb.bind(thisArg);\n    }\n    for (const [_, entry] of this.map) {\n      clb(entry.value, entry.uri, this);\n    }\n  }\n  *values() {\n    for (const entry of this.map.values()) {\n      yield entry.value;\n    }\n  }\n  *keys() {\n    for (const entry of this.map.values()) {\n      yield entry.uri;\n    }\n  }\n  *entries() {\n    for (const entry of this.map.values()) {\n      yield [entry.uri, entry.value];\n    }\n  }\n  *[(_a = Symbol.toStringTag, Symbol.iterator)]() {\n    for (const [, entry] of this.map) {\n      yield [entry.uri, entry.value];\n    }\n  }\n}\nclass ResourceSet {\n  constructor(entriesOrKey, toKey) {\n    this[_b] = 'ResourceSet';\n    if (!entriesOrKey || typeof entriesOrKey === 'function') {\n      this._map = new ResourceMap(entriesOrKey);\n    } else {\n      this._map = new ResourceMap(toKey);\n      entriesOrKey.forEach(this.add, this);\n    }\n  }\n  get size() {\n    return this._map.size;\n  }\n  add(value) {\n    this._map.set(value, value);\n    return this;\n  }\n  clear() {\n    this._map.clear();\n  }\n  delete(value) {\n    return this._map.delete(value);\n  }\n  forEach(callbackfn, thisArg) {\n    this._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));\n  }\n  has(value) {\n    return this._map.has(value);\n  }\n  entries() {\n    return this._map.entries();\n  }\n  keys() {\n    return this._map.keys();\n  }\n  values() {\n    return this._map.keys();\n  }\n  [(_b = Symbol.toStringTag, Symbol.iterator)]() {\n    return this.keys();\n  }\n}\nclass LinkedMap {\n  constructor() {\n    this[_c] = 'LinkedMap';\n    this._map = new Map();\n    this._head = undefined;\n    this._tail = undefined;\n    this._size = 0;\n    this._state = 0;\n  }\n  clear() {\n    this._map.clear();\n    this._head = undefined;\n    this._tail = undefined;\n    this._size = 0;\n    this._state++;\n  }\n  isEmpty() {\n    return !this._head && !this._tail;\n  }\n  get size() {\n    return this._size;\n  }\n  get first() {\n    return this._head?.value;\n  }\n  get last() {\n    return this._tail?.value;\n  }\n  has(key) {\n    return this._map.has(key);\n  }\n  get(key, touch = 0) {\n    const item = this._map.get(key);\n    if (!item) {\n      return undefined;\n    }\n    if (touch !== 0) {\n      this.touch(item, touch);\n    }\n    return item.value;\n  }\n  set(key, value, touch = 0) {\n    let item = this._map.get(key);\n    if (item) {\n      item.value = value;\n      if (touch !== 0) {\n        this.touch(item, touch);\n      }\n    } else {\n      item = {\n        key,\n        value,\n        next: undefined,\n        previous: undefined\n      };\n      switch (touch) {\n        case 0:\n          this.addItemLast(item);\n          break;\n        case 1:\n          this.addItemFirst(item);\n          break;\n        case 2:\n          this.addItemLast(item);\n          break;\n        default:\n          this.addItemLast(item);\n          break;\n      }\n      this._map.set(key, item);\n      this._size++;\n    }\n    return this;\n  }\n  delete(key) {\n    return !!this.remove(key);\n  }\n  remove(key) {\n    const item = this._map.get(key);\n    if (!item) {\n      return undefined;\n    }\n    this._map.delete(key);\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  }\n  shift() {\n    if (!this._head && !this._tail) {\n      return undefined;\n    }\n    if (!this._head || !this._tail) {\n      throw new Error('Invalid list');\n    }\n    const item = this._head;\n    this._map.delete(item.key);\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  }\n  forEach(callbackfn, thisArg) {\n    const state = this._state;\n    let current = this._head;\n    while (current) {\n      if (thisArg) {\n        callbackfn.bind(thisArg)(current.value, current.key, this);\n      } else {\n        callbackfn(current.value, current.key, this);\n      }\n      if (this._state !== state) {\n        throw new Error(`LinkedMap got modified during iteration.`);\n      }\n      current = current.next;\n    }\n  }\n  keys() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n        if (current) {\n          const result = {\n            value: current.key,\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n    };\n    return iterator;\n  }\n  values() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n        if (current) {\n          const result = {\n            value: current.value,\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n    };\n    return iterator;\n  }\n  entries() {\n    const map = this;\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]() {\n        return iterator;\n      },\n      next() {\n        if (map._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n        if (current) {\n          const result = {\n            value: [current.key, current.value],\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n    };\n    return iterator;\n  }\n  [(_c = Symbol.toStringTag, Symbol.iterator)]() {\n    return this.entries();\n  }\n  trimOld(newSize) {\n    if (newSize >= this.size) {\n      return;\n    }\n    if (newSize === 0) {\n      this.clear();\n      return;\n    }\n    let current = this._head;\n    let currentSize = this.size;\n    while (current && currentSize > newSize) {\n      this._map.delete(current.key);\n      current = current.next;\n      currentSize--;\n    }\n    this._head = current;\n    this._size = currentSize;\n    if (current) {\n      current.previous = undefined;\n    }\n    this._state++;\n  }\n  trimNew(newSize) {\n    if (newSize >= this.size) {\n      return;\n    }\n    if (newSize === 0) {\n      this.clear();\n      return;\n    }\n    let current = this._tail;\n    let currentSize = this.size;\n    while (current && currentSize > newSize) {\n      this._map.delete(current.key);\n      current = current.previous;\n      currentSize--;\n    }\n    this._tail = current;\n    this._size = currentSize;\n    if (current) {\n      current.next = undefined;\n    }\n    this._state++;\n  }\n  addItemFirst(item) {\n    if (!this._head && !this._tail) {\n      this._tail = item;\n    } else if (!this._head) {\n      throw new Error('Invalid list');\n    } else {\n      item.next = this._head;\n      this._head.previous = item;\n    }\n    this._head = item;\n    this._state++;\n  }\n  addItemLast(item) {\n    if (!this._head && !this._tail) {\n      this._head = item;\n    } else if (!this._tail) {\n      throw new Error('Invalid list');\n    } else {\n      item.previous = this._tail;\n      this._tail.next = item;\n    }\n    this._tail = item;\n    this._state++;\n  }\n  removeItem(item) {\n    if (item === this._head && item === this._tail) {\n      this._head = undefined;\n      this._tail = undefined;\n    } else if (item === this._head) {\n      if (!item.next) {\n        throw new Error('Invalid list');\n      }\n      item.next.previous = undefined;\n      this._head = item.next;\n    } else if (item === this._tail) {\n      if (!item.previous) {\n        throw new Error('Invalid list');\n      }\n      item.previous.next = undefined;\n      this._tail = item.previous;\n    } else {\n      const next = item.next;\n      const previous = item.previous;\n      if (!next || !previous) {\n        throw new Error('Invalid list');\n      }\n      next.previous = previous;\n      previous.next = next;\n    }\n    item.next = undefined;\n    item.previous = undefined;\n    this._state++;\n  }\n  touch(item, touch) {\n    if (!this._head || !this._tail) {\n      throw new Error('Invalid list');\n    }\n    if (touch !== 1 && touch !== 2) {\n      return;\n    }\n    if (touch === 1) {\n      if (item === this._head) {\n        return;\n      }\n      const next = item.next;\n      const previous = item.previous;\n      if (item === this._tail) {\n        previous.next = undefined;\n        this._tail = previous;\n      } else {\n        next.previous = previous;\n        previous.next = next;\n      }\n      item.previous = undefined;\n      item.next = this._head;\n      this._head.previous = item;\n      this._head = item;\n      this._state++;\n    } else if (touch === 2) {\n      if (item === this._tail) {\n        return;\n      }\n      const next = item.next;\n      const previous = item.previous;\n      if (item === this._head) {\n        next.previous = undefined;\n        this._head = next;\n      } else {\n        next.previous = previous;\n        previous.next = next;\n      }\n      item.next = undefined;\n      item.previous = this._tail;\n      this._tail.next = item;\n      this._tail = item;\n      this._state++;\n    }\n  }\n  toJSON() {\n    const data = [];\n    this.forEach((value, key) => {\n      data.push([key, value]);\n    });\n    return data;\n  }\n  fromJSON(data) {\n    this.clear();\n    for (const [key, value] of data) {\n      this.set(key, value);\n    }\n  }\n}\nclass Cache extends LinkedMap {\n  constructor(limit, ratio = 1) {\n    super();\n    this._limit = limit;\n    this._ratio = Math.min(Math.max(0, ratio), 1);\n  }\n  get limit() {\n    return this._limit;\n  }\n  set limit(limit) {\n    this._limit = limit;\n    this.checkTrim();\n  }\n  get ratio() {\n    return this._ratio;\n  }\n  set ratio(ratio) {\n    this._ratio = Math.min(Math.max(0, ratio), 1);\n    this.checkTrim();\n  }\n  get(key, touch = 2) {\n    return super.get(key, touch);\n  }\n  peek(key) {\n    return super.get(key, 0);\n  }\n  set(key, value) {\n    super.set(key, value, 2);\n    return this;\n  }\n  checkTrim() {\n    if (this.size > this._limit) {\n      this.trim(Math.round(this._limit * this._ratio));\n    }\n  }\n}\nclass LRUCache extends Cache {\n  constructor(limit, ratio = 1) {\n    super(limit, ratio);\n  }\n  trim(newSize) {\n    this.trimOld(newSize);\n  }\n  set(key, value) {\n    super.set(key, value);\n    this.checkTrim();\n    return this;\n  }\n}\nclass MRUCache extends Cache {\n  constructor(limit, ratio = 1) {\n    super(limit, ratio);\n  }\n  trim(newSize) {\n    this.trimNew(newSize);\n  }\n  set(key, value) {\n    if (this._limit <= this.size && !this.has(key)) {\n      this.trim(Math.round(this._limit * this._ratio) - 1);\n    }\n    super.set(key, value);\n    return this;\n  }\n}\nclass CounterSet {\n  constructor() {\n    this.map = new Map();\n  }\n  add(value) {\n    this.map.set(value, (this.map.get(value) || 0) + 1);\n    return this;\n  }\n  delete(value) {\n    let counter = this.map.get(value) || 0;\n    if (counter === 0) {\n      return false;\n    }\n    counter--;\n    if (counter === 0) {\n      this.map.delete(value);\n    } else {\n      this.map.set(value, counter);\n    }\n    return true;\n  }\n  has(value) {\n    return this.map.has(value);\n  }\n}\nclass BidirectionalMap {\n  constructor(entries) {\n    this._m1 = new Map();\n    this._m2 = new Map();\n    if (entries) {\n      for (const [key, value] of entries) {\n        this.set(key, value);\n      }\n    }\n  }\n  clear() {\n    this._m1.clear();\n    this._m2.clear();\n  }\n  set(key, value) {\n    this._m1.set(key, value);\n    this._m2.set(value, key);\n  }\n  get(key) {\n    return this._m1.get(key);\n  }\n  getKey(value) {\n    return this._m2.get(value);\n  }\n  delete(key) {\n    const value = this._m1.get(key);\n    if (value === undefined) {\n      return false;\n    }\n    this._m1.delete(key);\n    this._m2.delete(value);\n    return true;\n  }\n  forEach(callbackfn, thisArg) {\n    this._m1.forEach((value, key) => {\n      callbackfn.call(thisArg, value, key, this);\n    });\n  }\n  keys() {\n    return this._m1.keys();\n  }\n  values() {\n    return this._m1.values();\n  }\n}\nclass SetMap {\n  constructor() {\n    this.map = new Map();\n  }\n  add(key, value) {\n    let values = this.map.get(key);\n    if (!values) {\n      values = new Set();\n      this.map.set(key, values);\n    }\n    values.add(value);\n  }\n  delete(key, value) {\n    const values = this.map.get(key);\n    if (!values) {\n      return;\n    }\n    values.delete(value);\n    if (values.size === 0) {\n      this.map.delete(key);\n    }\n  }\n  forEach(key, fn) {\n    const values = this.map.get(key);\n    if (!values) {\n      return;\n    }\n    values.forEach(fn);\n  }\n  get(key) {\n    const values = this.map.get(key);\n    if (!values) {\n      return new Set();\n    }\n    return values;\n  }\n}\nfunction mapsStrictEqualIgnoreOrder(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const [key, value] of a) {\n    if (!b.has(key) || b.get(key) !== value) {\n      return false;\n    }\n  }\n  for (const [key] of b) {\n    if (!a.has(key)) {\n      return false;\n    }\n  }\n  return true;\n}\nexport { BidirectionalMap, CounterSet, LRUCache, LinkedMap, MRUCache, ResourceMap, ResourceSet, SetMap, getOrSet, mapsStrictEqualIgnoreOrder };","map":{"version":3,"names":["_a","_b","_c","getOrSet","map","key","value","result","get","undefined","set","ResourceMapEntry","constructor","uri","isEntries","arg","Array","isArray","ResourceMap","defaultToKey","resource","toString","toKey","Map","has","size","clear","delete","forEach","clb","thisArg","bind","_","entry","values","keys","entries","Symbol","toStringTag","iterator","ResourceSet","entriesOrKey","_map","add","callbackfn","_value","call","LinkedMap","_head","_tail","_size","_state","isEmpty","first","last","touch","item","next","previous","addItemLast","addItemFirst","remove","removeItem","shift","Error","state","current","done","trimOld","newSize","currentSize","trimNew","toJSON","data","push","fromJSON","Cache","limit","ratio","_limit","_ratio","Math","min","max","checkTrim","peek","trim","round","LRUCache","MRUCache","CounterSet","counter","BidirectionalMap","_m1","_m2","getKey","SetMap","Set","fn","mapsStrictEqualIgnoreOrder","a","b"],"sources":["/Users/phamtu/Downloads/Code/OCE/oce-frontend/node_modules/vscode/vscode/src/vs/base/common/map.js"],"sourcesContent":["var _a, _b, _c;\nfunction getOrSet(map, key, value) {\n    let result = map.get(key);\n    if (result === undefined) {\n        result = value;\n        map.set(key, result);\n    }\n    return result;\n}\nclass ResourceMapEntry {\n    constructor(uri, value) {\n        this.uri = uri;\n        this.value = value;\n    }\n}\nfunction isEntries(arg) {\n    return Array.isArray(arg);\n}\nclass ResourceMap {\n    static { this.defaultToKey = (resource) => ( resource.toString()); }\n    constructor(arg, toKey) {\n        this[_a] = 'ResourceMap';\n        if (arg instanceof ResourceMap) {\n            this.map = ( new Map(arg.map));\n            this.toKey = toKey ?? ResourceMap.defaultToKey;\n        }\n        else if (isEntries(arg)) {\n            this.map = ( new Map());\n            this.toKey = toKey ?? ResourceMap.defaultToKey;\n            for (const [resource, value] of arg) {\n                this.set(resource, value);\n            }\n        }\n        else {\n            this.map = ( new Map());\n            this.toKey = arg ?? ResourceMap.defaultToKey;\n        }\n    }\n    set(resource, value) {\n        this.map.set(this.toKey(resource), ( new ResourceMapEntry(resource, value)));\n        return this;\n    }\n    get(resource) {\n        return this.map.get(this.toKey(resource))?.value;\n    }\n    has(resource) {\n        return ( this.map.has(this.toKey(resource)));\n    }\n    get size() {\n        return this.map.size;\n    }\n    clear() {\n        this.map.clear();\n    }\n    delete(resource) {\n        return this.map.delete(this.toKey(resource));\n    }\n    forEach(clb, thisArg) {\n        if (typeof thisArg !== 'undefined') {\n            clb = clb.bind(thisArg);\n        }\n        for (const [_, entry] of this.map) {\n            clb(entry.value, entry.uri, this);\n        }\n    }\n    *values() {\n        for (const entry of ( this.map.values())) {\n            yield entry.value;\n        }\n    }\n    *keys() {\n        for (const entry of ( this.map.values())) {\n            yield entry.uri;\n        }\n    }\n    *entries() {\n        for (const entry of ( this.map.values())) {\n            yield [entry.uri, entry.value];\n        }\n    }\n    *[(_a = Symbol.toStringTag, Symbol.iterator)]() {\n        for (const [, entry] of this.map) {\n            yield [entry.uri, entry.value];\n        }\n    }\n}\nclass ResourceSet {\n    constructor(entriesOrKey, toKey) {\n        this[_b] = 'ResourceSet';\n        if (!entriesOrKey || typeof entriesOrKey === 'function') {\n            this._map = ( new ResourceMap(entriesOrKey));\n        }\n        else {\n            this._map = ( new ResourceMap(toKey));\n            entriesOrKey.forEach(this.add, this);\n        }\n    }\n    get size() {\n        return this._map.size;\n    }\n    add(value) {\n        this._map.set(value, value);\n        return this;\n    }\n    clear() {\n        this._map.clear();\n    }\n    delete(value) {\n        return this._map.delete(value);\n    }\n    forEach(callbackfn, thisArg) {\n        this._map.forEach((_value, key) => callbackfn.call(thisArg, key, key, this));\n    }\n    has(value) {\n        return ( this._map.has(value));\n    }\n    entries() {\n        return this._map.entries();\n    }\n    keys() {\n        return ( this._map.keys());\n    }\n    values() {\n        return ( this._map.keys());\n    }\n    [(_b = Symbol.toStringTag, Symbol.iterator)]() {\n        return ( this.keys());\n    }\n}\nclass LinkedMap {\n    constructor() {\n        this[_c] = 'LinkedMap';\n        this._map = ( new Map());\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state = 0;\n    }\n    clear() {\n        this._map.clear();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state++;\n    }\n    isEmpty() {\n        return !this._head && !this._tail;\n    }\n    get size() {\n        return this._size;\n    }\n    get first() {\n        return this._head?.value;\n    }\n    get last() {\n        return this._tail?.value;\n    }\n    has(key) {\n        return ( this._map.has(key));\n    }\n    get(key, touch = 0 ) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        if (touch !== 0 ) {\n            this.touch(item, touch);\n        }\n        return item.value;\n    }\n    set(key, value, touch = 0 ) {\n        let item = this._map.get(key);\n        if (item) {\n            item.value = value;\n            if (touch !== 0 ) {\n                this.touch(item, touch);\n            }\n        }\n        else {\n            item = { key, value, next: undefined, previous: undefined };\n            switch (touch) {\n                case 0 :\n                    this.addItemLast(item);\n                    break;\n                case 1 :\n                    this.addItemFirst(item);\n                    break;\n                case 2 :\n                    this.addItemLast(item);\n                    break;\n                default:\n                    this.addItemLast(item);\n                    break;\n            }\n            this._map.set(key, item);\n            this._size++;\n        }\n        return this;\n    }\n    delete(key) {\n        return !!this.remove(key);\n    }\n    remove(key) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        this._map.delete(key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    shift() {\n        if (!this._head && !this._tail) {\n            return undefined;\n        }\n        if (!this._head || !this._tail) {\n            throw ( new Error('Invalid list'));\n        }\n        const item = this._head;\n        this._map.delete(item.key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    forEach(callbackfn, thisArg) {\n        const state = this._state;\n        let current = this._head;\n        while (current) {\n            if (thisArg) {\n                callbackfn.bind(thisArg)(current.value, current.key, this);\n            }\n            else {\n                callbackfn(current.value, current.key, this);\n            }\n            if (this._state !== state) {\n                throw ( new Error(`LinkedMap got modified during iteration.`));\n            }\n            current = current.next;\n        }\n    }\n    keys() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw ( new Error(`LinkedMap got modified during iteration.`));\n                }\n                if (current) {\n                    const result = { value: current.key, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    values() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw ( new Error(`LinkedMap got modified during iteration.`));\n                }\n                if (current) {\n                    const result = { value: current.value, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    entries() {\n        const map = this;\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]() {\n                return iterator;\n            },\n            next() {\n                if (map._state !== state) {\n                    throw ( new Error(`LinkedMap got modified during iteration.`));\n                }\n                if (current) {\n                    const result = { value: [current.key, current.value], done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    [(_c = Symbol.toStringTag, Symbol.iterator)]() {\n        return this.entries();\n    }\n    trimOld(newSize) {\n        if (newSize >= this.size) {\n            return;\n        }\n        if (newSize === 0) {\n            this.clear();\n            return;\n        }\n        let current = this._head;\n        let currentSize = this.size;\n        while (current && currentSize > newSize) {\n            this._map.delete(current.key);\n            current = current.next;\n            currentSize--;\n        }\n        this._head = current;\n        this._size = currentSize;\n        if (current) {\n            current.previous = undefined;\n        }\n        this._state++;\n    }\n    trimNew(newSize) {\n        if (newSize >= this.size) {\n            return;\n        }\n        if (newSize === 0) {\n            this.clear();\n            return;\n        }\n        let current = this._tail;\n        let currentSize = this.size;\n        while (current && currentSize > newSize) {\n            this._map.delete(current.key);\n            current = current.previous;\n            currentSize--;\n        }\n        this._tail = current;\n        this._size = currentSize;\n        if (current) {\n            current.next = undefined;\n        }\n        this._state++;\n    }\n    addItemFirst(item) {\n        if (!this._head && !this._tail) {\n            this._tail = item;\n        }\n        else if (!this._head) {\n            throw ( new Error('Invalid list'));\n        }\n        else {\n            item.next = this._head;\n            this._head.previous = item;\n        }\n        this._head = item;\n        this._state++;\n    }\n    addItemLast(item) {\n        if (!this._head && !this._tail) {\n            this._head = item;\n        }\n        else if (!this._tail) {\n            throw ( new Error('Invalid list'));\n        }\n        else {\n            item.previous = this._tail;\n            this._tail.next = item;\n        }\n        this._tail = item;\n        this._state++;\n    }\n    removeItem(item) {\n        if (item === this._head && item === this._tail) {\n            this._head = undefined;\n            this._tail = undefined;\n        }\n        else if (item === this._head) {\n            if (!item.next) {\n                throw ( new Error('Invalid list'));\n            }\n            item.next.previous = undefined;\n            this._head = item.next;\n        }\n        else if (item === this._tail) {\n            if (!item.previous) {\n                throw ( new Error('Invalid list'));\n            }\n            item.previous.next = undefined;\n            this._tail = item.previous;\n        }\n        else {\n            const next = item.next;\n            const previous = item.previous;\n            if (!next || !previous) {\n                throw ( new Error('Invalid list'));\n            }\n            next.previous = previous;\n            previous.next = next;\n        }\n        item.next = undefined;\n        item.previous = undefined;\n        this._state++;\n    }\n    touch(item, touch) {\n        if (!this._head || !this._tail) {\n            throw ( new Error('Invalid list'));\n        }\n        if (((touch !== 1  && touch !== 2) )) {\n            return;\n        }\n        if (touch === 1 ) {\n            if (item === this._head) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            if (item === this._tail) {\n                previous.next = undefined;\n                this._tail = previous;\n            }\n            else {\n                next.previous = previous;\n                previous.next = next;\n            }\n            item.previous = undefined;\n            item.next = this._head;\n            this._head.previous = item;\n            this._head = item;\n            this._state++;\n        }\n        else if (touch === 2 ) {\n            if (item === this._tail) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            if (item === this._head) {\n                next.previous = undefined;\n                this._head = next;\n            }\n            else {\n                next.previous = previous;\n                previous.next = next;\n            }\n            item.next = undefined;\n            item.previous = this._tail;\n            this._tail.next = item;\n            this._tail = item;\n            this._state++;\n        }\n    }\n    toJSON() {\n        const data = [];\n        this.forEach((value, key) => {\n            data.push([key, value]);\n        });\n        return data;\n    }\n    fromJSON(data) {\n        this.clear();\n        for (const [key, value] of data) {\n            this.set(key, value);\n        }\n    }\n}\nclass Cache extends LinkedMap {\n    constructor(limit, ratio = 1) {\n        super();\n        this._limit = limit;\n        this._ratio = Math.min(Math.max(0, ratio), 1);\n    }\n    get limit() {\n        return this._limit;\n    }\n    set limit(limit) {\n        this._limit = limit;\n        this.checkTrim();\n    }\n    get ratio() {\n        return this._ratio;\n    }\n    set ratio(ratio) {\n        this._ratio = Math.min(Math.max(0, ratio), 1);\n        this.checkTrim();\n    }\n    get(key, touch = 2 ) {\n        return super.get(key, touch);\n    }\n    peek(key) {\n        return super.get(key, 0 );\n    }\n    set(key, value) {\n        super.set(key, value, 2 );\n        return this;\n    }\n    checkTrim() {\n        if (this.size > this._limit) {\n            this.trim(Math.round(this._limit * this._ratio));\n        }\n    }\n}\nclass LRUCache extends Cache {\n    constructor(limit, ratio = 1) {\n        super(limit, ratio);\n    }\n    trim(newSize) {\n        this.trimOld(newSize);\n    }\n    set(key, value) {\n        super.set(key, value);\n        this.checkTrim();\n        return this;\n    }\n}\nclass MRUCache extends Cache {\n    constructor(limit, ratio = 1) {\n        super(limit, ratio);\n    }\n    trim(newSize) {\n        this.trimNew(newSize);\n    }\n    set(key, value) {\n        if (this._limit <= this.size && !( this.has(key))) {\n            this.trim(Math.round(this._limit * this._ratio) - 1);\n        }\n        super.set(key, value);\n        return this;\n    }\n}\nclass CounterSet {\n    constructor() {\n        this.map = ( new Map());\n    }\n    add(value) {\n        this.map.set(value, (this.map.get(value) || 0) + 1);\n        return this;\n    }\n    delete(value) {\n        let counter = this.map.get(value) || 0;\n        if (counter === 0) {\n            return false;\n        }\n        counter--;\n        if (counter === 0) {\n            this.map.delete(value);\n        }\n        else {\n            this.map.set(value, counter);\n        }\n        return true;\n    }\n    has(value) {\n        return ( this.map.has(value));\n    }\n}\nclass BidirectionalMap {\n    constructor(entries) {\n        this._m1 = ( new Map());\n        this._m2 = ( new Map());\n        if (entries) {\n            for (const [key, value] of entries) {\n                this.set(key, value);\n            }\n        }\n    }\n    clear() {\n        this._m1.clear();\n        this._m2.clear();\n    }\n    set(key, value) {\n        this._m1.set(key, value);\n        this._m2.set(value, key);\n    }\n    get(key) {\n        return this._m1.get(key);\n    }\n    getKey(value) {\n        return this._m2.get(value);\n    }\n    delete(key) {\n        const value = this._m1.get(key);\n        if (value === undefined) {\n            return false;\n        }\n        this._m1.delete(key);\n        this._m2.delete(value);\n        return true;\n    }\n    forEach(callbackfn, thisArg) {\n        this._m1.forEach((value, key) => {\n            callbackfn.call(thisArg, value, key, this);\n        });\n    }\n    keys() {\n        return ( this._m1.keys());\n    }\n    values() {\n        return ( this._m1.values());\n    }\n}\nclass SetMap {\n    constructor() {\n        this.map = ( new Map());\n    }\n    add(key, value) {\n        let values = this.map.get(key);\n        if (!values) {\n            values = ( new Set());\n            this.map.set(key, values);\n        }\n        values.add(value);\n    }\n    delete(key, value) {\n        const values = this.map.get(key);\n        if (!values) {\n            return;\n        }\n        values.delete(value);\n        if (values.size === 0) {\n            this.map.delete(key);\n        }\n    }\n    forEach(key, fn) {\n        const values = this.map.get(key);\n        if (!values) {\n            return;\n        }\n        values.forEach(fn);\n    }\n    get(key) {\n        const values = this.map.get(key);\n        if (!values) {\n            return ( new Set());\n        }\n        return values;\n    }\n}\nfunction mapsStrictEqualIgnoreOrder(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const [key, value] of a) {\n        if (!( b.has(key)) || b.get(key) !== value) {\n            return false;\n        }\n    }\n    for (const [key] of b) {\n        if (!( a.has(key))) {\n            return false;\n        }\n    }\n    return true;\n}\nexport { BidirectionalMap, CounterSet, LRUCache, LinkedMap, MRUCache, ResourceMap, ResourceSet, SetMap, getOrSet, mapsStrictEqualIgnoreOrder };\n"],"mappings":"AAAA,IAAIA,EAAE,EAAEC,EAAE,EAAEC,EAAE;AACd,SAASC,QAAQA,CAACC,GAAG,EAAEC,GAAG,EAAEC,KAAK,EAAE;EAC/B,IAAIC,MAAM,GAAGH,GAAG,CAACI,GAAG,CAACH,GAAG,CAAC;EACzB,IAAIE,MAAM,KAAKE,SAAS,EAAE;IACtBF,MAAM,GAAGD,KAAK;IACdF,GAAG,CAACM,GAAG,CAACL,GAAG,EAAEE,MAAM,CAAC;EACxB;EACA,OAAOA,MAAM;AACjB;AACA,MAAMI,gBAAgB,CAAC;EACnBC,WAAWA,CAACC,GAAG,EAAEP,KAAK,EAAE;IACpB,IAAI,CAACO,GAAG,GAAGA,GAAG;IACd,IAAI,CAACP,KAAK,GAAGA,KAAK;EACtB;AACJ;AACA,SAASQ,SAASA,CAACC,GAAG,EAAE;EACpB,OAAOC,KAAK,CAACC,OAAO,CAACF,GAAG,CAAC;AAC7B;AACA,MAAMG,WAAW,CAAC;EACd;IAAS,IAAI,CAACC,YAAY,GAAIC,QAAQ,IAAOA,QAAQ,CAACC,QAAQ,CAAC,CAAE;EAAE;EACnET,WAAWA,CAACG,GAAG,EAAEO,KAAK,EAAE;IACpB,IAAI,CAACtB,EAAE,CAAC,GAAG,aAAa;IACxB,IAAIe,GAAG,YAAYG,WAAW,EAAE;MAC5B,IAAI,CAACd,GAAG,GAAK,IAAImB,GAAG,CAACR,GAAG,CAACX,GAAG,CAAE;MAC9B,IAAI,CAACkB,KAAK,GAAGA,KAAK,IAAIJ,WAAW,CAACC,YAAY;IAClD,CAAC,MACI,IAAIL,SAAS,CAACC,GAAG,CAAC,EAAE;MACrB,IAAI,CAACX,GAAG,GAAK,IAAImB,GAAG,CAAC,CAAE;MACvB,IAAI,CAACD,KAAK,GAAGA,KAAK,IAAIJ,WAAW,CAACC,YAAY;MAC9C,KAAK,MAAM,CAACC,QAAQ,EAAEd,KAAK,CAAC,IAAIS,GAAG,EAAE;QACjC,IAAI,CAACL,GAAG,CAACU,QAAQ,EAAEd,KAAK,CAAC;MAC7B;IACJ,CAAC,MACI;MACD,IAAI,CAACF,GAAG,GAAK,IAAImB,GAAG,CAAC,CAAE;MACvB,IAAI,CAACD,KAAK,GAAGP,GAAG,IAAIG,WAAW,CAACC,YAAY;IAChD;EACJ;EACAT,GAAGA,CAACU,QAAQ,EAAEd,KAAK,EAAE;IACjB,IAAI,CAACF,GAAG,CAACM,GAAG,CAAC,IAAI,CAACY,KAAK,CAACF,QAAQ,CAAC,EAAI,IAAIT,gBAAgB,CAACS,QAAQ,EAAEd,KAAK,CAAE,CAAC;IAC5E,OAAO,IAAI;EACf;EACAE,GAAGA,CAACY,QAAQ,EAAE;IACV,OAAO,IAAI,CAAChB,GAAG,CAACI,GAAG,CAAC,IAAI,CAACc,KAAK,CAACF,QAAQ,CAAC,CAAC,EAAEd,KAAK;EACpD;EACAkB,GAAGA,CAACJ,QAAQ,EAAE;IACV,OAAS,IAAI,CAAChB,GAAG,CAACoB,GAAG,CAAC,IAAI,CAACF,KAAK,CAACF,QAAQ,CAAC,CAAC;EAC/C;EACA,IAAIK,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,CAACrB,GAAG,CAACqB,IAAI;EACxB;EACAC,KAAKA,CAAA,EAAG;IACJ,IAAI,CAACtB,GAAG,CAACsB,KAAK,CAAC,CAAC;EACpB;EACAC,MAAMA,CAACP,QAAQ,EAAE;IACb,OAAO,IAAI,CAAChB,GAAG,CAACuB,MAAM,CAAC,IAAI,CAACL,KAAK,CAACF,QAAQ,CAAC,CAAC;EAChD;EACAQ,OAAOA,CAACC,GAAG,EAAEC,OAAO,EAAE;IAClB,IAAI,OAAOA,OAAO,KAAK,WAAW,EAAE;MAChCD,GAAG,GAAGA,GAAG,CAACE,IAAI,CAACD,OAAO,CAAC;IAC3B;IACA,KAAK,MAAM,CAACE,CAAC,EAAEC,KAAK,CAAC,IAAI,IAAI,CAAC7B,GAAG,EAAE;MAC/ByB,GAAG,CAACI,KAAK,CAAC3B,KAAK,EAAE2B,KAAK,CAACpB,GAAG,EAAE,IAAI,CAAC;IACrC;EACJ;EACA,CAACqB,MAAMA,CAAA,EAAG;IACN,KAAK,MAAMD,KAAK,IAAM,IAAI,CAAC7B,GAAG,CAAC8B,MAAM,CAAC,CAAC,EAAG;MACtC,MAAMD,KAAK,CAAC3B,KAAK;IACrB;EACJ;EACA,CAAC6B,IAAIA,CAAA,EAAG;IACJ,KAAK,MAAMF,KAAK,IAAM,IAAI,CAAC7B,GAAG,CAAC8B,MAAM,CAAC,CAAC,EAAG;MACtC,MAAMD,KAAK,CAACpB,GAAG;IACnB;EACJ;EACA,CAACuB,OAAOA,CAAA,EAAG;IACP,KAAK,MAAMH,KAAK,IAAM,IAAI,CAAC7B,GAAG,CAAC8B,MAAM,CAAC,CAAC,EAAG;MACtC,MAAM,CAACD,KAAK,CAACpB,GAAG,EAAEoB,KAAK,CAAC3B,KAAK,CAAC;IAClC;EACJ;EACA,GAAGN,EAAE,GAAGqC,MAAM,CAACC,WAAW,EAAED,MAAM,CAACE,QAAQ,KAAK;IAC5C,KAAK,MAAM,GAAGN,KAAK,CAAC,IAAI,IAAI,CAAC7B,GAAG,EAAE;MAC9B,MAAM,CAAC6B,KAAK,CAACpB,GAAG,EAAEoB,KAAK,CAAC3B,KAAK,CAAC;IAClC;EACJ;AACJ;AACA,MAAMkC,WAAW,CAAC;EACd5B,WAAWA,CAAC6B,YAAY,EAAEnB,KAAK,EAAE;IAC7B,IAAI,CAACrB,EAAE,CAAC,GAAG,aAAa;IACxB,IAAI,CAACwC,YAAY,IAAI,OAAOA,YAAY,KAAK,UAAU,EAAE;MACrD,IAAI,CAACC,IAAI,GAAK,IAAIxB,WAAW,CAACuB,YAAY,CAAE;IAChD,CAAC,MACI;MACD,IAAI,CAACC,IAAI,GAAK,IAAIxB,WAAW,CAACI,KAAK,CAAE;MACrCmB,YAAY,CAACb,OAAO,CAAC,IAAI,CAACe,GAAG,EAAE,IAAI,CAAC;IACxC;EACJ;EACA,IAAIlB,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,CAACiB,IAAI,CAACjB,IAAI;EACzB;EACAkB,GAAGA,CAACrC,KAAK,EAAE;IACP,IAAI,CAACoC,IAAI,CAAChC,GAAG,CAACJ,KAAK,EAAEA,KAAK,CAAC;IAC3B,OAAO,IAAI;EACf;EACAoB,KAAKA,CAAA,EAAG;IACJ,IAAI,CAACgB,IAAI,CAAChB,KAAK,CAAC,CAAC;EACrB;EACAC,MAAMA,CAACrB,KAAK,EAAE;IACV,OAAO,IAAI,CAACoC,IAAI,CAACf,MAAM,CAACrB,KAAK,CAAC;EAClC;EACAsB,OAAOA,CAACgB,UAAU,EAAEd,OAAO,EAAE;IACzB,IAAI,CAACY,IAAI,CAACd,OAAO,CAAC,CAACiB,MAAM,EAAExC,GAAG,KAAKuC,UAAU,CAACE,IAAI,CAAChB,OAAO,EAAEzB,GAAG,EAAEA,GAAG,EAAE,IAAI,CAAC,CAAC;EAChF;EACAmB,GAAGA,CAAClB,KAAK,EAAE;IACP,OAAS,IAAI,CAACoC,IAAI,CAAClB,GAAG,CAAClB,KAAK,CAAC;EACjC;EACA8B,OAAOA,CAAA,EAAG;IACN,OAAO,IAAI,CAACM,IAAI,CAACN,OAAO,CAAC,CAAC;EAC9B;EACAD,IAAIA,CAAA,EAAG;IACH,OAAS,IAAI,CAACO,IAAI,CAACP,IAAI,CAAC,CAAC;EAC7B;EACAD,MAAMA,CAAA,EAAG;IACL,OAAS,IAAI,CAACQ,IAAI,CAACP,IAAI,CAAC,CAAC;EAC7B;EACA,EAAElC,EAAE,GAAGoC,MAAM,CAACC,WAAW,EAAED,MAAM,CAACE,QAAQ,KAAK;IAC3C,OAAS,IAAI,CAACJ,IAAI,CAAC,CAAC;EACxB;AACJ;AACA,MAAMY,SAAS,CAAC;EACZnC,WAAWA,CAAA,EAAG;IACV,IAAI,CAACV,EAAE,CAAC,GAAG,WAAW;IACtB,IAAI,CAACwC,IAAI,GAAK,IAAInB,GAAG,CAAC,CAAE;IACxB,IAAI,CAACyB,KAAK,GAAGvC,SAAS;IACtB,IAAI,CAACwC,KAAK,GAAGxC,SAAS;IACtB,IAAI,CAACyC,KAAK,GAAG,CAAC;IACd,IAAI,CAACC,MAAM,GAAG,CAAC;EACnB;EACAzB,KAAKA,CAAA,EAAG;IACJ,IAAI,CAACgB,IAAI,CAAChB,KAAK,CAAC,CAAC;IACjB,IAAI,CAACsB,KAAK,GAAGvC,SAAS;IACtB,IAAI,CAACwC,KAAK,GAAGxC,SAAS;IACtB,IAAI,CAACyC,KAAK,GAAG,CAAC;IACd,IAAI,CAACC,MAAM,EAAE;EACjB;EACAC,OAAOA,CAAA,EAAG;IACN,OAAO,CAAC,IAAI,CAACJ,KAAK,IAAI,CAAC,IAAI,CAACC,KAAK;EACrC;EACA,IAAIxB,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,CAACyB,KAAK;EACrB;EACA,IAAIG,KAAKA,CAAA,EAAG;IACR,OAAO,IAAI,CAACL,KAAK,EAAE1C,KAAK;EAC5B;EACA,IAAIgD,IAAIA,CAAA,EAAG;IACP,OAAO,IAAI,CAACL,KAAK,EAAE3C,KAAK;EAC5B;EACAkB,GAAGA,CAACnB,GAAG,EAAE;IACL,OAAS,IAAI,CAACqC,IAAI,CAAClB,GAAG,CAACnB,GAAG,CAAC;EAC/B;EACAG,GAAGA,CAACH,GAAG,EAAEkD,KAAK,GAAG,CAAC,EAAG;IACjB,MAAMC,IAAI,GAAG,IAAI,CAACd,IAAI,CAAClC,GAAG,CAACH,GAAG,CAAC;IAC/B,IAAI,CAACmD,IAAI,EAAE;MACP,OAAO/C,SAAS;IACpB;IACA,IAAI8C,KAAK,KAAK,CAAC,EAAG;MACd,IAAI,CAACA,KAAK,CAACC,IAAI,EAAED,KAAK,CAAC;IAC3B;IACA,OAAOC,IAAI,CAAClD,KAAK;EACrB;EACAI,GAAGA,CAACL,GAAG,EAAEC,KAAK,EAAEiD,KAAK,GAAG,CAAC,EAAG;IACxB,IAAIC,IAAI,GAAG,IAAI,CAACd,IAAI,CAAClC,GAAG,CAACH,GAAG,CAAC;IAC7B,IAAImD,IAAI,EAAE;MACNA,IAAI,CAAClD,KAAK,GAAGA,KAAK;MAClB,IAAIiD,KAAK,KAAK,CAAC,EAAG;QACd,IAAI,CAACA,KAAK,CAACC,IAAI,EAAED,KAAK,CAAC;MAC3B;IACJ,CAAC,MACI;MACDC,IAAI,GAAG;QAAEnD,GAAG;QAAEC,KAAK;QAAEmD,IAAI,EAAEhD,SAAS;QAAEiD,QAAQ,EAAEjD;MAAU,CAAC;MAC3D,QAAQ8C,KAAK;QACT,KAAK,CAAC;UACF,IAAI,CAACI,WAAW,CAACH,IAAI,CAAC;UACtB;QACJ,KAAK,CAAC;UACF,IAAI,CAACI,YAAY,CAACJ,IAAI,CAAC;UACvB;QACJ,KAAK,CAAC;UACF,IAAI,CAACG,WAAW,CAACH,IAAI,CAAC;UACtB;QACJ;UACI,IAAI,CAACG,WAAW,CAACH,IAAI,CAAC;UACtB;MACR;MACA,IAAI,CAACd,IAAI,CAAChC,GAAG,CAACL,GAAG,EAAEmD,IAAI,CAAC;MACxB,IAAI,CAACN,KAAK,EAAE;IAChB;IACA,OAAO,IAAI;EACf;EACAvB,MAAMA,CAACtB,GAAG,EAAE;IACR,OAAO,CAAC,CAAC,IAAI,CAACwD,MAAM,CAACxD,GAAG,CAAC;EAC7B;EACAwD,MAAMA,CAACxD,GAAG,EAAE;IACR,MAAMmD,IAAI,GAAG,IAAI,CAACd,IAAI,CAAClC,GAAG,CAACH,GAAG,CAAC;IAC/B,IAAI,CAACmD,IAAI,EAAE;MACP,OAAO/C,SAAS;IACpB;IACA,IAAI,CAACiC,IAAI,CAACf,MAAM,CAACtB,GAAG,CAAC;IACrB,IAAI,CAACyD,UAAU,CAACN,IAAI,CAAC;IACrB,IAAI,CAACN,KAAK,EAAE;IACZ,OAAOM,IAAI,CAAClD,KAAK;EACrB;EACAyD,KAAKA,CAAA,EAAG;IACJ,IAAI,CAAC,IAAI,CAACf,KAAK,IAAI,CAAC,IAAI,CAACC,KAAK,EAAE;MAC5B,OAAOxC,SAAS;IACpB;IACA,IAAI,CAAC,IAAI,CAACuC,KAAK,IAAI,CAAC,IAAI,CAACC,KAAK,EAAE;MAC5B,MAAQ,IAAIe,KAAK,CAAC,cAAc,CAAC;IACrC;IACA,MAAMR,IAAI,GAAG,IAAI,CAACR,KAAK;IACvB,IAAI,CAACN,IAAI,CAACf,MAAM,CAAC6B,IAAI,CAACnD,GAAG,CAAC;IAC1B,IAAI,CAACyD,UAAU,CAACN,IAAI,CAAC;IACrB,IAAI,CAACN,KAAK,EAAE;IACZ,OAAOM,IAAI,CAAClD,KAAK;EACrB;EACAsB,OAAOA,CAACgB,UAAU,EAAEd,OAAO,EAAE;IACzB,MAAMmC,KAAK,GAAG,IAAI,CAACd,MAAM;IACzB,IAAIe,OAAO,GAAG,IAAI,CAAClB,KAAK;IACxB,OAAOkB,OAAO,EAAE;MACZ,IAAIpC,OAAO,EAAE;QACTc,UAAU,CAACb,IAAI,CAACD,OAAO,CAAC,CAACoC,OAAO,CAAC5D,KAAK,EAAE4D,OAAO,CAAC7D,GAAG,EAAE,IAAI,CAAC;MAC9D,CAAC,MACI;QACDuC,UAAU,CAACsB,OAAO,CAAC5D,KAAK,EAAE4D,OAAO,CAAC7D,GAAG,EAAE,IAAI,CAAC;MAChD;MACA,IAAI,IAAI,CAAC8C,MAAM,KAAKc,KAAK,EAAE;QACvB,MAAQ,IAAID,KAAK,CAAE,0CAAyC,CAAC;MACjE;MACAE,OAAO,GAAGA,OAAO,CAACT,IAAI;IAC1B;EACJ;EACAtB,IAAIA,CAAA,EAAG;IACH,MAAM/B,GAAG,GAAG,IAAI;IAChB,MAAM6D,KAAK,GAAG,IAAI,CAACd,MAAM;IACzB,IAAIe,OAAO,GAAG,IAAI,CAAClB,KAAK;IACxB,MAAMT,QAAQ,GAAG;MACb,CAACF,MAAM,CAACE,QAAQ,IAAI;QAChB,OAAOA,QAAQ;MACnB,CAAC;MACDkB,IAAIA,CAAA,EAAG;QACH,IAAIrD,GAAG,CAAC+C,MAAM,KAAKc,KAAK,EAAE;UACtB,MAAQ,IAAID,KAAK,CAAE,0CAAyC,CAAC;QACjE;QACA,IAAIE,OAAO,EAAE;UACT,MAAM3D,MAAM,GAAG;YAAED,KAAK,EAAE4D,OAAO,CAAC7D,GAAG;YAAE8D,IAAI,EAAE;UAAM,CAAC;UAClDD,OAAO,GAAGA,OAAO,CAACT,IAAI;UACtB,OAAOlD,MAAM;QACjB,CAAC,MACI;UACD,OAAO;YAAED,KAAK,EAAEG,SAAS;YAAE0D,IAAI,EAAE;UAAK,CAAC;QAC3C;MACJ;IACJ,CAAC;IACD,OAAO5B,QAAQ;EACnB;EACAL,MAAMA,CAAA,EAAG;IACL,MAAM9B,GAAG,GAAG,IAAI;IAChB,MAAM6D,KAAK,GAAG,IAAI,CAACd,MAAM;IACzB,IAAIe,OAAO,GAAG,IAAI,CAAClB,KAAK;IACxB,MAAMT,QAAQ,GAAG;MACb,CAACF,MAAM,CAACE,QAAQ,IAAI;QAChB,OAAOA,QAAQ;MACnB,CAAC;MACDkB,IAAIA,CAAA,EAAG;QACH,IAAIrD,GAAG,CAAC+C,MAAM,KAAKc,KAAK,EAAE;UACtB,MAAQ,IAAID,KAAK,CAAE,0CAAyC,CAAC;QACjE;QACA,IAAIE,OAAO,EAAE;UACT,MAAM3D,MAAM,GAAG;YAAED,KAAK,EAAE4D,OAAO,CAAC5D,KAAK;YAAE6D,IAAI,EAAE;UAAM,CAAC;UACpDD,OAAO,GAAGA,OAAO,CAACT,IAAI;UACtB,OAAOlD,MAAM;QACjB,CAAC,MACI;UACD,OAAO;YAAED,KAAK,EAAEG,SAAS;YAAE0D,IAAI,EAAE;UAAK,CAAC;QAC3C;MACJ;IACJ,CAAC;IACD,OAAO5B,QAAQ;EACnB;EACAH,OAAOA,CAAA,EAAG;IACN,MAAMhC,GAAG,GAAG,IAAI;IAChB,MAAM6D,KAAK,GAAG,IAAI,CAACd,MAAM;IACzB,IAAIe,OAAO,GAAG,IAAI,CAAClB,KAAK;IACxB,MAAMT,QAAQ,GAAG;MACb,CAACF,MAAM,CAACE,QAAQ,IAAI;QAChB,OAAOA,QAAQ;MACnB,CAAC;MACDkB,IAAIA,CAAA,EAAG;QACH,IAAIrD,GAAG,CAAC+C,MAAM,KAAKc,KAAK,EAAE;UACtB,MAAQ,IAAID,KAAK,CAAE,0CAAyC,CAAC;QACjE;QACA,IAAIE,OAAO,EAAE;UACT,MAAM3D,MAAM,GAAG;YAAED,KAAK,EAAE,CAAC4D,OAAO,CAAC7D,GAAG,EAAE6D,OAAO,CAAC5D,KAAK,CAAC;YAAE6D,IAAI,EAAE;UAAM,CAAC;UACnED,OAAO,GAAGA,OAAO,CAACT,IAAI;UACtB,OAAOlD,MAAM;QACjB,CAAC,MACI;UACD,OAAO;YAAED,KAAK,EAAEG,SAAS;YAAE0D,IAAI,EAAE;UAAK,CAAC;QAC3C;MACJ;IACJ,CAAC;IACD,OAAO5B,QAAQ;EACnB;EACA,EAAErC,EAAE,GAAGmC,MAAM,CAACC,WAAW,EAAED,MAAM,CAACE,QAAQ,KAAK;IAC3C,OAAO,IAAI,CAACH,OAAO,CAAC,CAAC;EACzB;EACAgC,OAAOA,CAACC,OAAO,EAAE;IACb,IAAIA,OAAO,IAAI,IAAI,CAAC5C,IAAI,EAAE;MACtB;IACJ;IACA,IAAI4C,OAAO,KAAK,CAAC,EAAE;MACf,IAAI,CAAC3C,KAAK,CAAC,CAAC;MACZ;IACJ;IACA,IAAIwC,OAAO,GAAG,IAAI,CAAClB,KAAK;IACxB,IAAIsB,WAAW,GAAG,IAAI,CAAC7C,IAAI;IAC3B,OAAOyC,OAAO,IAAII,WAAW,GAAGD,OAAO,EAAE;MACrC,IAAI,CAAC3B,IAAI,CAACf,MAAM,CAACuC,OAAO,CAAC7D,GAAG,CAAC;MAC7B6D,OAAO,GAAGA,OAAO,CAACT,IAAI;MACtBa,WAAW,EAAE;IACjB;IACA,IAAI,CAACtB,KAAK,GAAGkB,OAAO;IACpB,IAAI,CAAChB,KAAK,GAAGoB,WAAW;IACxB,IAAIJ,OAAO,EAAE;MACTA,OAAO,CAACR,QAAQ,GAAGjD,SAAS;IAChC;IACA,IAAI,CAAC0C,MAAM,EAAE;EACjB;EACAoB,OAAOA,CAACF,OAAO,EAAE;IACb,IAAIA,OAAO,IAAI,IAAI,CAAC5C,IAAI,EAAE;MACtB;IACJ;IACA,IAAI4C,OAAO,KAAK,CAAC,EAAE;MACf,IAAI,CAAC3C,KAAK,CAAC,CAAC;MACZ;IACJ;IACA,IAAIwC,OAAO,GAAG,IAAI,CAACjB,KAAK;IACxB,IAAIqB,WAAW,GAAG,IAAI,CAAC7C,IAAI;IAC3B,OAAOyC,OAAO,IAAII,WAAW,GAAGD,OAAO,EAAE;MACrC,IAAI,CAAC3B,IAAI,CAACf,MAAM,CAACuC,OAAO,CAAC7D,GAAG,CAAC;MAC7B6D,OAAO,GAAGA,OAAO,CAACR,QAAQ;MAC1BY,WAAW,EAAE;IACjB;IACA,IAAI,CAACrB,KAAK,GAAGiB,OAAO;IACpB,IAAI,CAAChB,KAAK,GAAGoB,WAAW;IACxB,IAAIJ,OAAO,EAAE;MACTA,OAAO,CAACT,IAAI,GAAGhD,SAAS;IAC5B;IACA,IAAI,CAAC0C,MAAM,EAAE;EACjB;EACAS,YAAYA,CAACJ,IAAI,EAAE;IACf,IAAI,CAAC,IAAI,CAACR,KAAK,IAAI,CAAC,IAAI,CAACC,KAAK,EAAE;MAC5B,IAAI,CAACA,KAAK,GAAGO,IAAI;IACrB,CAAC,MACI,IAAI,CAAC,IAAI,CAACR,KAAK,EAAE;MAClB,MAAQ,IAAIgB,KAAK,CAAC,cAAc,CAAC;IACrC,CAAC,MACI;MACDR,IAAI,CAACC,IAAI,GAAG,IAAI,CAACT,KAAK;MACtB,IAAI,CAACA,KAAK,CAACU,QAAQ,GAAGF,IAAI;IAC9B;IACA,IAAI,CAACR,KAAK,GAAGQ,IAAI;IACjB,IAAI,CAACL,MAAM,EAAE;EACjB;EACAQ,WAAWA,CAACH,IAAI,EAAE;IACd,IAAI,CAAC,IAAI,CAACR,KAAK,IAAI,CAAC,IAAI,CAACC,KAAK,EAAE;MAC5B,IAAI,CAACD,KAAK,GAAGQ,IAAI;IACrB,CAAC,MACI,IAAI,CAAC,IAAI,CAACP,KAAK,EAAE;MAClB,MAAQ,IAAIe,KAAK,CAAC,cAAc,CAAC;IACrC,CAAC,MACI;MACDR,IAAI,CAACE,QAAQ,GAAG,IAAI,CAACT,KAAK;MAC1B,IAAI,CAACA,KAAK,CAACQ,IAAI,GAAGD,IAAI;IAC1B;IACA,IAAI,CAACP,KAAK,GAAGO,IAAI;IACjB,IAAI,CAACL,MAAM,EAAE;EACjB;EACAW,UAAUA,CAACN,IAAI,EAAE;IACb,IAAIA,IAAI,KAAK,IAAI,CAACR,KAAK,IAAIQ,IAAI,KAAK,IAAI,CAACP,KAAK,EAAE;MAC5C,IAAI,CAACD,KAAK,GAAGvC,SAAS;MACtB,IAAI,CAACwC,KAAK,GAAGxC,SAAS;IAC1B,CAAC,MACI,IAAI+C,IAAI,KAAK,IAAI,CAACR,KAAK,EAAE;MAC1B,IAAI,CAACQ,IAAI,CAACC,IAAI,EAAE;QACZ,MAAQ,IAAIO,KAAK,CAAC,cAAc,CAAC;MACrC;MACAR,IAAI,CAACC,IAAI,CAACC,QAAQ,GAAGjD,SAAS;MAC9B,IAAI,CAACuC,KAAK,GAAGQ,IAAI,CAACC,IAAI;IAC1B,CAAC,MACI,IAAID,IAAI,KAAK,IAAI,CAACP,KAAK,EAAE;MAC1B,IAAI,CAACO,IAAI,CAACE,QAAQ,EAAE;QAChB,MAAQ,IAAIM,KAAK,CAAC,cAAc,CAAC;MACrC;MACAR,IAAI,CAACE,QAAQ,CAACD,IAAI,GAAGhD,SAAS;MAC9B,IAAI,CAACwC,KAAK,GAAGO,IAAI,CAACE,QAAQ;IAC9B,CAAC,MACI;MACD,MAAMD,IAAI,GAAGD,IAAI,CAACC,IAAI;MACtB,MAAMC,QAAQ,GAAGF,IAAI,CAACE,QAAQ;MAC9B,IAAI,CAACD,IAAI,IAAI,CAACC,QAAQ,EAAE;QACpB,MAAQ,IAAIM,KAAK,CAAC,cAAc,CAAC;MACrC;MACAP,IAAI,CAACC,QAAQ,GAAGA,QAAQ;MACxBA,QAAQ,CAACD,IAAI,GAAGA,IAAI;IACxB;IACAD,IAAI,CAACC,IAAI,GAAGhD,SAAS;IACrB+C,IAAI,CAACE,QAAQ,GAAGjD,SAAS;IACzB,IAAI,CAAC0C,MAAM,EAAE;EACjB;EACAI,KAAKA,CAACC,IAAI,EAAED,KAAK,EAAE;IACf,IAAI,CAAC,IAAI,CAACP,KAAK,IAAI,CAAC,IAAI,CAACC,KAAK,EAAE;MAC5B,MAAQ,IAAIe,KAAK,CAAC,cAAc,CAAC;IACrC;IACA,IAAMT,KAAK,KAAK,CAAC,IAAKA,KAAK,KAAK,CAAC,EAAK;MAClC;IACJ;IACA,IAAIA,KAAK,KAAK,CAAC,EAAG;MACd,IAAIC,IAAI,KAAK,IAAI,CAACR,KAAK,EAAE;QACrB;MACJ;MACA,MAAMS,IAAI,GAAGD,IAAI,CAACC,IAAI;MACtB,MAAMC,QAAQ,GAAGF,IAAI,CAACE,QAAQ;MAC9B,IAAIF,IAAI,KAAK,IAAI,CAACP,KAAK,EAAE;QACrBS,QAAQ,CAACD,IAAI,GAAGhD,SAAS;QACzB,IAAI,CAACwC,KAAK,GAAGS,QAAQ;MACzB,CAAC,MACI;QACDD,IAAI,CAACC,QAAQ,GAAGA,QAAQ;QACxBA,QAAQ,CAACD,IAAI,GAAGA,IAAI;MACxB;MACAD,IAAI,CAACE,QAAQ,GAAGjD,SAAS;MACzB+C,IAAI,CAACC,IAAI,GAAG,IAAI,CAACT,KAAK;MACtB,IAAI,CAACA,KAAK,CAACU,QAAQ,GAAGF,IAAI;MAC1B,IAAI,CAACR,KAAK,GAAGQ,IAAI;MACjB,IAAI,CAACL,MAAM,EAAE;IACjB,CAAC,MACI,IAAII,KAAK,KAAK,CAAC,EAAG;MACnB,IAAIC,IAAI,KAAK,IAAI,CAACP,KAAK,EAAE;QACrB;MACJ;MACA,MAAMQ,IAAI,GAAGD,IAAI,CAACC,IAAI;MACtB,MAAMC,QAAQ,GAAGF,IAAI,CAACE,QAAQ;MAC9B,IAAIF,IAAI,KAAK,IAAI,CAACR,KAAK,EAAE;QACrBS,IAAI,CAACC,QAAQ,GAAGjD,SAAS;QACzB,IAAI,CAACuC,KAAK,GAAGS,IAAI;MACrB,CAAC,MACI;QACDA,IAAI,CAACC,QAAQ,GAAGA,QAAQ;QACxBA,QAAQ,CAACD,IAAI,GAAGA,IAAI;MACxB;MACAD,IAAI,CAACC,IAAI,GAAGhD,SAAS;MACrB+C,IAAI,CAACE,QAAQ,GAAG,IAAI,CAACT,KAAK;MAC1B,IAAI,CAACA,KAAK,CAACQ,IAAI,GAAGD,IAAI;MACtB,IAAI,CAACP,KAAK,GAAGO,IAAI;MACjB,IAAI,CAACL,MAAM,EAAE;IACjB;EACJ;EACAqB,MAAMA,CAAA,EAAG;IACL,MAAMC,IAAI,GAAG,EAAE;IACf,IAAI,CAAC7C,OAAO,CAAC,CAACtB,KAAK,EAAED,GAAG,KAAK;MACzBoE,IAAI,CAACC,IAAI,CAAC,CAACrE,GAAG,EAAEC,KAAK,CAAC,CAAC;IAC3B,CAAC,CAAC;IACF,OAAOmE,IAAI;EACf;EACAE,QAAQA,CAACF,IAAI,EAAE;IACX,IAAI,CAAC/C,KAAK,CAAC,CAAC;IACZ,KAAK,MAAM,CAACrB,GAAG,EAAEC,KAAK,CAAC,IAAImE,IAAI,EAAE;MAC7B,IAAI,CAAC/D,GAAG,CAACL,GAAG,EAAEC,KAAK,CAAC;IACxB;EACJ;AACJ;AACA,MAAMsE,KAAK,SAAS7B,SAAS,CAAC;EAC1BnC,WAAWA,CAACiE,KAAK,EAAEC,KAAK,GAAG,CAAC,EAAE;IAC1B,KAAK,CAAC,CAAC;IACP,IAAI,CAACC,MAAM,GAAGF,KAAK;IACnB,IAAI,CAACG,MAAM,GAAGC,IAAI,CAACC,GAAG,CAACD,IAAI,CAACE,GAAG,CAAC,CAAC,EAAEL,KAAK,CAAC,EAAE,CAAC,CAAC;EACjD;EACA,IAAID,KAAKA,CAAA,EAAG;IACR,OAAO,IAAI,CAACE,MAAM;EACtB;EACA,IAAIF,KAAKA,CAACA,KAAK,EAAE;IACb,IAAI,CAACE,MAAM,GAAGF,KAAK;IACnB,IAAI,CAACO,SAAS,CAAC,CAAC;EACpB;EACA,IAAIN,KAAKA,CAAA,EAAG;IACR,OAAO,IAAI,CAACE,MAAM;EACtB;EACA,IAAIF,KAAKA,CAACA,KAAK,EAAE;IACb,IAAI,CAACE,MAAM,GAAGC,IAAI,CAACC,GAAG,CAACD,IAAI,CAACE,GAAG,CAAC,CAAC,EAAEL,KAAK,CAAC,EAAE,CAAC,CAAC;IAC7C,IAAI,CAACM,SAAS,CAAC,CAAC;EACpB;EACA5E,GAAGA,CAACH,GAAG,EAAEkD,KAAK,GAAG,CAAC,EAAG;IACjB,OAAO,KAAK,CAAC/C,GAAG,CAACH,GAAG,EAAEkD,KAAK,CAAC;EAChC;EACA8B,IAAIA,CAAChF,GAAG,EAAE;IACN,OAAO,KAAK,CAACG,GAAG,CAACH,GAAG,EAAE,CAAE,CAAC;EAC7B;EACAK,GAAGA,CAACL,GAAG,EAAEC,KAAK,EAAE;IACZ,KAAK,CAACI,GAAG,CAACL,GAAG,EAAEC,KAAK,EAAE,CAAE,CAAC;IACzB,OAAO,IAAI;EACf;EACA8E,SAASA,CAAA,EAAG;IACR,IAAI,IAAI,CAAC3D,IAAI,GAAG,IAAI,CAACsD,MAAM,EAAE;MACzB,IAAI,CAACO,IAAI,CAACL,IAAI,CAACM,KAAK,CAAC,IAAI,CAACR,MAAM,GAAG,IAAI,CAACC,MAAM,CAAC,CAAC;IACpD;EACJ;AACJ;AACA,MAAMQ,QAAQ,SAASZ,KAAK,CAAC;EACzBhE,WAAWA,CAACiE,KAAK,EAAEC,KAAK,GAAG,CAAC,EAAE;IAC1B,KAAK,CAACD,KAAK,EAAEC,KAAK,CAAC;EACvB;EACAQ,IAAIA,CAACjB,OAAO,EAAE;IACV,IAAI,CAACD,OAAO,CAACC,OAAO,CAAC;EACzB;EACA3D,GAAGA,CAACL,GAAG,EAAEC,KAAK,EAAE;IACZ,KAAK,CAACI,GAAG,CAACL,GAAG,EAAEC,KAAK,CAAC;IACrB,IAAI,CAAC8E,SAAS,CAAC,CAAC;IAChB,OAAO,IAAI;EACf;AACJ;AACA,MAAMK,QAAQ,SAASb,KAAK,CAAC;EACzBhE,WAAWA,CAACiE,KAAK,EAAEC,KAAK,GAAG,CAAC,EAAE;IAC1B,KAAK,CAACD,KAAK,EAAEC,KAAK,CAAC;EACvB;EACAQ,IAAIA,CAACjB,OAAO,EAAE;IACV,IAAI,CAACE,OAAO,CAACF,OAAO,CAAC;EACzB;EACA3D,GAAGA,CAACL,GAAG,EAAEC,KAAK,EAAE;IACZ,IAAI,IAAI,CAACyE,MAAM,IAAI,IAAI,CAACtD,IAAI,IAAI,CAAG,IAAI,CAACD,GAAG,CAACnB,GAAG,CAAE,EAAE;MAC/C,IAAI,CAACiF,IAAI,CAACL,IAAI,CAACM,KAAK,CAAC,IAAI,CAACR,MAAM,GAAG,IAAI,CAACC,MAAM,CAAC,GAAG,CAAC,CAAC;IACxD;IACA,KAAK,CAACtE,GAAG,CAACL,GAAG,EAAEC,KAAK,CAAC;IACrB,OAAO,IAAI;EACf;AACJ;AACA,MAAMoF,UAAU,CAAC;EACb9E,WAAWA,CAAA,EAAG;IACV,IAAI,CAACR,GAAG,GAAK,IAAImB,GAAG,CAAC,CAAE;EAC3B;EACAoB,GAAGA,CAACrC,KAAK,EAAE;IACP,IAAI,CAACF,GAAG,CAACM,GAAG,CAACJ,KAAK,EAAE,CAAC,IAAI,CAACF,GAAG,CAACI,GAAG,CAACF,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IACnD,OAAO,IAAI;EACf;EACAqB,MAAMA,CAACrB,KAAK,EAAE;IACV,IAAIqF,OAAO,GAAG,IAAI,CAACvF,GAAG,CAACI,GAAG,CAACF,KAAK,CAAC,IAAI,CAAC;IACtC,IAAIqF,OAAO,KAAK,CAAC,EAAE;MACf,OAAO,KAAK;IAChB;IACAA,OAAO,EAAE;IACT,IAAIA,OAAO,KAAK,CAAC,EAAE;MACf,IAAI,CAACvF,GAAG,CAACuB,MAAM,CAACrB,KAAK,CAAC;IAC1B,CAAC,MACI;MACD,IAAI,CAACF,GAAG,CAACM,GAAG,CAACJ,KAAK,EAAEqF,OAAO,CAAC;IAChC;IACA,OAAO,IAAI;EACf;EACAnE,GAAGA,CAAClB,KAAK,EAAE;IACP,OAAS,IAAI,CAACF,GAAG,CAACoB,GAAG,CAAClB,KAAK,CAAC;EAChC;AACJ;AACA,MAAMsF,gBAAgB,CAAC;EACnBhF,WAAWA,CAACwB,OAAO,EAAE;IACjB,IAAI,CAACyD,GAAG,GAAK,IAAItE,GAAG,CAAC,CAAE;IACvB,IAAI,CAACuE,GAAG,GAAK,IAAIvE,GAAG,CAAC,CAAE;IACvB,IAAIa,OAAO,EAAE;MACT,KAAK,MAAM,CAAC/B,GAAG,EAAEC,KAAK,CAAC,IAAI8B,OAAO,EAAE;QAChC,IAAI,CAAC1B,GAAG,CAACL,GAAG,EAAEC,KAAK,CAAC;MACxB;IACJ;EACJ;EACAoB,KAAKA,CAAA,EAAG;IACJ,IAAI,CAACmE,GAAG,CAACnE,KAAK,CAAC,CAAC;IAChB,IAAI,CAACoE,GAAG,CAACpE,KAAK,CAAC,CAAC;EACpB;EACAhB,GAAGA,CAACL,GAAG,EAAEC,KAAK,EAAE;IACZ,IAAI,CAACuF,GAAG,CAACnF,GAAG,CAACL,GAAG,EAAEC,KAAK,CAAC;IACxB,IAAI,CAACwF,GAAG,CAACpF,GAAG,CAACJ,KAAK,EAAED,GAAG,CAAC;EAC5B;EACAG,GAAGA,CAACH,GAAG,EAAE;IACL,OAAO,IAAI,CAACwF,GAAG,CAACrF,GAAG,CAACH,GAAG,CAAC;EAC5B;EACA0F,MAAMA,CAACzF,KAAK,EAAE;IACV,OAAO,IAAI,CAACwF,GAAG,CAACtF,GAAG,CAACF,KAAK,CAAC;EAC9B;EACAqB,MAAMA,CAACtB,GAAG,EAAE;IACR,MAAMC,KAAK,GAAG,IAAI,CAACuF,GAAG,CAACrF,GAAG,CAACH,GAAG,CAAC;IAC/B,IAAIC,KAAK,KAAKG,SAAS,EAAE;MACrB,OAAO,KAAK;IAChB;IACA,IAAI,CAACoF,GAAG,CAAClE,MAAM,CAACtB,GAAG,CAAC;IACpB,IAAI,CAACyF,GAAG,CAACnE,MAAM,CAACrB,KAAK,CAAC;IACtB,OAAO,IAAI;EACf;EACAsB,OAAOA,CAACgB,UAAU,EAAEd,OAAO,EAAE;IACzB,IAAI,CAAC+D,GAAG,CAACjE,OAAO,CAAC,CAACtB,KAAK,EAAED,GAAG,KAAK;MAC7BuC,UAAU,CAACE,IAAI,CAAChB,OAAO,EAAExB,KAAK,EAAED,GAAG,EAAE,IAAI,CAAC;IAC9C,CAAC,CAAC;EACN;EACA8B,IAAIA,CAAA,EAAG;IACH,OAAS,IAAI,CAAC0D,GAAG,CAAC1D,IAAI,CAAC,CAAC;EAC5B;EACAD,MAAMA,CAAA,EAAG;IACL,OAAS,IAAI,CAAC2D,GAAG,CAAC3D,MAAM,CAAC,CAAC;EAC9B;AACJ;AACA,MAAM8D,MAAM,CAAC;EACTpF,WAAWA,CAAA,EAAG;IACV,IAAI,CAACR,GAAG,GAAK,IAAImB,GAAG,CAAC,CAAE;EAC3B;EACAoB,GAAGA,CAACtC,GAAG,EAAEC,KAAK,EAAE;IACZ,IAAI4B,MAAM,GAAG,IAAI,CAAC9B,GAAG,CAACI,GAAG,CAACH,GAAG,CAAC;IAC9B,IAAI,CAAC6B,MAAM,EAAE;MACTA,MAAM,GAAK,IAAI+D,GAAG,CAAC,CAAE;MACrB,IAAI,CAAC7F,GAAG,CAACM,GAAG,CAACL,GAAG,EAAE6B,MAAM,CAAC;IAC7B;IACAA,MAAM,CAACS,GAAG,CAACrC,KAAK,CAAC;EACrB;EACAqB,MAAMA,CAACtB,GAAG,EAAEC,KAAK,EAAE;IACf,MAAM4B,MAAM,GAAG,IAAI,CAAC9B,GAAG,CAACI,GAAG,CAACH,GAAG,CAAC;IAChC,IAAI,CAAC6B,MAAM,EAAE;MACT;IACJ;IACAA,MAAM,CAACP,MAAM,CAACrB,KAAK,CAAC;IACpB,IAAI4B,MAAM,CAACT,IAAI,KAAK,CAAC,EAAE;MACnB,IAAI,CAACrB,GAAG,CAACuB,MAAM,CAACtB,GAAG,CAAC;IACxB;EACJ;EACAuB,OAAOA,CAACvB,GAAG,EAAE6F,EAAE,EAAE;IACb,MAAMhE,MAAM,GAAG,IAAI,CAAC9B,GAAG,CAACI,GAAG,CAACH,GAAG,CAAC;IAChC,IAAI,CAAC6B,MAAM,EAAE;MACT;IACJ;IACAA,MAAM,CAACN,OAAO,CAACsE,EAAE,CAAC;EACtB;EACA1F,GAAGA,CAACH,GAAG,EAAE;IACL,MAAM6B,MAAM,GAAG,IAAI,CAAC9B,GAAG,CAACI,GAAG,CAACH,GAAG,CAAC;IAChC,IAAI,CAAC6B,MAAM,EAAE;MACT,OAAS,IAAI+D,GAAG,CAAC,CAAC;IACtB;IACA,OAAO/D,MAAM;EACjB;AACJ;AACA,SAASiE,0BAA0BA,CAACC,CAAC,EAAEC,CAAC,EAAE;EACtC,IAAID,CAAC,KAAKC,CAAC,EAAE;IACT,OAAO,IAAI;EACf;EACA,IAAID,CAAC,CAAC3E,IAAI,KAAK4E,CAAC,CAAC5E,IAAI,EAAE;IACnB,OAAO,KAAK;EAChB;EACA,KAAK,MAAM,CAACpB,GAAG,EAAEC,KAAK,CAAC,IAAI8F,CAAC,EAAE;IAC1B,IAAI,CAAGC,CAAC,CAAC7E,GAAG,CAACnB,GAAG,CAAE,IAAIgG,CAAC,CAAC7F,GAAG,CAACH,GAAG,CAAC,KAAKC,KAAK,EAAE;MACxC,OAAO,KAAK;IAChB;EACJ;EACA,KAAK,MAAM,CAACD,GAAG,CAAC,IAAIgG,CAAC,EAAE;IACnB,IAAI,CAAGD,CAAC,CAAC5E,GAAG,CAACnB,GAAG,CAAE,EAAE;MAChB,OAAO,KAAK;IAChB;EACJ;EACA,OAAO,IAAI;AACf;AACA,SAASuF,gBAAgB,EAAEF,UAAU,EAAEF,QAAQ,EAAEzC,SAAS,EAAE0C,QAAQ,EAAEvE,WAAW,EAAEsB,WAAW,EAAEwD,MAAM,EAAE7F,QAAQ,EAAEgG,0BAA0B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}