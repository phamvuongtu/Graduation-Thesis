{"ast":null,"code":"\"use strict\";\n\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;\nconst ral_1 = require(\"./ral\");\nconst Is = require(\"./is\");\nconst events_1 = require(\"./events\");\nconst semaphore_1 = require(\"./semaphore\");\nvar MessageReader;\n(function (MessageReader) {\n  function is(value) {\n    let candidate = value;\n    return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);\n  }\n  MessageReader.is = is;\n})(MessageReader || (exports.MessageReader = MessageReader = {}));\nclass AbstractMessageReader {\n  constructor() {\n    this.errorEmitter = new events_1.Emitter();\n    this.closeEmitter = new events_1.Emitter();\n    this.partialMessageEmitter = new events_1.Emitter();\n  }\n  dispose() {\n    this.errorEmitter.dispose();\n    this.closeEmitter.dispose();\n  }\n  get onError() {\n    return this.errorEmitter.event;\n  }\n  fireError(error) {\n    this.errorEmitter.fire(this.asError(error));\n  }\n  get onClose() {\n    return this.closeEmitter.event;\n  }\n  fireClose() {\n    this.closeEmitter.fire(undefined);\n  }\n  get onPartialMessage() {\n    return this.partialMessageEmitter.event;\n  }\n  firePartialMessage(info) {\n    this.partialMessageEmitter.fire(info);\n  }\n  asError(error) {\n    if (error instanceof Error) {\n      return error;\n    } else {\n      return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\n    }\n  }\n}\nexports.AbstractMessageReader = AbstractMessageReader;\nvar ResolvedMessageReaderOptions;\n(function (ResolvedMessageReaderOptions) {\n  function fromOptions(options) {\n    let charset;\n    let result;\n    let contentDecoder;\n    const contentDecoders = new Map();\n    let contentTypeDecoder;\n    const contentTypeDecoders = new Map();\n    if (options === undefined || typeof options === 'string') {\n      charset = options ?? 'utf-8';\n    } else {\n      charset = options.charset ?? 'utf-8';\n      if (options.contentDecoder !== undefined) {\n        contentDecoder = options.contentDecoder;\n        contentDecoders.set(contentDecoder.name, contentDecoder);\n      }\n      if (options.contentDecoders !== undefined) {\n        for (const decoder of options.contentDecoders) {\n          contentDecoders.set(decoder.name, decoder);\n        }\n      }\n      if (options.contentTypeDecoder !== undefined) {\n        contentTypeDecoder = options.contentTypeDecoder;\n        contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);\n      }\n      if (options.contentTypeDecoders !== undefined) {\n        for (const decoder of options.contentTypeDecoders) {\n          contentTypeDecoders.set(decoder.name, decoder);\n        }\n      }\n    }\n    if (contentTypeDecoder === undefined) {\n      contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;\n      contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);\n    }\n    return {\n      charset,\n      contentDecoder,\n      contentDecoders,\n      contentTypeDecoder,\n      contentTypeDecoders\n    };\n  }\n  ResolvedMessageReaderOptions.fromOptions = fromOptions;\n})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));\nclass ReadableStreamMessageReader extends AbstractMessageReader {\n  constructor(readable, options) {\n    super();\n    this.readable = readable;\n    this.options = ResolvedMessageReaderOptions.fromOptions(options);\n    this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);\n    this._partialMessageTimeout = 10000;\n    this.nextMessageLength = -1;\n    this.messageToken = 0;\n    this.readSemaphore = new semaphore_1.Semaphore(1);\n  }\n  set partialMessageTimeout(timeout) {\n    this._partialMessageTimeout = timeout;\n  }\n  get partialMessageTimeout() {\n    return this._partialMessageTimeout;\n  }\n  listen(callback) {\n    this.nextMessageLength = -1;\n    this.messageToken = 0;\n    this.partialMessageTimer = undefined;\n    this.callback = callback;\n    const result = this.readable.onData(data => {\n      this.onData(data);\n    });\n    this.readable.onError(error => this.fireError(error));\n    this.readable.onClose(() => this.fireClose());\n    return result;\n  }\n  onData(data) {\n    try {\n      this.buffer.append(data);\n      while (true) {\n        if (this.nextMessageLength === -1) {\n          const headers = this.buffer.tryReadHeaders(true);\n          if (!headers) {\n            return;\n          }\n          const contentLength = headers.get('content-length');\n          if (!contentLength) {\n            this.fireError(new Error(`Header must provide a Content-Length property.\\n${JSON.stringify(Object.fromEntries(headers))}`));\n            return;\n          }\n          const length = parseInt(contentLength);\n          if (isNaN(length)) {\n            this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));\n            return;\n          }\n          this.nextMessageLength = length;\n        }\n        const body = this.buffer.tryReadBody(this.nextMessageLength);\n        if (body === undefined) {\n          /** We haven't received the full message yet. */\n          this.setPartialMessageTimer();\n          return;\n        }\n        this.clearPartialMessageTimer();\n        this.nextMessageLength = -1;\n        // Make sure that we convert one received message after the\n        // other. Otherwise it could happen that a decoding of a second\n        // smaller message finished before the decoding of a first larger\n        // message and then we would deliver the second message first.\n        this.readSemaphore.lock(async () => {\n          const bytes = this.options.contentDecoder !== undefined ? await this.options.contentDecoder.decode(body) : body;\n          const message = await this.options.contentTypeDecoder.decode(bytes, this.options);\n          this.callback(message);\n        }).catch(error => {\n          this.fireError(error);\n        });\n      }\n    } catch (error) {\n      this.fireError(error);\n    }\n  }\n  clearPartialMessageTimer() {\n    if (this.partialMessageTimer) {\n      this.partialMessageTimer.dispose();\n      this.partialMessageTimer = undefined;\n    }\n  }\n  setPartialMessageTimer() {\n    this.clearPartialMessageTimer();\n    if (this._partialMessageTimeout <= 0) {\n      return;\n    }\n    this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {\n      this.partialMessageTimer = undefined;\n      if (token === this.messageToken) {\n        this.firePartialMessage({\n          messageToken: token,\n          waitingTime: timeout\n        });\n        this.setPartialMessageTimer();\n      }\n    }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);\n  }\n}\nexports.ReadableStreamMessageReader = ReadableStreamMessageReader;","map":{"version":3,"names":["Object","defineProperty","exports","value","ReadableStreamMessageReader","AbstractMessageReader","MessageReader","ral_1","require","Is","events_1","semaphore_1","is","candidate","func","listen","dispose","onError","onClose","onPartialMessage","constructor","errorEmitter","Emitter","closeEmitter","partialMessageEmitter","event","fireError","error","fire","asError","fireClose","undefined","firePartialMessage","info","Error","string","message","ResolvedMessageReaderOptions","fromOptions","options","charset","result","contentDecoder","contentDecoders","Map","contentTypeDecoder","contentTypeDecoders","set","name","decoder","default","applicationJson","readable","buffer","messageBuffer","create","_partialMessageTimeout","nextMessageLength","messageToken","readSemaphore","Semaphore","partialMessageTimeout","timeout","callback","partialMessageTimer","onData","data","append","headers","tryReadHeaders","contentLength","get","JSON","stringify","fromEntries","length","parseInt","isNaN","body","tryReadBody","setPartialMessageTimer","clearPartialMessageTimer","lock","bytes","decode","catch","timer","setTimeout","token","waitingTime"],"sources":["/Users/phamtu/Downloads/Code/OCE/oce-frontend/node_modules/vscode-jsonrpc/lib/common/messageReader.js"],"sourcesContent":["\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;\nconst ral_1 = require(\"./ral\");\nconst Is = require(\"./is\");\nconst events_1 = require(\"./events\");\nconst semaphore_1 = require(\"./semaphore\");\nvar MessageReader;\n(function (MessageReader) {\n    function is(value) {\n        let candidate = value;\n        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&\n            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);\n    }\n    MessageReader.is = is;\n})(MessageReader || (exports.MessageReader = MessageReader = {}));\nclass AbstractMessageReader {\n    constructor() {\n        this.errorEmitter = new events_1.Emitter();\n        this.closeEmitter = new events_1.Emitter();\n        this.partialMessageEmitter = new events_1.Emitter();\n    }\n    dispose() {\n        this.errorEmitter.dispose();\n        this.closeEmitter.dispose();\n    }\n    get onError() {\n        return this.errorEmitter.event;\n    }\n    fireError(error) {\n        this.errorEmitter.fire(this.asError(error));\n    }\n    get onClose() {\n        return this.closeEmitter.event;\n    }\n    fireClose() {\n        this.closeEmitter.fire(undefined);\n    }\n    get onPartialMessage() {\n        return this.partialMessageEmitter.event;\n    }\n    firePartialMessage(info) {\n        this.partialMessageEmitter.fire(info);\n    }\n    asError(error) {\n        if (error instanceof Error) {\n            return error;\n        }\n        else {\n            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\n        }\n    }\n}\nexports.AbstractMessageReader = AbstractMessageReader;\nvar ResolvedMessageReaderOptions;\n(function (ResolvedMessageReaderOptions) {\n    function fromOptions(options) {\n        let charset;\n        let result;\n        let contentDecoder;\n        const contentDecoders = new Map();\n        let contentTypeDecoder;\n        const contentTypeDecoders = new Map();\n        if (options === undefined || typeof options === 'string') {\n            charset = options ?? 'utf-8';\n        }\n        else {\n            charset = options.charset ?? 'utf-8';\n            if (options.contentDecoder !== undefined) {\n                contentDecoder = options.contentDecoder;\n                contentDecoders.set(contentDecoder.name, contentDecoder);\n            }\n            if (options.contentDecoders !== undefined) {\n                for (const decoder of options.contentDecoders) {\n                    contentDecoders.set(decoder.name, decoder);\n                }\n            }\n            if (options.contentTypeDecoder !== undefined) {\n                contentTypeDecoder = options.contentTypeDecoder;\n                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);\n            }\n            if (options.contentTypeDecoders !== undefined) {\n                for (const decoder of options.contentTypeDecoders) {\n                    contentTypeDecoders.set(decoder.name, decoder);\n                }\n            }\n        }\n        if (contentTypeDecoder === undefined) {\n            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;\n            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);\n        }\n        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };\n    }\n    ResolvedMessageReaderOptions.fromOptions = fromOptions;\n})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));\nclass ReadableStreamMessageReader extends AbstractMessageReader {\n    constructor(readable, options) {\n        super();\n        this.readable = readable;\n        this.options = ResolvedMessageReaderOptions.fromOptions(options);\n        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);\n        this._partialMessageTimeout = 10000;\n        this.nextMessageLength = -1;\n        this.messageToken = 0;\n        this.readSemaphore = new semaphore_1.Semaphore(1);\n    }\n    set partialMessageTimeout(timeout) {\n        this._partialMessageTimeout = timeout;\n    }\n    get partialMessageTimeout() {\n        return this._partialMessageTimeout;\n    }\n    listen(callback) {\n        this.nextMessageLength = -1;\n        this.messageToken = 0;\n        this.partialMessageTimer = undefined;\n        this.callback = callback;\n        const result = this.readable.onData((data) => {\n            this.onData(data);\n        });\n        this.readable.onError((error) => this.fireError(error));\n        this.readable.onClose(() => this.fireClose());\n        return result;\n    }\n    onData(data) {\n        try {\n            this.buffer.append(data);\n            while (true) {\n                if (this.nextMessageLength === -1) {\n                    const headers = this.buffer.tryReadHeaders(true);\n                    if (!headers) {\n                        return;\n                    }\n                    const contentLength = headers.get('content-length');\n                    if (!contentLength) {\n                        this.fireError(new Error(`Header must provide a Content-Length property.\\n${JSON.stringify(Object.fromEntries(headers))}`));\n                        return;\n                    }\n                    const length = parseInt(contentLength);\n                    if (isNaN(length)) {\n                        this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));\n                        return;\n                    }\n                    this.nextMessageLength = length;\n                }\n                const body = this.buffer.tryReadBody(this.nextMessageLength);\n                if (body === undefined) {\n                    /** We haven't received the full message yet. */\n                    this.setPartialMessageTimer();\n                    return;\n                }\n                this.clearPartialMessageTimer();\n                this.nextMessageLength = -1;\n                // Make sure that we convert one received message after the\n                // other. Otherwise it could happen that a decoding of a second\n                // smaller message finished before the decoding of a first larger\n                // message and then we would deliver the second message first.\n                this.readSemaphore.lock(async () => {\n                    const bytes = this.options.contentDecoder !== undefined\n                        ? await this.options.contentDecoder.decode(body)\n                        : body;\n                    const message = await this.options.contentTypeDecoder.decode(bytes, this.options);\n                    this.callback(message);\n                }).catch((error) => {\n                    this.fireError(error);\n                });\n            }\n        }\n        catch (error) {\n            this.fireError(error);\n        }\n    }\n    clearPartialMessageTimer() {\n        if (this.partialMessageTimer) {\n            this.partialMessageTimer.dispose();\n            this.partialMessageTimer = undefined;\n        }\n    }\n    setPartialMessageTimer() {\n        this.clearPartialMessageTimer();\n        if (this._partialMessageTimeout <= 0) {\n            return;\n        }\n        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {\n            this.partialMessageTimer = undefined;\n            if (token === this.messageToken) {\n                this.firePartialMessage({ messageToken: token, waitingTime: timeout });\n                this.setPartialMessageTimer();\n            }\n        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);\n    }\n}\nexports.ReadableStreamMessageReader = ReadableStreamMessageReader;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}