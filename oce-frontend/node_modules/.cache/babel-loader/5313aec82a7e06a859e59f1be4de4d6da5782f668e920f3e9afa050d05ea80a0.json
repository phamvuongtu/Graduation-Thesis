{"ast":null,"code":"import { onUnexpectedError } from './errors.js';\nimport { toDisposable, DisposableStore } from './lifecycle.js';\nfunction isReadableStream(obj) {\n  const candidate = obj;\n  if (!candidate) {\n    return false;\n  }\n  return [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(fn => typeof fn === 'function');\n}\nfunction isReadableBufferedStream(obj) {\n  const candidate = obj;\n  if (!candidate) {\n    return false;\n  }\n  return isReadableStream(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === 'boolean';\n}\nfunction newWriteableStream(reducer, options) {\n  return new WriteableStreamImpl(reducer, options);\n}\nclass WriteableStreamImpl {\n  constructor(reducer, options) {\n    this.reducer = reducer;\n    this.options = options;\n    this.state = {\n      flowing: false,\n      ended: false,\n      destroyed: false\n    };\n    this.buffer = {\n      data: [],\n      error: []\n    };\n    this.listeners = {\n      data: [],\n      error: [],\n      end: []\n    };\n    this.pendingWritePromises = [];\n  }\n  pause() {\n    if (this.state.destroyed) {\n      return;\n    }\n    this.state.flowing = false;\n  }\n  resume() {\n    if (this.state.destroyed) {\n      return;\n    }\n    if (!this.state.flowing) {\n      this.state.flowing = true;\n      this.flowData();\n      this.flowErrors();\n      this.flowEnd();\n    }\n  }\n  write(data) {\n    if (this.state.destroyed) {\n      return;\n    }\n    if (this.state.flowing) {\n      this.emitData(data);\n    } else {\n      this.buffer.data.push(data);\n      if (typeof this.options?.highWaterMark === 'number' && this.buffer.data.length > this.options.highWaterMark) {\n        return new Promise(resolve => this.pendingWritePromises.push(resolve));\n      }\n    }\n  }\n  error(error) {\n    if (this.state.destroyed) {\n      return;\n    }\n    if (this.state.flowing) {\n      this.emitError(error);\n    } else {\n      this.buffer.error.push(error);\n    }\n  }\n  end(result) {\n    if (this.state.destroyed) {\n      return;\n    }\n    if (typeof result !== 'undefined') {\n      this.write(result);\n    }\n    if (this.state.flowing) {\n      this.emitEnd();\n      this.destroy();\n    } else {\n      this.state.ended = true;\n    }\n  }\n  emitData(data) {\n    this.listeners.data.slice(0).forEach(listener => listener(data));\n  }\n  emitError(error) {\n    if (this.listeners.error.length === 0) {\n      onUnexpectedError(error);\n    } else {\n      this.listeners.error.slice(0).forEach(listener => listener(error));\n    }\n  }\n  emitEnd() {\n    this.listeners.end.slice(0).forEach(listener => listener());\n  }\n  on(event, callback) {\n    if (this.state.destroyed) {\n      return;\n    }\n    switch (event) {\n      case 'data':\n        this.listeners.data.push(callback);\n        this.resume();\n        break;\n      case 'end':\n        this.listeners.end.push(callback);\n        if (this.state.flowing && this.flowEnd()) {\n          this.destroy();\n        }\n        break;\n      case 'error':\n        this.listeners.error.push(callback);\n        if (this.state.flowing) {\n          this.flowErrors();\n        }\n        break;\n    }\n  }\n  removeListener(event, callback) {\n    if (this.state.destroyed) {\n      return;\n    }\n    let listeners = undefined;\n    switch (event) {\n      case 'data':\n        listeners = this.listeners.data;\n        break;\n      case 'end':\n        listeners = this.listeners.end;\n        break;\n      case 'error':\n        listeners = this.listeners.error;\n        break;\n    }\n    if (listeners) {\n      const index = listeners.indexOf(callback);\n      if (index >= 0) {\n        listeners.splice(index, 1);\n      }\n    }\n  }\n  flowData() {\n    if (this.buffer.data.length > 0) {\n      const fullDataBuffer = this.reducer(this.buffer.data);\n      this.emitData(fullDataBuffer);\n      this.buffer.data.length = 0;\n      const pendingWritePromises = [...this.pendingWritePromises];\n      this.pendingWritePromises.length = 0;\n      pendingWritePromises.forEach(pendingWritePromise => pendingWritePromise());\n    }\n  }\n  flowErrors() {\n    if (this.listeners.error.length > 0) {\n      for (const error of this.buffer.error) {\n        this.emitError(error);\n      }\n      this.buffer.error.length = 0;\n    }\n  }\n  flowEnd() {\n    if (this.state.ended) {\n      this.emitEnd();\n      return this.listeners.end.length > 0;\n    }\n    return false;\n  }\n  destroy() {\n    if (!this.state.destroyed) {\n      this.state.destroyed = true;\n      this.state.ended = true;\n      this.buffer.data.length = 0;\n      this.buffer.error.length = 0;\n      this.listeners.data.length = 0;\n      this.listeners.error.length = 0;\n      this.listeners.end.length = 0;\n      this.pendingWritePromises.length = 0;\n    }\n  }\n}\nfunction consumeReadable(readable, reducer) {\n  const chunks = [];\n  let chunk;\n  while ((chunk = readable.read()) !== null) {\n    chunks.push(chunk);\n  }\n  return reducer(chunks);\n}\nfunction peekReadable(readable, reducer, maxChunks) {\n  const chunks = [];\n  let chunk = undefined;\n  while ((chunk = readable.read()) !== null && chunks.length < maxChunks) {\n    chunks.push(chunk);\n  }\n  if (chunk === null && chunks.length > 0) {\n    return reducer(chunks);\n  }\n  return {\n    read: () => {\n      if (chunks.length > 0) {\n        return chunks.shift();\n      }\n      if (typeof chunk !== 'undefined') {\n        const lastReadChunk = chunk;\n        chunk = undefined;\n        return lastReadChunk;\n      }\n      return readable.read();\n    }\n  };\n}\nfunction consumeStream(stream, reducer) {\n  return new Promise((resolve, reject) => {\n    const chunks = [];\n    listenStream(stream, {\n      onData: chunk => {\n        if (reducer) {\n          chunks.push(chunk);\n        }\n      },\n      onError: error => {\n        if (reducer) {\n          reject(error);\n        } else {\n          resolve(undefined);\n        }\n      },\n      onEnd: () => {\n        if (reducer) {\n          resolve(reducer(chunks));\n        } else {\n          resolve(undefined);\n        }\n      }\n    });\n  });\n}\nfunction listenStream(stream, listener, token) {\n  stream.on('error', error => {\n    if (!token?.isCancellationRequested) {\n      listener.onError(error);\n    }\n  });\n  stream.on('end', () => {\n    if (!token?.isCancellationRequested) {\n      listener.onEnd();\n    }\n  });\n  stream.on('data', data => {\n    if (!token?.isCancellationRequested) {\n      listener.onData(data);\n    }\n  });\n}\nfunction peekStream(stream, maxChunks) {\n  return new Promise((resolve, reject) => {\n    const streamListeners = new DisposableStore();\n    const buffer = [];\n    const dataListener = chunk => {\n      buffer.push(chunk);\n      if (buffer.length > maxChunks) {\n        streamListeners.dispose();\n        stream.pause();\n        return resolve({\n          stream,\n          buffer,\n          ended: false\n        });\n      }\n    };\n    const errorListener = error => {\n      streamListeners.dispose();\n      return reject(error);\n    };\n    const endListener = () => {\n      streamListeners.dispose();\n      return resolve({\n        stream,\n        buffer,\n        ended: true\n      });\n    };\n    streamListeners.add(toDisposable(() => stream.removeListener('error', errorListener)));\n    stream.on('error', errorListener);\n    streamListeners.add(toDisposable(() => stream.removeListener('end', endListener)));\n    stream.on('end', endListener);\n    streamListeners.add(toDisposable(() => stream.removeListener('data', dataListener)));\n    stream.on('data', dataListener);\n  });\n}\nfunction toStream(t, reducer) {\n  const stream = newWriteableStream(reducer);\n  stream.end(t);\n  return stream;\n}\nfunction emptyStream() {\n  const stream = newWriteableStream(() => {\n    throw new Error('not supported');\n  });\n  stream.end();\n  return stream;\n}\nfunction toReadable(t) {\n  let consumed = false;\n  return {\n    read: () => {\n      if (consumed) {\n        return null;\n      }\n      consumed = true;\n      return t;\n    }\n  };\n}\nfunction transform(stream, transformer, reducer) {\n  const target = newWriteableStream(reducer);\n  listenStream(stream, {\n    onData: data => target.write(transformer.data(data)),\n    onError: error => target.error(transformer.error ? transformer.error(error) : error),\n    onEnd: () => target.end()\n  });\n  return target;\n}\nfunction prefixedReadable(prefix, readable, reducer) {\n  let prefixHandled = false;\n  return {\n    read: () => {\n      const chunk = readable.read();\n      if (!prefixHandled) {\n        prefixHandled = true;\n        if (chunk !== null) {\n          return reducer([prefix, chunk]);\n        }\n        return prefix;\n      }\n      return chunk;\n    }\n  };\n}\nfunction prefixedStream(prefix, stream, reducer) {\n  let prefixHandled = false;\n  const target = newWriteableStream(reducer);\n  listenStream(stream, {\n    onData: data => {\n      if (!prefixHandled) {\n        prefixHandled = true;\n        return target.write(reducer([prefix, data]));\n      }\n      return target.write(data);\n    },\n    onError: error => target.error(error),\n    onEnd: () => {\n      if (!prefixHandled) {\n        prefixHandled = true;\n        target.write(prefix);\n      }\n      target.end();\n    }\n  });\n  return target;\n}\nexport { consumeReadable, consumeStream, emptyStream, isReadableBufferedStream, isReadableStream, listenStream, newWriteableStream, peekReadable, peekStream, prefixedReadable, prefixedStream, toReadable, toStream, transform };","map":{"version":3,"names":["onUnexpectedError","toDisposable","DisposableStore","isReadableStream","obj","candidate","on","pause","resume","destroy","every","fn","isReadableBufferedStream","stream","Array","isArray","buffer","ended","newWriteableStream","reducer","options","WriteableStreamImpl","constructor","state","flowing","destroyed","data","error","listeners","end","pendingWritePromises","flowData","flowErrors","flowEnd","write","emitData","push","highWaterMark","length","Promise","resolve","emitError","result","emitEnd","slice","forEach","listener","event","callback","removeListener","undefined","index","indexOf","splice","fullDataBuffer","pendingWritePromise","consumeReadable","readable","chunks","chunk","read","peekReadable","maxChunks","shift","lastReadChunk","consumeStream","reject","listenStream","onData","onError","onEnd","token","isCancellationRequested","peekStream","streamListeners","dataListener","dispose","errorListener","endListener","add","toStream","t","emptyStream","Error","toReadable","consumed","transform","transformer","target","prefixedReadable","prefix","prefixHandled","prefixedStream"],"sources":["/Users/phamtu/Downloads/Code/OCE/oce-frontend/node_modules/vscode/vscode/src/vs/base/common/stream.js"],"sourcesContent":["import { onUnexpectedError } from './errors.js';\nimport { toDisposable, DisposableStore } from './lifecycle.js';\nfunction isReadableStream(obj) {\n    const candidate = obj;\n    if (!candidate) {\n        return false;\n    }\n    return [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(fn => typeof fn === 'function');\n}\nfunction isReadableBufferedStream(obj) {\n    const candidate = obj;\n    if (!candidate) {\n        return false;\n    }\n    return isReadableStream(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === 'boolean';\n}\nfunction newWriteableStream(reducer, options) {\n    return ( new WriteableStreamImpl(reducer, options));\n}\nclass WriteableStreamImpl {\n    constructor(reducer, options) {\n        this.reducer = reducer;\n        this.options = options;\n        this.state = {\n            flowing: false,\n            ended: false,\n            destroyed: false\n        };\n        this.buffer = {\n            data: [],\n            error: []\n        };\n        this.listeners = {\n            data: [],\n            error: [],\n            end: []\n        };\n        this.pendingWritePromises = [];\n    }\n    pause() {\n        if (this.state.destroyed) {\n            return;\n        }\n        this.state.flowing = false;\n    }\n    resume() {\n        if (this.state.destroyed) {\n            return;\n        }\n        if (!this.state.flowing) {\n            this.state.flowing = true;\n            this.flowData();\n            this.flowErrors();\n            this.flowEnd();\n        }\n    }\n    write(data) {\n        if (this.state.destroyed) {\n            return;\n        }\n        if (this.state.flowing) {\n            this.emitData(data);\n        }\n        else {\n            this.buffer.data.push(data);\n            if (typeof this.options?.highWaterMark === 'number' && this.buffer.data.length > this.options.highWaterMark) {\n                return ( new Promise(resolve => this.pendingWritePromises.push(resolve)));\n            }\n        }\n    }\n    error(error) {\n        if (this.state.destroyed) {\n            return;\n        }\n        if (this.state.flowing) {\n            this.emitError(error);\n        }\n        else {\n            this.buffer.error.push(error);\n        }\n    }\n    end(result) {\n        if (this.state.destroyed) {\n            return;\n        }\n        if (typeof result !== 'undefined') {\n            this.write(result);\n        }\n        if (this.state.flowing) {\n            this.emitEnd();\n            this.destroy();\n        }\n        else {\n            this.state.ended = true;\n        }\n    }\n    emitData(data) {\n        this.listeners.data.slice(0).forEach(listener => listener(data));\n    }\n    emitError(error) {\n        if (this.listeners.error.length === 0) {\n            onUnexpectedError(error);\n        }\n        else {\n            this.listeners.error.slice(0).forEach(listener => listener(error));\n        }\n    }\n    emitEnd() {\n        this.listeners.end.slice(0).forEach(listener => listener());\n    }\n    on(event, callback) {\n        if (this.state.destroyed) {\n            return;\n        }\n        switch (event) {\n            case 'data':\n                this.listeners.data.push(callback);\n                this.resume();\n                break;\n            case 'end':\n                this.listeners.end.push(callback);\n                if (this.state.flowing && this.flowEnd()) {\n                    this.destroy();\n                }\n                break;\n            case 'error':\n                this.listeners.error.push(callback);\n                if (this.state.flowing) {\n                    this.flowErrors();\n                }\n                break;\n        }\n    }\n    removeListener(event, callback) {\n        if (this.state.destroyed) {\n            return;\n        }\n        let listeners = undefined;\n        switch (event) {\n            case 'data':\n                listeners = this.listeners.data;\n                break;\n            case 'end':\n                listeners = this.listeners.end;\n                break;\n            case 'error':\n                listeners = this.listeners.error;\n                break;\n        }\n        if (listeners) {\n            const index = listeners.indexOf(callback);\n            if (index >= 0) {\n                listeners.splice(index, 1);\n            }\n        }\n    }\n    flowData() {\n        if (this.buffer.data.length > 0) {\n            const fullDataBuffer = this.reducer(this.buffer.data);\n            this.emitData(fullDataBuffer);\n            this.buffer.data.length = 0;\n            const pendingWritePromises = [...this.pendingWritePromises];\n            this.pendingWritePromises.length = 0;\n            pendingWritePromises.forEach(pendingWritePromise => pendingWritePromise());\n        }\n    }\n    flowErrors() {\n        if (this.listeners.error.length > 0) {\n            for (const error of this.buffer.error) {\n                this.emitError(error);\n            }\n            this.buffer.error.length = 0;\n        }\n    }\n    flowEnd() {\n        if (this.state.ended) {\n            this.emitEnd();\n            return this.listeners.end.length > 0;\n        }\n        return false;\n    }\n    destroy() {\n        if (!this.state.destroyed) {\n            this.state.destroyed = true;\n            this.state.ended = true;\n            this.buffer.data.length = 0;\n            this.buffer.error.length = 0;\n            this.listeners.data.length = 0;\n            this.listeners.error.length = 0;\n            this.listeners.end.length = 0;\n            this.pendingWritePromises.length = 0;\n        }\n    }\n}\nfunction consumeReadable(readable, reducer) {\n    const chunks = [];\n    let chunk;\n    while ((chunk = readable.read()) !== null) {\n        chunks.push(chunk);\n    }\n    return reducer(chunks);\n}\nfunction peekReadable(readable, reducer, maxChunks) {\n    const chunks = [];\n    let chunk = undefined;\n    while ((chunk = readable.read()) !== null && chunks.length < maxChunks) {\n        chunks.push(chunk);\n    }\n    if (chunk === null && chunks.length > 0) {\n        return reducer(chunks);\n    }\n    return {\n        read: () => {\n            if (chunks.length > 0) {\n                return chunks.shift();\n            }\n            if (typeof chunk !== 'undefined') {\n                const lastReadChunk = chunk;\n                chunk = undefined;\n                return lastReadChunk;\n            }\n            return readable.read();\n        }\n    };\n}\nfunction consumeStream(stream, reducer) {\n    return ( new Promise((resolve, reject) => {\n        const chunks = [];\n        listenStream(stream, {\n            onData: chunk => {\n                if (reducer) {\n                    chunks.push(chunk);\n                }\n            },\n            onError: error => {\n                if (reducer) {\n                    reject(error);\n                }\n                else {\n                    resolve(undefined);\n                }\n            },\n            onEnd: () => {\n                if (reducer) {\n                    resolve(reducer(chunks));\n                }\n                else {\n                    resolve(undefined);\n                }\n            }\n        });\n    }));\n}\nfunction listenStream(stream, listener, token) {\n    stream.on('error', error => {\n        if (!token?.isCancellationRequested) {\n            listener.onError(error);\n        }\n    });\n    stream.on('end', () => {\n        if (!token?.isCancellationRequested) {\n            listener.onEnd();\n        }\n    });\n    stream.on('data', data => {\n        if (!token?.isCancellationRequested) {\n            listener.onData(data);\n        }\n    });\n}\nfunction peekStream(stream, maxChunks) {\n    return ( new Promise((resolve, reject) => {\n        const streamListeners = ( new DisposableStore());\n        const buffer = [];\n        const dataListener = (chunk) => {\n            buffer.push(chunk);\n            if (buffer.length > maxChunks) {\n                streamListeners.dispose();\n                stream.pause();\n                return resolve({ stream, buffer, ended: false });\n            }\n        };\n        const errorListener = (error) => {\n            streamListeners.dispose();\n            return reject(error);\n        };\n        const endListener = () => {\n            streamListeners.dispose();\n            return resolve({ stream, buffer, ended: true });\n        };\n        streamListeners.add(toDisposable(() => stream.removeListener('error', errorListener)));\n        stream.on('error', errorListener);\n        streamListeners.add(toDisposable(() => stream.removeListener('end', endListener)));\n        stream.on('end', endListener);\n        streamListeners.add(toDisposable(() => stream.removeListener('data', dataListener)));\n        stream.on('data', dataListener);\n    }));\n}\nfunction toStream(t, reducer) {\n    const stream = newWriteableStream(reducer);\n    stream.end(t);\n    return stream;\n}\nfunction emptyStream() {\n    const stream = newWriteableStream(() => { throw ( new Error('not supported')); });\n    stream.end();\n    return stream;\n}\nfunction toReadable(t) {\n    let consumed = false;\n    return {\n        read: () => {\n            if (consumed) {\n                return null;\n            }\n            consumed = true;\n            return t;\n        }\n    };\n}\nfunction transform(stream, transformer, reducer) {\n    const target = newWriteableStream(reducer);\n    listenStream(stream, {\n        onData: data => target.write(transformer.data(data)),\n        onError: error => target.error(transformer.error ? transformer.error(error) : error),\n        onEnd: () => target.end()\n    });\n    return target;\n}\nfunction prefixedReadable(prefix, readable, reducer) {\n    let prefixHandled = false;\n    return {\n        read: () => {\n            const chunk = readable.read();\n            if (!prefixHandled) {\n                prefixHandled = true;\n                if (chunk !== null) {\n                    return reducer([prefix, chunk]);\n                }\n                return prefix;\n            }\n            return chunk;\n        }\n    };\n}\nfunction prefixedStream(prefix, stream, reducer) {\n    let prefixHandled = false;\n    const target = newWriteableStream(reducer);\n    listenStream(stream, {\n        onData: data => {\n            if (!prefixHandled) {\n                prefixHandled = true;\n                return target.write(reducer([prefix, data]));\n            }\n            return target.write(data);\n        },\n        onError: error => target.error(error),\n        onEnd: () => {\n            if (!prefixHandled) {\n                prefixHandled = true;\n                target.write(prefix);\n            }\n            target.end();\n        }\n    });\n    return target;\n}\nexport { consumeReadable, consumeStream, emptyStream, isReadableBufferedStream, isReadableStream, listenStream, newWriteableStream, peekReadable, peekStream, prefixedReadable, prefixedStream, toReadable, toStream, transform };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}