{"ast":null,"code":"import { isMacintosh, isLinux, isWindows, isWeb, isEdge, isFirefox, isChrome, isSafari } from '../../../base/common/platform.js';\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { Scanner } from './scanner.js';\nimport { localizeWithPath } from '../../../nls.js';\nimport { illegalArgument } from '../../../base/common/errors.js';\nconst _moduleId = \"vs/platform/contextkey/common/contextkey\";\nconst CONSTANT_VALUES = new Map();\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', isEdge);\nCONSTANT_VALUES.set('isFirefox', isFirefox);\nCONSTANT_VALUES.set('isChrome', isChrome);\nCONSTANT_VALUES.set('isSafari', isSafari);\nfunction setConstant(key, value) {\n  if (CONSTANT_VALUES.get(key) !== undefined) {\n    throw illegalArgument('contextkey.setConstant(k, v) invoked with already set constant `k`');\n  }\n  CONSTANT_VALUES.set(key, value);\n}\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst defaultConfig = {\n  regexParsingWithErrorRecovery: true\n};\nconst errorEmptyString = localizeWithPath(_moduleId, 0, \"Empty context key expression\");\nconst hintEmptyString = localizeWithPath(_moduleId, 1, \"Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.\");\nconst errorNoInAfterNot = localizeWithPath(_moduleId, 2, \"'in' after 'not'.\");\nconst errorClosingParenthesis = localizeWithPath(_moduleId, 3, \"closing parenthesis ')'\");\nconst errorUnexpectedToken = localizeWithPath(_moduleId, 4, \"Unexpected token\");\nconst hintUnexpectedToken = localizeWithPath(_moduleId, 5, \"Did you forget to put && or || before the token?\");\nconst errorUnexpectedEOF = localizeWithPath(_moduleId, 6, \"Unexpected end of expression\");\nconst hintUnexpectedEOF = localizeWithPath(_moduleId, 7, \"Did you forget to put a context key?\");\nclass Parser {\n  static {\n    this._parseError = new Error();\n  }\n  get lexingErrors() {\n    return this._scanner.errors;\n  }\n  get parsingErrors() {\n    return this._parsingErrors;\n  }\n  constructor(_config = defaultConfig) {\n    this._config = _config;\n    this._scanner = new Scanner();\n    this._tokens = [];\n    this._current = 0;\n    this._parsingErrors = [];\n    this._flagsGYRe = /g|y/g;\n  }\n  parse(input) {\n    if (input === '') {\n      this._parsingErrors.push({\n        message: errorEmptyString,\n        offset: 0,\n        lexeme: '',\n        additionalInfo: hintEmptyString\n      });\n      return undefined;\n    }\n    this._tokens = this._scanner.reset(input).scan();\n    this._current = 0;\n    this._parsingErrors = [];\n    try {\n      const expr = this._expr();\n      if (!this._isAtEnd()) {\n        const peek = this._peek();\n        const additionalInfo = peek.type === 17 ? hintUnexpectedToken : undefined;\n        this._parsingErrors.push({\n          message: errorUnexpectedToken,\n          offset: peek.offset,\n          lexeme: Scanner.getLexeme(peek),\n          additionalInfo\n        });\n        throw Parser._parseError;\n      }\n      return expr;\n    } catch (e) {\n      if (!(e === Parser._parseError)) {\n        throw e;\n      }\n      return undefined;\n    }\n  }\n  _expr() {\n    return this._or();\n  }\n  _or() {\n    const expr = [this._and()];\n    while (this._matchOne(16)) {\n      const right = this._and();\n      expr.push(right);\n    }\n    return expr.length === 1 ? expr[0] : ContextKeyExpr.or(...expr);\n  }\n  _and() {\n    const expr = [this._term()];\n    while (this._matchOne(15)) {\n      const right = this._term();\n      expr.push(right);\n    }\n    return expr.length === 1 ? expr[0] : ContextKeyExpr.and(...expr);\n  }\n  _term() {\n    if (this._matchOne(2)) {\n      const peek = this._peek();\n      switch (peek.type) {\n        case 11:\n          this._advance();\n          return ContextKeyFalseExpr.INSTANCE;\n        case 12:\n          this._advance();\n          return ContextKeyTrueExpr.INSTANCE;\n        case 0:\n          {\n            this._advance();\n            const expr = this._expr();\n            this._consume(1, errorClosingParenthesis);\n            return expr?.negate();\n          }\n        case 17:\n          this._advance();\n          return ContextKeyNotExpr.create(peek.lexeme);\n        default:\n          throw this._errExpectedButGot(`KEY | true | false | '(' expression ')'`, peek);\n      }\n    }\n    return this._primary();\n  }\n  _primary() {\n    const peek = this._peek();\n    switch (peek.type) {\n      case 11:\n        this._advance();\n        return ContextKeyExpr.true();\n      case 12:\n        this._advance();\n        return ContextKeyExpr.false();\n      case 0:\n        {\n          this._advance();\n          const expr = this._expr();\n          this._consume(1, errorClosingParenthesis);\n          return expr;\n        }\n      case 17:\n        {\n          const key = peek.lexeme;\n          this._advance();\n          if (this._matchOne(9)) {\n            const expr = this._peek();\n            if (!this._config.regexParsingWithErrorRecovery) {\n              this._advance();\n              if (expr.type !== 10) {\n                throw this._errExpectedButGot(`REGEX`, expr);\n              }\n              const regexLexeme = expr.lexeme;\n              const closingSlashIndex = regexLexeme.lastIndexOf('/');\n              const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n              let regexp;\n              try {\n                regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);\n              } catch (e) {\n                throw this._errExpectedButGot(`REGEX`, expr);\n              }\n              return ContextKeyRegexExpr.create(key, regexp);\n            }\n            switch (expr.type) {\n              case 10:\n              case 19:\n                {\n                  const lexemeReconstruction = [expr.lexeme];\n                  this._advance();\n                  let followingToken = this._peek();\n                  let parenBalance = 0;\n                  for (let i = 0; i < expr.lexeme.length; i++) {\n                    if (expr.lexeme.charCodeAt(i) === 40) {\n                      parenBalance++;\n                    } else if (expr.lexeme.charCodeAt(i) === 41) {\n                      parenBalance--;\n                    }\n                  }\n                  while (!this._isAtEnd() && followingToken.type !== 15 && followingToken.type !== 16) {\n                    switch (followingToken.type) {\n                      case 0:\n                        parenBalance++;\n                        break;\n                      case 1:\n                        parenBalance--;\n                        break;\n                      case 10:\n                      case 18:\n                        for (let i = 0; i < followingToken.lexeme.length; i++) {\n                          if (followingToken.lexeme.charCodeAt(i) === 40) {\n                            parenBalance++;\n                          } else if (expr.lexeme.charCodeAt(i) === 41) {\n                            parenBalance--;\n                          }\n                        }\n                    }\n                    if (parenBalance < 0) {\n                      break;\n                    }\n                    lexemeReconstruction.push(Scanner.getLexeme(followingToken));\n                    this._advance();\n                    followingToken = this._peek();\n                  }\n                  const regexLexeme = lexemeReconstruction.join('');\n                  const closingSlashIndex = regexLexeme.lastIndexOf('/');\n                  const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n                  let regexp;\n                  try {\n                    regexp = new RegExp(regexLexeme.substring(1, closingSlashIndex), flags);\n                  } catch (e) {\n                    throw this._errExpectedButGot(`REGEX`, expr);\n                  }\n                  return ContextKeyExpr.regex(key, regexp);\n                }\n              case 18:\n                {\n                  const serializedValue = expr.lexeme;\n                  this._advance();\n                  let regex = null;\n                  if (!isFalsyOrWhitespace(serializedValue)) {\n                    const start = serializedValue.indexOf('/');\n                    const end = serializedValue.lastIndexOf('/');\n                    if (start !== end && start >= 0) {\n                      const value = serializedValue.slice(start + 1, end);\n                      const caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n                      try {\n                        regex = new RegExp(value, caseIgnoreFlag);\n                      } catch (_e) {\n                        throw this._errExpectedButGot(`REGEX`, expr);\n                      }\n                    }\n                  }\n                  if (regex === null) {\n                    throw this._errExpectedButGot('REGEX', expr);\n                  }\n                  return ContextKeyRegexExpr.create(key, regex);\n                }\n              default:\n                throw this._errExpectedButGot('REGEX', this._peek());\n            }\n          }\n          if (this._matchOne(14)) {\n            this._consume(13, errorNoInAfterNot);\n            const right = this._value();\n            return ContextKeyExpr.notIn(key, right);\n          }\n          const maybeOp = this._peek().type;\n          switch (maybeOp) {\n            case 3:\n              {\n                this._advance();\n                const right = this._value();\n                if (this._previous().type === 18) {\n                  return ContextKeyExpr.equals(key, right);\n                }\n                switch (right) {\n                  case 'true':\n                    return ContextKeyExpr.has(key);\n                  case 'false':\n                    return ContextKeyExpr.not(key);\n                  default:\n                    return ContextKeyExpr.equals(key, right);\n                }\n              }\n            case 4:\n              {\n                this._advance();\n                const right = this._value();\n                if (this._previous().type === 18) {\n                  return ContextKeyExpr.notEquals(key, right);\n                }\n                switch (right) {\n                  case 'true':\n                    return ContextKeyExpr.not(key);\n                  case 'false':\n                    return ContextKeyExpr.has(key);\n                  default:\n                    return ContextKeyExpr.notEquals(key, right);\n                }\n              }\n            case 5:\n              this._advance();\n              return ContextKeySmallerExpr.create(key, this._value());\n            case 6:\n              this._advance();\n              return ContextKeySmallerEqualsExpr.create(key, this._value());\n            case 7:\n              this._advance();\n              return ContextKeyGreaterExpr.create(key, this._value());\n            case 8:\n              this._advance();\n              return ContextKeyGreaterEqualsExpr.create(key, this._value());\n            case 13:\n              this._advance();\n              return ContextKeyExpr.in(key, this._value());\n            default:\n              return ContextKeyExpr.has(key);\n          }\n        }\n      case 20:\n        this._parsingErrors.push({\n          message: errorUnexpectedEOF,\n          offset: peek.offset,\n          lexeme: '',\n          additionalInfo: hintUnexpectedEOF\n        });\n        throw Parser._parseError;\n      default:\n        throw this._errExpectedButGot(`true | false | KEY \\n\\t| KEY '=~' REGEX \\n\\t| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());\n    }\n  }\n  _value() {\n    const token = this._peek();\n    switch (token.type) {\n      case 17:\n      case 18:\n        this._advance();\n        return token.lexeme;\n      case 11:\n        this._advance();\n        return 'true';\n      case 12:\n        this._advance();\n        return 'false';\n      case 13:\n        this._advance();\n        return 'in';\n      default:\n        return '';\n    }\n  }\n  _removeFlagsGY(flags) {\n    return flags.replaceAll(this._flagsGYRe, '');\n  }\n  _previous() {\n    return this._tokens[this._current - 1];\n  }\n  _matchOne(token) {\n    if (this._check(token)) {\n      this._advance();\n      return true;\n    }\n    return false;\n  }\n  _advance() {\n    if (!this._isAtEnd()) {\n      this._current++;\n    }\n    return this._previous();\n  }\n  _consume(type, message) {\n    if (this._check(type)) {\n      return this._advance();\n    }\n    throw this._errExpectedButGot(message, this._peek());\n  }\n  _errExpectedButGot(expected, got, additionalInfo) {\n    const message = localizeWithPath(_moduleId, 8, \"Expected: {0}\\nReceived: '{1}'.\", expected, Scanner.getLexeme(got));\n    const offset = got.offset;\n    const lexeme = Scanner.getLexeme(got);\n    this._parsingErrors.push({\n      message,\n      offset,\n      lexeme,\n      additionalInfo\n    });\n    return Parser._parseError;\n  }\n  _check(type) {\n    return this._peek().type === type;\n  }\n  _peek() {\n    return this._tokens[this._current];\n  }\n  _isAtEnd() {\n    return this._peek().type === 20;\n  }\n}\nclass ContextKeyExpr {\n  static false() {\n    return ContextKeyFalseExpr.INSTANCE;\n  }\n  static true() {\n    return ContextKeyTrueExpr.INSTANCE;\n  }\n  static has(key) {\n    return ContextKeyDefinedExpr.create(key);\n  }\n  static equals(key, value) {\n    return ContextKeyEqualsExpr.create(key, value);\n  }\n  static notEquals(key, value) {\n    return ContextKeyNotEqualsExpr.create(key, value);\n  }\n  static regex(key, value) {\n    return ContextKeyRegexExpr.create(key, value);\n  }\n  static in(key, value) {\n    return ContextKeyInExpr.create(key, value);\n  }\n  static notIn(key, value) {\n    return ContextKeyNotInExpr.create(key, value);\n  }\n  static not(key) {\n    return ContextKeyNotExpr.create(key);\n  }\n  static and(...expr) {\n    return ContextKeyAndExpr.create(expr, null, true);\n  }\n  static or(...expr) {\n    return ContextKeyOrExpr.create(expr, null, true);\n  }\n  static greater(key, value) {\n    return ContextKeyGreaterExpr.create(key, value);\n  }\n  static greaterEquals(key, value) {\n    return ContextKeyGreaterEqualsExpr.create(key, value);\n  }\n  static smaller(key, value) {\n    return ContextKeySmallerExpr.create(key, value);\n  }\n  static smallerEquals(key, value) {\n    return ContextKeySmallerEqualsExpr.create(key, value);\n  }\n  static {\n    this._parser = new Parser({\n      regexParsingWithErrorRecovery: false\n    });\n  }\n  static deserialize(serialized) {\n    if (serialized === undefined || serialized === null) {\n      return undefined;\n    }\n    const expr = this._parser.parse(serialized);\n    return expr;\n  }\n}\nfunction validateWhenClauses(whenClauses) {\n  const parser = new Parser({\n    regexParsingWithErrorRecovery: false\n  });\n  return whenClauses.map(whenClause => {\n    parser.parse(whenClause);\n    if (parser.lexingErrors.length > 0) {\n      return parser.lexingErrors.map(se => ({\n        errorMessage: se.additionalInfo ? localizeWithPath(_moduleId, 9, \"Unexpected token. Hint: {0}\", se.additionalInfo) : localizeWithPath(_moduleId, 10, \"Unexpected token.\"),\n        offset: se.offset,\n        length: se.lexeme.length\n      }));\n    } else if (parser.parsingErrors.length > 0) {\n      return parser.parsingErrors.map(pe => ({\n        errorMessage: pe.additionalInfo ? `${pe.message}. ${pe.additionalInfo}` : pe.message,\n        offset: pe.offset,\n        length: pe.lexeme.length\n      }));\n    } else {\n      return [];\n    }\n  });\n}\nfunction expressionsAreEqualWithConstantSubstitution(a, b) {\n  const aExpr = a ? a.substituteConstants() : undefined;\n  const bExpr = b ? b.substituteConstants() : undefined;\n  if (!aExpr && !bExpr) {\n    return true;\n  }\n  if (!aExpr || !bExpr) {\n    return false;\n  }\n  return aExpr.equals(bExpr);\n}\nfunction cmp(a, b) {\n  return a.cmp(b);\n}\nclass ContextKeyFalseExpr {\n  static {\n    this.INSTANCE = new ContextKeyFalseExpr();\n  }\n  constructor() {\n    this.type = 0;\n  }\n  cmp(other) {\n    return this.type - other.type;\n  }\n  equals(other) {\n    return other.type === this.type;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    return false;\n  }\n  serialize() {\n    return 'false';\n  }\n  keys() {\n    return [];\n  }\n  map(mapFnc) {\n    return this;\n  }\n  negate() {\n    return ContextKeyTrueExpr.INSTANCE;\n  }\n}\nclass ContextKeyTrueExpr {\n  static {\n    this.INSTANCE = new ContextKeyTrueExpr();\n  }\n  constructor() {\n    this.type = 1;\n  }\n  cmp(other) {\n    return this.type - other.type;\n  }\n  equals(other) {\n    return other.type === this.type;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    return true;\n  }\n  serialize() {\n    return 'true';\n  }\n  keys() {\n    return [];\n  }\n  map(mapFnc) {\n    return this;\n  }\n  negate() {\n    return ContextKeyFalseExpr.INSTANCE;\n  }\n}\nclass ContextKeyDefinedExpr {\n  static create(key, negated = null) {\n    const constantValue = CONSTANT_VALUES.get(key);\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n    return new ContextKeyDefinedExpr(key, negated);\n  }\n  constructor(key, negated) {\n    this.key = key;\n    this.negated = negated;\n    this.type = 2;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp1(this.key, other.key);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key;\n    }\n    return false;\n  }\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n    return this;\n  }\n  evaluate(context) {\n    return !!context.getValue(this.key);\n  }\n  serialize() {\n    return this.key;\n  }\n  keys() {\n    return [this.key];\n  }\n  map(mapFnc) {\n    return mapFnc.mapDefined(this.key);\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotExpr.create(this.key, this);\n    }\n    return this.negated;\n  }\n}\nclass ContextKeyEqualsExpr {\n  static create(key, value, negated = null) {\n    if (typeof value === 'boolean') {\n      return value ? ContextKeyDefinedExpr.create(key, negated) : ContextKeyNotExpr.create(key, negated);\n    }\n    const constantValue = CONSTANT_VALUES.get(key);\n    if (typeof constantValue === 'boolean') {\n      const trueValue = constantValue ? 'true' : 'false';\n      return value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n    return new ContextKeyEqualsExpr(key, value, negated);\n  }\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 4;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n    if (typeof constantValue === 'boolean') {\n      const trueValue = constantValue ? 'true' : 'false';\n      return this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n    }\n    return this;\n  }\n  evaluate(context) {\n    return context.getValue(this.key) == this.value;\n  }\n  serialize() {\n    return `${this.key} == '${this.value}'`;\n  }\n  keys() {\n    return [this.key];\n  }\n  map(mapFnc) {\n    return mapFnc.mapEquals(this.key, this.value);\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n    }\n    return this.negated;\n  }\n}\nclass ContextKeyInExpr {\n  static create(key, valueKey) {\n    return new ContextKeyInExpr(key, valueKey);\n  }\n  constructor(key, valueKey) {\n    this.key = key;\n    this.valueKey = valueKey;\n    this.type = 10;\n    this.negated = null;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.valueKey, other.key, other.valueKey);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.valueKey === other.valueKey;\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    const source = context.getValue(this.valueKey);\n    const item = context.getValue(this.key);\n    if (Array.isArray(source)) {\n      return source.includes(item);\n    }\n    if (typeof item === 'string' && typeof source === 'object' && source !== null) {\n      return hasOwnProperty.call(source, item);\n    }\n    return false;\n  }\n  serialize() {\n    return `${this.key} in '${this.valueKey}'`;\n  }\n  keys() {\n    return [this.key, this.valueKey];\n  }\n  map(mapFnc) {\n    return mapFnc.mapIn(this.key, this.valueKey);\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);\n    }\n    return this.negated;\n  }\n}\nclass ContextKeyNotInExpr {\n  static create(key, valueKey) {\n    return new ContextKeyNotInExpr(key, valueKey);\n  }\n  constructor(key, valueKey) {\n    this.key = key;\n    this.valueKey = valueKey;\n    this.type = 11;\n    this._negated = ContextKeyInExpr.create(key, valueKey);\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return this._negated.cmp(other._negated);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this._negated.equals(other._negated);\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    return !this._negated.evaluate(context);\n  }\n  serialize() {\n    return `${this.key} not in '${this.valueKey}'`;\n  }\n  keys() {\n    return this._negated.keys();\n  }\n  map(mapFnc) {\n    return mapFnc.mapNotIn(this.key, this.valueKey);\n  }\n  negate() {\n    return this._negated;\n  }\n}\nclass ContextKeyNotEqualsExpr {\n  static create(key, value, negated = null) {\n    if (typeof value === 'boolean') {\n      if (value) {\n        return ContextKeyNotExpr.create(key, negated);\n      }\n      return ContextKeyDefinedExpr.create(key, negated);\n    }\n    const constantValue = CONSTANT_VALUES.get(key);\n    if (typeof constantValue === 'boolean') {\n      const falseValue = constantValue ? 'true' : 'false';\n      return value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n    return new ContextKeyNotEqualsExpr(key, value, negated);\n  }\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 5;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n    if (typeof constantValue === 'boolean') {\n      const falseValue = constantValue ? 'true' : 'false';\n      return this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n    return this;\n  }\n  evaluate(context) {\n    return context.getValue(this.key) != this.value;\n  }\n  serialize() {\n    return `${this.key} != '${this.value}'`;\n  }\n  keys() {\n    return [this.key];\n  }\n  map(mapFnc) {\n    return mapFnc.mapNotEquals(this.key, this.value);\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n    }\n    return this.negated;\n  }\n}\nclass ContextKeyNotExpr {\n  static create(key, negated = null) {\n    const constantValue = CONSTANT_VALUES.get(key);\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n    return new ContextKeyNotExpr(key, negated);\n  }\n  constructor(key, negated) {\n    this.key = key;\n    this.negated = negated;\n    this.type = 3;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp1(this.key, other.key);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key;\n    }\n    return false;\n  }\n  substituteConstants() {\n    const constantValue = CONSTANT_VALUES.get(this.key);\n    if (typeof constantValue === 'boolean') {\n      return constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE;\n    }\n    return this;\n  }\n  evaluate(context) {\n    return !context.getValue(this.key);\n  }\n  serialize() {\n    return `!${this.key}`;\n  }\n  keys() {\n    return [this.key];\n  }\n  map(mapFnc) {\n    return mapFnc.mapNot(this.key);\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyDefinedExpr.create(this.key, this);\n    }\n    return this.negated;\n  }\n}\nfunction withFloatOrStr(value, callback) {\n  if (typeof value === 'string') {\n    const n = parseFloat(value);\n    if (!isNaN(n)) {\n      value = n;\n    }\n  }\n  if (typeof value === 'string' || typeof value === 'number') {\n    return callback(value);\n  }\n  return ContextKeyFalseExpr.INSTANCE;\n}\nclass ContextKeyGreaterExpr {\n  static create(key, _value, negated = null) {\n    return withFloatOrStr(_value, value => new ContextKeyGreaterExpr(key, value, negated));\n  }\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 12;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n    return parseFloat(context.getValue(this.key)) > this.value;\n  }\n  serialize() {\n    return `${this.key} > ${this.value}`;\n  }\n  keys() {\n    return [this.key];\n  }\n  map(mapFnc) {\n    return mapFnc.mapGreater(this.key, this.value);\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n    }\n    return this.negated;\n  }\n}\nclass ContextKeyGreaterEqualsExpr {\n  static create(key, _value, negated = null) {\n    return withFloatOrStr(_value, value => new ContextKeyGreaterEqualsExpr(key, value, negated));\n  }\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 13;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n    return parseFloat(context.getValue(this.key)) >= this.value;\n  }\n  serialize() {\n    return `${this.key} >= ${this.value}`;\n  }\n  keys() {\n    return [this.key];\n  }\n  map(mapFnc) {\n    return mapFnc.mapGreaterEquals(this.key, this.value);\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n    }\n    return this.negated;\n  }\n}\nclass ContextKeySmallerExpr {\n  static create(key, _value, negated = null) {\n    return withFloatOrStr(_value, value => new ContextKeySmallerExpr(key, value, negated));\n  }\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 14;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n    return parseFloat(context.getValue(this.key)) < this.value;\n  }\n  serialize() {\n    return `${this.key} < ${this.value}`;\n  }\n  keys() {\n    return [this.key];\n  }\n  map(mapFnc) {\n    return mapFnc.mapSmaller(this.key, this.value);\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n    }\n    return this.negated;\n  }\n}\nclass ContextKeySmallerEqualsExpr {\n  static create(key, _value, negated = null) {\n    return withFloatOrStr(_value, value => new ContextKeySmallerEqualsExpr(key, value, negated));\n  }\n  constructor(key, value, negated) {\n    this.key = key;\n    this.value = value;\n    this.negated = negated;\n    this.type = 15;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return cmp2(this.key, this.value, other.key, other.value);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this.key === other.key && this.value === other.value;\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    if (typeof this.value === 'string') {\n      return false;\n    }\n    return parseFloat(context.getValue(this.key)) <= this.value;\n  }\n  serialize() {\n    return `${this.key} <= ${this.value}`;\n  }\n  keys() {\n    return [this.key];\n  }\n  map(mapFnc) {\n    return mapFnc.mapSmallerEquals(this.key, this.value);\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n    }\n    return this.negated;\n  }\n}\nclass ContextKeyRegexExpr {\n  static create(key, regexp) {\n    return new ContextKeyRegexExpr(key, regexp);\n  }\n  constructor(key, regexp) {\n    this.key = key;\n    this.regexp = regexp;\n    this.type = 7;\n    this.negated = null;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    if (this.key < other.key) {\n      return -1;\n    }\n    if (this.key > other.key) {\n      return 1;\n    }\n    const thisSource = this.regexp ? this.regexp.source : '';\n    const otherSource = other.regexp ? other.regexp.source : '';\n    if (thisSource < otherSource) {\n      return -1;\n    }\n    if (thisSource > otherSource) {\n      return 1;\n    }\n    return 0;\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      const thisSource = this.regexp ? this.regexp.source : '';\n      const otherSource = other.regexp ? other.regexp.source : '';\n      return this.key === other.key && thisSource === otherSource;\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    const value = context.getValue(this.key);\n    return this.regexp ? this.regexp.test(value) : false;\n  }\n  serialize() {\n    const value = this.regexp ? `/${this.regexp.source}/${this.regexp.flags}` : '/invalid/';\n    return `${this.key} =~ ${value}`;\n  }\n  keys() {\n    return [this.key];\n  }\n  map(mapFnc) {\n    return mapFnc.mapRegex(this.key, this.regexp);\n  }\n  negate() {\n    if (!this.negated) {\n      this.negated = ContextKeyNotRegexExpr.create(this);\n    }\n    return this.negated;\n  }\n}\nclass ContextKeyNotRegexExpr {\n  static create(actual) {\n    return new ContextKeyNotRegexExpr(actual);\n  }\n  constructor(_actual) {\n    this._actual = _actual;\n    this.type = 8;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    return this._actual.cmp(other._actual);\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      return this._actual.equals(other._actual);\n    }\n    return false;\n  }\n  substituteConstants() {\n    return this;\n  }\n  evaluate(context) {\n    return !this._actual.evaluate(context);\n  }\n  serialize() {\n    return `!(${this._actual.serialize()})`;\n  }\n  keys() {\n    return this._actual.keys();\n  }\n  map(mapFnc) {\n    return new ContextKeyNotRegexExpr(this._actual.map(mapFnc));\n  }\n  negate() {\n    return this._actual;\n  }\n}\nfunction eliminateConstantsInArray(arr) {\n  let newArr = null;\n  for (let i = 0, len = arr.length; i < len; i++) {\n    const newExpr = arr[i].substituteConstants();\n    if (arr[i] !== newExpr) {\n      if (newArr === null) {\n        newArr = [];\n        for (let j = 0; j < i; j++) {\n          newArr[j] = arr[j];\n        }\n      }\n    }\n    if (newArr !== null) {\n      newArr[i] = newExpr;\n    }\n  }\n  if (newArr === null) {\n    return arr;\n  }\n  return newArr;\n}\nclass ContextKeyAndExpr {\n  static create(_expr, negated, extraRedundantCheck) {\n    return ContextKeyAndExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n  }\n  constructor(expr, negated) {\n    this.expr = expr;\n    this.negated = negated;\n    this.type = 6;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    if (this.expr.length < other.expr.length) {\n      return -1;\n    }\n    if (this.expr.length > other.expr.length) {\n      return 1;\n    }\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      const r = cmp(this.expr[i], other.expr[i]);\n      if (r !== 0) {\n        return r;\n      }\n    }\n    return 0;\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      if (this.expr.length !== other.expr.length) {\n        return false;\n      }\n      for (let i = 0, len = this.expr.length; i < len; i++) {\n        if (!this.expr[i].equals(other.expr[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  substituteConstants() {\n    const exprArr = eliminateConstantsInArray(this.expr);\n    if (exprArr === this.expr) {\n      return this;\n    }\n    return ContextKeyAndExpr.create(exprArr, this.negated, false);\n  }\n  evaluate(context) {\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      if (!this.expr[i].evaluate(context)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  static _normalizeArr(arr, negated, extraRedundantCheck) {\n    const expr = [];\n    let hasTrue = false;\n    for (const e of arr) {\n      if (!e) {\n        continue;\n      }\n      if (e.type === 1) {\n        hasTrue = true;\n        continue;\n      }\n      if (e.type === 0) {\n        return ContextKeyFalseExpr.INSTANCE;\n      }\n      if (e.type === 6) {\n        expr.push(...e.expr);\n        continue;\n      }\n      expr.push(e);\n    }\n    if (expr.length === 0 && hasTrue) {\n      return ContextKeyTrueExpr.INSTANCE;\n    }\n    if (expr.length === 0) {\n      return undefined;\n    }\n    if (expr.length === 1) {\n      return expr[0];\n    }\n    expr.sort(cmp);\n    for (let i = 1; i < expr.length; i++) {\n      if (expr[i - 1].equals(expr[i])) {\n        expr.splice(i, 1);\n        i--;\n      }\n    }\n    if (expr.length === 1) {\n      return expr[0];\n    }\n    while (expr.length > 1) {\n      const lastElement = expr[expr.length - 1];\n      if (lastElement.type !== 9) {\n        break;\n      }\n      expr.pop();\n      const secondToLastElement = expr.pop();\n      const isFinished = expr.length === 0;\n      const resultElement = ContextKeyOrExpr.create(lastElement.expr.map(el => ContextKeyAndExpr.create([el, secondToLastElement], null, extraRedundantCheck)), null, isFinished);\n      if (resultElement) {\n        expr.push(resultElement);\n        expr.sort(cmp);\n      }\n    }\n    if (expr.length === 1) {\n      return expr[0];\n    }\n    if (extraRedundantCheck) {\n      for (let i = 0; i < expr.length; i++) {\n        for (let j = i + 1; j < expr.length; j++) {\n          if (expr[i].negate().equals(expr[j])) {\n            return ContextKeyFalseExpr.INSTANCE;\n          }\n        }\n      }\n      if (expr.length === 1) {\n        return expr[0];\n      }\n    }\n    return new ContextKeyAndExpr(expr, negated);\n  }\n  serialize() {\n    return this.expr.map(e => e.serialize()).join(' && ');\n  }\n  keys() {\n    const result = [];\n    for (const expr of this.expr) {\n      result.push(...expr.keys());\n    }\n    return result;\n  }\n  map(mapFnc) {\n    return new ContextKeyAndExpr(this.expr.map(expr => expr.map(mapFnc)), null);\n  }\n  negate() {\n    if (!this.negated) {\n      const result = [];\n      for (const expr of this.expr) {\n        result.push(expr.negate());\n      }\n      this.negated = ContextKeyOrExpr.create(result, this, true);\n    }\n    return this.negated;\n  }\n}\nclass ContextKeyOrExpr {\n  static create(_expr, negated, extraRedundantCheck) {\n    return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n  }\n  constructor(expr, negated) {\n    this.expr = expr;\n    this.negated = negated;\n    this.type = 9;\n  }\n  cmp(other) {\n    if (other.type !== this.type) {\n      return this.type - other.type;\n    }\n    if (this.expr.length < other.expr.length) {\n      return -1;\n    }\n    if (this.expr.length > other.expr.length) {\n      return 1;\n    }\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      const r = cmp(this.expr[i], other.expr[i]);\n      if (r !== 0) {\n        return r;\n      }\n    }\n    return 0;\n  }\n  equals(other) {\n    if (other.type === this.type) {\n      if (this.expr.length !== other.expr.length) {\n        return false;\n      }\n      for (let i = 0, len = this.expr.length; i < len; i++) {\n        if (!this.expr[i].equals(other.expr[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  substituteConstants() {\n    const exprArr = eliminateConstantsInArray(this.expr);\n    if (exprArr === this.expr) {\n      return this;\n    }\n    return ContextKeyOrExpr.create(exprArr, this.negated, false);\n  }\n  evaluate(context) {\n    for (let i = 0, len = this.expr.length; i < len; i++) {\n      if (this.expr[i].evaluate(context)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  static _normalizeArr(arr, negated, extraRedundantCheck) {\n    let expr = [];\n    let hasFalse = false;\n    if (arr) {\n      for (let i = 0, len = arr.length; i < len; i++) {\n        const e = arr[i];\n        if (!e) {\n          continue;\n        }\n        if (e.type === 0) {\n          hasFalse = true;\n          continue;\n        }\n        if (e.type === 1) {\n          return ContextKeyTrueExpr.INSTANCE;\n        }\n        if (e.type === 9) {\n          expr = expr.concat(e.expr);\n          continue;\n        }\n        expr.push(e);\n      }\n      if (expr.length === 0 && hasFalse) {\n        return ContextKeyFalseExpr.INSTANCE;\n      }\n      expr.sort(cmp);\n    }\n    if (expr.length === 0) {\n      return undefined;\n    }\n    if (expr.length === 1) {\n      return expr[0];\n    }\n    for (let i = 1; i < expr.length; i++) {\n      if (expr[i - 1].equals(expr[i])) {\n        expr.splice(i, 1);\n        i--;\n      }\n    }\n    if (expr.length === 1) {\n      return expr[0];\n    }\n    if (extraRedundantCheck) {\n      for (let i = 0; i < expr.length; i++) {\n        for (let j = i + 1; j < expr.length; j++) {\n          if (expr[i].negate().equals(expr[j])) {\n            return ContextKeyTrueExpr.INSTANCE;\n          }\n        }\n      }\n      if (expr.length === 1) {\n        return expr[0];\n      }\n    }\n    return new ContextKeyOrExpr(expr, negated);\n  }\n  serialize() {\n    return this.expr.map(e => e.serialize()).join(' || ');\n  }\n  keys() {\n    const result = [];\n    for (const expr of this.expr) {\n      result.push(...expr.keys());\n    }\n    return result;\n  }\n  map(mapFnc) {\n    return new ContextKeyOrExpr(this.expr.map(expr => expr.map(mapFnc)), null);\n  }\n  negate() {\n    if (!this.negated) {\n      const result = [];\n      for (const expr of this.expr) {\n        result.push(expr.negate());\n      }\n      while (result.length > 1) {\n        const LEFT = result.shift();\n        const RIGHT = result.shift();\n        const all = [];\n        for (const left of getTerminals(LEFT)) {\n          for (const right of getTerminals(RIGHT)) {\n            all.push(ContextKeyAndExpr.create([left, right], null, false));\n          }\n        }\n        result.unshift(ContextKeyOrExpr.create(all, null, false));\n      }\n      this.negated = ContextKeyOrExpr.create(result, this, true);\n    }\n    return this.negated;\n  }\n}\nclass RawContextKey extends ContextKeyDefinedExpr {\n  static {\n    this._info = [];\n  }\n  static all() {\n    return RawContextKey._info.values();\n  }\n  constructor(key, defaultValue, metaOrHide) {\n    super(key, null);\n    this._defaultValue = defaultValue;\n    if (typeof metaOrHide === 'object') {\n      RawContextKey._info.push({\n        ...metaOrHide,\n        key\n      });\n    } else if (metaOrHide !== true) {\n      RawContextKey._info.push({\n        key,\n        description: metaOrHide,\n        type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined\n      });\n    }\n  }\n  bindTo(target) {\n    return target.createKey(this.key, this._defaultValue);\n  }\n  getValue(target) {\n    return target.getContextKeyValue(this.key);\n  }\n  toNegated() {\n    return this.negate();\n  }\n  isEqualTo(value) {\n    return ContextKeyEqualsExpr.create(this.key, value);\n  }\n  notEqualsTo(value) {\n    return ContextKeyNotEqualsExpr.create(this.key, value);\n  }\n}\nfunction cmp1(key1, key2) {\n  if (key1 < key2) {\n    return -1;\n  }\n  if (key1 > key2) {\n    return 1;\n  }\n  return 0;\n}\nfunction cmp2(key1, value1, key2, value2) {\n  if (key1 < key2) {\n    return -1;\n  }\n  if (key1 > key2) {\n    return 1;\n  }\n  if (value1 < value2) {\n    return -1;\n  }\n  if (value1 > value2) {\n    return 1;\n  }\n  return 0;\n}\nfunction implies(p, q) {\n  if (p.type === 0 || q.type === 1) {\n    return true;\n  }\n  if (p.type === 9) {\n    if (q.type === 9) {\n      return allElementsIncluded(p.expr, q.expr);\n    }\n    return false;\n  }\n  if (q.type === 9) {\n    for (const element of q.expr) {\n      if (implies(p, element)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  if (p.type === 6) {\n    if (q.type === 6) {\n      return allElementsIncluded(q.expr, p.expr);\n    }\n    for (const element of p.expr) {\n      if (implies(element, q)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  return p.equals(q);\n}\nfunction allElementsIncluded(p, q) {\n  let pIndex = 0;\n  let qIndex = 0;\n  while (pIndex < p.length && qIndex < q.length) {\n    const cmp = p[pIndex].cmp(q[qIndex]);\n    if (cmp < 0) {\n      return false;\n    } else if (cmp === 0) {\n      pIndex++;\n      qIndex++;\n    } else {\n      qIndex++;\n    }\n  }\n  return pIndex === p.length;\n}\nfunction getTerminals(node) {\n  if (node.type === 9) {\n    return node.expr;\n  }\n  return [node];\n}\nexport { ContextKeyAndExpr, ContextKeyDefinedExpr, ContextKeyEqualsExpr, ContextKeyExpr, ContextKeyFalseExpr, ContextKeyGreaterEqualsExpr, ContextKeyGreaterExpr, ContextKeyInExpr, ContextKeyNotEqualsExpr, ContextKeyNotExpr, ContextKeyNotInExpr, ContextKeyNotRegexExpr, ContextKeyOrExpr, ContextKeyRegexExpr, ContextKeySmallerEqualsExpr, ContextKeySmallerExpr, ContextKeyTrueExpr, Parser, RawContextKey, expressionsAreEqualWithConstantSubstitution, implies, setConstant, validateWhenClauses };","map":{"version":3,"names":["isMacintosh","isLinux","isWindows","isWeb","isEdge","isFirefox","isChrome","isSafari","isFalsyOrWhitespace","Scanner","localizeWithPath","illegalArgument","_moduleId","CONSTANT_VALUES","Map","set","setConstant","key","value","get","undefined","hasOwnProperty","Object","prototype","defaultConfig","regexParsingWithErrorRecovery","errorEmptyString","hintEmptyString","errorNoInAfterNot","errorClosingParenthesis","errorUnexpectedToken","hintUnexpectedToken","errorUnexpectedEOF","hintUnexpectedEOF","Parser","_parseError","Error","lexingErrors","_scanner","errors","parsingErrors","_parsingErrors","constructor","_config","_tokens","_current","_flagsGYRe","parse","input","push","message","offset","lexeme","additionalInfo","reset","scan","expr","_expr","_isAtEnd","peek","_peek","type","getLexeme","e","_or","_and","_matchOne","right","length","ContextKeyExpr","or","_term","and","_advance","ContextKeyFalseExpr","INSTANCE","ContextKeyTrueExpr","_consume","negate","ContextKeyNotExpr","create","_errExpectedButGot","_primary","true","false","regexLexeme","closingSlashIndex","lastIndexOf","flags","_removeFlagsGY","substring","regexp","RegExp","ContextKeyRegexExpr","lexemeReconstruction","followingToken","parenBalance","i","charCodeAt","join","regex","serializedValue","start","indexOf","end","slice","caseIgnoreFlag","_e","_value","notIn","maybeOp","_previous","equals","has","not","notEquals","ContextKeySmallerExpr","ContextKeySmallerEqualsExpr","ContextKeyGreaterExpr","ContextKeyGreaterEqualsExpr","in","token","replaceAll","_check","expected","got","ContextKeyDefinedExpr","ContextKeyEqualsExpr","ContextKeyNotEqualsExpr","ContextKeyInExpr","ContextKeyNotInExpr","ContextKeyAndExpr","ContextKeyOrExpr","greater","greaterEquals","smaller","smallerEquals","_parser","deserialize","serialized","validateWhenClauses","whenClauses","parser","map","whenClause","se","errorMessage","pe","expressionsAreEqualWithConstantSubstitution","a","b","aExpr","substituteConstants","bExpr","cmp","other","evaluate","context","serialize","keys","mapFnc","negated","constantValue","cmp1","getValue","mapDefined","trueValue","cmp2","mapEquals","valueKey","source","item","Array","isArray","includes","call","mapIn","_negated","mapNotIn","falseValue","mapNotEquals","mapNot","withFloatOrStr","callback","n","parseFloat","isNaN","mapGreater","mapGreaterEquals","mapSmaller","mapSmallerEquals","thisSource","otherSource","test","mapRegex","ContextKeyNotRegexExpr","actual","_actual","eliminateConstantsInArray","arr","newArr","len","newExpr","j","extraRedundantCheck","_normalizeArr","r","exprArr","hasTrue","sort","splice","lastElement","pop","secondToLastElement","isFinished","resultElement","el","result","hasFalse","concat","LEFT","shift","RIGHT","all","left","getTerminals","unshift","RawContextKey","_info","values","defaultValue","metaOrHide","_defaultValue","description","bindTo","target","createKey","getContextKeyValue","toNegated","isEqualTo","notEqualsTo","key1","key2","value1","value2","implies","p","q","allElementsIncluded","element","pIndex","qIndex","node"],"sources":["/Users/phamtu/Downloads/Code/OCE/oce-frontend/node_modules/vscode/vscode/src/vs/platform/contextkey/common/contextkey.js"],"sourcesContent":["import { isMacintosh, isLinux, isWindows, isWeb, isEdge, isFirefox, isChrome, isSafari } from '../../../base/common/platform.js';\nimport { isFalsyOrWhitespace } from '../../../base/common/strings.js';\nimport { Scanner } from './scanner.js';\nimport { localizeWithPath } from '../../../nls.js';\nimport { illegalArgument } from '../../../base/common/errors.js';\nconst _moduleId = \"vs/platform/contextkey/common/contextkey\";\nconst CONSTANT_VALUES = ( (new Map()));\nCONSTANT_VALUES.set('false', false);\nCONSTANT_VALUES.set('true', true);\nCONSTANT_VALUES.set('isMac', isMacintosh);\nCONSTANT_VALUES.set('isLinux', isLinux);\nCONSTANT_VALUES.set('isWindows', isWindows);\nCONSTANT_VALUES.set('isWeb', isWeb);\nCONSTANT_VALUES.set('isMacNative', isMacintosh && !isWeb);\nCONSTANT_VALUES.set('isEdge', isEdge);\nCONSTANT_VALUES.set('isFirefox', isFirefox);\nCONSTANT_VALUES.set('isChrome', isChrome);\nCONSTANT_VALUES.set('isSafari', isSafari);\nfunction setConstant(key, value) {\n    if (CONSTANT_VALUES.get(key) !== undefined) {\n        throw illegalArgument('contextkey.setConstant(k, v) invoked with already set constant `k`');\n    }\n    CONSTANT_VALUES.set(key, value);\n}\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst defaultConfig = {\n    regexParsingWithErrorRecovery: true\n};\nconst errorEmptyString = ( localizeWithPath(_moduleId, 0, \"Empty context key expression\"));\nconst hintEmptyString = ( localizeWithPath(\n    _moduleId,\n    1,\n    \"Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively.\"\n));\nconst errorNoInAfterNot = ( localizeWithPath(_moduleId, 2, \"'in' after 'not'.\"));\nconst errorClosingParenthesis = ( localizeWithPath(_moduleId, 3, \"closing parenthesis ')'\"));\nconst errorUnexpectedToken = ( localizeWithPath(_moduleId, 4, \"Unexpected token\"));\nconst hintUnexpectedToken = ( localizeWithPath(_moduleId, 5, \"Did you forget to put && or || before the token?\"));\nconst errorUnexpectedEOF = ( localizeWithPath(_moduleId, 6, \"Unexpected end of expression\"));\nconst hintUnexpectedEOF = ( localizeWithPath(_moduleId, 7, \"Did you forget to put a context key?\"));\nclass Parser {\n    static { this._parseError = ( (new Error())); }\n    get lexingErrors() {\n        return this._scanner.errors;\n    }\n    get parsingErrors() {\n        return this._parsingErrors;\n    }\n    constructor(_config = defaultConfig) {\n        this._config = _config;\n        this._scanner = ( (new Scanner()));\n        this._tokens = [];\n        this._current = 0;\n        this._parsingErrors = [];\n        this._flagsGYRe = /g|y/g;\n    }\n    parse(input) {\n        if (input === '') {\n            this._parsingErrors.push({ message: errorEmptyString, offset: 0, lexeme: '', additionalInfo: hintEmptyString });\n            return undefined;\n        }\n        this._tokens = this._scanner.reset(input).scan();\n        this._current = 0;\n        this._parsingErrors = [];\n        try {\n            const expr = this._expr();\n            if (!this._isAtEnd()) {\n                const peek = this._peek();\n                const additionalInfo = peek.type === 17  ? hintUnexpectedToken : undefined;\n                this._parsingErrors.push({ message: errorUnexpectedToken, offset: peek.offset, lexeme: Scanner.getLexeme(peek), additionalInfo });\n                throw Parser._parseError;\n            }\n            return expr;\n        }\n        catch (e) {\n            if (!(e === Parser._parseError)) {\n                throw e;\n            }\n            return undefined;\n        }\n    }\n    _expr() {\n        return this._or();\n    }\n    _or() {\n        const expr = [this._and()];\n        while (this._matchOne(16 )) {\n            const right = this._and();\n            expr.push(right);\n        }\n        return expr.length === 1 ? expr[0] : ( (ContextKeyExpr.or(...expr)));\n    }\n    _and() {\n        const expr = [this._term()];\n        while (this._matchOne(15 )) {\n            const right = this._term();\n            expr.push(right);\n        }\n        return expr.length === 1 ? expr[0] : ( (ContextKeyExpr.and(...expr)));\n    }\n    _term() {\n        if (this._matchOne(2 )) {\n            const peek = this._peek();\n            switch (peek.type) {\n                case 11 :\n                    this._advance();\n                    return ContextKeyFalseExpr.INSTANCE;\n                case 12 :\n                    this._advance();\n                    return ContextKeyTrueExpr.INSTANCE;\n                case 0 : {\n                    this._advance();\n                    const expr = this._expr();\n                    this._consume(1 , errorClosingParenthesis);\n                    return expr?.negate();\n                }\n                case 17 :\n                    this._advance();\n                    return (\n                         (ContextKeyNotExpr.create(peek.lexeme))\n                    );\n                default:\n                    throw this._errExpectedButGot(`KEY | true | false | '(' expression ')'`, peek);\n            }\n        }\n        return this._primary();\n    }\n    _primary() {\n        const peek = this._peek();\n        switch (peek.type) {\n            case 11 :\n                this._advance();\n                return ContextKeyExpr.true();\n            case 12 :\n                this._advance();\n                return (\n                     (ContextKeyExpr.false())\n                );\n            case 0 : {\n                this._advance();\n                const expr = this._expr();\n                this._consume(1 , errorClosingParenthesis);\n                return expr;\n            }\n            case 17 : {\n                const key = peek.lexeme;\n                this._advance();\n                if (this._matchOne(9 )) {\n                    const expr = this._peek();\n                    if (!this._config.regexParsingWithErrorRecovery) {\n                        this._advance();\n                        if (expr.type !== 10 ) {\n                            throw this._errExpectedButGot(`REGEX`, expr);\n                        }\n                        const regexLexeme = expr.lexeme;\n                        const closingSlashIndex = regexLexeme.lastIndexOf('/');\n                        const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n                        let regexp;\n                        try {\n                            regexp = ( (new RegExp(regexLexeme.substring(1, closingSlashIndex), flags)));\n                        }\n                        catch (e) {\n                            throw this._errExpectedButGot(`REGEX`, expr);\n                        }\n                        return ContextKeyRegexExpr.create(key, regexp);\n                    }\n                    switch (expr.type) {\n                        case 10 :\n                        case 19 : {\n                            const lexemeReconstruction = [expr.lexeme];\n                            this._advance();\n                            let followingToken = this._peek();\n                            let parenBalance = 0;\n                            for (let i = 0; i < expr.lexeme.length; i++) {\n                                if (expr.lexeme.charCodeAt(i) === 40 ) {\n                                    parenBalance++;\n                                }\n                                else if (expr.lexeme.charCodeAt(i) === 41 ) {\n                                    parenBalance--;\n                                }\n                            }\n                            while (!this._isAtEnd() && followingToken.type !== 15  && followingToken.type !== 16 ) {\n                                switch (followingToken.type) {\n                                    case 0 :\n                                        parenBalance++;\n                                        break;\n                                    case 1 :\n                                        parenBalance--;\n                                        break;\n                                    case 10 :\n                                    case 18 :\n                                        for (let i = 0; i < followingToken.lexeme.length; i++) {\n                                            if (followingToken.lexeme.charCodeAt(i) === 40 ) {\n                                                parenBalance++;\n                                            }\n                                            else if (expr.lexeme.charCodeAt(i) === 41 ) {\n                                                parenBalance--;\n                                            }\n                                        }\n                                }\n                                if (parenBalance < 0) {\n                                    break;\n                                }\n                                lexemeReconstruction.push(Scanner.getLexeme(followingToken));\n                                this._advance();\n                                followingToken = this._peek();\n                            }\n                            const regexLexeme = lexemeReconstruction.join('');\n                            const closingSlashIndex = regexLexeme.lastIndexOf('/');\n                            const flags = closingSlashIndex === regexLexeme.length - 1 ? undefined : this._removeFlagsGY(regexLexeme.substring(closingSlashIndex + 1));\n                            let regexp;\n                            try {\n                                regexp = ( (new RegExp(regexLexeme.substring(1, closingSlashIndex), flags)));\n                            }\n                            catch (e) {\n                                throw this._errExpectedButGot(`REGEX`, expr);\n                            }\n                            return (\n                                 (ContextKeyExpr.regex(key, regexp))\n                            );\n                        }\n                        case 18 : {\n                            const serializedValue = expr.lexeme;\n                            this._advance();\n                            let regex = null;\n                            if (!isFalsyOrWhitespace(serializedValue)) {\n                                const start = serializedValue.indexOf('/');\n                                const end = serializedValue.lastIndexOf('/');\n                                if (start !== end && start >= 0) {\n                                    const value = serializedValue.slice(start + 1, end);\n                                    const caseIgnoreFlag = serializedValue[end + 1] === 'i' ? 'i' : '';\n                                    try {\n                                        regex = ( (new RegExp(value, caseIgnoreFlag)));\n                                    }\n                                    catch (_e) {\n                                        throw this._errExpectedButGot(`REGEX`, expr);\n                                    }\n                                }\n                            }\n                            if (regex === null) {\n                                throw this._errExpectedButGot('REGEX', expr);\n                            }\n                            return ContextKeyRegexExpr.create(key, regex);\n                        }\n                        default:\n                            throw this._errExpectedButGot('REGEX', this._peek());\n                    }\n                }\n                if (this._matchOne(14 )) {\n                    this._consume(13 , errorNoInAfterNot);\n                    const right = this._value();\n                    return ContextKeyExpr.notIn(key, right);\n                }\n                const maybeOp = this._peek().type;\n                switch (maybeOp) {\n                    case 3 : {\n                        this._advance();\n                        const right = this._value();\n                        if (this._previous().type === 18 ) {\n                            return (\n                                 (ContextKeyExpr.equals(key, right))\n                            );\n                        }\n                        switch (right) {\n                            case 'true':\n                                return (\n                                     (ContextKeyExpr.has(key))\n                                );\n                            case 'false':\n                                return ContextKeyExpr.not(key);\n                            default:\n                                return (\n                                     (ContextKeyExpr.equals(key, right))\n                                );\n                        }\n                    }\n                    case 4 : {\n                        this._advance();\n                        const right = this._value();\n                        if (this._previous().type === 18 ) {\n                            return (\n                                 (ContextKeyExpr.notEquals(key, right))\n                            );\n                        }\n                        switch (right) {\n                            case 'true':\n                                return ContextKeyExpr.not(key);\n                            case 'false':\n                                return (\n                                     (ContextKeyExpr.has(key))\n                                );\n                            default:\n                                return (\n                                     (ContextKeyExpr.notEquals(key, right))\n                                );\n                        }\n                    }\n                    case 5 :\n                        this._advance();\n                        return ContextKeySmallerExpr.create(key, this._value());\n                    case 6 :\n                        this._advance();\n                        return ContextKeySmallerEqualsExpr.create(key, this._value());\n                    case 7 :\n                        this._advance();\n                        return ContextKeyGreaterExpr.create(key, this._value());\n                    case 8 :\n                        this._advance();\n                        return ContextKeyGreaterEqualsExpr.create(key, this._value());\n                    case 13 :\n                        this._advance();\n                        return ContextKeyExpr.in(key, this._value());\n                    default:\n                        return (\n                             (ContextKeyExpr.has(key))\n                        );\n                }\n            }\n            case 20 :\n                this._parsingErrors.push({ message: errorUnexpectedEOF, offset: peek.offset, lexeme: '', additionalInfo: hintUnexpectedEOF });\n                throw Parser._parseError;\n            default:\n                throw this._errExpectedButGot(`true | false | KEY \\n\\t| KEY '=~' REGEX \\n\\t| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());\n        }\n    }\n    _value() {\n        const token = this._peek();\n        switch (token.type) {\n            case 17 :\n            case 18 :\n                this._advance();\n                return token.lexeme;\n            case 11 :\n                this._advance();\n                return 'true';\n            case 12 :\n                this._advance();\n                return 'false';\n            case 13 :\n                this._advance();\n                return 'in';\n            default:\n                return '';\n        }\n    }\n    _removeFlagsGY(flags) {\n        return flags.replaceAll(this._flagsGYRe, '');\n    }\n    _previous() {\n        return this._tokens[this._current - 1];\n    }\n    _matchOne(token) {\n        if (this._check(token)) {\n            this._advance();\n            return true;\n        }\n        return false;\n    }\n    _advance() {\n        if (!this._isAtEnd()) {\n            this._current++;\n        }\n        return this._previous();\n    }\n    _consume(type, message) {\n        if (this._check(type)) {\n            return this._advance();\n        }\n        throw this._errExpectedButGot(message, this._peek());\n    }\n    _errExpectedButGot(expected, got, additionalInfo) {\n        const message = ( localizeWithPath(\n            _moduleId,\n            8,\n            \"Expected: {0}\\nReceived: '{1}'.\",\n            expected,\n            Scanner.getLexeme(got)\n        ));\n        const offset = got.offset;\n        const lexeme = Scanner.getLexeme(got);\n        this._parsingErrors.push({ message, offset, lexeme, additionalInfo });\n        return Parser._parseError;\n    }\n    _check(type) {\n        return this._peek().type === type;\n    }\n    _peek() {\n        return this._tokens[this._current];\n    }\n    _isAtEnd() {\n        return this._peek().type === 20 ;\n    }\n}\nclass ContextKeyExpr {\n    static false() {\n        return ContextKeyFalseExpr.INSTANCE;\n    }\n    static true() {\n        return ContextKeyTrueExpr.INSTANCE;\n    }\n    static has(key) {\n        return (\n             (ContextKeyDefinedExpr.create(key))\n        );\n    }\n    static equals(key, value) {\n        return ContextKeyEqualsExpr.create(key, value);\n    }\n    static notEquals(key, value) {\n        return ContextKeyNotEqualsExpr.create(key, value);\n    }\n    static regex(key, value) {\n        return ContextKeyRegexExpr.create(key, value);\n    }\n    static in(key, value) {\n        return ContextKeyInExpr.create(key, value);\n    }\n    static notIn(key, value) {\n        return ContextKeyNotInExpr.create(key, value);\n    }\n    static not(key) {\n        return (\n             (ContextKeyNotExpr.create(key))\n        );\n    }\n    static and(...expr) {\n        return ContextKeyAndExpr.create(expr, null, true);\n    }\n    static or(...expr) {\n        return ContextKeyOrExpr.create(expr, null, true);\n    }\n    static greater(key, value) {\n        return ContextKeyGreaterExpr.create(key, value);\n    }\n    static greaterEquals(key, value) {\n        return ContextKeyGreaterEqualsExpr.create(key, value);\n    }\n    static smaller(key, value) {\n        return ContextKeySmallerExpr.create(key, value);\n    }\n    static smallerEquals(key, value) {\n        return ContextKeySmallerEqualsExpr.create(key, value);\n    }\n    static { this._parser = ( (new Parser({ regexParsingWithErrorRecovery: false }))); }\n    static deserialize(serialized) {\n        if (serialized === undefined || serialized === null) {\n            return undefined;\n        }\n        const expr = this._parser.parse(serialized);\n        return expr;\n    }\n}\nfunction validateWhenClauses(whenClauses) {\n    const parser = ( (new Parser({ regexParsingWithErrorRecovery: false })));\n    return (\n         (whenClauses.map(whenClause => {\n            parser.parse(whenClause);\n            if (parser.lexingErrors.length > 0) {\n                return (\n                     (parser.lexingErrors.map((se) => ({\n                        errorMessage: se.additionalInfo ?\n                            ( localizeWithPath(_moduleId, 9, \"Unexpected token. Hint: {0}\", se.additionalInfo)) :\n                            ( localizeWithPath(_moduleId, 10, \"Unexpected token.\")),\n                        offset: se.offset,\n                        length: se.lexeme.length,\n                    })))\n                );\n            }\n            else if (parser.parsingErrors.length > 0) {\n                return (\n                     (parser.parsingErrors.map((pe) => ({\n                        errorMessage: pe.additionalInfo ? `${pe.message}. ${pe.additionalInfo}` : pe.message,\n                        offset: pe.offset,\n                        length: pe.lexeme.length,\n                    })))\n                );\n            }\n            else {\n                return [];\n            }\n        }))\n    );\n}\nfunction expressionsAreEqualWithConstantSubstitution(a, b) {\n    const aExpr = a ? a.substituteConstants() : undefined;\n    const bExpr = b ? b.substituteConstants() : undefined;\n    if (!aExpr && !bExpr) {\n        return true;\n    }\n    if (!aExpr || !bExpr) {\n        return false;\n    }\n    return aExpr.equals(bExpr);\n}\nfunction cmp(a, b) {\n    return a.cmp(b);\n}\nclass ContextKeyFalseExpr {\n    static { this.INSTANCE = ( (new ContextKeyFalseExpr())); }\n    constructor() {\n        this.type = 0 ;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return false;\n    }\n    serialize() {\n        return 'false';\n    }\n    keys() {\n        return [];\n    }\n    map(mapFnc) {\n        return this;\n    }\n    negate() {\n        return ContextKeyTrueExpr.INSTANCE;\n    }\n}\nclass ContextKeyTrueExpr {\n    static { this.INSTANCE = ( (new ContextKeyTrueExpr())); }\n    constructor() {\n        this.type = 1 ;\n    }\n    cmp(other) {\n        return this.type - other.type;\n    }\n    equals(other) {\n        return (other.type === this.type);\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return true;\n    }\n    serialize() {\n        return 'true';\n    }\n    keys() {\n        return [];\n    }\n    map(mapFnc) {\n        return this;\n    }\n    negate() {\n        return ContextKeyFalseExpr.INSTANCE;\n    }\n}\nclass ContextKeyDefinedExpr {\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return (\n             (new ContextKeyDefinedExpr(key, negated))\n        );\n    }\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 2 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return constantValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE;\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!!context.getValue(this.key));\n    }\n    serialize() {\n        return this.key;\n    }\n    keys() {\n        return [this.key];\n    }\n    map(mapFnc) {\n        return mapFnc.mapDefined(this.key);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ( (ContextKeyNotExpr.create(this.key, this)));\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyEqualsExpr {\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            return (value ?  (ContextKeyDefinedExpr.create(key, negated)) :  (ContextKeyNotExpr.create(key, negated)));\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return (\n             (new ContextKeyEqualsExpr(key, value, negated))\n        );\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 4 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const trueValue = constantValue ? 'true' : 'false';\n            return (this.value === trueValue ? ContextKeyTrueExpr.INSTANCE : ContextKeyFalseExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (context.getValue(this.key) == this.value);\n    }\n    serialize() {\n        return `${this.key} == '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    map(mapFnc) {\n        return mapFnc.mapEquals(this.key, this.value);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyInExpr {\n    static create(key, valueKey) {\n        return (\n             (new ContextKeyInExpr(key, valueKey))\n        );\n    }\n    constructor(key, valueKey) {\n        this.key = key;\n        this.valueKey = valueKey;\n        this.type = 10 ;\n        this.negated = null;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.valueKey, other.key, other.valueKey);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.valueKey === other.valueKey);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        const source = context.getValue(this.valueKey);\n        const item = context.getValue(this.key);\n        if (Array.isArray(source)) {\n            return source.includes(item);\n        }\n        if (typeof item === 'string' && typeof source === 'object' && source !== null) {\n            return hasOwnProperty.call(source, item);\n        }\n        return false;\n    }\n    serialize() {\n        return `${this.key} in '${this.valueKey}'`;\n    }\n    keys() {\n        return [this.key, this.valueKey];\n    }\n    map(mapFnc) {\n        return mapFnc.mapIn(this.key, this.valueKey);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotInExpr.create(this.key, this.valueKey);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyNotInExpr {\n    static create(key, valueKey) {\n        return (\n             (new ContextKeyNotInExpr(key, valueKey))\n        );\n    }\n    constructor(key, valueKey) {\n        this.key = key;\n        this.valueKey = valueKey;\n        this.type = 11 ;\n        this._negated = ContextKeyInExpr.create(key, valueKey);\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._negated.cmp(other._negated);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._negated.equals(other._negated);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._negated.evaluate(context);\n    }\n    serialize() {\n        return `${this.key} not in '${this.valueKey}'`;\n    }\n    keys() {\n        return (\n             (this._negated.keys())\n        );\n    }\n    map(mapFnc) {\n        return mapFnc.mapNotIn(this.key, this.valueKey);\n    }\n    negate() {\n        return this._negated;\n    }\n}\nclass ContextKeyNotEqualsExpr {\n    static create(key, value, negated = null) {\n        if (typeof value === 'boolean') {\n            if (value) {\n                return (\n                     (ContextKeyNotExpr.create(key, negated))\n                );\n            }\n            return (\n                 (ContextKeyDefinedExpr.create(key, negated))\n            );\n        }\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return (\n             (new ContextKeyNotEqualsExpr(key, value, negated))\n        );\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 5 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            const falseValue = constantValue ? 'true' : 'false';\n            return (this.value === falseValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (context.getValue(this.key) != this.value);\n    }\n    serialize() {\n        return `${this.key} != '${this.value}'`;\n    }\n    keys() {\n        return [this.key];\n    }\n    map(mapFnc) {\n        return mapFnc.mapNotEquals(this.key, this.value);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyNotExpr {\n    static create(key, negated = null) {\n        const constantValue = CONSTANT_VALUES.get(key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return (\n             (new ContextKeyNotExpr(key, negated))\n        );\n    }\n    constructor(key, negated) {\n        this.key = key;\n        this.negated = negated;\n        this.type = 3 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp1(this.key, other.key);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key);\n        }\n        return false;\n    }\n    substituteConstants() {\n        const constantValue = CONSTANT_VALUES.get(this.key);\n        if (typeof constantValue === 'boolean') {\n            return (constantValue ? ContextKeyFalseExpr.INSTANCE : ContextKeyTrueExpr.INSTANCE);\n        }\n        return this;\n    }\n    evaluate(context) {\n        return (!context.getValue(this.key));\n    }\n    serialize() {\n        return `!${this.key}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    map(mapFnc) {\n        return mapFnc.mapNot(this.key);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ( (ContextKeyDefinedExpr.create(this.key, this)));\n        }\n        return this.negated;\n    }\n}\nfunction withFloatOrStr(value, callback) {\n    if (typeof value === 'string') {\n        const n = parseFloat(value);\n        if (!isNaN(n)) {\n            value = n;\n        }\n    }\n    if (typeof value === 'string' || typeof value === 'number') {\n        return callback(value);\n    }\n    return ContextKeyFalseExpr.INSTANCE;\n}\nclass ContextKeyGreaterExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => ( (new ContextKeyGreaterExpr(key, value, negated))));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 12 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) > this.value);\n    }\n    serialize() {\n        return `${this.key} > ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    map(mapFnc) {\n        return mapFnc.mapGreater(this.key, this.value);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyGreaterEqualsExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => ( (new ContextKeyGreaterEqualsExpr(key, value, negated))));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 13 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) >= this.value);\n    }\n    serialize() {\n        return `${this.key} >= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    map(mapFnc) {\n        return mapFnc.mapGreaterEquals(this.key, this.value);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeySmallerExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeySmallerExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => ( (new ContextKeySmallerExpr(key, value, negated))));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 14 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) < this.value);\n    }\n    serialize() {\n        return `${this.key} < ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    map(mapFnc) {\n        return mapFnc.mapSmaller(this.key, this.value);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterEqualsExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeySmallerEqualsExpr {\n    static create(key, _value, negated = null) {\n        return withFloatOrStr(_value, (value) => ( (new ContextKeySmallerEqualsExpr(key, value, negated))));\n    }\n    constructor(key, value, negated) {\n        this.key = key;\n        this.value = value;\n        this.negated = negated;\n        this.type = 15 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return cmp2(this.key, this.value, other.key, other.value);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return (this.key === other.key && this.value === other.value);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        if (typeof this.value === 'string') {\n            return false;\n        }\n        return (parseFloat(context.getValue(this.key)) <= this.value);\n    }\n    serialize() {\n        return `${this.key} <= ${this.value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    map(mapFnc) {\n        return mapFnc.mapSmallerEquals(this.key, this.value);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyGreaterExpr.create(this.key, this.value, this);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyRegexExpr {\n    static create(key, regexp) {\n        return (\n             (new ContextKeyRegexExpr(key, regexp))\n        );\n    }\n    constructor(key, regexp) {\n        this.key = key;\n        this.regexp = regexp;\n        this.type = 7 ;\n        this.negated = null;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.key < other.key) {\n            return -1;\n        }\n        if (this.key > other.key) {\n            return 1;\n        }\n        const thisSource = this.regexp ? this.regexp.source : '';\n        const otherSource = other.regexp ? other.regexp.source : '';\n        if (thisSource < otherSource) {\n            return -1;\n        }\n        if (thisSource > otherSource) {\n            return 1;\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            const thisSource = this.regexp ? this.regexp.source : '';\n            const otherSource = other.regexp ? other.regexp.source : '';\n            return (this.key === other.key && thisSource === otherSource);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        const value = context.getValue(this.key);\n        return this.regexp ? this.regexp.test(value) : false;\n    }\n    serialize() {\n        const value = this.regexp\n            ? `/${this.regexp.source}/${this.regexp.flags}`\n            : '/invalid/';\n        return `${this.key} =~ ${value}`;\n    }\n    keys() {\n        return [this.key];\n    }\n    map(mapFnc) {\n        return mapFnc.mapRegex(this.key, this.regexp);\n    }\n    negate() {\n        if (!this.negated) {\n            this.negated = ContextKeyNotRegexExpr.create(this);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyNotRegexExpr {\n    static create(actual) {\n        return (\n             (new ContextKeyNotRegexExpr(actual))\n        );\n    }\n    constructor(_actual) {\n        this._actual = _actual;\n        this.type = 8 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        return this._actual.cmp(other._actual);\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            return this._actual.equals(other._actual);\n        }\n        return false;\n    }\n    substituteConstants() {\n        return this;\n    }\n    evaluate(context) {\n        return !this._actual.evaluate(context);\n    }\n    serialize() {\n        return `!(${this._actual.serialize()})`;\n    }\n    keys() {\n        return (\n             (this._actual.keys())\n        );\n    }\n    map(mapFnc) {\n        return (\n             (new ContextKeyNotRegexExpr( (this._actual.map(mapFnc))))\n        );\n    }\n    negate() {\n        return this._actual;\n    }\n}\nfunction eliminateConstantsInArray(arr) {\n    let newArr = null;\n    for (let i = 0, len = arr.length; i < len; i++) {\n        const newExpr = arr[i].substituteConstants();\n        if (arr[i] !== newExpr) {\n            if (newArr === null) {\n                newArr = [];\n                for (let j = 0; j < i; j++) {\n                    newArr[j] = arr[j];\n                }\n            }\n        }\n        if (newArr !== null) {\n            newArr[i] = newExpr;\n        }\n    }\n    if (newArr === null) {\n        return arr;\n    }\n    return newArr;\n}\nclass ContextKeyAndExpr {\n    static create(_expr, negated, extraRedundantCheck) {\n        return ContextKeyAndExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n    }\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 6 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            return this;\n        }\n        return ContextKeyAndExpr.create(exprArr, this.negated, false);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (!this.expr[i].evaluate(context)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static _normalizeArr(arr, negated, extraRedundantCheck) {\n        const expr = [];\n        let hasTrue = false;\n        for (const e of arr) {\n            if (!e) {\n                continue;\n            }\n            if (e.type === 1 ) {\n                hasTrue = true;\n                continue;\n            }\n            if (e.type === 0 ) {\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            if (e.type === 6 ) {\n                expr.push(...e.expr);\n                continue;\n            }\n            expr.push(e);\n        }\n        if (expr.length === 0 && hasTrue) {\n            return ContextKeyTrueExpr.INSTANCE;\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        expr.sort(cmp);\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        while (expr.length > 1) {\n            const lastElement = expr[expr.length - 1];\n            if (lastElement.type !== 9 ) {\n                break;\n            }\n            expr.pop();\n            const secondToLastElement = expr.pop();\n            const isFinished = (expr.length === 0);\n            const resultElement = ContextKeyOrExpr.create(( (lastElement.expr.map(\n                el => ContextKeyAndExpr.create([el, secondToLastElement], null, extraRedundantCheck)\n            ))), null, isFinished);\n            if (resultElement) {\n                expr.push(resultElement);\n                expr.sort(cmp);\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        if (extraRedundantCheck) {\n            for (let i = 0; i < expr.length; i++) {\n                for (let j = i + 1; j < expr.length; j++) {\n                    if (( (expr[i].negate())).equals(expr[j])) {\n                        return ContextKeyFalseExpr.INSTANCE;\n                    }\n                }\n            }\n            if (expr.length === 1) {\n                return expr[0];\n            }\n        }\n        return (\n             (new ContextKeyAndExpr(expr, negated))\n        );\n    }\n    serialize() {\n        return ( (this.expr.map(e => e.serialize()))).join(' && ');\n    }\n    keys() {\n        const result = [];\n        for (const expr of this.expr) {\n            result.push(...( (expr.keys())));\n        }\n        return result;\n    }\n    map(mapFnc) {\n        return (\n             (new ContextKeyAndExpr(\n                 (this.expr.map(expr => ( (expr.map(mapFnc))))),\n                null\n            ))\n        );\n    }\n    negate() {\n        if (!this.negated) {\n            const result = [];\n            for (const expr of this.expr) {\n                result.push(( (expr.negate())));\n            }\n            this.negated = ContextKeyOrExpr.create(result, this, true);\n        }\n        return this.negated;\n    }\n}\nclass ContextKeyOrExpr {\n    static create(_expr, negated, extraRedundantCheck) {\n        return ContextKeyOrExpr._normalizeArr(_expr, negated, extraRedundantCheck);\n    }\n    constructor(expr, negated) {\n        this.expr = expr;\n        this.negated = negated;\n        this.type = 9 ;\n    }\n    cmp(other) {\n        if (other.type !== this.type) {\n            return this.type - other.type;\n        }\n        if (this.expr.length < other.expr.length) {\n            return -1;\n        }\n        if (this.expr.length > other.expr.length) {\n            return 1;\n        }\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            const r = cmp(this.expr[i], other.expr[i]);\n            if (r !== 0) {\n                return r;\n            }\n        }\n        return 0;\n    }\n    equals(other) {\n        if (other.type === this.type) {\n            if (this.expr.length !== other.expr.length) {\n                return false;\n            }\n            for (let i = 0, len = this.expr.length; i < len; i++) {\n                if (!this.expr[i].equals(other.expr[i])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    substituteConstants() {\n        const exprArr = eliminateConstantsInArray(this.expr);\n        if (exprArr === this.expr) {\n            return this;\n        }\n        return ContextKeyOrExpr.create(exprArr, this.negated, false);\n    }\n    evaluate(context) {\n        for (let i = 0, len = this.expr.length; i < len; i++) {\n            if (this.expr[i].evaluate(context)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static _normalizeArr(arr, negated, extraRedundantCheck) {\n        let expr = [];\n        let hasFalse = false;\n        if (arr) {\n            for (let i = 0, len = arr.length; i < len; i++) {\n                const e = arr[i];\n                if (!e) {\n                    continue;\n                }\n                if (e.type === 0 ) {\n                    hasFalse = true;\n                    continue;\n                }\n                if (e.type === 1 ) {\n                    return ContextKeyTrueExpr.INSTANCE;\n                }\n                if (e.type === 9 ) {\n                    expr = expr.concat(e.expr);\n                    continue;\n                }\n                expr.push(e);\n            }\n            if (expr.length === 0 && hasFalse) {\n                return ContextKeyFalseExpr.INSTANCE;\n            }\n            expr.sort(cmp);\n        }\n        if (expr.length === 0) {\n            return undefined;\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        for (let i = 1; i < expr.length; i++) {\n            if (expr[i - 1].equals(expr[i])) {\n                expr.splice(i, 1);\n                i--;\n            }\n        }\n        if (expr.length === 1) {\n            return expr[0];\n        }\n        if (extraRedundantCheck) {\n            for (let i = 0; i < expr.length; i++) {\n                for (let j = i + 1; j < expr.length; j++) {\n                    if (( (expr[i].negate())).equals(expr[j])) {\n                        return ContextKeyTrueExpr.INSTANCE;\n                    }\n                }\n            }\n            if (expr.length === 1) {\n                return expr[0];\n            }\n        }\n        return (\n             (new ContextKeyOrExpr(expr, negated))\n        );\n    }\n    serialize() {\n        return ( (this.expr.map(e => e.serialize()))).join(' || ');\n    }\n    keys() {\n        const result = [];\n        for (const expr of this.expr) {\n            result.push(...( (expr.keys())));\n        }\n        return result;\n    }\n    map(mapFnc) {\n        return (\n             (new ContextKeyOrExpr(\n                 (this.expr.map(expr => ( (expr.map(mapFnc))))),\n                null\n            ))\n        );\n    }\n    negate() {\n        if (!this.negated) {\n            const result = [];\n            for (const expr of this.expr) {\n                result.push(( (expr.negate())));\n            }\n            while (result.length > 1) {\n                const LEFT = result.shift();\n                const RIGHT = result.shift();\n                const all = [];\n                for (const left of getTerminals(LEFT)) {\n                    for (const right of getTerminals(RIGHT)) {\n                        all.push(ContextKeyAndExpr.create([left, right], null, false));\n                    }\n                }\n                result.unshift(ContextKeyOrExpr.create(all, null, false));\n            }\n            this.negated = ContextKeyOrExpr.create(result, this, true);\n        }\n        return this.negated;\n    }\n}\nclass RawContextKey extends ContextKeyDefinedExpr {\n    static { this._info = []; }\n    static all() {\n        return (\n             (RawContextKey._info.values())\n        );\n    }\n    constructor(key, defaultValue, metaOrHide) {\n        super(key, null);\n        this._defaultValue = defaultValue;\n        if (typeof metaOrHide === 'object') {\n            RawContextKey._info.push({ ...metaOrHide, key });\n        }\n        else if (metaOrHide !== true) {\n            RawContextKey._info.push({ key, description: metaOrHide, type: defaultValue !== null && defaultValue !== undefined ? typeof defaultValue : undefined });\n        }\n    }\n    bindTo(target) {\n        return target.createKey(this.key, this._defaultValue);\n    }\n    getValue(target) {\n        return target.getContextKeyValue(this.key);\n    }\n    toNegated() {\n        return (\n             (this.negate())\n        );\n    }\n    isEqualTo(value) {\n        return ContextKeyEqualsExpr.create(this.key, value);\n    }\n    notEqualsTo(value) {\n        return ContextKeyNotEqualsExpr.create(this.key, value);\n    }\n}\nfunction cmp1(key1, key2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    return 0;\n}\nfunction cmp2(key1, value1, key2, value2) {\n    if (key1 < key2) {\n        return -1;\n    }\n    if (key1 > key2) {\n        return 1;\n    }\n    if (value1 < value2) {\n        return -1;\n    }\n    if (value1 > value2) {\n        return 1;\n    }\n    return 0;\n}\nfunction implies(p, q) {\n    if (p.type === 0  || q.type === 1 ) {\n        return true;\n    }\n    if (p.type === 9 ) {\n        if (q.type === 9 ) {\n            return allElementsIncluded(p.expr, q.expr);\n        }\n        return false;\n    }\n    if (q.type === 9 ) {\n        for (const element of q.expr) {\n            if (implies(p, element)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (p.type === 6 ) {\n        if (q.type === 6 ) {\n            return allElementsIncluded(q.expr, p.expr);\n        }\n        for (const element of p.expr) {\n            if (implies(element, q)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return p.equals(q);\n}\nfunction allElementsIncluded(p, q) {\n    let pIndex = 0;\n    let qIndex = 0;\n    while (pIndex < p.length && qIndex < q.length) {\n        const cmp = p[pIndex].cmp(q[qIndex]);\n        if (cmp < 0) {\n            return false;\n        }\n        else if (cmp === 0) {\n            pIndex++;\n            qIndex++;\n        }\n        else {\n            qIndex++;\n        }\n    }\n    return (pIndex === p.length);\n}\nfunction getTerminals(node) {\n    if (node.type === 9 ) {\n        return node.expr;\n    }\n    return [node];\n}\nexport { ContextKeyAndExpr, ContextKeyDefinedExpr, ContextKeyEqualsExpr, ContextKeyExpr, ContextKeyFalseExpr, ContextKeyGreaterEqualsExpr, ContextKeyGreaterExpr, ContextKeyInExpr, ContextKeyNotEqualsExpr, ContextKeyNotExpr, ContextKeyNotInExpr, ContextKeyNotRegexExpr, ContextKeyOrExpr, ContextKeyRegexExpr, ContextKeySmallerEqualsExpr, ContextKeySmallerExpr, ContextKeyTrueExpr, Parser, RawContextKey, expressionsAreEqualWithConstantSubstitution, implies, setConstant, validateWhenClauses };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}