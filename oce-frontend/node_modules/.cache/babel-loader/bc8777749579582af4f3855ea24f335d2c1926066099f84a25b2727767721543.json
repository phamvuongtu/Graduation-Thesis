{"ast":null,"code":"\"use strict\";\n\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forEach = exports.mapAsync = exports.map = exports.clearTestMode = exports.setTestMode = exports.Semaphore = exports.Delayer = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nclass Delayer {\n  constructor(defaultDelay) {\n    this.defaultDelay = defaultDelay;\n    this.timeout = undefined;\n    this.completionPromise = undefined;\n    this.onSuccess = undefined;\n    this.task = undefined;\n  }\n  trigger(task, delay = this.defaultDelay) {\n    this.task = task;\n    if (delay >= 0) {\n      this.cancelTimeout();\n    }\n    if (!this.completionPromise) {\n      this.completionPromise = new Promise(resolve => {\n        this.onSuccess = resolve;\n      }).then(() => {\n        this.completionPromise = undefined;\n        this.onSuccess = undefined;\n        var result = this.task();\n        this.task = undefined;\n        return result;\n      });\n    }\n    if (delay >= 0 || this.timeout === void 0) {\n      this.timeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {\n        this.timeout = undefined;\n        this.onSuccess(undefined);\n      }, delay >= 0 ? delay : this.defaultDelay);\n    }\n    return this.completionPromise;\n  }\n  forceDelivery() {\n    if (!this.completionPromise) {\n      return undefined;\n    }\n    this.cancelTimeout();\n    let result = this.task();\n    this.completionPromise = undefined;\n    this.onSuccess = undefined;\n    this.task = undefined;\n    return result;\n  }\n  isTriggered() {\n    return this.timeout !== undefined;\n  }\n  cancel() {\n    this.cancelTimeout();\n    this.completionPromise = undefined;\n  }\n  cancelTimeout() {\n    if (this.timeout !== undefined) {\n      this.timeout.dispose();\n      this.timeout = undefined;\n    }\n  }\n}\nexports.Delayer = Delayer;\nclass Semaphore {\n  constructor(capacity = 1) {\n    if (capacity <= 0) {\n      throw new Error('Capacity must be greater than 0');\n    }\n    this._capacity = capacity;\n    this._active = 0;\n    this._waiting = [];\n  }\n  lock(thunk) {\n    return new Promise((resolve, reject) => {\n      this._waiting.push({\n        thunk,\n        resolve,\n        reject\n      });\n      this.runNext();\n    });\n  }\n  get active() {\n    return this._active;\n  }\n  runNext() {\n    if (this._waiting.length === 0 || this._active === this._capacity) {\n      return;\n    }\n    (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => this.doRunNext());\n  }\n  doRunNext() {\n    if (this._waiting.length === 0 || this._active === this._capacity) {\n      return;\n    }\n    const next = this._waiting.shift();\n    this._active++;\n    if (this._active > this._capacity) {\n      throw new Error(`To many thunks active`);\n    }\n    try {\n      const result = next.thunk();\n      if (result instanceof Promise) {\n        result.then(value => {\n          this._active--;\n          next.resolve(value);\n          this.runNext();\n        }, err => {\n          this._active--;\n          next.reject(err);\n          this.runNext();\n        });\n      } else {\n        this._active--;\n        next.resolve(result);\n        this.runNext();\n      }\n    } catch (err) {\n      this._active--;\n      next.reject(err);\n      this.runNext();\n    }\n  }\n}\nexports.Semaphore = Semaphore;\nlet $test = false;\nfunction setTestMode() {\n  $test = true;\n}\nexports.setTestMode = setTestMode;\nfunction clearTestMode() {\n  $test = false;\n}\nexports.clearTestMode = clearTestMode;\nconst defaultYieldTimeout = 15 /*ms*/;\nclass Timer {\n  constructor(yieldAfter = defaultYieldTimeout) {\n    this.yieldAfter = $test === true ? Math.max(yieldAfter, 2) : Math.max(yieldAfter, defaultYieldTimeout);\n    this.startTime = Date.now();\n    this.counter = 0;\n    this.total = 0;\n    // start with a counter interval of 1.\n    this.counterInterval = 1;\n  }\n  start() {\n    this.counter = 0;\n    this.total = 0;\n    this.counterInterval = 1;\n    this.startTime = Date.now();\n  }\n  shouldYield() {\n    if (++this.counter >= this.counterInterval) {\n      const timeTaken = Date.now() - this.startTime;\n      const timeLeft = Math.max(0, this.yieldAfter - timeTaken);\n      this.total += this.counter;\n      this.counter = 0;\n      if (timeTaken >= this.yieldAfter || timeLeft <= 1) {\n        // Yield also if time left <= 1 since we compute the counter\n        // for max < 2 ms.\n        // Start with interval 1 again. We could do some calculation\n        // with using 80% of the last counter however other things (GC)\n        // affect the timing heavily since we have small timings (1 - 15ms).\n        this.counterInterval = 1;\n        this.total = 0;\n        return true;\n      } else {\n        // Only increase the counter until we have spent <= 2 ms. Increasing\n        // the counter further is very fragile since timing is influenced\n        // by other things and can increase the counter too much. This will result\n        // that we yield in average after [14 - 16]ms.\n        switch (timeTaken) {\n          case 0:\n          case 1:\n            this.counterInterval = this.total * 2;\n            break;\n        }\n      }\n    }\n    return false;\n  }\n}\nasync function map(items, func, token, options) {\n  if (items.length === 0) {\n    return [];\n  }\n  const result = new Array(items.length);\n  const timer = new Timer(options?.yieldAfter);\n  function convertBatch(start) {\n    timer.start();\n    for (let i = start; i < items.length; i++) {\n      result[i] = func(items[i]);\n      if (timer.shouldYield()) {\n        options?.yieldCallback && options.yieldCallback();\n        return i + 1;\n      }\n    }\n    return -1;\n  }\n  // Convert the first batch sync on the same frame.\n  let index = convertBatch(0);\n  while (index !== -1) {\n    if (token !== undefined && token.isCancellationRequested) {\n      break;\n    }\n    index = await new Promise(resolve => {\n      (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {\n        resolve(convertBatch(index));\n      });\n    });\n  }\n  return result;\n}\nexports.map = map;\nasync function mapAsync(items, func, token, options) {\n  if (items.length === 0) {\n    return [];\n  }\n  const result = new Array(items.length);\n  const timer = new Timer(options?.yieldAfter);\n  async function convertBatch(start) {\n    timer.start();\n    for (let i = start; i < items.length; i++) {\n      result[i] = await func(items[i], token);\n      if (timer.shouldYield()) {\n        options?.yieldCallback && options.yieldCallback();\n        return i + 1;\n      }\n    }\n    return -1;\n  }\n  let index = await convertBatch(0);\n  while (index !== -1) {\n    if (token !== undefined && token.isCancellationRequested) {\n      break;\n    }\n    index = await new Promise(resolve => {\n      (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {\n        resolve(convertBatch(index));\n      });\n    });\n  }\n  return result;\n}\nexports.mapAsync = mapAsync;\nasync function forEach(items, func, token, options) {\n  if (items.length === 0) {\n    return;\n  }\n  const timer = new Timer(options?.yieldAfter);\n  function runBatch(start) {\n    timer.start();\n    for (let i = start; i < items.length; i++) {\n      func(items[i]);\n      if (timer.shouldYield()) {\n        options?.yieldCallback && options.yieldCallback();\n        return i + 1;\n      }\n    }\n    return -1;\n  }\n  // Convert the first batch sync on the same frame.\n  let index = runBatch(0);\n  while (index !== -1) {\n    if (token !== undefined && token.isCancellationRequested) {\n      break;\n    }\n    index = await new Promise(resolve => {\n      (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {\n        resolve(runBatch(index));\n      });\n    });\n  }\n}\nexports.forEach = forEach;","map":{"version":3,"names":["Object","defineProperty","exports","value","forEach","mapAsync","map","clearTestMode","setTestMode","Semaphore","Delayer","vscode_languageserver_protocol_1","require","constructor","defaultDelay","timeout","undefined","completionPromise","onSuccess","task","trigger","delay","cancelTimeout","Promise","resolve","then","result","RAL","timer","setTimeout","forceDelivery","isTriggered","cancel","dispose","capacity","Error","_capacity","_active","_waiting","lock","thunk","reject","push","runNext","active","length","setImmediate","doRunNext","next","shift","err","$test","defaultYieldTimeout","Timer","yieldAfter","Math","max","startTime","Date","now","counter","total","counterInterval","start","shouldYield","timeTaken","timeLeft","items","func","token","options","Array","convertBatch","i","yieldCallback","index","isCancellationRequested","runBatch"],"sources":["/Users/phamtu/Downloads/Code/OCE/oce-frontend/node_modules/vscode-languageclient/lib/common/utils/async.js"],"sourcesContent":["\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.forEach = exports.mapAsync = exports.map = exports.clearTestMode = exports.setTestMode = exports.Semaphore = exports.Delayer = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nclass Delayer {\n    constructor(defaultDelay) {\n        this.defaultDelay = defaultDelay;\n        this.timeout = undefined;\n        this.completionPromise = undefined;\n        this.onSuccess = undefined;\n        this.task = undefined;\n    }\n    trigger(task, delay = this.defaultDelay) {\n        this.task = task;\n        if (delay >= 0) {\n            this.cancelTimeout();\n        }\n        if (!this.completionPromise) {\n            this.completionPromise = new Promise((resolve) => {\n                this.onSuccess = resolve;\n            }).then(() => {\n                this.completionPromise = undefined;\n                this.onSuccess = undefined;\n                var result = this.task();\n                this.task = undefined;\n                return result;\n            });\n        }\n        if (delay >= 0 || this.timeout === void 0) {\n            this.timeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {\n                this.timeout = undefined;\n                this.onSuccess(undefined);\n            }, delay >= 0 ? delay : this.defaultDelay);\n        }\n        return this.completionPromise;\n    }\n    forceDelivery() {\n        if (!this.completionPromise) {\n            return undefined;\n        }\n        this.cancelTimeout();\n        let result = this.task();\n        this.completionPromise = undefined;\n        this.onSuccess = undefined;\n        this.task = undefined;\n        return result;\n    }\n    isTriggered() {\n        return this.timeout !== undefined;\n    }\n    cancel() {\n        this.cancelTimeout();\n        this.completionPromise = undefined;\n    }\n    cancelTimeout() {\n        if (this.timeout !== undefined) {\n            this.timeout.dispose();\n            this.timeout = undefined;\n        }\n    }\n}\nexports.Delayer = Delayer;\nclass Semaphore {\n    constructor(capacity = 1) {\n        if (capacity <= 0) {\n            throw new Error('Capacity must be greater than 0');\n        }\n        this._capacity = capacity;\n        this._active = 0;\n        this._waiting = [];\n    }\n    lock(thunk) {\n        return new Promise((resolve, reject) => {\n            this._waiting.push({ thunk, resolve, reject });\n            this.runNext();\n        });\n    }\n    get active() {\n        return this._active;\n    }\n    runNext() {\n        if (this._waiting.length === 0 || this._active === this._capacity) {\n            return;\n        }\n        (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => this.doRunNext());\n    }\n    doRunNext() {\n        if (this._waiting.length === 0 || this._active === this._capacity) {\n            return;\n        }\n        const next = this._waiting.shift();\n        this._active++;\n        if (this._active > this._capacity) {\n            throw new Error(`To many thunks active`);\n        }\n        try {\n            const result = next.thunk();\n            if (result instanceof Promise) {\n                result.then((value) => {\n                    this._active--;\n                    next.resolve(value);\n                    this.runNext();\n                }, (err) => {\n                    this._active--;\n                    next.reject(err);\n                    this.runNext();\n                });\n            }\n            else {\n                this._active--;\n                next.resolve(result);\n                this.runNext();\n            }\n        }\n        catch (err) {\n            this._active--;\n            next.reject(err);\n            this.runNext();\n        }\n    }\n}\nexports.Semaphore = Semaphore;\nlet $test = false;\nfunction setTestMode() {\n    $test = true;\n}\nexports.setTestMode = setTestMode;\nfunction clearTestMode() {\n    $test = false;\n}\nexports.clearTestMode = clearTestMode;\nconst defaultYieldTimeout = 15 /*ms*/;\nclass Timer {\n    constructor(yieldAfter = defaultYieldTimeout) {\n        this.yieldAfter = $test === true ? Math.max(yieldAfter, 2) : Math.max(yieldAfter, defaultYieldTimeout);\n        this.startTime = Date.now();\n        this.counter = 0;\n        this.total = 0;\n        // start with a counter interval of 1.\n        this.counterInterval = 1;\n    }\n    start() {\n        this.counter = 0;\n        this.total = 0;\n        this.counterInterval = 1;\n        this.startTime = Date.now();\n    }\n    shouldYield() {\n        if (++this.counter >= this.counterInterval) {\n            const timeTaken = Date.now() - this.startTime;\n            const timeLeft = Math.max(0, this.yieldAfter - timeTaken);\n            this.total += this.counter;\n            this.counter = 0;\n            if (timeTaken >= this.yieldAfter || timeLeft <= 1) {\n                // Yield also if time left <= 1 since we compute the counter\n                // for max < 2 ms.\n                // Start with interval 1 again. We could do some calculation\n                // with using 80% of the last counter however other things (GC)\n                // affect the timing heavily since we have small timings (1 - 15ms).\n                this.counterInterval = 1;\n                this.total = 0;\n                return true;\n            }\n            else {\n                // Only increase the counter until we have spent <= 2 ms. Increasing\n                // the counter further is very fragile since timing is influenced\n                // by other things and can increase the counter too much. This will result\n                // that we yield in average after [14 - 16]ms.\n                switch (timeTaken) {\n                    case 0:\n                    case 1:\n                        this.counterInterval = this.total * 2;\n                        break;\n                }\n            }\n        }\n        return false;\n    }\n}\nasync function map(items, func, token, options) {\n    if (items.length === 0) {\n        return [];\n    }\n    const result = new Array(items.length);\n    const timer = new Timer(options?.yieldAfter);\n    function convertBatch(start) {\n        timer.start();\n        for (let i = start; i < items.length; i++) {\n            result[i] = func(items[i]);\n            if (timer.shouldYield()) {\n                options?.yieldCallback && options.yieldCallback();\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n    // Convert the first batch sync on the same frame.\n    let index = convertBatch(0);\n    while (index !== -1) {\n        if (token !== undefined && token.isCancellationRequested) {\n            break;\n        }\n        index = await new Promise((resolve) => {\n            (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {\n                resolve(convertBatch(index));\n            });\n        });\n    }\n    return result;\n}\nexports.map = map;\nasync function mapAsync(items, func, token, options) {\n    if (items.length === 0) {\n        return [];\n    }\n    const result = new Array(items.length);\n    const timer = new Timer(options?.yieldAfter);\n    async function convertBatch(start) {\n        timer.start();\n        for (let i = start; i < items.length; i++) {\n            result[i] = await func(items[i], token);\n            if (timer.shouldYield()) {\n                options?.yieldCallback && options.yieldCallback();\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n    let index = await convertBatch(0);\n    while (index !== -1) {\n        if (token !== undefined && token.isCancellationRequested) {\n            break;\n        }\n        index = await new Promise((resolve) => {\n            (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {\n                resolve(convertBatch(index));\n            });\n        });\n    }\n    return result;\n}\nexports.mapAsync = mapAsync;\nasync function forEach(items, func, token, options) {\n    if (items.length === 0) {\n        return;\n    }\n    const timer = new Timer(options?.yieldAfter);\n    function runBatch(start) {\n        timer.start();\n        for (let i = start; i < items.length; i++) {\n            func(items[i]);\n            if (timer.shouldYield()) {\n                options?.yieldCallback && options.yieldCallback();\n                return i + 1;\n            }\n        }\n        return -1;\n    }\n    // Convert the first batch sync on the same frame.\n    let index = runBatch(0);\n    while (index !== -1) {\n        if (token !== undefined && token.isCancellationRequested) {\n            break;\n        }\n        index = await new Promise((resolve) => {\n            (0, vscode_languageserver_protocol_1.RAL)().timer.setImmediate(() => {\n                resolve(runBatch(index));\n            });\n        });\n    }\n}\nexports.forEach = forEach;\n"],"mappings":"AAAA,YAAY;;AACZ;AACA;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,OAAO,GAAGF,OAAO,CAACG,QAAQ,GAAGH,OAAO,CAACI,GAAG,GAAGJ,OAAO,CAACK,aAAa,GAAGL,OAAO,CAACM,WAAW,GAAGN,OAAO,CAACO,SAAS,GAAGP,OAAO,CAACQ,OAAO,GAAG,KAAK,CAAC;AAC7I,MAAMC,gCAAgC,GAAGC,OAAO,CAAC,gCAAgC,CAAC;AAClF,MAAMF,OAAO,CAAC;EACVG,WAAWA,CAACC,YAAY,EAAE;IACtB,IAAI,CAACA,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACC,OAAO,GAAGC,SAAS;IACxB,IAAI,CAACC,iBAAiB,GAAGD,SAAS;IAClC,IAAI,CAACE,SAAS,GAAGF,SAAS;IAC1B,IAAI,CAACG,IAAI,GAAGH,SAAS;EACzB;EACAI,OAAOA,CAACD,IAAI,EAAEE,KAAK,GAAG,IAAI,CAACP,YAAY,EAAE;IACrC,IAAI,CAACK,IAAI,GAAGA,IAAI;IAChB,IAAIE,KAAK,IAAI,CAAC,EAAE;MACZ,IAAI,CAACC,aAAa,CAAC,CAAC;IACxB;IACA,IAAI,CAAC,IAAI,CAACL,iBAAiB,EAAE;MACzB,IAAI,CAACA,iBAAiB,GAAG,IAAIM,OAAO,CAAEC,OAAO,IAAK;QAC9C,IAAI,CAACN,SAAS,GAAGM,OAAO;MAC5B,CAAC,CAAC,CAACC,IAAI,CAAC,MAAM;QACV,IAAI,CAACR,iBAAiB,GAAGD,SAAS;QAClC,IAAI,CAACE,SAAS,GAAGF,SAAS;QAC1B,IAAIU,MAAM,GAAG,IAAI,CAACP,IAAI,CAAC,CAAC;QACxB,IAAI,CAACA,IAAI,GAAGH,SAAS;QACrB,OAAOU,MAAM;MACjB,CAAC,CAAC;IACN;IACA,IAAIL,KAAK,IAAI,CAAC,IAAI,IAAI,CAACN,OAAO,KAAK,KAAK,CAAC,EAAE;MACvC,IAAI,CAACA,OAAO,GAAG,CAAC,CAAC,EAAEJ,gCAAgC,CAACgB,GAAG,EAAE,CAAC,CAACC,KAAK,CAACC,UAAU,CAAC,MAAM;QAC9E,IAAI,CAACd,OAAO,GAAGC,SAAS;QACxB,IAAI,CAACE,SAAS,CAACF,SAAS,CAAC;MAC7B,CAAC,EAAEK,KAAK,IAAI,CAAC,GAAGA,KAAK,GAAG,IAAI,CAACP,YAAY,CAAC;IAC9C;IACA,OAAO,IAAI,CAACG,iBAAiB;EACjC;EACAa,aAAaA,CAAA,EAAG;IACZ,IAAI,CAAC,IAAI,CAACb,iBAAiB,EAAE;MACzB,OAAOD,SAAS;IACpB;IACA,IAAI,CAACM,aAAa,CAAC,CAAC;IACpB,IAAII,MAAM,GAAG,IAAI,CAACP,IAAI,CAAC,CAAC;IACxB,IAAI,CAACF,iBAAiB,GAAGD,SAAS;IAClC,IAAI,CAACE,SAAS,GAAGF,SAAS;IAC1B,IAAI,CAACG,IAAI,GAAGH,SAAS;IACrB,OAAOU,MAAM;EACjB;EACAK,WAAWA,CAAA,EAAG;IACV,OAAO,IAAI,CAAChB,OAAO,KAAKC,SAAS;EACrC;EACAgB,MAAMA,CAAA,EAAG;IACL,IAAI,CAACV,aAAa,CAAC,CAAC;IACpB,IAAI,CAACL,iBAAiB,GAAGD,SAAS;EACtC;EACAM,aAAaA,CAAA,EAAG;IACZ,IAAI,IAAI,CAACP,OAAO,KAAKC,SAAS,EAAE;MAC5B,IAAI,CAACD,OAAO,CAACkB,OAAO,CAAC,CAAC;MACtB,IAAI,CAAClB,OAAO,GAAGC,SAAS;IAC5B;EACJ;AACJ;AACAd,OAAO,CAACQ,OAAO,GAAGA,OAAO;AACzB,MAAMD,SAAS,CAAC;EACZI,WAAWA,CAACqB,QAAQ,GAAG,CAAC,EAAE;IACtB,IAAIA,QAAQ,IAAI,CAAC,EAAE;MACf,MAAM,IAAIC,KAAK,CAAC,iCAAiC,CAAC;IACtD;IACA,IAAI,CAACC,SAAS,GAAGF,QAAQ;IACzB,IAAI,CAACG,OAAO,GAAG,CAAC;IAChB,IAAI,CAACC,QAAQ,GAAG,EAAE;EACtB;EACAC,IAAIA,CAACC,KAAK,EAAE;IACR,OAAO,IAAIjB,OAAO,CAAC,CAACC,OAAO,EAAEiB,MAAM,KAAK;MACpC,IAAI,CAACH,QAAQ,CAACI,IAAI,CAAC;QAAEF,KAAK;QAAEhB,OAAO;QAAEiB;MAAO,CAAC,CAAC;MAC9C,IAAI,CAACE,OAAO,CAAC,CAAC;IAClB,CAAC,CAAC;EACN;EACA,IAAIC,MAAMA,CAAA,EAAG;IACT,OAAO,IAAI,CAACP,OAAO;EACvB;EACAM,OAAOA,CAAA,EAAG;IACN,IAAI,IAAI,CAACL,QAAQ,CAACO,MAAM,KAAK,CAAC,IAAI,IAAI,CAACR,OAAO,KAAK,IAAI,CAACD,SAAS,EAAE;MAC/D;IACJ;IACA,CAAC,CAAC,EAAEzB,gCAAgC,CAACgB,GAAG,EAAE,CAAC,CAACC,KAAK,CAACkB,YAAY,CAAC,MAAM,IAAI,CAACC,SAAS,CAAC,CAAC,CAAC;EAC1F;EACAA,SAASA,CAAA,EAAG;IACR,IAAI,IAAI,CAACT,QAAQ,CAACO,MAAM,KAAK,CAAC,IAAI,IAAI,CAACR,OAAO,KAAK,IAAI,CAACD,SAAS,EAAE;MAC/D;IACJ;IACA,MAAMY,IAAI,GAAG,IAAI,CAACV,QAAQ,CAACW,KAAK,CAAC,CAAC;IAClC,IAAI,CAACZ,OAAO,EAAE;IACd,IAAI,IAAI,CAACA,OAAO,GAAG,IAAI,CAACD,SAAS,EAAE;MAC/B,MAAM,IAAID,KAAK,CAAE,uBAAsB,CAAC;IAC5C;IACA,IAAI;MACA,MAAMT,MAAM,GAAGsB,IAAI,CAACR,KAAK,CAAC,CAAC;MAC3B,IAAId,MAAM,YAAYH,OAAO,EAAE;QAC3BG,MAAM,CAACD,IAAI,CAAEtB,KAAK,IAAK;UACnB,IAAI,CAACkC,OAAO,EAAE;UACdW,IAAI,CAACxB,OAAO,CAACrB,KAAK,CAAC;UACnB,IAAI,CAACwC,OAAO,CAAC,CAAC;QAClB,CAAC,EAAGO,GAAG,IAAK;UACR,IAAI,CAACb,OAAO,EAAE;UACdW,IAAI,CAACP,MAAM,CAACS,GAAG,CAAC;UAChB,IAAI,CAACP,OAAO,CAAC,CAAC;QAClB,CAAC,CAAC;MACN,CAAC,MACI;QACD,IAAI,CAACN,OAAO,EAAE;QACdW,IAAI,CAACxB,OAAO,CAACE,MAAM,CAAC;QACpB,IAAI,CAACiB,OAAO,CAAC,CAAC;MAClB;IACJ,CAAC,CACD,OAAOO,GAAG,EAAE;MACR,IAAI,CAACb,OAAO,EAAE;MACdW,IAAI,CAACP,MAAM,CAACS,GAAG,CAAC;MAChB,IAAI,CAACP,OAAO,CAAC,CAAC;IAClB;EACJ;AACJ;AACAzC,OAAO,CAACO,SAAS,GAAGA,SAAS;AAC7B,IAAI0C,KAAK,GAAG,KAAK;AACjB,SAAS3C,WAAWA,CAAA,EAAG;EACnB2C,KAAK,GAAG,IAAI;AAChB;AACAjD,OAAO,CAACM,WAAW,GAAGA,WAAW;AACjC,SAASD,aAAaA,CAAA,EAAG;EACrB4C,KAAK,GAAG,KAAK;AACjB;AACAjD,OAAO,CAACK,aAAa,GAAGA,aAAa;AACrC,MAAM6C,mBAAmB,GAAG,EAAE,CAAC;AAC/B,MAAMC,KAAK,CAAC;EACRxC,WAAWA,CAACyC,UAAU,GAAGF,mBAAmB,EAAE;IAC1C,IAAI,CAACE,UAAU,GAAGH,KAAK,KAAK,IAAI,GAAGI,IAAI,CAACC,GAAG,CAACF,UAAU,EAAE,CAAC,CAAC,GAAGC,IAAI,CAACC,GAAG,CAACF,UAAU,EAAEF,mBAAmB,CAAC;IACtG,IAAI,CAACK,SAAS,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;IAC3B,IAAI,CAACC,OAAO,GAAG,CAAC;IAChB,IAAI,CAACC,KAAK,GAAG,CAAC;IACd;IACA,IAAI,CAACC,eAAe,GAAG,CAAC;EAC5B;EACAC,KAAKA,CAAA,EAAG;IACJ,IAAI,CAACH,OAAO,GAAG,CAAC;IAChB,IAAI,CAACC,KAAK,GAAG,CAAC;IACd,IAAI,CAACC,eAAe,GAAG,CAAC;IACxB,IAAI,CAACL,SAAS,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;EAC/B;EACAK,WAAWA,CAAA,EAAG;IACV,IAAI,EAAE,IAAI,CAACJ,OAAO,IAAI,IAAI,CAACE,eAAe,EAAE;MACxC,MAAMG,SAAS,GAAGP,IAAI,CAACC,GAAG,CAAC,CAAC,GAAG,IAAI,CAACF,SAAS;MAC7C,MAAMS,QAAQ,GAAGX,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,IAAI,CAACF,UAAU,GAAGW,SAAS,CAAC;MACzD,IAAI,CAACJ,KAAK,IAAI,IAAI,CAACD,OAAO;MAC1B,IAAI,CAACA,OAAO,GAAG,CAAC;MAChB,IAAIK,SAAS,IAAI,IAAI,CAACX,UAAU,IAAIY,QAAQ,IAAI,CAAC,EAAE;QAC/C;QACA;QACA;QACA;QACA;QACA,IAAI,CAACJ,eAAe,GAAG,CAAC;QACxB,IAAI,CAACD,KAAK,GAAG,CAAC;QACd,OAAO,IAAI;MACf,CAAC,MACI;QACD;QACA;QACA;QACA;QACA,QAAQI,SAAS;UACb,KAAK,CAAC;UACN,KAAK,CAAC;YACF,IAAI,CAACH,eAAe,GAAG,IAAI,CAACD,KAAK,GAAG,CAAC;YACrC;QACR;MACJ;IACJ;IACA,OAAO,KAAK;EAChB;AACJ;AACA,eAAevD,GAAGA,CAAC6D,KAAK,EAAEC,IAAI,EAAEC,KAAK,EAAEC,OAAO,EAAE;EAC5C,IAAIH,KAAK,CAACtB,MAAM,KAAK,CAAC,EAAE;IACpB,OAAO,EAAE;EACb;EACA,MAAMnB,MAAM,GAAG,IAAI6C,KAAK,CAACJ,KAAK,CAACtB,MAAM,CAAC;EACtC,MAAMjB,KAAK,GAAG,IAAIyB,KAAK,CAACiB,OAAO,EAAEhB,UAAU,CAAC;EAC5C,SAASkB,YAAYA,CAACT,KAAK,EAAE;IACzBnC,KAAK,CAACmC,KAAK,CAAC,CAAC;IACb,KAAK,IAAIU,CAAC,GAAGV,KAAK,EAAEU,CAAC,GAAGN,KAAK,CAACtB,MAAM,EAAE4B,CAAC,EAAE,EAAE;MACvC/C,MAAM,CAAC+C,CAAC,CAAC,GAAGL,IAAI,CAACD,KAAK,CAACM,CAAC,CAAC,CAAC;MAC1B,IAAI7C,KAAK,CAACoC,WAAW,CAAC,CAAC,EAAE;QACrBM,OAAO,EAAEI,aAAa,IAAIJ,OAAO,CAACI,aAAa,CAAC,CAAC;QACjD,OAAOD,CAAC,GAAG,CAAC;MAChB;IACJ;IACA,OAAO,CAAC,CAAC;EACb;EACA;EACA,IAAIE,KAAK,GAAGH,YAAY,CAAC,CAAC,CAAC;EAC3B,OAAOG,KAAK,KAAK,CAAC,CAAC,EAAE;IACjB,IAAIN,KAAK,KAAKrD,SAAS,IAAIqD,KAAK,CAACO,uBAAuB,EAAE;MACtD;IACJ;IACAD,KAAK,GAAG,MAAM,IAAIpD,OAAO,CAAEC,OAAO,IAAK;MACnC,CAAC,CAAC,EAAEb,gCAAgC,CAACgB,GAAG,EAAE,CAAC,CAACC,KAAK,CAACkB,YAAY,CAAC,MAAM;QACjEtB,OAAO,CAACgD,YAAY,CAACG,KAAK,CAAC,CAAC;MAChC,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EACA,OAAOjD,MAAM;AACjB;AACAxB,OAAO,CAACI,GAAG,GAAGA,GAAG;AACjB,eAAeD,QAAQA,CAAC8D,KAAK,EAAEC,IAAI,EAAEC,KAAK,EAAEC,OAAO,EAAE;EACjD,IAAIH,KAAK,CAACtB,MAAM,KAAK,CAAC,EAAE;IACpB,OAAO,EAAE;EACb;EACA,MAAMnB,MAAM,GAAG,IAAI6C,KAAK,CAACJ,KAAK,CAACtB,MAAM,CAAC;EACtC,MAAMjB,KAAK,GAAG,IAAIyB,KAAK,CAACiB,OAAO,EAAEhB,UAAU,CAAC;EAC5C,eAAekB,YAAYA,CAACT,KAAK,EAAE;IAC/BnC,KAAK,CAACmC,KAAK,CAAC,CAAC;IACb,KAAK,IAAIU,CAAC,GAAGV,KAAK,EAAEU,CAAC,GAAGN,KAAK,CAACtB,MAAM,EAAE4B,CAAC,EAAE,EAAE;MACvC/C,MAAM,CAAC+C,CAAC,CAAC,GAAG,MAAML,IAAI,CAACD,KAAK,CAACM,CAAC,CAAC,EAAEJ,KAAK,CAAC;MACvC,IAAIzC,KAAK,CAACoC,WAAW,CAAC,CAAC,EAAE;QACrBM,OAAO,EAAEI,aAAa,IAAIJ,OAAO,CAACI,aAAa,CAAC,CAAC;QACjD,OAAOD,CAAC,GAAG,CAAC;MAChB;IACJ;IACA,OAAO,CAAC,CAAC;EACb;EACA,IAAIE,KAAK,GAAG,MAAMH,YAAY,CAAC,CAAC,CAAC;EACjC,OAAOG,KAAK,KAAK,CAAC,CAAC,EAAE;IACjB,IAAIN,KAAK,KAAKrD,SAAS,IAAIqD,KAAK,CAACO,uBAAuB,EAAE;MACtD;IACJ;IACAD,KAAK,GAAG,MAAM,IAAIpD,OAAO,CAAEC,OAAO,IAAK;MACnC,CAAC,CAAC,EAAEb,gCAAgC,CAACgB,GAAG,EAAE,CAAC,CAACC,KAAK,CAACkB,YAAY,CAAC,MAAM;QACjEtB,OAAO,CAACgD,YAAY,CAACG,KAAK,CAAC,CAAC;MAChC,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EACA,OAAOjD,MAAM;AACjB;AACAxB,OAAO,CAACG,QAAQ,GAAGA,QAAQ;AAC3B,eAAeD,OAAOA,CAAC+D,KAAK,EAAEC,IAAI,EAAEC,KAAK,EAAEC,OAAO,EAAE;EAChD,IAAIH,KAAK,CAACtB,MAAM,KAAK,CAAC,EAAE;IACpB;EACJ;EACA,MAAMjB,KAAK,GAAG,IAAIyB,KAAK,CAACiB,OAAO,EAAEhB,UAAU,CAAC;EAC5C,SAASuB,QAAQA,CAACd,KAAK,EAAE;IACrBnC,KAAK,CAACmC,KAAK,CAAC,CAAC;IACb,KAAK,IAAIU,CAAC,GAAGV,KAAK,EAAEU,CAAC,GAAGN,KAAK,CAACtB,MAAM,EAAE4B,CAAC,EAAE,EAAE;MACvCL,IAAI,CAACD,KAAK,CAACM,CAAC,CAAC,CAAC;MACd,IAAI7C,KAAK,CAACoC,WAAW,CAAC,CAAC,EAAE;QACrBM,OAAO,EAAEI,aAAa,IAAIJ,OAAO,CAACI,aAAa,CAAC,CAAC;QACjD,OAAOD,CAAC,GAAG,CAAC;MAChB;IACJ;IACA,OAAO,CAAC,CAAC;EACb;EACA;EACA,IAAIE,KAAK,GAAGE,QAAQ,CAAC,CAAC,CAAC;EACvB,OAAOF,KAAK,KAAK,CAAC,CAAC,EAAE;IACjB,IAAIN,KAAK,KAAKrD,SAAS,IAAIqD,KAAK,CAACO,uBAAuB,EAAE;MACtD;IACJ;IACAD,KAAK,GAAG,MAAM,IAAIpD,OAAO,CAAEC,OAAO,IAAK;MACnC,CAAC,CAAC,EAAEb,gCAAgC,CAACgB,GAAG,EAAE,CAAC,CAACC,KAAK,CAACkB,YAAY,CAAC,MAAM;QACjEtB,OAAO,CAACqD,QAAQ,CAACF,KAAK,CAAC,CAAC;MAC5B,CAAC,CAAC;IACN,CAAC,CAAC;EACN;AACJ;AACAzE,OAAO,CAACE,OAAO,GAAGA,OAAO","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}