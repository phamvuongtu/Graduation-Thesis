{"ast":null,"code":"import { cwd, env, platform } from './process.js';\nconst CHAR_UPPERCASE_A = 65;\nconst CHAR_LOWERCASE_A = 97;\nconst CHAR_UPPERCASE_Z = 90;\nconst CHAR_LOWERCASE_Z = 122;\nconst CHAR_DOT = 46;\nconst CHAR_FORWARD_SLASH = 47;\nconst CHAR_BACKWARD_SLASH = 92;\nconst CHAR_COLON = 58;\nconst CHAR_QUESTION_MARK = 63;\nclass ErrorInvalidArgType extends Error {\n  constructor(name, expected, actual) {\n    let determiner;\n    if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n      determiner = 'must not be';\n      expected = expected.replace(/^not /, '');\n    } else {\n      determiner = 'must be';\n    }\n    const type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n    let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n    msg += `. Received type ${typeof actual}`;\n    super(msg);\n    this.code = 'ERR_INVALID_ARG_TYPE';\n  }\n}\nfunction validateObject(pathObject, name) {\n  if (pathObject === null || typeof pathObject !== 'object') {\n    throw new ErrorInvalidArgType(name, 'Object', pathObject);\n  }\n}\nfunction validateString(value, name) {\n  if (typeof value !== 'string') {\n    throw new ErrorInvalidArgType(name, 'string', value);\n  }\n}\nconst platformIsWin32 = platform === 'win32';\nfunction isPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\nfunction isPosixPathSeparator(code) {\n  return code === CHAR_FORWARD_SLASH;\n}\nfunction isWindowsDeviceRoot(code) {\n  return code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z || code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z;\n}\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n  let res = '';\n  let lastSegmentLength = 0;\n  let lastSlash = -1;\n  let dots = 0;\n  let code = 0;\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length) {\n      code = path.charCodeAt(i);\n    } else if (isPathSeparator(code)) {\n      break;\n    } else {\n      code = CHAR_FORWARD_SLASH;\n    }\n    if (isPathSeparator(code)) {\n      if (lastSlash === i - 1 || dots === 1) ;else if (dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== CHAR_DOT || res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(separator);\n            if (lastSlashIndex === -1) {\n              res = '';\n              lastSegmentLength = 0;\n            } else {\n              res = res.slice(0, lastSlashIndex);\n              lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n            }\n            lastSlash = i;\n            dots = 0;\n            continue;\n          } else if (res.length !== 0) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          res += res.length > 0 ? `${separator}..` : '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0) {\n          res += `${separator}${path.slice(lastSlash + 1, i)}`;\n        } else {\n          res = path.slice(lastSlash + 1, i);\n        }\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === CHAR_DOT && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\nfunction _format(sep, pathObject) {\n  validateObject(pathObject, 'pathObject');\n  const dir = pathObject.dir || pathObject.root;\n  const base = pathObject.base || `${pathObject.name || ''}${pathObject.ext || ''}`;\n  if (!dir) {\n    return base;\n  }\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\nconst win32 = {\n  resolve(...pathSegments) {\n    let resolvedDevice = '';\n    let resolvedTail = '';\n    let resolvedAbsolute = false;\n    for (let i = pathSegments.length - 1; i >= -1; i--) {\n      let path;\n      if (i >= 0) {\n        path = pathSegments[i];\n        validateString(path, 'path');\n        if (path.length === 0) {\n          continue;\n        }\n      } else if (resolvedDevice.length === 0) {\n        path = cwd();\n      } else {\n        path = env[`=${resolvedDevice}`] || cwd();\n        if (path === undefined || path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() && path.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n          path = `${resolvedDevice}\\\\`;\n        }\n      }\n      const len = path.length;\n      let rootEnd = 0;\n      let device = '';\n      let isAbsolute = false;\n      const code = path.charCodeAt(0);\n      if (len === 1) {\n        if (isPathSeparator(code)) {\n          rootEnd = 1;\n          isAbsolute = true;\n        }\n      } else if (isPathSeparator(code)) {\n        isAbsolute = true;\n        if (isPathSeparator(path.charCodeAt(1))) {\n          let j = 2;\n          let last = j;\n          while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            const firstPart = path.slice(last, j);\n            last = j;\n            while (j < len && isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j < len && j !== last) {\n              last = j;\n              while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                j++;\n              }\n              if (j === len || j !== last) {\n                device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                rootEnd = j;\n              }\n            }\n          }\n        } else {\n          rootEnd = 1;\n        }\n      } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n        device = path.slice(0, 2);\n        rootEnd = 2;\n        if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n          isAbsolute = true;\n          rootEnd = 3;\n        }\n      }\n      if (device.length > 0) {\n        if (resolvedDevice.length > 0) {\n          if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n            continue;\n          }\n        } else {\n          resolvedDevice = device;\n        }\n      }\n      if (resolvedAbsolute) {\n        if (resolvedDevice.length > 0) {\n          break;\n        }\n      } else {\n        resolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n        resolvedAbsolute = isAbsolute;\n        if (isAbsolute && resolvedDevice.length > 0) {\n          break;\n        }\n      }\n    }\n    resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\', isPathSeparator);\n    return resolvedAbsolute ? `${resolvedDevice}\\\\${resolvedTail}` : `${resolvedDevice}${resolvedTail}` || '.';\n  },\n  normalize(path) {\n    validateString(path, 'path');\n    const len = path.length;\n    if (len === 0) {\n      return '.';\n    }\n    let rootEnd = 0;\n    let device;\n    let isAbsolute = false;\n    const code = path.charCodeAt(0);\n    if (len === 1) {\n      return isPosixPathSeparator(code) ? '\\\\' : path;\n    }\n    if (isPathSeparator(code)) {\n      isAbsolute = true;\n      if (isPathSeparator(path.charCodeAt(1))) {\n        let j = 2;\n        let last = j;\n        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          const firstPart = path.slice(last, j);\n          last = j;\n          while (j < len && isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            last = j;\n            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j === len) {\n              return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n            }\n            if (j !== last) {\n              device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n              rootEnd = j;\n            }\n          }\n        }\n      } else {\n        rootEnd = 1;\n      }\n    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n      device = path.slice(0, 2);\n      rootEnd = 2;\n      if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n        isAbsolute = true;\n        rootEnd = 3;\n      }\n    }\n    let tail = rootEnd < len ? normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) : '';\n    if (tail.length === 0 && !isAbsolute) {\n      tail = '.';\n    }\n    if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n      tail += '\\\\';\n    }\n    if (device === undefined) {\n      return isAbsolute ? `\\\\${tail}` : tail;\n    }\n    return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n  },\n  isAbsolute(path) {\n    validateString(path, 'path');\n    const len = path.length;\n    if (len === 0) {\n      return false;\n    }\n    const code = path.charCodeAt(0);\n    return isPathSeparator(code) || len > 2 && isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON && isPathSeparator(path.charCodeAt(2));\n  },\n  join(...paths) {\n    if (paths.length === 0) {\n      return '.';\n    }\n    let joined;\n    let firstPart;\n    for (let i = 0; i < paths.length; ++i) {\n      const arg = paths[i];\n      validateString(arg, 'path');\n      if (arg.length > 0) {\n        if (joined === undefined) {\n          joined = firstPart = arg;\n        } else {\n          joined += `\\\\${arg}`;\n        }\n      }\n    }\n    if (joined === undefined) {\n      return '.';\n    }\n    let needsReplace = true;\n    let slashCount = 0;\n    if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n      ++slashCount;\n      const firstLen = firstPart.length;\n      if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n        ++slashCount;\n        if (firstLen > 2) {\n          if (isPathSeparator(firstPart.charCodeAt(2))) {\n            ++slashCount;\n          } else {\n            needsReplace = false;\n          }\n        }\n      }\n    }\n    if (needsReplace) {\n      while (slashCount < joined.length && isPathSeparator(joined.charCodeAt(slashCount))) {\n        slashCount++;\n      }\n      if (slashCount >= 2) {\n        joined = `\\\\${joined.slice(slashCount)}`;\n      }\n    }\n    return win32.normalize(joined);\n  },\n  relative(from, to) {\n    validateString(from, 'from');\n    validateString(to, 'to');\n    if (from === to) {\n      return '';\n    }\n    const fromOrig = win32.resolve(from);\n    const toOrig = win32.resolve(to);\n    if (fromOrig === toOrig) {\n      return '';\n    }\n    from = fromOrig.toLowerCase();\n    to = toOrig.toLowerCase();\n    if (from === to) {\n      return '';\n    }\n    let fromStart = 0;\n    while (fromStart < from.length && from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n      fromStart++;\n    }\n    let fromEnd = from.length;\n    while (fromEnd - 1 > fromStart && from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n      fromEnd--;\n    }\n    const fromLen = fromEnd - fromStart;\n    let toStart = 0;\n    while (toStart < to.length && to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n      toStart++;\n    }\n    let toEnd = to.length;\n    while (toEnd - 1 > toStart && to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n      toEnd--;\n    }\n    const toLen = toEnd - toStart;\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = from.charCodeAt(fromStart + i);\n      if (fromCode !== to.charCodeAt(toStart + i)) {\n        break;\n      } else if (fromCode === CHAR_BACKWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    }\n    if (i !== length) {\n      if (lastCommonSep === -1) {\n        return toOrig;\n      }\n    } else {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n          return toOrig.slice(toStart + i + 1);\n        }\n        if (i === 2) {\n          return toOrig.slice(toStart + i);\n        }\n      }\n      if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n          lastCommonSep = i;\n        } else if (i === 2) {\n          lastCommonSep = 3;\n        }\n      }\n      if (lastCommonSep === -1) {\n        lastCommonSep = 0;\n      }\n    }\n    let out = '';\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n        out += out.length === 0 ? '..' : '\\\\..';\n      }\n    }\n    toStart += lastCommonSep;\n    if (out.length > 0) {\n      return `${out}${toOrig.slice(toStart, toEnd)}`;\n    }\n    if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n      ++toStart;\n    }\n    return toOrig.slice(toStart, toEnd);\n  },\n  toNamespacedPath(path) {\n    if (typeof path !== 'string' || path.length === 0) {\n      return path;\n    }\n    const resolvedPath = win32.resolve(path);\n    if (resolvedPath.length <= 2) {\n      return path;\n    }\n    if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n      if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n        const code = resolvedPath.charCodeAt(2);\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n          return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n        }\n      }\n    } else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) && resolvedPath.charCodeAt(1) === CHAR_COLON && resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n      return `\\\\\\\\?\\\\${resolvedPath}`;\n    }\n    return path;\n  },\n  dirname(path) {\n    validateString(path, 'path');\n    const len = path.length;\n    if (len === 0) {\n      return '.';\n    }\n    let rootEnd = -1;\n    let offset = 0;\n    const code = path.charCodeAt(0);\n    if (len === 1) {\n      return isPathSeparator(code) ? path : '.';\n    }\n    if (isPathSeparator(code)) {\n      rootEnd = offset = 1;\n      if (isPathSeparator(path.charCodeAt(1))) {\n        let j = 2;\n        let last = j;\n        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          last = j;\n          while (j < len && isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            last = j;\n            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j === len) {\n              return path;\n            }\n            if (j !== last) {\n              rootEnd = offset = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n      rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n      offset = rootEnd;\n    }\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = len - 1; i >= offset; --i) {\n      if (isPathSeparator(path.charCodeAt(i))) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1) {\n      if (rootEnd === -1) {\n        return '.';\n      }\n      end = rootEnd;\n    }\n    return path.slice(0, end);\n  },\n  basename(path, ext) {\n    if (ext !== undefined) {\n      validateString(ext, 'ext');\n    }\n    validateString(path, 'path');\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (path.length >= 2 && isWindowsDeviceRoot(path.charCodeAt(0)) && path.charCodeAt(1) === CHAR_COLON) {\n      start = 2;\n    }\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path) {\n        return '';\n      }\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= start; --i) {\n        const code = path.charCodeAt(i);\n        if (isPathSeparator(code)) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n      return path.slice(start, end);\n    }\n    for (i = path.length - 1; i >= start; --i) {\n      if (isPathSeparator(path.charCodeAt(i))) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1) {\n      return '';\n    }\n    return path.slice(start, end);\n  },\n  extname(path) {\n    validateString(path, 'path');\n    let start = 0;\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    if (path.length >= 2 && path.charCodeAt(1) === CHAR_COLON && isWindowsDeviceRoot(path.charCodeAt(0))) {\n      start = startPart = 2;\n    }\n    for (let i = path.length - 1; i >= start; --i) {\n      const code = path.charCodeAt(i);\n      if (isPathSeparator(code)) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n  format: _format.bind(null, '\\\\'),\n  parse(path) {\n    validateString(path, 'path');\n    const ret = {\n      root: '',\n      dir: '',\n      base: '',\n      ext: '',\n      name: ''\n    };\n    if (path.length === 0) {\n      return ret;\n    }\n    const len = path.length;\n    let rootEnd = 0;\n    let code = path.charCodeAt(0);\n    if (len === 1) {\n      if (isPathSeparator(code)) {\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      ret.base = ret.name = path;\n      return ret;\n    }\n    if (isPathSeparator(code)) {\n      rootEnd = 1;\n      if (isPathSeparator(path.charCodeAt(1))) {\n        let j = 2;\n        let last = j;\n        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n          j++;\n        }\n        if (j < len && j !== last) {\n          last = j;\n          while (j < len && isPathSeparator(path.charCodeAt(j))) {\n            j++;\n          }\n          if (j < len && j !== last) {\n            last = j;\n            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n              j++;\n            }\n            if (j === len) {\n              rootEnd = j;\n            } else if (j !== last) {\n              rootEnd = j + 1;\n            }\n          }\n        }\n      }\n    } else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n      if (len <= 2) {\n        ret.root = ret.dir = path;\n        return ret;\n      }\n      rootEnd = 2;\n      if (isPathSeparator(path.charCodeAt(2))) {\n        if (len === 3) {\n          ret.root = ret.dir = path;\n          return ret;\n        }\n        rootEnd = 3;\n      }\n    }\n    if (rootEnd > 0) {\n      ret.root = path.slice(0, rootEnd);\n    }\n    let startDot = -1;\n    let startPart = rootEnd;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n    let preDotState = 0;\n    for (; i >= rootEnd; --i) {\n      code = path.charCodeAt(i);\n      if (isPathSeparator(code)) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (end !== -1) {\n      if (startDot === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n        ret.base = ret.name = path.slice(startPart, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n        ret.ext = path.slice(startDot, end);\n      }\n    }\n    if (startPart > 0 && startPart !== rootEnd) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else {\n      ret.dir = ret.root;\n    }\n    return ret;\n  },\n  sep: '\\\\',\n  delimiter: ';',\n  win32: null,\n  posix: null\n};\nconst posixCwd = (() => {\n  if (platformIsWin32) {\n    const regexp = /\\\\/g;\n    return () => {\n      const cwd$1 = cwd().replace(regexp, '/');\n      return cwd$1.slice(cwd$1.indexOf('/'));\n    };\n  }\n  return () => cwd();\n})();\nconst posix = {\n  resolve(...pathSegments) {\n    let resolvedPath = '';\n    let resolvedAbsolute = false;\n    for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      const path = i >= 0 ? pathSegments[i] : posixCwd();\n      validateString(path, 'path');\n      if (path.length === 0) {\n        continue;\n      }\n      resolvedPath = `${path}/${resolvedPath}`;\n      resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    }\n    resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\n    if (resolvedAbsolute) {\n      return `/${resolvedPath}`;\n    }\n    return resolvedPath.length > 0 ? resolvedPath : '.';\n  },\n  normalize(path) {\n    validateString(path, 'path');\n    if (path.length === 0) {\n      return '.';\n    }\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n    path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n    if (path.length === 0) {\n      if (isAbsolute) {\n        return '/';\n      }\n      return trailingSeparator ? './' : '.';\n    }\n    if (trailingSeparator) {\n      path += '/';\n    }\n    return isAbsolute ? `/${path}` : path;\n  },\n  isAbsolute(path) {\n    validateString(path, 'path');\n    return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n  },\n  join(...paths) {\n    if (paths.length === 0) {\n      return '.';\n    }\n    let joined;\n    for (let i = 0; i < paths.length; ++i) {\n      const arg = paths[i];\n      validateString(arg, 'path');\n      if (arg.length > 0) {\n        if (joined === undefined) {\n          joined = arg;\n        } else {\n          joined += `/${arg}`;\n        }\n      }\n    }\n    if (joined === undefined) {\n      return '.';\n    }\n    return posix.normalize(joined);\n  },\n  relative(from, to) {\n    validateString(from, 'from');\n    validateString(to, 'to');\n    if (from === to) {\n      return '';\n    }\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n    if (from === to) {\n      return '';\n    }\n    const fromStart = 1;\n    const fromEnd = from.length;\n    const fromLen = fromEnd - fromStart;\n    const toStart = 1;\n    const toLen = to.length - toStart;\n    const length = fromLen < toLen ? fromLen : toLen;\n    let lastCommonSep = -1;\n    let i = 0;\n    for (; i < length; i++) {\n      const fromCode = from.charCodeAt(fromStart + i);\n      if (fromCode !== to.charCodeAt(toStart + i)) {\n        break;\n      } else if (fromCode === CHAR_FORWARD_SLASH) {\n        lastCommonSep = i;\n      }\n    }\n    if (i === length) {\n      if (toLen > length) {\n        if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n          return to.slice(toStart + i + 1);\n        }\n        if (i === 0) {\n          return to.slice(toStart + i);\n        }\n      } else if (fromLen > length) {\n        if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n          lastCommonSep = i;\n        } else if (i === 0) {\n          lastCommonSep = 0;\n        }\n      }\n    }\n    let out = '';\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        out += out.length === 0 ? '..' : '/..';\n      }\n    }\n    return `${out}${to.slice(toStart + lastCommonSep)}`;\n  },\n  toNamespacedPath(path) {\n    return path;\n  },\n  dirname(path) {\n    validateString(path, 'path');\n    if (path.length === 0) {\n      return '.';\n    }\n    const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let end = -1;\n    let matchedSlash = true;\n    for (let i = path.length - 1; i >= 1; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        matchedSlash = false;\n      }\n    }\n    if (end === -1) {\n      return hasRoot ? '/' : '.';\n    }\n    if (hasRoot && end === 1) {\n      return '//';\n    }\n    return path.slice(0, end);\n  },\n  basename(path, ext) {\n    if (ext !== undefined) {\n      validateString(ext, 'ext');\n    }\n    validateString(path, 'path');\n    let start = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i;\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext === path) {\n        return '';\n      }\n      let extIdx = ext.length - 1;\n      let firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        const code = path.charCodeAt(i);\n        if (code === CHAR_FORWARD_SLASH) {\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                end = i;\n              }\n            } else {\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n      if (start === end) {\n        end = firstNonSlashEnd;\n      } else if (end === -1) {\n        end = path.length;\n      }\n      return path.slice(start, end);\n    }\n    for (i = path.length - 1; i >= 0; --i) {\n      if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          start = i + 1;\n          break;\n        }\n      } else if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n    }\n    if (end === -1) {\n      return '';\n    }\n    return path.slice(start, end);\n  },\n  extname(path) {\n    validateString(path, 'path');\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let preDotState = 0;\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (startDot === -1 || end === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n  format: _format.bind(null, '/'),\n  parse(path) {\n    validateString(path, 'path');\n    const ret = {\n      root: '',\n      dir: '',\n      base: '',\n      ext: '',\n      name: ''\n    };\n    if (path.length === 0) {\n      return ret;\n    }\n    const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    let start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    let startDot = -1;\n    let startPart = 0;\n    let end = -1;\n    let matchedSlash = true;\n    let i = path.length - 1;\n    let preDotState = 0;\n    for (; i >= start; --i) {\n      const code = path.charCodeAt(i);\n      if (code === CHAR_FORWARD_SLASH) {\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === CHAR_DOT) {\n        if (startDot === -1) {\n          startDot = i;\n        } else if (preDotState !== 1) {\n          preDotState = 1;\n        }\n      } else if (startDot !== -1) {\n        preDotState = -1;\n      }\n    }\n    if (end !== -1) {\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\n      if (startDot === -1 || preDotState === 0 || preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n        ret.base = ret.name = path.slice(start, end);\n      } else {\n        ret.name = path.slice(start, startDot);\n        ret.base = path.slice(start, end);\n        ret.ext = path.slice(startDot, end);\n      }\n    }\n    if (startPart > 0) {\n      ret.dir = path.slice(0, startPart - 1);\n    } else if (isAbsolute) {\n      ret.dir = '/';\n    }\n    return ret;\n  },\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\nconst normalize = platformIsWin32 ? win32.normalize : posix.normalize;\nconst isAbsolute = platformIsWin32 ? win32.isAbsolute : posix.isAbsolute;\nconst join = platformIsWin32 ? win32.join : posix.join;\nconst resolve = platformIsWin32 ? win32.resolve : posix.resolve;\nconst relative = platformIsWin32 ? win32.relative : posix.relative;\nconst dirname = platformIsWin32 ? win32.dirname : posix.dirname;\nconst basename = platformIsWin32 ? win32.basename : posix.basename;\nconst extname = platformIsWin32 ? win32.extname : posix.extname;\nconst parse = platformIsWin32 ? win32.parse : posix.parse;\nconst sep = platformIsWin32 ? win32.sep : posix.sep;\nconst delimiter = platformIsWin32 ? win32.delimiter : posix.delimiter;\nexport { basename, delimiter, dirname, extname, isAbsolute, join, normalize, parse, posix, relative, resolve, sep, win32 };","map":{"version":3,"names":["cwd","env","platform","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_DOT","CHAR_FORWARD_SLASH","CHAR_BACKWARD_SLASH","CHAR_COLON","CHAR_QUESTION_MARK","ErrorInvalidArgType","Error","constructor","name","expected","actual","determiner","indexOf","replace","type","msg","code","validateObject","pathObject","validateString","value","platformIsWin32","isPathSeparator","isPosixPathSeparator","isWindowsDeviceRoot","normalizeString","path","allowAboveRoot","separator","res","lastSegmentLength","lastSlash","dots","i","length","charCodeAt","lastSlashIndex","lastIndexOf","slice","_format","sep","dir","root","base","ext","win32","resolve","pathSegments","resolvedDevice","resolvedTail","resolvedAbsolute","undefined","toLowerCase","len","rootEnd","device","isAbsolute","j","last","firstPart","normalize","tail","join","paths","joined","arg","needsReplace","slashCount","firstLen","relative","from","to","fromOrig","toOrig","fromStart","fromEnd","fromLen","toStart","toEnd","toLen","lastCommonSep","fromCode","out","toNamespacedPath","resolvedPath","dirname","offset","end","matchedSlash","basename","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","bind","parse","ret","delimiter","posix","posixCwd","regexp","cwd$1","trailingSeparator","hasRoot"],"sources":["/Users/phamtu/Downloads/Code/OCE/oce-frontend/node_modules/vscode/vscode/src/vs/base/common/path.js"],"sourcesContent":["import { cwd, env, platform } from './process.js';\nconst CHAR_UPPERCASE_A = 65;\nconst CHAR_LOWERCASE_A = 97;\nconst CHAR_UPPERCASE_Z = 90;\nconst CHAR_LOWERCASE_Z = 122;\nconst CHAR_DOT = 46;\nconst CHAR_FORWARD_SLASH = 47;\nconst CHAR_BACKWARD_SLASH = 92;\nconst CHAR_COLON = 58;\nconst CHAR_QUESTION_MARK = 63;\nclass ErrorInvalidArgType extends Error {\n    constructor(name, expected, actual) {\n        let determiner;\n        if (typeof expected === 'string' && expected.indexOf('not ') === 0) {\n            determiner = 'must not be';\n            expected = expected.replace(/^not /, '');\n        }\n        else {\n            determiner = 'must be';\n        }\n        const type = name.indexOf('.') !== -1 ? 'property' : 'argument';\n        let msg = `The \"${name}\" ${type} ${determiner} of type ${expected}`;\n        msg += `. Received type ${typeof actual}`;\n        super(msg);\n        this.code = 'ERR_INVALID_ARG_TYPE';\n    }\n}\nfunction validateObject(pathObject, name) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n        throw ( new ErrorInvalidArgType(name, 'Object', pathObject));\n    }\n}\nfunction validateString(value, name) {\n    if (typeof value !== 'string') {\n        throw ( new ErrorInvalidArgType(name, 'string', value));\n    }\n}\nconst platformIsWin32 = (platform === 'win32');\nfunction isPathSeparator(code) {\n    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n}\nfunction isPosixPathSeparator(code) {\n    return code === CHAR_FORWARD_SLASH;\n}\nfunction isWindowsDeviceRoot(code) {\n    return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\n        (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\n}\nfunction normalizeString(path, allowAboveRoot, separator, isPathSeparator) {\n    let res = '';\n    let lastSegmentLength = 0;\n    let lastSlash = -1;\n    let dots = 0;\n    let code = 0;\n    for (let i = 0; i <= path.length; ++i) {\n        if (i < path.length) {\n            code = path.charCodeAt(i);\n        }\n        else if (isPathSeparator(code)) {\n            break;\n        }\n        else {\n            code = CHAR_FORWARD_SLASH;\n        }\n        if (isPathSeparator(code)) {\n            if (lastSlash === i - 1 || dots === 1) ;\n            else if (dots === 2) {\n                if (res.length < 2 || lastSegmentLength !== 2 ||\n                    res.charCodeAt(res.length - 1) !== CHAR_DOT ||\n                    res.charCodeAt(res.length - 2) !== CHAR_DOT) {\n                    if (res.length > 2) {\n                        const lastSlashIndex = res.lastIndexOf(separator);\n                        if (lastSlashIndex === -1) {\n                            res = '';\n                            lastSegmentLength = 0;\n                        }\n                        else {\n                            res = res.slice(0, lastSlashIndex);\n                            lastSegmentLength = res.length - 1 - res.lastIndexOf(separator);\n                        }\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                    else if (res.length !== 0) {\n                        res = '';\n                        lastSegmentLength = 0;\n                        lastSlash = i;\n                        dots = 0;\n                        continue;\n                    }\n                }\n                if (allowAboveRoot) {\n                    res += res.length > 0 ? `${separator}..` : '..';\n                    lastSegmentLength = 2;\n                }\n            }\n            else {\n                if (res.length > 0) {\n                    res += `${separator}${path.slice(lastSlash + 1, i)}`;\n                }\n                else {\n                    res = path.slice(lastSlash + 1, i);\n                }\n                lastSegmentLength = i - lastSlash - 1;\n            }\n            lastSlash = i;\n            dots = 0;\n        }\n        else if (code === CHAR_DOT && dots !== -1) {\n            ++dots;\n        }\n        else {\n            dots = -1;\n        }\n    }\n    return res;\n}\nfunction _format(sep, pathObject) {\n    validateObject(pathObject, 'pathObject');\n    const dir = pathObject.dir || pathObject.root;\n    const base = pathObject.base ||\n        `${pathObject.name || ''}${pathObject.ext || ''}`;\n    if (!dir) {\n        return base;\n    }\n    return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\n}\nconst win32 = {\n    resolve(...pathSegments) {\n        let resolvedDevice = '';\n        let resolvedTail = '';\n        let resolvedAbsolute = false;\n        for (let i = pathSegments.length - 1; i >= -1; i--) {\n            let path;\n            if (i >= 0) {\n                path = pathSegments[i];\n                validateString(path, 'path');\n                if (path.length === 0) {\n                    continue;\n                }\n            }\n            else if (resolvedDevice.length === 0) {\n                path = cwd();\n            }\n            else {\n                path = env[`=${resolvedDevice}`] || cwd();\n                if (path === undefined ||\n                    (path.slice(0, 2).toLowerCase() !== resolvedDevice.toLowerCase() &&\n                        path.charCodeAt(2) === CHAR_BACKWARD_SLASH)) {\n                    path = `${resolvedDevice}\\\\`;\n                }\n            }\n            const len = path.length;\n            let rootEnd = 0;\n            let device = '';\n            let isAbsolute = false;\n            const code = path.charCodeAt(0);\n            if (len === 1) {\n                if (isPathSeparator(code)) {\n                    rootEnd = 1;\n                    isAbsolute = true;\n                }\n            }\n            else if (isPathSeparator(code)) {\n                isAbsolute = true;\n                if (isPathSeparator(path.charCodeAt(1))) {\n                    let j = 2;\n                    let last = j;\n                    while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        const firstPart = path.slice(last, j);\n                        last = j;\n                        while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j < len && j !== last) {\n                            last = j;\n                            while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                                j++;\n                            }\n                            if (j === len || j !== last) {\n                                device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                                rootEnd = j;\n                            }\n                        }\n                    }\n                }\n                else {\n                    rootEnd = 1;\n                }\n            }\n            else if (isWindowsDeviceRoot(code) &&\n                path.charCodeAt(1) === CHAR_COLON) {\n                device = path.slice(0, 2);\n                rootEnd = 2;\n                if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n                    isAbsolute = true;\n                    rootEnd = 3;\n                }\n            }\n            if (device.length > 0) {\n                if (resolvedDevice.length > 0) {\n                    if (device.toLowerCase() !== resolvedDevice.toLowerCase()) {\n                        continue;\n                    }\n                }\n                else {\n                    resolvedDevice = device;\n                }\n            }\n            if (resolvedAbsolute) {\n                if (resolvedDevice.length > 0) {\n                    break;\n                }\n            }\n            else {\n                resolvedTail = `${path.slice(rootEnd)}\\\\${resolvedTail}`;\n                resolvedAbsolute = isAbsolute;\n                if (isAbsolute && resolvedDevice.length > 0) {\n                    break;\n                }\n            }\n        }\n        resolvedTail = normalizeString(resolvedTail, !resolvedAbsolute, '\\\\', isPathSeparator);\n        return resolvedAbsolute ?\n            `${resolvedDevice}\\\\${resolvedTail}` :\n            `${resolvedDevice}${resolvedTail}` || '.';\n    },\n    normalize(path) {\n        validateString(path, 'path');\n        const len = path.length;\n        if (len === 0) {\n            return '.';\n        }\n        let rootEnd = 0;\n        let device;\n        let isAbsolute = false;\n        const code = path.charCodeAt(0);\n        if (len === 1) {\n            return isPosixPathSeparator(code) ? '\\\\' : path;\n        }\n        if (isPathSeparator(code)) {\n            isAbsolute = true;\n            if (isPathSeparator(path.charCodeAt(1))) {\n                let j = 2;\n                let last = j;\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                    j++;\n                }\n                if (j < len && j !== last) {\n                    const firstPart = path.slice(last, j);\n                    last = j;\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        last = j;\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j === len) {\n                            return `\\\\\\\\${firstPart}\\\\${path.slice(last)}\\\\`;\n                        }\n                        if (j !== last) {\n                            device = `\\\\\\\\${firstPart}\\\\${path.slice(last, j)}`;\n                            rootEnd = j;\n                        }\n                    }\n                }\n            }\n            else {\n                rootEnd = 1;\n            }\n        }\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n            device = path.slice(0, 2);\n            rootEnd = 2;\n            if (len > 2 && isPathSeparator(path.charCodeAt(2))) {\n                isAbsolute = true;\n                rootEnd = 3;\n            }\n        }\n        let tail = rootEnd < len ?\n            normalizeString(path.slice(rootEnd), !isAbsolute, '\\\\', isPathSeparator) :\n            '';\n        if (tail.length === 0 && !isAbsolute) {\n            tail = '.';\n        }\n        if (tail.length > 0 && isPathSeparator(path.charCodeAt(len - 1))) {\n            tail += '\\\\';\n        }\n        if (device === undefined) {\n            return isAbsolute ? `\\\\${tail}` : tail;\n        }\n        return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\n    },\n    isAbsolute(path) {\n        validateString(path, 'path');\n        const len = path.length;\n        if (len === 0) {\n            return false;\n        }\n        const code = path.charCodeAt(0);\n        return isPathSeparator(code) ||\n            (len > 2 &&\n                isWindowsDeviceRoot(code) &&\n                path.charCodeAt(1) === CHAR_COLON &&\n                isPathSeparator(path.charCodeAt(2)));\n    },\n    join(...paths) {\n        if (paths.length === 0) {\n            return '.';\n        }\n        let joined;\n        let firstPart;\n        for (let i = 0; i < paths.length; ++i) {\n            const arg = paths[i];\n            validateString(arg, 'path');\n            if (arg.length > 0) {\n                if (joined === undefined) {\n                    joined = firstPart = arg;\n                }\n                else {\n                    joined += `\\\\${arg}`;\n                }\n            }\n        }\n        if (joined === undefined) {\n            return '.';\n        }\n        let needsReplace = true;\n        let slashCount = 0;\n        if (typeof firstPart === 'string' && isPathSeparator(firstPart.charCodeAt(0))) {\n            ++slashCount;\n            const firstLen = firstPart.length;\n            if (firstLen > 1 && isPathSeparator(firstPart.charCodeAt(1))) {\n                ++slashCount;\n                if (firstLen > 2) {\n                    if (isPathSeparator(firstPart.charCodeAt(2))) {\n                        ++slashCount;\n                    }\n                    else {\n                        needsReplace = false;\n                    }\n                }\n            }\n        }\n        if (needsReplace) {\n            while (slashCount < joined.length &&\n                isPathSeparator(joined.charCodeAt(slashCount))) {\n                slashCount++;\n            }\n            if (slashCount >= 2) {\n                joined = `\\\\${joined.slice(slashCount)}`;\n            }\n        }\n        return win32.normalize(joined);\n    },\n    relative(from, to) {\n        validateString(from, 'from');\n        validateString(to, 'to');\n        if (from === to) {\n            return '';\n        }\n        const fromOrig = win32.resolve(from);\n        const toOrig = win32.resolve(to);\n        if (fromOrig === toOrig) {\n            return '';\n        }\n        from = fromOrig.toLowerCase();\n        to = toOrig.toLowerCase();\n        if (from === to) {\n            return '';\n        }\n        let fromStart = 0;\n        while (fromStart < from.length &&\n            from.charCodeAt(fromStart) === CHAR_BACKWARD_SLASH) {\n            fromStart++;\n        }\n        let fromEnd = from.length;\n        while (fromEnd - 1 > fromStart &&\n            from.charCodeAt(fromEnd - 1) === CHAR_BACKWARD_SLASH) {\n            fromEnd--;\n        }\n        const fromLen = fromEnd - fromStart;\n        let toStart = 0;\n        while (toStart < to.length &&\n            to.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n            toStart++;\n        }\n        let toEnd = to.length;\n        while (toEnd - 1 > toStart &&\n            to.charCodeAt(toEnd - 1) === CHAR_BACKWARD_SLASH) {\n            toEnd--;\n        }\n        const toLen = toEnd - toStart;\n        const length = fromLen < toLen ? fromLen : toLen;\n        let lastCommonSep = -1;\n        let i = 0;\n        for (; i < length; i++) {\n            const fromCode = from.charCodeAt(fromStart + i);\n            if (fromCode !== to.charCodeAt(toStart + i)) {\n                break;\n            }\n            else if (fromCode === CHAR_BACKWARD_SLASH) {\n                lastCommonSep = i;\n            }\n        }\n        if (i !== length) {\n            if (lastCommonSep === -1) {\n                return toOrig;\n            }\n        }\n        else {\n            if (toLen > length) {\n                if (to.charCodeAt(toStart + i) === CHAR_BACKWARD_SLASH) {\n                    return toOrig.slice(toStart + i + 1);\n                }\n                if (i === 2) {\n                    return toOrig.slice(toStart + i);\n                }\n            }\n            if (fromLen > length) {\n                if (from.charCodeAt(fromStart + i) === CHAR_BACKWARD_SLASH) {\n                    lastCommonSep = i;\n                }\n                else if (i === 2) {\n                    lastCommonSep = 3;\n                }\n            }\n            if (lastCommonSep === -1) {\n                lastCommonSep = 0;\n            }\n        }\n        let out = '';\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_BACKWARD_SLASH) {\n                out += out.length === 0 ? '..' : '\\\\..';\n            }\n        }\n        toStart += lastCommonSep;\n        if (out.length > 0) {\n            return `${out}${toOrig.slice(toStart, toEnd)}`;\n        }\n        if (toOrig.charCodeAt(toStart) === CHAR_BACKWARD_SLASH) {\n            ++toStart;\n        }\n        return toOrig.slice(toStart, toEnd);\n    },\n    toNamespacedPath(path) {\n        if (typeof path !== 'string' || path.length === 0) {\n            return path;\n        }\n        const resolvedPath = win32.resolve(path);\n        if (resolvedPath.length <= 2) {\n            return path;\n        }\n        if (resolvedPath.charCodeAt(0) === CHAR_BACKWARD_SLASH) {\n            if (resolvedPath.charCodeAt(1) === CHAR_BACKWARD_SLASH) {\n                const code = resolvedPath.charCodeAt(2);\n                if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\n                    return `\\\\\\\\?\\\\UNC\\\\${resolvedPath.slice(2)}`;\n                }\n            }\n        }\n        else if (isWindowsDeviceRoot(resolvedPath.charCodeAt(0)) &&\n            resolvedPath.charCodeAt(1) === CHAR_COLON &&\n            resolvedPath.charCodeAt(2) === CHAR_BACKWARD_SLASH) {\n            return `\\\\\\\\?\\\\${resolvedPath}`;\n        }\n        return path;\n    },\n    dirname(path) {\n        validateString(path, 'path');\n        const len = path.length;\n        if (len === 0) {\n            return '.';\n        }\n        let rootEnd = -1;\n        let offset = 0;\n        const code = path.charCodeAt(0);\n        if (len === 1) {\n            return isPathSeparator(code) ? path : '.';\n        }\n        if (isPathSeparator(code)) {\n            rootEnd = offset = 1;\n            if (isPathSeparator(path.charCodeAt(1))) {\n                let j = 2;\n                let last = j;\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                    j++;\n                }\n                if (j < len && j !== last) {\n                    last = j;\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        last = j;\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j === len) {\n                            return path;\n                        }\n                        if (j !== last) {\n                            rootEnd = offset = j + 1;\n                        }\n                    }\n                }\n            }\n        }\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n            rootEnd = len > 2 && isPathSeparator(path.charCodeAt(2)) ? 3 : 2;\n            offset = rootEnd;\n        }\n        let end = -1;\n        let matchedSlash = true;\n        for (let i = len - 1; i >= offset; --i) {\n            if (isPathSeparator(path.charCodeAt(i))) {\n                if (!matchedSlash) {\n                    end = i;\n                    break;\n                }\n            }\n            else {\n                matchedSlash = false;\n            }\n        }\n        if (end === -1) {\n            if (rootEnd === -1) {\n                return '.';\n            }\n            end = rootEnd;\n        }\n        return path.slice(0, end);\n    },\n    basename(path, ext) {\n        if (ext !== undefined) {\n            validateString(ext, 'ext');\n        }\n        validateString(path, 'path');\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i;\n        if (path.length >= 2 &&\n            isWindowsDeviceRoot(path.charCodeAt(0)) &&\n            path.charCodeAt(1) === CHAR_COLON) {\n            start = 2;\n        }\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n            if (ext === path) {\n                return '';\n            }\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n            for (i = path.length - 1; i >= start; --i) {\n                const code = path.charCodeAt(i);\n                if (isPathSeparator(code)) {\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else {\n                    if (firstNonSlashEnd === -1) {\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0) {\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) {\n                                end = i;\n                            }\n                        }\n                        else {\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n            if (start === end) {\n                end = firstNonSlashEnd;\n            }\n            else if (end === -1) {\n                end = path.length;\n            }\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= start; --i) {\n            if (isPathSeparator(path.charCodeAt(i))) {\n                if (!matchedSlash) {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1) {\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n        if (end === -1) {\n            return '';\n        }\n        return path.slice(start, end);\n    },\n    extname(path) {\n        validateString(path, 'path');\n        let start = 0;\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let preDotState = 0;\n        if (path.length >= 2 &&\n            path.charCodeAt(1) === CHAR_COLON &&\n            isWindowsDeviceRoot(path.charCodeAt(0))) {\n            start = startPart = 2;\n        }\n        for (let i = path.length - 1; i >= start; --i) {\n            const code = path.charCodeAt(i);\n            if (isPathSeparator(code)) {\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                preDotState = -1;\n            }\n        }\n        if (startDot === -1 ||\n            end === -1 ||\n            preDotState === 0 ||\n            (preDotState === 1 &&\n                startDot === end - 1 &&\n                startDot === startPart + 1)) {\n            return '';\n        }\n        return path.slice(startDot, end);\n    },\n    format: _format.bind(null, '\\\\'),\n    parse(path) {\n        validateString(path, 'path');\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n        if (path.length === 0) {\n            return ret;\n        }\n        const len = path.length;\n        let rootEnd = 0;\n        let code = path.charCodeAt(0);\n        if (len === 1) {\n            if (isPathSeparator(code)) {\n                ret.root = ret.dir = path;\n                return ret;\n            }\n            ret.base = ret.name = path;\n            return ret;\n        }\n        if (isPathSeparator(code)) {\n            rootEnd = 1;\n            if (isPathSeparator(path.charCodeAt(1))) {\n                let j = 2;\n                let last = j;\n                while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                    j++;\n                }\n                if (j < len && j !== last) {\n                    last = j;\n                    while (j < len && isPathSeparator(path.charCodeAt(j))) {\n                        j++;\n                    }\n                    if (j < len && j !== last) {\n                        last = j;\n                        while (j < len && !isPathSeparator(path.charCodeAt(j))) {\n                            j++;\n                        }\n                        if (j === len) {\n                            rootEnd = j;\n                        }\n                        else if (j !== last) {\n                            rootEnd = j + 1;\n                        }\n                    }\n                }\n            }\n        }\n        else if (isWindowsDeviceRoot(code) && path.charCodeAt(1) === CHAR_COLON) {\n            if (len <= 2) {\n                ret.root = ret.dir = path;\n                return ret;\n            }\n            rootEnd = 2;\n            if (isPathSeparator(path.charCodeAt(2))) {\n                if (len === 3) {\n                    ret.root = ret.dir = path;\n                    return ret;\n                }\n                rootEnd = 3;\n            }\n        }\n        if (rootEnd > 0) {\n            ret.root = path.slice(0, rootEnd);\n        }\n        let startDot = -1;\n        let startPart = rootEnd;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n        let preDotState = 0;\n        for (; i >= rootEnd; --i) {\n            code = path.charCodeAt(i);\n            if (isPathSeparator(code)) {\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                preDotState = -1;\n            }\n        }\n        if (end !== -1) {\n            if (startDot === -1 ||\n                preDotState === 0 ||\n                (preDotState === 1 &&\n                    startDot === end - 1 &&\n                    startDot === startPart + 1)) {\n                ret.base = ret.name = path.slice(startPart, end);\n            }\n            else {\n                ret.name = path.slice(startPart, startDot);\n                ret.base = path.slice(startPart, end);\n                ret.ext = path.slice(startDot, end);\n            }\n        }\n        if (startPart > 0 && startPart !== rootEnd) {\n            ret.dir = path.slice(0, startPart - 1);\n        }\n        else {\n            ret.dir = ret.root;\n        }\n        return ret;\n    },\n    sep: '\\\\',\n    delimiter: ';',\n    win32: null,\n    posix: null\n};\nconst posixCwd = (() => {\n    if (platformIsWin32) {\n        const regexp = /\\\\/g;\n        return () => {\n            const cwd$1 = cwd().replace(regexp, '/');\n            return cwd$1.slice(cwd$1.indexOf('/'));\n        };\n    }\n    return () => cwd();\n})();\nconst posix = {\n    resolve(...pathSegments) {\n        let resolvedPath = '';\n        let resolvedAbsolute = false;\n        for (let i = pathSegments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n            const path = i >= 0 ? pathSegments[i] : posixCwd();\n            validateString(path, 'path');\n            if (path.length === 0) {\n                continue;\n            }\n            resolvedPath = `${path}/${resolvedPath}`;\n            resolvedAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        }\n        resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute, '/', isPosixPathSeparator);\n        if (resolvedAbsolute) {\n            return `/${resolvedPath}`;\n        }\n        return resolvedPath.length > 0 ? resolvedPath : '.';\n    },\n    normalize(path) {\n        validateString(path, 'path');\n        if (path.length === 0) {\n            return '.';\n        }\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        const trailingSeparator = path.charCodeAt(path.length - 1) === CHAR_FORWARD_SLASH;\n        path = normalizeString(path, !isAbsolute, '/', isPosixPathSeparator);\n        if (path.length === 0) {\n            if (isAbsolute) {\n                return '/';\n            }\n            return trailingSeparator ? './' : '.';\n        }\n        if (trailingSeparator) {\n            path += '/';\n        }\n        return isAbsolute ? `/${path}` : path;\n    },\n    isAbsolute(path) {\n        validateString(path, 'path');\n        return path.length > 0 && path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n    },\n    join(...paths) {\n        if (paths.length === 0) {\n            return '.';\n        }\n        let joined;\n        for (let i = 0; i < paths.length; ++i) {\n            const arg = paths[i];\n            validateString(arg, 'path');\n            if (arg.length > 0) {\n                if (joined === undefined) {\n                    joined = arg;\n                }\n                else {\n                    joined += `/${arg}`;\n                }\n            }\n        }\n        if (joined === undefined) {\n            return '.';\n        }\n        return posix.normalize(joined);\n    },\n    relative(from, to) {\n        validateString(from, 'from');\n        validateString(to, 'to');\n        if (from === to) {\n            return '';\n        }\n        from = posix.resolve(from);\n        to = posix.resolve(to);\n        if (from === to) {\n            return '';\n        }\n        const fromStart = 1;\n        const fromEnd = from.length;\n        const fromLen = fromEnd - fromStart;\n        const toStart = 1;\n        const toLen = to.length - toStart;\n        const length = (fromLen < toLen ? fromLen : toLen);\n        let lastCommonSep = -1;\n        let i = 0;\n        for (; i < length; i++) {\n            const fromCode = from.charCodeAt(fromStart + i);\n            if (fromCode !== to.charCodeAt(toStart + i)) {\n                break;\n            }\n            else if (fromCode === CHAR_FORWARD_SLASH) {\n                lastCommonSep = i;\n            }\n        }\n        if (i === length) {\n            if (toLen > length) {\n                if (to.charCodeAt(toStart + i) === CHAR_FORWARD_SLASH) {\n                    return to.slice(toStart + i + 1);\n                }\n                if (i === 0) {\n                    return to.slice(toStart + i);\n                }\n            }\n            else if (fromLen > length) {\n                if (from.charCodeAt(fromStart + i) === CHAR_FORWARD_SLASH) {\n                    lastCommonSep = i;\n                }\n                else if (i === 0) {\n                    lastCommonSep = 0;\n                }\n            }\n        }\n        let out = '';\n        for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n            if (i === fromEnd || from.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                out += out.length === 0 ? '..' : '/..';\n            }\n        }\n        return `${out}${to.slice(toStart + lastCommonSep)}`;\n    },\n    toNamespacedPath(path) {\n        return path;\n    },\n    dirname(path) {\n        validateString(path, 'path');\n        if (path.length === 0) {\n            return '.';\n        }\n        const hasRoot = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        let end = -1;\n        let matchedSlash = true;\n        for (let i = path.length - 1; i >= 1; --i) {\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                if (!matchedSlash) {\n                    end = i;\n                    break;\n                }\n            }\n            else {\n                matchedSlash = false;\n            }\n        }\n        if (end === -1) {\n            return hasRoot ? '/' : '.';\n        }\n        if (hasRoot && end === 1) {\n            return '//';\n        }\n        return path.slice(0, end);\n    },\n    basename(path, ext) {\n        if (ext !== undefined) {\n            validateString(ext, 'ext');\n        }\n        validateString(path, 'path');\n        let start = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i;\n        if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n            if (ext === path) {\n                return '';\n            }\n            let extIdx = ext.length - 1;\n            let firstNonSlashEnd = -1;\n            for (i = path.length - 1; i >= 0; --i) {\n                const code = path.charCodeAt(i);\n                if (code === CHAR_FORWARD_SLASH) {\n                    if (!matchedSlash) {\n                        start = i + 1;\n                        break;\n                    }\n                }\n                else {\n                    if (firstNonSlashEnd === -1) {\n                        matchedSlash = false;\n                        firstNonSlashEnd = i + 1;\n                    }\n                    if (extIdx >= 0) {\n                        if (code === ext.charCodeAt(extIdx)) {\n                            if (--extIdx === -1) {\n                                end = i;\n                            }\n                        }\n                        else {\n                            extIdx = -1;\n                            end = firstNonSlashEnd;\n                        }\n                    }\n                }\n            }\n            if (start === end) {\n                end = firstNonSlashEnd;\n            }\n            else if (end === -1) {\n                end = path.length;\n            }\n            return path.slice(start, end);\n        }\n        for (i = path.length - 1; i >= 0; --i) {\n            if (path.charCodeAt(i) === CHAR_FORWARD_SLASH) {\n                if (!matchedSlash) {\n                    start = i + 1;\n                    break;\n                }\n            }\n            else if (end === -1) {\n                matchedSlash = false;\n                end = i + 1;\n            }\n        }\n        if (end === -1) {\n            return '';\n        }\n        return path.slice(start, end);\n    },\n    extname(path) {\n        validateString(path, 'path');\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let preDotState = 0;\n        for (let i = path.length - 1; i >= 0; --i) {\n            const code = path.charCodeAt(i);\n            if (code === CHAR_FORWARD_SLASH) {\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                preDotState = -1;\n            }\n        }\n        if (startDot === -1 ||\n            end === -1 ||\n            preDotState === 0 ||\n            (preDotState === 1 &&\n                startDot === end - 1 &&\n                startDot === startPart + 1)) {\n            return '';\n        }\n        return path.slice(startDot, end);\n    },\n    format: _format.bind(null, '/'),\n    parse(path) {\n        validateString(path, 'path');\n        const ret = { root: '', dir: '', base: '', ext: '', name: '' };\n        if (path.length === 0) {\n            return ret;\n        }\n        const isAbsolute = path.charCodeAt(0) === CHAR_FORWARD_SLASH;\n        let start;\n        if (isAbsolute) {\n            ret.root = '/';\n            start = 1;\n        }\n        else {\n            start = 0;\n        }\n        let startDot = -1;\n        let startPart = 0;\n        let end = -1;\n        let matchedSlash = true;\n        let i = path.length - 1;\n        let preDotState = 0;\n        for (; i >= start; --i) {\n            const code = path.charCodeAt(i);\n            if (code === CHAR_FORWARD_SLASH) {\n                if (!matchedSlash) {\n                    startPart = i + 1;\n                    break;\n                }\n                continue;\n            }\n            if (end === -1) {\n                matchedSlash = false;\n                end = i + 1;\n            }\n            if (code === CHAR_DOT) {\n                if (startDot === -1) {\n                    startDot = i;\n                }\n                else if (preDotState !== 1) {\n                    preDotState = 1;\n                }\n            }\n            else if (startDot !== -1) {\n                preDotState = -1;\n            }\n        }\n        if (end !== -1) {\n            const start = startPart === 0 && isAbsolute ? 1 : startPart;\n            if (startDot === -1 ||\n                preDotState === 0 ||\n                (preDotState === 1 &&\n                    startDot === end - 1 &&\n                    startDot === startPart + 1)) {\n                ret.base = ret.name = path.slice(start, end);\n            }\n            else {\n                ret.name = path.slice(start, startDot);\n                ret.base = path.slice(start, end);\n                ret.ext = path.slice(startDot, end);\n            }\n        }\n        if (startPart > 0) {\n            ret.dir = path.slice(0, startPart - 1);\n        }\n        else if (isAbsolute) {\n            ret.dir = '/';\n        }\n        return ret;\n    },\n    sep: '/',\n    delimiter: ':',\n    win32: null,\n    posix: null\n};\nposix.win32 = win32.win32 = win32;\nposix.posix = win32.posix = posix;\nconst normalize = (platformIsWin32 ? win32.normalize : posix.normalize);\nconst isAbsolute = (platformIsWin32 ? win32.isAbsolute : posix.isAbsolute);\nconst join = (platformIsWin32 ? win32.join : posix.join);\nconst resolve = (platformIsWin32 ? win32.resolve : posix.resolve);\nconst relative = (platformIsWin32 ? win32.relative : posix.relative);\nconst dirname = (platformIsWin32 ? win32.dirname : posix.dirname);\nconst basename = (platformIsWin32 ? win32.basename : posix.basename);\nconst extname = (platformIsWin32 ? win32.extname : posix.extname);\nconst parse = (platformIsWin32 ? win32.parse : posix.parse);\nconst sep = (platformIsWin32 ? win32.sep : posix.sep);\nconst delimiter = (platformIsWin32 ? win32.delimiter : posix.delimiter);\nexport { basename, delimiter, dirname, extname, isAbsolute, join, normalize, parse, posix, relative, resolve, sep, win32 };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}