{"ast":null,"code":"import { isEqualOrParent as isEqualOrParent$1, toSlashes, toPosixPath, getRoot } from './extpath.js';\nimport { Schemas } from './network.js';\nimport { posix, dirname as dirname$1, normalize, relative, resolve, sep } from './path.js';\nimport { isWindows, isLinux } from './platform.js';\nimport { compare, equalsIgnoreCase } from './strings.js';\nimport { uriToFsPath, URI } from './uri.js';\nfunction originalFSPath(uri) {\n  return uriToFsPath(uri, true);\n}\nclass ExtUri {\n  constructor(_ignorePathCasing) {\n    this._ignorePathCasing = _ignorePathCasing;\n  }\n  compare(uri1, uri2, ignoreFragment = false) {\n    if (uri1 === uri2) {\n      return 0;\n    }\n    return compare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n  }\n  isEqual(uri1, uri2, ignoreFragment = false) {\n    if (uri1 === uri2) {\n      return true;\n    }\n    if (!uri1 || !uri2) {\n      return false;\n    }\n    return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n  }\n  getComparisonKey(uri, ignoreFragment = false) {\n    return uri.with({\n      path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n      fragment: ignoreFragment ? null : undefined\n    }).toString();\n  }\n  ignorePathCasing(uri) {\n    return this._ignorePathCasing(uri);\n  }\n  isEqualOrParent(base, parentCandidate, ignoreFragment = false) {\n    if (base.scheme === parentCandidate.scheme) {\n      if (base.scheme === Schemas.file) {\n        return isEqualOrParent$1(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n      }\n      if (isEqualAuthority(base.authority, parentCandidate.authority)) {\n        return isEqualOrParent$1(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n      }\n    }\n    return false;\n  }\n  joinPath(resource, ...pathFragment) {\n    return URI.joinPath(resource, ...pathFragment);\n  }\n  basenameOrAuthority(resource) {\n    return basename(resource) || resource.authority;\n  }\n  basename(resource) {\n    return posix.basename(resource.path);\n  }\n  extname(resource) {\n    return posix.extname(resource.path);\n  }\n  dirname(resource) {\n    if (resource.path.length === 0) {\n      return resource;\n    }\n    let dirname;\n    if (resource.scheme === Schemas.file) {\n      dirname = URI.file(dirname$1(originalFSPath(resource))).path;\n    } else {\n      dirname = posix.dirname(resource.path);\n      if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47) {\n        console.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n        dirname = '/';\n      }\n    }\n    return resource.with({\n      path: dirname\n    });\n  }\n  normalizePath(resource) {\n    if (!resource.path.length) {\n      return resource;\n    }\n    let normalizedPath;\n    if (resource.scheme === Schemas.file) {\n      normalizedPath = URI.file(normalize(originalFSPath(resource))).path;\n    } else {\n      normalizedPath = posix.normalize(resource.path);\n    }\n    return resource.with({\n      path: normalizedPath\n    });\n  }\n  relativePath(from, to) {\n    if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n      return undefined;\n    }\n    if (from.scheme === Schemas.file) {\n      const relativePath = relative(originalFSPath(from), originalFSPath(to));\n      return isWindows ? toSlashes(relativePath) : relativePath;\n    }\n    let fromPath = from.path || '/';\n    const toPath = to.path || '/';\n    if (this._ignorePathCasing(from)) {\n      let i = 0;\n      for (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n        if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n          if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n            break;\n          }\n        }\n      }\n      fromPath = toPath.substr(0, i) + fromPath.substr(i);\n    }\n    return posix.relative(fromPath, toPath);\n  }\n  resolvePath(base, path) {\n    if (base.scheme === Schemas.file) {\n      const newURI = URI.file(resolve(originalFSPath(base), path));\n      return base.with({\n        authority: newURI.authority,\n        path: newURI.path\n      });\n    }\n    path = toPosixPath(path);\n    return base.with({\n      path: posix.resolve(base.path, path)\n    });\n  }\n  isAbsolutePath(resource) {\n    return !!resource.path && resource.path[0] === '/';\n  }\n  isEqualAuthority(a1, a2) {\n    return a1 === a2 || a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2);\n  }\n  hasTrailingPathSeparator(resource, sep$1 = sep) {\n    if (resource.scheme === Schemas.file) {\n      const fsp = originalFSPath(resource);\n      return fsp.length > getRoot(fsp).length && fsp[fsp.length - 1] === sep$1;\n    } else {\n      const p = resource.path;\n      return p.length > 1 && p.charCodeAt(p.length - 1) === 47 && !/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath);\n    }\n  }\n  removeTrailingPathSeparator(resource, sep$1 = sep) {\n    if (hasTrailingPathSeparator(resource, sep$1)) {\n      return resource.with({\n        path: resource.path.substr(0, resource.path.length - 1)\n      });\n    }\n    return resource;\n  }\n  addTrailingPathSeparator(resource, sep$1 = sep) {\n    let isRootSep = false;\n    if (resource.scheme === Schemas.file) {\n      const fsp = originalFSPath(resource);\n      isRootSep = fsp !== undefined && fsp.length === getRoot(fsp).length && fsp[fsp.length - 1] === sep$1;\n    } else {\n      sep$1 = '/';\n      const p = resource.path;\n      isRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === 47;\n    }\n    if (!isRootSep && !hasTrailingPathSeparator(resource, sep$1)) {\n      return resource.with({\n        path: resource.path + '/'\n      });\n    }\n    return resource;\n  }\n}\nconst extUri = new ExtUri(() => false);\nconst extUriBiasedIgnorePathCase = new ExtUri(uri => {\n  return uri.scheme === Schemas.file ? !isLinux : true;\n});\nconst extUriIgnorePathCase = new ExtUri(_ => true);\nconst isEqual = extUri.isEqual.bind(extUri);\nconst isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nextUri.getComparisonKey.bind(extUri);\nconst basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nconst basename = extUri.basename.bind(extUri);\nconst extname = extUri.extname.bind(extUri);\nconst dirname = extUri.dirname.bind(extUri);\nconst joinPath = extUri.joinPath.bind(extUri);\nconst normalizePath = extUri.normalizePath.bind(extUri);\nconst relativePath = extUri.relativePath.bind(extUri);\nconst resolvePath = extUri.resolvePath.bind(extUri);\nconst isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nconst isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nconst hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nconst removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nconst addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\nfunction distinctParents(items, resourceAccessor) {\n  const distinctParents = [];\n  for (let i = 0; i < items.length; i++) {\n    const candidateResource = resourceAccessor(items[i]);\n    if (items.some((otherItem, index) => {\n      if (index === i) {\n        return false;\n      }\n      return isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n    })) {\n      continue;\n    }\n    distinctParents.push(items[i]);\n  }\n  return distinctParents;\n}\nvar DataUri;\n(function (DataUri) {\n  DataUri.META_DATA_LABEL = 'label';\n  DataUri.META_DATA_DESCRIPTION = 'description';\n  DataUri.META_DATA_SIZE = 'size';\n  DataUri.META_DATA_MIME = 'mime';\n  function parseMetaData(dataUri) {\n    const metadata = new Map();\n    const meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n    meta.split(';').forEach(property => {\n      const [key, value] = property.split(':');\n      if (key && value) {\n        metadata.set(key, value);\n      }\n    });\n    const mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n    if (mime) {\n      metadata.set(DataUri.META_DATA_MIME, mime);\n    }\n    return metadata;\n  }\n  DataUri.parseMetaData = parseMetaData;\n})(DataUri || (DataUri = {}));\nfunction toLocalResource(resource, authority, localScheme) {\n  if (authority) {\n    let path = resource.path;\n    if (path && path[0] !== posix.sep) {\n      path = posix.sep + path;\n    }\n    return resource.with({\n      scheme: localScheme,\n      authority,\n      path\n    });\n  }\n  return resource.with({\n    scheme: localScheme\n  });\n}\nexport { DataUri, ExtUri, addTrailingPathSeparator, basename, basenameOrAuthority, dirname, distinctParents, extUri, extUriBiasedIgnorePathCase, extUriIgnorePathCase, extname, hasTrailingPathSeparator, isAbsolutePath, isEqual, isEqualAuthority, isEqualOrParent, joinPath, normalizePath, originalFSPath, relativePath, removeTrailingPathSeparator, resolvePath, toLocalResource };","map":{"version":3,"names":["isEqualOrParent","isEqualOrParent$1","toSlashes","toPosixPath","getRoot","Schemas","posix","dirname","dirname$1","normalize","relative","resolve","sep","isWindows","isLinux","compare","equalsIgnoreCase","uriToFsPath","URI","originalFSPath","uri","ExtUri","constructor","_ignorePathCasing","uri1","uri2","ignoreFragment","getComparisonKey","isEqual","with","path","toLowerCase","undefined","fragment","toString","ignorePathCasing","base","parentCandidate","scheme","file","query","isEqualAuthority","authority","joinPath","resource","pathFragment","basenameOrAuthority","basename","extname","length","charCodeAt","console","error","normalizePath","normalizedPath","relativePath","from","to","fromPath","toPath","i","len","Math","min","charAt","substr","resolvePath","newURI","isAbsolutePath","a1","a2","hasTrailingPathSeparator","sep$1","fsp","p","test","fsPath","removeTrailingPathSeparator","addTrailingPathSeparator","isRootSep","extUri","extUriBiasedIgnorePathCase","extUriIgnorePathCase","_","bind","distinctParents","items","resourceAccessor","candidateResource","some","otherItem","index","push","DataUri","META_DATA_LABEL","META_DATA_DESCRIPTION","META_DATA_SIZE","META_DATA_MIME","parseMetaData","dataUri","metadata","Map","meta","substring","indexOf","lastIndexOf","split","forEach","property","key","value","set","mime","toLocalResource","localScheme"],"sources":["/Users/phamtu/Downloads/Code/OCE/oce-frontend/node_modules/vscode/vscode/src/vs/base/common/resources.js"],"sourcesContent":["import { isEqualOrParent as isEqualOrParent$1, toSlashes, toPosixPath, getRoot } from './extpath.js';\nimport { Schemas } from './network.js';\nimport { posix, dirname as dirname$1, normalize, relative, resolve, sep } from './path.js';\nimport { isWindows, isLinux } from './platform.js';\nimport { compare, equalsIgnoreCase } from './strings.js';\nimport { uriToFsPath, URI } from './uri.js';\nfunction originalFSPath(uri) {\n    return uriToFsPath(uri, true);\n}\nclass ExtUri {\n    constructor(_ignorePathCasing) {\n        this._ignorePathCasing = _ignorePathCasing;\n    }\n    compare(uri1, uri2, ignoreFragment = false) {\n        if (uri1 === uri2) {\n            return 0;\n        }\n        return compare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n    }\n    isEqual(uri1, uri2, ignoreFragment = false) {\n        if (uri1 === uri2) {\n            return true;\n        }\n        if (!uri1 || !uri2) {\n            return false;\n        }\n        return this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n    }\n    getComparisonKey(uri, ignoreFragment = false) {\n        return ( uri.with({\n            path: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n            fragment: ignoreFragment ? null : undefined\n        }).toString());\n    }\n    ignorePathCasing(uri) {\n        return this._ignorePathCasing(uri);\n    }\n    isEqualOrParent(base, parentCandidate, ignoreFragment = false) {\n        if (base.scheme === parentCandidate.scheme) {\n            if (base.scheme === Schemas.file) {\n                return isEqualOrParent$1(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n            }\n            if (isEqualAuthority(base.authority, parentCandidate.authority)) {\n                return isEqualOrParent$1(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n            }\n        }\n        return false;\n    }\n    joinPath(resource, ...pathFragment) {\n        return URI.joinPath(resource, ...pathFragment);\n    }\n    basenameOrAuthority(resource) {\n        return basename(resource) || resource.authority;\n    }\n    basename(resource) {\n        return posix.basename(resource.path);\n    }\n    extname(resource) {\n        return posix.extname(resource.path);\n    }\n    dirname(resource) {\n        if (resource.path.length === 0) {\n            return resource;\n        }\n        let dirname;\n        if (resource.scheme === Schemas.file) {\n            dirname = URI.file(dirname$1(originalFSPath(resource))).path;\n        }\n        else {\n            dirname = posix.dirname(resource.path);\n            if (resource.authority && dirname.length && dirname.charCodeAt(0) !== 47 ) {\n                console.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n                dirname = '/';\n            }\n        }\n        return resource.with({\n            path: dirname\n        });\n    }\n    normalizePath(resource) {\n        if (!resource.path.length) {\n            return resource;\n        }\n        let normalizedPath;\n        if (resource.scheme === Schemas.file) {\n            normalizedPath = URI.file(normalize(originalFSPath(resource))).path;\n        }\n        else {\n            normalizedPath = posix.normalize(resource.path);\n        }\n        return resource.with({\n            path: normalizedPath\n        });\n    }\n    relativePath(from, to) {\n        if (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n            return undefined;\n        }\n        if (from.scheme === Schemas.file) {\n            const relativePath = relative(originalFSPath(from), originalFSPath(to));\n            return isWindows ? toSlashes(relativePath) : relativePath;\n        }\n        let fromPath = from.path || '/';\n        const toPath = to.path || '/';\n        if (this._ignorePathCasing(from)) {\n            let i = 0;\n            for (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n                if (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n                    if (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n                        break;\n                    }\n                }\n            }\n            fromPath = toPath.substr(0, i) + fromPath.substr(i);\n        }\n        return posix.relative(fromPath, toPath);\n    }\n    resolvePath(base, path) {\n        if (base.scheme === Schemas.file) {\n            const newURI = URI.file(resolve(originalFSPath(base), path));\n            return base.with({\n                authority: newURI.authority,\n                path: newURI.path\n            });\n        }\n        path = toPosixPath(path);\n        return base.with({\n            path: posix.resolve(base.path, path)\n        });\n    }\n    isAbsolutePath(resource) {\n        return !!resource.path && resource.path[0] === '/';\n    }\n    isEqualAuthority(a1, a2) {\n        return a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n    }\n    hasTrailingPathSeparator(resource, sep$1 = sep) {\n        if (resource.scheme === Schemas.file) {\n            const fsp = originalFSPath(resource);\n            return fsp.length > getRoot(fsp).length && fsp[fsp.length - 1] === sep$1;\n        }\n        else {\n            const p = resource.path;\n            return ((p.length > 1 && p.charCodeAt(p.length - 1) === 47) ) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath));\n        }\n    }\n    removeTrailingPathSeparator(resource, sep$1 = sep) {\n        if (hasTrailingPathSeparator(resource, sep$1)) {\n            return resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n        }\n        return resource;\n    }\n    addTrailingPathSeparator(resource, sep$1 = sep) {\n        let isRootSep = false;\n        if (resource.scheme === Schemas.file) {\n            const fsp = originalFSPath(resource);\n            isRootSep = ((fsp !== undefined) && (fsp.length === getRoot(fsp).length) && (fsp[fsp.length - 1] === sep$1));\n        }\n        else {\n            sep$1 = '/';\n            const p = resource.path;\n            isRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === 47 ;\n        }\n        if (!isRootSep && !hasTrailingPathSeparator(resource, sep$1)) {\n            return resource.with({ path: resource.path + '/' });\n        }\n        return resource;\n    }\n}\nconst extUri = ( new ExtUri(() => false));\nconst extUriBiasedIgnorePathCase = ( new ExtUri(uri => {\n    return uri.scheme === Schemas.file ? !isLinux : true;\n}));\nconst extUriIgnorePathCase = ( new ExtUri(_ => true));\nconst isEqual = extUri.isEqual.bind(extUri);\nconst isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nextUri.getComparisonKey.bind(extUri);\nconst basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nconst basename = extUri.basename.bind(extUri);\nconst extname = extUri.extname.bind(extUri);\nconst dirname = extUri.dirname.bind(extUri);\nconst joinPath = extUri.joinPath.bind(extUri);\nconst normalizePath = extUri.normalizePath.bind(extUri);\nconst relativePath = extUri.relativePath.bind(extUri);\nconst resolvePath = extUri.resolvePath.bind(extUri);\nconst isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nconst isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nconst hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nconst removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nconst addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\nfunction distinctParents(items, resourceAccessor) {\n    const distinctParents = [];\n    for (let i = 0; i < items.length; i++) {\n        const candidateResource = resourceAccessor(items[i]);\n        if (( items.some((otherItem, index) => {\n            if (index === i) {\n                return false;\n            }\n            return isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n        }))) {\n            continue;\n        }\n        distinctParents.push(items[i]);\n    }\n    return distinctParents;\n}\nvar DataUri;\n( (function(DataUri) {\n    DataUri.META_DATA_LABEL = 'label';\n    DataUri.META_DATA_DESCRIPTION = 'description';\n    DataUri.META_DATA_SIZE = 'size';\n    DataUri.META_DATA_MIME = 'mime';\n    function parseMetaData(dataUri) {\n        const metadata = ( new Map());\n        const meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n        meta.split(';').forEach(property => {\n            const [key, value] = property.split(':');\n            if (key && value) {\n                metadata.set(key, value);\n            }\n        });\n        const mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n        if (mime) {\n            metadata.set(DataUri.META_DATA_MIME, mime);\n        }\n        return metadata;\n    }\n    DataUri.parseMetaData = parseMetaData;\n})(DataUri || (DataUri = {})));\nfunction toLocalResource(resource, authority, localScheme) {\n    if (authority) {\n        let path = resource.path;\n        if (path && path[0] !== posix.sep) {\n            path = posix.sep + path;\n        }\n        return resource.with({ scheme: localScheme, authority, path });\n    }\n    return resource.with({ scheme: localScheme });\n}\nexport { DataUri, ExtUri, addTrailingPathSeparator, basename, basenameOrAuthority, dirname, distinctParents, extUri, extUriBiasedIgnorePathCase, extUriIgnorePathCase, extname, hasTrailingPathSeparator, isAbsolutePath, isEqual, isEqualAuthority, isEqualOrParent, joinPath, normalizePath, originalFSPath, relativePath, removeTrailingPathSeparator, resolvePath, toLocalResource };\n"],"mappings":"AAAA,SAASA,eAAe,IAAIC,iBAAiB,EAAEC,SAAS,EAAEC,WAAW,EAAEC,OAAO,QAAQ,cAAc;AACpG,SAASC,OAAO,QAAQ,cAAc;AACtC,SAASC,KAAK,EAAEC,OAAO,IAAIC,SAAS,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,OAAO,EAAEC,GAAG,QAAQ,WAAW;AAC1F,SAASC,SAAS,EAAEC,OAAO,QAAQ,eAAe;AAClD,SAASC,OAAO,EAAEC,gBAAgB,QAAQ,cAAc;AACxD,SAASC,WAAW,EAAEC,GAAG,QAAQ,UAAU;AAC3C,SAASC,cAAcA,CAACC,GAAG,EAAE;EACzB,OAAOH,WAAW,CAACG,GAAG,EAAE,IAAI,CAAC;AACjC;AACA,MAAMC,MAAM,CAAC;EACTC,WAAWA,CAACC,iBAAiB,EAAE;IAC3B,IAAI,CAACA,iBAAiB,GAAGA,iBAAiB;EAC9C;EACAR,OAAOA,CAACS,IAAI,EAAEC,IAAI,EAAEC,cAAc,GAAG,KAAK,EAAE;IACxC,IAAIF,IAAI,KAAKC,IAAI,EAAE;MACf,OAAO,CAAC;IACZ;IACA,OAAOV,OAAO,CAAC,IAAI,CAACY,gBAAgB,CAACH,IAAI,EAAEE,cAAc,CAAC,EAAE,IAAI,CAACC,gBAAgB,CAACF,IAAI,EAAEC,cAAc,CAAC,CAAC;EAC5G;EACAE,OAAOA,CAACJ,IAAI,EAAEC,IAAI,EAAEC,cAAc,GAAG,KAAK,EAAE;IACxC,IAAIF,IAAI,KAAKC,IAAI,EAAE;MACf,OAAO,IAAI;IACf;IACA,IAAI,CAACD,IAAI,IAAI,CAACC,IAAI,EAAE;MAChB,OAAO,KAAK;IAChB;IACA,OAAO,IAAI,CAACE,gBAAgB,CAACH,IAAI,EAAEE,cAAc,CAAC,KAAK,IAAI,CAACC,gBAAgB,CAACF,IAAI,EAAEC,cAAc,CAAC;EACtG;EACAC,gBAAgBA,CAACP,GAAG,EAAEM,cAAc,GAAG,KAAK,EAAE;IAC1C,OAASN,GAAG,CAACS,IAAI,CAAC;MACdC,IAAI,EAAE,IAAI,CAACP,iBAAiB,CAACH,GAAG,CAAC,GAAGA,GAAG,CAACU,IAAI,CAACC,WAAW,CAAC,CAAC,GAAGC,SAAS;MACtEC,QAAQ,EAAEP,cAAc,GAAG,IAAI,GAAGM;IACtC,CAAC,CAAC,CAACE,QAAQ,CAAC,CAAC;EACjB;EACAC,gBAAgBA,CAACf,GAAG,EAAE;IAClB,OAAO,IAAI,CAACG,iBAAiB,CAACH,GAAG,CAAC;EACtC;EACApB,eAAeA,CAACoC,IAAI,EAAEC,eAAe,EAAEX,cAAc,GAAG,KAAK,EAAE;IAC3D,IAAIU,IAAI,CAACE,MAAM,KAAKD,eAAe,CAACC,MAAM,EAAE;MACxC,IAAIF,IAAI,CAACE,MAAM,KAAKjC,OAAO,CAACkC,IAAI,EAAE;QAC9B,OAAOtC,iBAAiB,CAACkB,cAAc,CAACiB,IAAI,CAAC,EAAEjB,cAAc,CAACkB,eAAe,CAAC,EAAE,IAAI,CAACd,iBAAiB,CAACa,IAAI,CAAC,CAAC,IAAIA,IAAI,CAACI,KAAK,KAAKH,eAAe,CAACG,KAAK,KAAKd,cAAc,IAAIU,IAAI,CAACH,QAAQ,KAAKI,eAAe,CAACJ,QAAQ,CAAC;MAC3N;MACA,IAAIQ,gBAAgB,CAACL,IAAI,CAACM,SAAS,EAAEL,eAAe,CAACK,SAAS,CAAC,EAAE;QAC7D,OAAOzC,iBAAiB,CAACmC,IAAI,CAACN,IAAI,EAAEO,eAAe,CAACP,IAAI,EAAE,IAAI,CAACP,iBAAiB,CAACa,IAAI,CAAC,EAAE,GAAG,CAAC,IAAIA,IAAI,CAACI,KAAK,KAAKH,eAAe,CAACG,KAAK,KAAKd,cAAc,IAAIU,IAAI,CAACH,QAAQ,KAAKI,eAAe,CAACJ,QAAQ,CAAC;MAC1M;IACJ;IACA,OAAO,KAAK;EAChB;EACAU,QAAQA,CAACC,QAAQ,EAAE,GAAGC,YAAY,EAAE;IAChC,OAAO3B,GAAG,CAACyB,QAAQ,CAACC,QAAQ,EAAE,GAAGC,YAAY,CAAC;EAClD;EACAC,mBAAmBA,CAACF,QAAQ,EAAE;IAC1B,OAAOG,QAAQ,CAACH,QAAQ,CAAC,IAAIA,QAAQ,CAACF,SAAS;EACnD;EACAK,QAAQA,CAACH,QAAQ,EAAE;IACf,OAAOtC,KAAK,CAACyC,QAAQ,CAACH,QAAQ,CAACd,IAAI,CAAC;EACxC;EACAkB,OAAOA,CAACJ,QAAQ,EAAE;IACd,OAAOtC,KAAK,CAAC0C,OAAO,CAACJ,QAAQ,CAACd,IAAI,CAAC;EACvC;EACAvB,OAAOA,CAACqC,QAAQ,EAAE;IACd,IAAIA,QAAQ,CAACd,IAAI,CAACmB,MAAM,KAAK,CAAC,EAAE;MAC5B,OAAOL,QAAQ;IACnB;IACA,IAAIrC,OAAO;IACX,IAAIqC,QAAQ,CAACN,MAAM,KAAKjC,OAAO,CAACkC,IAAI,EAAE;MAClChC,OAAO,GAAGW,GAAG,CAACqB,IAAI,CAAC/B,SAAS,CAACW,cAAc,CAACyB,QAAQ,CAAC,CAAC,CAAC,CAACd,IAAI;IAChE,CAAC,MACI;MACDvB,OAAO,GAAGD,KAAK,CAACC,OAAO,CAACqC,QAAQ,CAACd,IAAI,CAAC;MACtC,IAAIc,QAAQ,CAACF,SAAS,IAAInC,OAAO,CAAC0C,MAAM,IAAI1C,OAAO,CAAC2C,UAAU,CAAC,CAAC,CAAC,KAAK,EAAE,EAAG;QACvEC,OAAO,CAACC,KAAK,CAAE,YAAWR,QAAQ,CAACV,QAAS,gCAA+B,CAAC;QAC5E3B,OAAO,GAAG,GAAG;MACjB;IACJ;IACA,OAAOqC,QAAQ,CAACf,IAAI,CAAC;MACjBC,IAAI,EAAEvB;IACV,CAAC,CAAC;EACN;EACA8C,aAAaA,CAACT,QAAQ,EAAE;IACpB,IAAI,CAACA,QAAQ,CAACd,IAAI,CAACmB,MAAM,EAAE;MACvB,OAAOL,QAAQ;IACnB;IACA,IAAIU,cAAc;IAClB,IAAIV,QAAQ,CAACN,MAAM,KAAKjC,OAAO,CAACkC,IAAI,EAAE;MAClCe,cAAc,GAAGpC,GAAG,CAACqB,IAAI,CAAC9B,SAAS,CAACU,cAAc,CAACyB,QAAQ,CAAC,CAAC,CAAC,CAACd,IAAI;IACvE,CAAC,MACI;MACDwB,cAAc,GAAGhD,KAAK,CAACG,SAAS,CAACmC,QAAQ,CAACd,IAAI,CAAC;IACnD;IACA,OAAOc,QAAQ,CAACf,IAAI,CAAC;MACjBC,IAAI,EAAEwB;IACV,CAAC,CAAC;EACN;EACAC,YAAYA,CAACC,IAAI,EAAEC,EAAE,EAAE;IACnB,IAAID,IAAI,CAAClB,MAAM,KAAKmB,EAAE,CAACnB,MAAM,IAAI,CAACG,gBAAgB,CAACe,IAAI,CAACd,SAAS,EAAEe,EAAE,CAACf,SAAS,CAAC,EAAE;MAC9E,OAAOV,SAAS;IACpB;IACA,IAAIwB,IAAI,CAAClB,MAAM,KAAKjC,OAAO,CAACkC,IAAI,EAAE;MAC9B,MAAMgB,YAAY,GAAG7C,QAAQ,CAACS,cAAc,CAACqC,IAAI,CAAC,EAAErC,cAAc,CAACsC,EAAE,CAAC,CAAC;MACvE,OAAO5C,SAAS,GAAGX,SAAS,CAACqD,YAAY,CAAC,GAAGA,YAAY;IAC7D;IACA,IAAIG,QAAQ,GAAGF,IAAI,CAAC1B,IAAI,IAAI,GAAG;IAC/B,MAAM6B,MAAM,GAAGF,EAAE,CAAC3B,IAAI,IAAI,GAAG;IAC7B,IAAI,IAAI,CAACP,iBAAiB,CAACiC,IAAI,CAAC,EAAE;MAC9B,IAAII,CAAC,GAAG,CAAC;MACT,KAAK,MAAMC,GAAG,GAAGC,IAAI,CAACC,GAAG,CAACL,QAAQ,CAACT,MAAM,EAAEU,MAAM,CAACV,MAAM,CAAC,EAAEW,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QACrE,IAAIF,QAAQ,CAACR,UAAU,CAACU,CAAC,CAAC,KAAKD,MAAM,CAACT,UAAU,CAACU,CAAC,CAAC,EAAE;UACjD,IAAIF,QAAQ,CAACM,MAAM,CAACJ,CAAC,CAAC,CAAC7B,WAAW,CAAC,CAAC,KAAK4B,MAAM,CAACK,MAAM,CAACJ,CAAC,CAAC,CAAC7B,WAAW,CAAC,CAAC,EAAE;YACrE;UACJ;QACJ;MACJ;MACA2B,QAAQ,GAAGC,MAAM,CAACM,MAAM,CAAC,CAAC,EAAEL,CAAC,CAAC,GAAGF,QAAQ,CAACO,MAAM,CAACL,CAAC,CAAC;IACvD;IACA,OAAOtD,KAAK,CAACI,QAAQ,CAACgD,QAAQ,EAAEC,MAAM,CAAC;EAC3C;EACAO,WAAWA,CAAC9B,IAAI,EAAEN,IAAI,EAAE;IACpB,IAAIM,IAAI,CAACE,MAAM,KAAKjC,OAAO,CAACkC,IAAI,EAAE;MAC9B,MAAM4B,MAAM,GAAGjD,GAAG,CAACqB,IAAI,CAAC5B,OAAO,CAACQ,cAAc,CAACiB,IAAI,CAAC,EAAEN,IAAI,CAAC,CAAC;MAC5D,OAAOM,IAAI,CAACP,IAAI,CAAC;QACba,SAAS,EAAEyB,MAAM,CAACzB,SAAS;QAC3BZ,IAAI,EAAEqC,MAAM,CAACrC;MACjB,CAAC,CAAC;IACN;IACAA,IAAI,GAAG3B,WAAW,CAAC2B,IAAI,CAAC;IACxB,OAAOM,IAAI,CAACP,IAAI,CAAC;MACbC,IAAI,EAAExB,KAAK,CAACK,OAAO,CAACyB,IAAI,CAACN,IAAI,EAAEA,IAAI;IACvC,CAAC,CAAC;EACN;EACAsC,cAAcA,CAACxB,QAAQ,EAAE;IACrB,OAAO,CAAC,CAACA,QAAQ,CAACd,IAAI,IAAIc,QAAQ,CAACd,IAAI,CAAC,CAAC,CAAC,KAAK,GAAG;EACtD;EACAW,gBAAgBA,CAAC4B,EAAE,EAAEC,EAAE,EAAE;IACrB,OAAOD,EAAE,KAAKC,EAAE,IAAKD,EAAE,KAAKrC,SAAS,IAAIsC,EAAE,KAAKtC,SAAS,IAAIhB,gBAAgB,CAACqD,EAAE,EAAEC,EAAE,CAAE;EAC1F;EACAC,wBAAwBA,CAAC3B,QAAQ,EAAE4B,KAAK,GAAG5D,GAAG,EAAE;IAC5C,IAAIgC,QAAQ,CAACN,MAAM,KAAKjC,OAAO,CAACkC,IAAI,EAAE;MAClC,MAAMkC,GAAG,GAAGtD,cAAc,CAACyB,QAAQ,CAAC;MACpC,OAAO6B,GAAG,CAACxB,MAAM,GAAG7C,OAAO,CAACqE,GAAG,CAAC,CAACxB,MAAM,IAAIwB,GAAG,CAACA,GAAG,CAACxB,MAAM,GAAG,CAAC,CAAC,KAAKuB,KAAK;IAC5E,CAAC,MACI;MACD,MAAME,CAAC,GAAG9B,QAAQ,CAACd,IAAI;MACvB,OAAS4C,CAAC,CAACzB,MAAM,GAAG,CAAC,IAAIyB,CAAC,CAACxB,UAAU,CAACwB,CAAC,CAACzB,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE,IAAO,CAAE,qBAAqB,CAAC0B,IAAI,CAAC/B,QAAQ,CAACgC,MAAM,CAAE;IACnH;EACJ;EACAC,2BAA2BA,CAACjC,QAAQ,EAAE4B,KAAK,GAAG5D,GAAG,EAAE;IAC/C,IAAI2D,wBAAwB,CAAC3B,QAAQ,EAAE4B,KAAK,CAAC,EAAE;MAC3C,OAAO5B,QAAQ,CAACf,IAAI,CAAC;QAAEC,IAAI,EAAEc,QAAQ,CAACd,IAAI,CAACmC,MAAM,CAAC,CAAC,EAAErB,QAAQ,CAACd,IAAI,CAACmB,MAAM,GAAG,CAAC;MAAE,CAAC,CAAC;IACrF;IACA,OAAOL,QAAQ;EACnB;EACAkC,wBAAwBA,CAAClC,QAAQ,EAAE4B,KAAK,GAAG5D,GAAG,EAAE;IAC5C,IAAImE,SAAS,GAAG,KAAK;IACrB,IAAInC,QAAQ,CAACN,MAAM,KAAKjC,OAAO,CAACkC,IAAI,EAAE;MAClC,MAAMkC,GAAG,GAAGtD,cAAc,CAACyB,QAAQ,CAAC;MACpCmC,SAAS,GAAKN,GAAG,KAAKzC,SAAS,IAAMyC,GAAG,CAACxB,MAAM,KAAK7C,OAAO,CAACqE,GAAG,CAAC,CAACxB,MAAO,IAAKwB,GAAG,CAACA,GAAG,CAACxB,MAAM,GAAG,CAAC,CAAC,KAAKuB,KAAO;IAChH,CAAC,MACI;MACDA,KAAK,GAAG,GAAG;MACX,MAAME,CAAC,GAAG9B,QAAQ,CAACd,IAAI;MACvBiD,SAAS,GAAGL,CAAC,CAACzB,MAAM,KAAK,CAAC,IAAIyB,CAAC,CAACxB,UAAU,CAACwB,CAAC,CAACzB,MAAM,GAAG,CAAC,CAAC,KAAK,EAAE;IACnE;IACA,IAAI,CAAC8B,SAAS,IAAI,CAACR,wBAAwB,CAAC3B,QAAQ,EAAE4B,KAAK,CAAC,EAAE;MAC1D,OAAO5B,QAAQ,CAACf,IAAI,CAAC;QAAEC,IAAI,EAAEc,QAAQ,CAACd,IAAI,GAAG;MAAI,CAAC,CAAC;IACvD;IACA,OAAOc,QAAQ;EACnB;AACJ;AACA,MAAMoC,MAAM,GAAK,IAAI3D,MAAM,CAAC,MAAM,KAAK,CAAE;AACzC,MAAM4D,0BAA0B,GAAK,IAAI5D,MAAM,CAACD,GAAG,IAAI;EACnD,OAAOA,GAAG,CAACkB,MAAM,KAAKjC,OAAO,CAACkC,IAAI,GAAG,CAACzB,OAAO,GAAG,IAAI;AACxD,CAAC,CAAE;AACH,MAAMoE,oBAAoB,GAAK,IAAI7D,MAAM,CAAC8D,CAAC,IAAI,IAAI,CAAE;AACrD,MAAMvD,OAAO,GAAGoD,MAAM,CAACpD,OAAO,CAACwD,IAAI,CAACJ,MAAM,CAAC;AAC3C,MAAMhF,eAAe,GAAGgF,MAAM,CAAChF,eAAe,CAACoF,IAAI,CAACJ,MAAM,CAAC;AAC3DA,MAAM,CAACrD,gBAAgB,CAACyD,IAAI,CAACJ,MAAM,CAAC;AACpC,MAAMlC,mBAAmB,GAAGkC,MAAM,CAAClC,mBAAmB,CAACsC,IAAI,CAACJ,MAAM,CAAC;AACnE,MAAMjC,QAAQ,GAAGiC,MAAM,CAACjC,QAAQ,CAACqC,IAAI,CAACJ,MAAM,CAAC;AAC7C,MAAMhC,OAAO,GAAGgC,MAAM,CAAChC,OAAO,CAACoC,IAAI,CAACJ,MAAM,CAAC;AAC3C,MAAMzE,OAAO,GAAGyE,MAAM,CAACzE,OAAO,CAAC6E,IAAI,CAACJ,MAAM,CAAC;AAC3C,MAAMrC,QAAQ,GAAGqC,MAAM,CAACrC,QAAQ,CAACyC,IAAI,CAACJ,MAAM,CAAC;AAC7C,MAAM3B,aAAa,GAAG2B,MAAM,CAAC3B,aAAa,CAAC+B,IAAI,CAACJ,MAAM,CAAC;AACvD,MAAMzB,YAAY,GAAGyB,MAAM,CAACzB,YAAY,CAAC6B,IAAI,CAACJ,MAAM,CAAC;AACrD,MAAMd,WAAW,GAAGc,MAAM,CAACd,WAAW,CAACkB,IAAI,CAACJ,MAAM,CAAC;AACnD,MAAMZ,cAAc,GAAGY,MAAM,CAACZ,cAAc,CAACgB,IAAI,CAACJ,MAAM,CAAC;AACzD,MAAMvC,gBAAgB,GAAGuC,MAAM,CAACvC,gBAAgB,CAAC2C,IAAI,CAACJ,MAAM,CAAC;AAC7D,MAAMT,wBAAwB,GAAGS,MAAM,CAACT,wBAAwB,CAACa,IAAI,CAACJ,MAAM,CAAC;AAC7E,MAAMH,2BAA2B,GAAGG,MAAM,CAACH,2BAA2B,CAACO,IAAI,CAACJ,MAAM,CAAC;AACnF,MAAMF,wBAAwB,GAAGE,MAAM,CAACF,wBAAwB,CAACM,IAAI,CAACJ,MAAM,CAAC;AAC7E,SAASK,eAAeA,CAACC,KAAK,EAAEC,gBAAgB,EAAE;EAC9C,MAAMF,eAAe,GAAG,EAAE;EAC1B,KAAK,IAAIzB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0B,KAAK,CAACrC,MAAM,EAAEW,CAAC,EAAE,EAAE;IACnC,MAAM4B,iBAAiB,GAAGD,gBAAgB,CAACD,KAAK,CAAC1B,CAAC,CAAC,CAAC;IACpD,IAAM0B,KAAK,CAACG,IAAI,CAAC,CAACC,SAAS,EAAEC,KAAK,KAAK;MACnC,IAAIA,KAAK,KAAK/B,CAAC,EAAE;QACb,OAAO,KAAK;MAChB;MACA,OAAO5D,eAAe,CAACwF,iBAAiB,EAAED,gBAAgB,CAACG,SAAS,CAAC,CAAC;IAC1E,CAAC,CAAC,EAAG;MACD;IACJ;IACAL,eAAe,CAACO,IAAI,CAACN,KAAK,CAAC1B,CAAC,CAAC,CAAC;EAClC;EACA,OAAOyB,eAAe;AAC1B;AACA,IAAIQ,OAAO;AACT,CAAC,UAASA,OAAO,EAAE;EACjBA,OAAO,CAACC,eAAe,GAAG,OAAO;EACjCD,OAAO,CAACE,qBAAqB,GAAG,aAAa;EAC7CF,OAAO,CAACG,cAAc,GAAG,MAAM;EAC/BH,OAAO,CAACI,cAAc,GAAG,MAAM;EAC/B,SAASC,aAAaA,CAACC,OAAO,EAAE;IAC5B,MAAMC,QAAQ,GAAK,IAAIC,GAAG,CAAC,CAAE;IAC7B,MAAMC,IAAI,GAAGH,OAAO,CAACrE,IAAI,CAACyE,SAAS,CAACJ,OAAO,CAACrE,IAAI,CAAC0E,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,EAAEL,OAAO,CAACrE,IAAI,CAAC2E,WAAW,CAAC,GAAG,CAAC,CAAC;IACjGH,IAAI,CAACI,KAAK,CAAC,GAAG,CAAC,CAACC,OAAO,CAACC,QAAQ,IAAI;MAChC,MAAM,CAACC,GAAG,EAAEC,KAAK,CAAC,GAAGF,QAAQ,CAACF,KAAK,CAAC,GAAG,CAAC;MACxC,IAAIG,GAAG,IAAIC,KAAK,EAAE;QACdV,QAAQ,CAACW,GAAG,CAACF,GAAG,EAAEC,KAAK,CAAC;MAC5B;IACJ,CAAC,CAAC;IACF,MAAME,IAAI,GAAGb,OAAO,CAACrE,IAAI,CAACyE,SAAS,CAAC,CAAC,EAAEJ,OAAO,CAACrE,IAAI,CAAC0E,OAAO,CAAC,GAAG,CAAC,CAAC;IACjE,IAAIQ,IAAI,EAAE;MACNZ,QAAQ,CAACW,GAAG,CAAClB,OAAO,CAACI,cAAc,EAAEe,IAAI,CAAC;IAC9C;IACA,OAAOZ,QAAQ;EACnB;EACAP,OAAO,CAACK,aAAa,GAAGA,aAAa;AACzC,CAAC,EAAEL,OAAO,KAAKA,OAAO,GAAG,CAAC,CAAC,CAAC,CAAC;AAC7B,SAASoB,eAAeA,CAACrE,QAAQ,EAAEF,SAAS,EAAEwE,WAAW,EAAE;EACvD,IAAIxE,SAAS,EAAE;IACX,IAAIZ,IAAI,GAAGc,QAAQ,CAACd,IAAI;IACxB,IAAIA,IAAI,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAKxB,KAAK,CAACM,GAAG,EAAE;MAC/BkB,IAAI,GAAGxB,KAAK,CAACM,GAAG,GAAGkB,IAAI;IAC3B;IACA,OAAOc,QAAQ,CAACf,IAAI,CAAC;MAAES,MAAM,EAAE4E,WAAW;MAAExE,SAAS;MAAEZ;IAAK,CAAC,CAAC;EAClE;EACA,OAAOc,QAAQ,CAACf,IAAI,CAAC;IAAES,MAAM,EAAE4E;EAAY,CAAC,CAAC;AACjD;AACA,SAASrB,OAAO,EAAExE,MAAM,EAAEyD,wBAAwB,EAAE/B,QAAQ,EAAED,mBAAmB,EAAEvC,OAAO,EAAE8E,eAAe,EAAEL,MAAM,EAAEC,0BAA0B,EAAEC,oBAAoB,EAAElC,OAAO,EAAEuB,wBAAwB,EAAEH,cAAc,EAAExC,OAAO,EAAEa,gBAAgB,EAAEzC,eAAe,EAAE2C,QAAQ,EAAEU,aAAa,EAAElC,cAAc,EAAEoC,YAAY,EAAEsB,2BAA2B,EAAEX,WAAW,EAAE+C,eAAe","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}