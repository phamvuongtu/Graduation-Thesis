{"ast":null,"code":"import './arrays.js';\nimport { isThenable } from './async.js';\nimport { isEqualOrParent } from './extpath.js';\nimport { LRUCache } from './map.js';\nimport { sep, basename, extname, posix } from './path.js';\nimport { isLinux } from './platform.js';\nimport { escapeRegExpCharacters, ltrim } from './strings.js';\nfunction getEmptyExpression() {\n  return Object.create(null);\n}\nconst GLOBSTAR = '**';\nconst GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]';\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\nconst ALL_FORWARD_SLASHES = /\\//g;\nfunction starsToRegExp(starCount, isLastPattern) {\n  switch (starCount) {\n    case 0:\n      return '';\n    case 1:\n      return `${NO_PATH_REGEX}*?`;\n    default:\n      return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n  }\n}\nfunction splitGlobAware(pattern, splitChar) {\n  if (!pattern) {\n    return [];\n  }\n  const segments = [];\n  let inBraces = false;\n  let inBrackets = false;\n  let curVal = '';\n  for (const char of pattern) {\n    switch (char) {\n      case splitChar:\n        if (!inBraces && !inBrackets) {\n          segments.push(curVal);\n          curVal = '';\n          continue;\n        }\n        break;\n      case '{':\n        inBraces = true;\n        break;\n      case '}':\n        inBraces = false;\n        break;\n      case '[':\n        inBrackets = true;\n        break;\n      case ']':\n        inBrackets = false;\n        break;\n    }\n    curVal += char;\n  }\n  if (curVal) {\n    segments.push(curVal);\n  }\n  return segments;\n}\nfunction parseRegExp(pattern) {\n  if (!pattern) {\n    return '';\n  }\n  let regEx = '';\n  const segments = splitGlobAware(pattern, GLOB_SPLIT);\n  if (segments.every(segment => segment === GLOBSTAR)) {\n    regEx = '.*';\n  } else {\n    let previousSegmentWasGlobStar = false;\n    segments.forEach((segment, index) => {\n      if (segment === GLOBSTAR) {\n        if (previousSegmentWasGlobStar) {\n          return;\n        }\n        regEx += starsToRegExp(2, index === segments.length - 1);\n      } else {\n        let inBraces = false;\n        let braceVal = '';\n        let inBrackets = false;\n        let bracketVal = '';\n        for (const char of segment) {\n          if (char !== '}' && inBraces) {\n            braceVal += char;\n            continue;\n          }\n          if (inBrackets && (char !== ']' || !bracketVal)) {\n            let res;\n            if (char === '-') {\n              res = char;\n            } else if ((char === '^' || char === '!') && !bracketVal) {\n              res = '^';\n            } else if (char === GLOB_SPLIT) {\n              res = '';\n            } else {\n              res = escapeRegExpCharacters(char);\n            }\n            bracketVal += res;\n            continue;\n          }\n          switch (char) {\n            case '{':\n              inBraces = true;\n              continue;\n            case '[':\n              inBrackets = true;\n              continue;\n            case '}':\n              {\n                const choices = splitGlobAware(braceVal, ',');\n                const braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n                regEx += braceRegExp;\n                inBraces = false;\n                braceVal = '';\n                break;\n              }\n            case ']':\n              {\n                regEx += '[' + bracketVal + ']';\n                inBrackets = false;\n                bracketVal = '';\n                break;\n              }\n            case '?':\n              regEx += NO_PATH_REGEX;\n              continue;\n            case '*':\n              regEx += starsToRegExp(1);\n              continue;\n            default:\n              regEx += escapeRegExpCharacters(char);\n          }\n        }\n        if (index < segments.length - 1 && (segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)) {\n          regEx += PATH_REGEX;\n        }\n      }\n      previousSegmentWasGlobStar = segment === GLOBSTAR;\n    });\n  }\n  return regEx;\n}\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/;\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/;\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/;\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/;\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/;\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/;\nconst CACHE = new LRUCache(10000);\nconst FALSE = function () {\n  return false;\n};\nconst NULL = function () {\n  return null;\n};\nfunction parsePattern(arg1, options) {\n  if (!arg1) {\n    return NULL;\n  }\n  let pattern;\n  if (typeof arg1 !== 'string') {\n    pattern = arg1.pattern;\n  } else {\n    pattern = arg1;\n  }\n  pattern = pattern.trim();\n  const patternKey = `${pattern}_${!!options.trimForExclusions}`;\n  let parsedPattern = CACHE.get(patternKey);\n  if (parsedPattern) {\n    return wrapRelativePattern(parsedPattern, arg1);\n  }\n  let match;\n  if (T1.test(pattern)) {\n    parsedPattern = trivia1(pattern.substr(4), pattern);\n  } else if (match = T2.exec(trimForExclusions(pattern, options))) {\n    parsedPattern = trivia2(match[1], pattern);\n  } else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) {\n    parsedPattern = trivia3(pattern, options);\n  } else if (match = T4.exec(trimForExclusions(pattern, options))) {\n    parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n  } else if (match = T5.exec(trimForExclusions(pattern, options))) {\n    parsedPattern = trivia4and5(match[1], pattern, false);\n  } else {\n    parsedPattern = toRegExp(pattern);\n  }\n  CACHE.set(patternKey, parsedPattern);\n  return wrapRelativePattern(parsedPattern, arg1);\n}\nfunction wrapRelativePattern(parsedPattern, arg2) {\n  if (typeof arg2 === 'string') {\n    return parsedPattern;\n  }\n  const wrappedPattern = function (path, basename) {\n    if (!isEqualOrParent(path, arg2.base, !isLinux)) {\n      return null;\n    }\n    return parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename);\n  };\n  wrappedPattern.allBasenames = parsedPattern.allBasenames;\n  wrappedPattern.allPaths = parsedPattern.allPaths;\n  wrappedPattern.basenames = parsedPattern.basenames;\n  wrappedPattern.patterns = parsedPattern.patterns;\n  return wrappedPattern;\n}\nfunction trimForExclusions(pattern, options) {\n  return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern;\n}\nfunction trivia1(base, pattern) {\n  return function (path, basename) {\n    return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n  };\n}\nfunction trivia2(base, pattern) {\n  const slashBase = `/${base}`;\n  const backslashBase = `\\\\${base}`;\n  const parsedPattern = function (path, basename) {\n    if (typeof path !== 'string') {\n      return null;\n    }\n    if (basename) {\n      return basename === base ? pattern : null;\n    }\n    return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n  };\n  const basenames = [base];\n  parsedPattern.basenames = basenames;\n  parsedPattern.patterns = [pattern];\n  parsedPattern.allBasenames = basenames;\n  return parsedPattern;\n}\nfunction trivia3(pattern, options) {\n  const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1).split(',').map(pattern => parsePattern(pattern, options)).filter(pattern => pattern !== NULL), pattern);\n  const patternsLength = parsedPatterns.length;\n  if (!patternsLength) {\n    return NULL;\n  }\n  if (patternsLength === 1) {\n    return parsedPatterns[0];\n  }\n  const parsedPattern = function (path, basename) {\n    for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n      if (parsedPatterns[i](path, basename)) {\n        return pattern;\n      }\n    }\n    return null;\n  };\n  const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n  if (withBasenames) {\n    parsedPattern.allBasenames = withBasenames.allBasenames;\n  }\n  const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n  if (allPaths.length) {\n    parsedPattern.allPaths = allPaths;\n  }\n  return parsedPattern;\n}\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n  const usingPosixSep = sep === posix.sep;\n  const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n  const nativePathEnd = sep + nativePath;\n  const targetPathEnd = posix.sep + targetPath;\n  let parsedPattern;\n  if (matchPathEnds) {\n    parsedPattern = function (path, basename) {\n      return typeof path === 'string' && (path === nativePath || path.endsWith(nativePathEnd) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n    };\n  } else {\n    parsedPattern = function (path, basename) {\n      return typeof path === 'string' && (path === nativePath || !usingPosixSep && path === targetPath) ? pattern : null;\n    };\n  }\n  parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n  return parsedPattern;\n}\nfunction toRegExp(pattern) {\n  try {\n    const regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n    return function (path) {\n      regExp.lastIndex = 0;\n      return typeof path === 'string' && regExp.test(path) ? pattern : null;\n    };\n  } catch (error) {\n    return NULL;\n  }\n}\nfunction match(arg1, path, hasSibling) {\n  if (!arg1 || typeof path !== 'string') {\n    return false;\n  }\n  return parse(arg1)(path, undefined, hasSibling);\n}\nfunction parse(arg1, options = {}) {\n  if (!arg1) {\n    return FALSE;\n  }\n  if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n    const parsedPattern = parsePattern(arg1, options);\n    if (parsedPattern === NULL) {\n      return FALSE;\n    }\n    const resultPattern = function (path, basename) {\n      return !!parsedPattern(path, basename);\n    };\n    if (parsedPattern.allBasenames) {\n      resultPattern.allBasenames = parsedPattern.allBasenames;\n    }\n    if (parsedPattern.allPaths) {\n      resultPattern.allPaths = parsedPattern.allPaths;\n    }\n    return resultPattern;\n  }\n  return parsedExpression(arg1, options);\n}\nfunction isRelativePattern(obj) {\n  const rp = obj;\n  if (!rp) {\n    return false;\n  }\n  return typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\nfunction parsedExpression(expression, options) {\n  const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression).map(pattern => parseExpressionPattern(pattern, expression[pattern], options)).filter(pattern => pattern !== NULL));\n  const patternsLength = parsedPatterns.length;\n  if (!patternsLength) {\n    return NULL;\n  }\n  if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {\n    if (patternsLength === 1) {\n      return parsedPatterns[0];\n    }\n    const resultExpression = function (path, basename) {\n      let resultPromises = undefined;\n      for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n        const result = parsedPatterns[i](path, basename);\n        if (typeof result === 'string') {\n          return result;\n        }\n        if (isThenable(result)) {\n          if (!resultPromises) {\n            resultPromises = [];\n          }\n          resultPromises.push(result);\n        }\n      }\n      if (resultPromises) {\n        return (async () => {\n          for (const resultPromise of resultPromises) {\n            const result = await resultPromise;\n            if (typeof result === 'string') {\n              return result;\n            }\n          }\n          return null;\n        })();\n      }\n      return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n      resultExpression.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n      resultExpression.allPaths = allPaths;\n    }\n    return resultExpression;\n  }\n  const resultExpression = function (path, base, hasSibling) {\n    let name = undefined;\n    let resultPromises = undefined;\n    for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n      const parsedPattern = parsedPatterns[i];\n      if (parsedPattern.requiresSiblings && hasSibling) {\n        if (!base) {\n          base = basename(path);\n        }\n        if (!name) {\n          name = base.substr(0, base.length - extname(path).length);\n        }\n      }\n      const result = parsedPattern(path, base, name, hasSibling);\n      if (typeof result === 'string') {\n        return result;\n      }\n      if (isThenable(result)) {\n        if (!resultPromises) {\n          resultPromises = [];\n        }\n        resultPromises.push(result);\n      }\n    }\n    if (resultPromises) {\n      return (async () => {\n        for (const resultPromise of resultPromises) {\n          const result = await resultPromise;\n          if (typeof result === 'string') {\n            return result;\n          }\n        }\n        return null;\n      })();\n    }\n    return null;\n  };\n  const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n  if (withBasenames) {\n    resultExpression.allBasenames = withBasenames.allBasenames;\n  }\n  const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n  if (allPaths.length) {\n    resultExpression.allPaths = allPaths;\n  }\n  return resultExpression;\n}\nfunction parseExpressionPattern(pattern, value, options) {\n  if (value === false) {\n    return NULL;\n  }\n  const parsedPattern = parsePattern(pattern, options);\n  if (parsedPattern === NULL) {\n    return NULL;\n  }\n  if (typeof value === 'boolean') {\n    return parsedPattern;\n  }\n  if (value) {\n    const when = value.when;\n    if (typeof when === 'string') {\n      const result = (path, basename, name, hasSibling) => {\n        if (!hasSibling || !parsedPattern(path, basename)) {\n          return null;\n        }\n        const clausePattern = when.replace('$(basename)', () => name);\n        const matched = hasSibling(clausePattern);\n        return isThenable(matched) ? matched.then(match => match ? pattern : null) : matched ? pattern : null;\n      };\n      result.requiresSiblings = true;\n      return result;\n    }\n  }\n  return parsedPattern;\n}\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n  const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\n  if (basenamePatterns.length < 2) {\n    return parsedPatterns;\n  }\n  const basenames = basenamePatterns.reduce((all, current) => {\n    const basenames = current.basenames;\n    return basenames ? all.concat(basenames) : all;\n  }, []);\n  let patterns;\n  if (result) {\n    patterns = [];\n    for (let i = 0, n = basenames.length; i < n; i++) {\n      patterns.push(result);\n    }\n  } else {\n    patterns = basenamePatterns.reduce((all, current) => {\n      const patterns = current.patterns;\n      return patterns ? all.concat(patterns) : all;\n    }, []);\n  }\n  const aggregate = function (path, basename) {\n    if (typeof path !== 'string') {\n      return null;\n    }\n    if (!basename) {\n      let i;\n      for (i = path.length; i > 0; i--) {\n        const ch = path.charCodeAt(i - 1);\n        if (ch === 47 || ch === 92) {\n          break;\n        }\n      }\n      basename = path.substr(i);\n    }\n    const index = basenames.indexOf(basename);\n    return index !== -1 ? patterns[index] : null;\n  };\n  aggregate.basenames = basenames;\n  aggregate.patterns = patterns;\n  aggregate.allBasenames = basenames;\n  const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\n  aggregatedPatterns.push(aggregate);\n  return aggregatedPatterns;\n}\nexport { GLOBSTAR, GLOB_SPLIT, getEmptyExpression, isRelativePattern, match, parse, splitGlobAware };","map":{"version":3,"names":["isThenable","isEqualOrParent","LRUCache","sep","basename","extname","posix","isLinux","escapeRegExpCharacters","ltrim","getEmptyExpression","Object","create","GLOBSTAR","GLOB_SPLIT","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","isLastPattern","splitGlobAware","pattern","splitChar","segments","inBraces","inBrackets","curVal","char","push","parseRegExp","regEx","every","segment","previousSegmentWasGlobStar","forEach","index","length","braceVal","bracketVal","res","choices","braceRegExp","map","choice","join","T1","T2","T3","T3_2","T4","T5","CACHE","FALSE","NULL","parsePattern","arg1","options","trim","patternKey","trimForExclusions","parsedPattern","get","wrapRelativePattern","match","test","trivia1","substr","exec","trivia2","trivia3","trivia4and5","toRegExp","set","arg2","wrappedPattern","path","base","allBasenames","allPaths","basenames","patterns","endsWith","slashBase","backslashBase","parsedPatterns","aggregateBasenameMatches","slice","split","filter","patternsLength","i","n","withBasenames","find","reduce","all","current","concat","targetPath","matchPathEnds","usingPosixSep","nativePath","replace","nativePathEnd","targetPathEnd","regExp","RegExp","lastIndex","error","hasSibling","parse","undefined","isRelativePattern","resultPattern","parsedExpression","obj","rp","expression","getOwnPropertyNames","parseExpressionPattern","some","requiresSiblings","resultExpression","resultPromises","result","resultPromise","name","value","when","clausePattern","matched","then","basenamePatterns","aggregate","ch","charCodeAt","indexOf","aggregatedPatterns"],"sources":["/Users/phamtu/Downloads/Code/OCE/oce-frontend/node_modules/vscode/vscode/src/vs/base/common/glob.js"],"sourcesContent":["import './arrays.js';\nimport { isThenable } from './async.js';\nimport { isEqualOrParent } from './extpath.js';\nimport { LRUCache } from './map.js';\nimport { sep, basename, extname, posix } from './path.js';\nimport { isLinux } from './platform.js';\nimport { escapeRegExpCharacters, ltrim } from './strings.js';\nfunction getEmptyExpression() {\n    return Object.create(null);\n}\nconst GLOBSTAR = '**';\nconst GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]';\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\nconst ALL_FORWARD_SLASHES = /\\//g;\nfunction starsToRegExp(starCount, isLastPattern) {\n    switch (starCount) {\n        case 0:\n            return '';\n        case 1:\n            return `${NO_PATH_REGEX}*?`;\n        default:\n            return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n    }\n}\nfunction splitGlobAware(pattern, splitChar) {\n    if (!pattern) {\n        return [];\n    }\n    const segments = [];\n    let inBraces = false;\n    let inBrackets = false;\n    let curVal = '';\n    for (const char of pattern) {\n        switch (char) {\n            case splitChar:\n                if (!inBraces && !inBrackets) {\n                    segments.push(curVal);\n                    curVal = '';\n                    continue;\n                }\n                break;\n            case '{':\n                inBraces = true;\n                break;\n            case '}':\n                inBraces = false;\n                break;\n            case '[':\n                inBrackets = true;\n                break;\n            case ']':\n                inBrackets = false;\n                break;\n        }\n        curVal += char;\n    }\n    if (curVal) {\n        segments.push(curVal);\n    }\n    return segments;\n}\nfunction parseRegExp(pattern) {\n    if (!pattern) {\n        return '';\n    }\n    let regEx = '';\n    const segments = splitGlobAware(pattern, GLOB_SPLIT);\n    if (segments.every(segment => segment === GLOBSTAR)) {\n        regEx = '.*';\n    }\n    else {\n        let previousSegmentWasGlobStar = false;\n        segments.forEach((segment, index) => {\n            if (segment === GLOBSTAR) {\n                if (previousSegmentWasGlobStar) {\n                    return;\n                }\n                regEx += starsToRegExp(2, index === segments.length - 1);\n            }\n            else {\n                let inBraces = false;\n                let braceVal = '';\n                let inBrackets = false;\n                let bracketVal = '';\n                for (const char of segment) {\n                    if (char !== '}' && inBraces) {\n                        braceVal += char;\n                        continue;\n                    }\n                    if (inBrackets && (char !== ']' || !bracketVal) ) {\n                        let res;\n                        if (char === '-') {\n                            res = char;\n                        }\n                        else if ((char === '^' || char === '!') && !bracketVal) {\n                            res = '^';\n                        }\n                        else if (char === GLOB_SPLIT) {\n                            res = '';\n                        }\n                        else {\n                            res = escapeRegExpCharacters(char);\n                        }\n                        bracketVal += res;\n                        continue;\n                    }\n                    switch (char) {\n                        case '{':\n                            inBraces = true;\n                            continue;\n                        case '[':\n                            inBrackets = true;\n                            continue;\n                        case '}': {\n                            const choices = splitGlobAware(braceVal, ',');\n                            const braceRegExp = `(?:${( choices.map(choice => parseRegExp(choice))).join('|')})`;\n                            regEx += braceRegExp;\n                            inBraces = false;\n                            braceVal = '';\n                            break;\n                        }\n                        case ']': {\n                            regEx += ('[' + bracketVal + ']');\n                            inBrackets = false;\n                            bracketVal = '';\n                            break;\n                        }\n                        case '?':\n                            regEx += NO_PATH_REGEX;\n                            continue;\n                        case '*':\n                            regEx += starsToRegExp(1);\n                            continue;\n                        default:\n                            regEx += escapeRegExpCharacters(char);\n                    }\n                }\n                if (index < segments.length - 1 &&\n                    ((\n                segments[index + 1] !== GLOBSTAR || index + 2 < segments.length)\n                    )) {\n                    regEx += PATH_REGEX;\n                }\n            }\n            previousSegmentWasGlobStar = (segment === GLOBSTAR);\n        });\n    }\n    return regEx;\n}\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/;\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/;\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/;\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/;\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/;\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/;\nconst CACHE = ( new LRUCache(10000));\nconst FALSE = function () {\n    return false;\n};\nconst NULL = function () {\n    return null;\n};\nfunction parsePattern(arg1, options) {\n    if (!arg1) {\n        return NULL;\n    }\n    let pattern;\n    if (typeof arg1 !== 'string') {\n        pattern = arg1.pattern;\n    }\n    else {\n        pattern = arg1;\n    }\n    pattern = pattern.trim();\n    const patternKey = `${pattern}_${!!options.trimForExclusions}`;\n    let parsedPattern = CACHE.get(patternKey);\n    if (parsedPattern) {\n        return wrapRelativePattern(parsedPattern, arg1);\n    }\n    let match;\n    if (T1.test(pattern)) {\n        parsedPattern = trivia1(pattern.substr(4), pattern);\n    }\n    else if (match = T2.exec(trimForExclusions(pattern, options))) {\n        parsedPattern = trivia2(match[1], pattern);\n    }\n    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) {\n        parsedPattern = trivia3(pattern, options);\n    }\n    else if (match = T4.exec(trimForExclusions(pattern, options))) {\n        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n    }\n    else if (match = T5.exec(trimForExclusions(pattern, options))) {\n        parsedPattern = trivia4and5(match[1], pattern, false);\n    }\n    else {\n        parsedPattern = toRegExp(pattern);\n    }\n    CACHE.set(patternKey, parsedPattern);\n    return wrapRelativePattern(parsedPattern, arg1);\n}\nfunction wrapRelativePattern(parsedPattern, arg2) {\n    if (typeof arg2 === 'string') {\n        return parsedPattern;\n    }\n    const wrappedPattern = function (path, basename) {\n        if (!isEqualOrParent(path, arg2.base, !isLinux)) {\n            return null;\n        }\n        return parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename);\n    };\n    wrappedPattern.allBasenames = parsedPattern.allBasenames;\n    wrappedPattern.allPaths = parsedPattern.allPaths;\n    wrappedPattern.basenames = parsedPattern.basenames;\n    wrappedPattern.patterns = parsedPattern.patterns;\n    return wrappedPattern;\n}\nfunction trimForExclusions(pattern, options) {\n    return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern;\n}\nfunction trivia1(base, pattern) {\n    return function (path, basename) {\n        return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n    };\n}\nfunction trivia2(base, pattern) {\n    const slashBase = `/${base}`;\n    const backslashBase = `\\\\${base}`;\n    const parsedPattern = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (basename) {\n            return basename === base ? pattern : null;\n        }\n        return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n    };\n    const basenames = [base];\n    parsedPattern.basenames = basenames;\n    parsedPattern.patterns = [pattern];\n    parsedPattern.allBasenames = basenames;\n    return parsedPattern;\n}\nfunction trivia3(pattern, options) {\n    const parsedPatterns = aggregateBasenameMatches(( pattern.slice(1, -1)\n        .split(',')\n        .map(pattern => parsePattern(pattern, options)))\n        .filter(pattern => pattern !== NULL), pattern);\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (patternsLength === 1) {\n        return parsedPatterns[0];\n    }\n    const parsedPattern = function (path, basename) {\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            if (parsedPatterns[i](path, basename)) {\n                return pattern;\n            }\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        parsedPattern.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        parsedPattern.allPaths = allPaths;\n    }\n    return parsedPattern;\n}\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n    const usingPosixSep = sep === posix.sep;\n    const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n    const nativePathEnd = sep + nativePath;\n    const targetPathEnd = posix.sep + targetPath;\n    let parsedPattern;\n    if (matchPathEnds) {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n        };\n    }\n    else {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;\n        };\n    }\n    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n    return parsedPattern;\n}\nfunction toRegExp(pattern) {\n    try {\n        const regExp = ( new RegExp(`^${parseRegExp(pattern)}$`));\n        return function (path) {\n            regExp.lastIndex = 0;\n            return typeof path === 'string' && regExp.test(path) ? pattern : null;\n        };\n    }\n    catch (error) {\n        return NULL;\n    }\n}\nfunction match(arg1, path, hasSibling) {\n    if (!arg1 || typeof path !== 'string') {\n        return false;\n    }\n    return parse(arg1)(path, undefined, hasSibling);\n}\nfunction parse(arg1, options = {}) {\n    if (!arg1) {\n        return FALSE;\n    }\n    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n        const parsedPattern = parsePattern(arg1, options);\n        if (parsedPattern === NULL) {\n            return FALSE;\n        }\n        const resultPattern = function (path, basename) {\n            return !!parsedPattern(path, basename);\n        };\n        if (parsedPattern.allBasenames) {\n            resultPattern.allBasenames = parsedPattern.allBasenames;\n        }\n        if (parsedPattern.allPaths) {\n            resultPattern.allPaths = parsedPattern.allPaths;\n        }\n        return resultPattern;\n    }\n    return parsedExpression(arg1, options);\n}\nfunction isRelativePattern(obj) {\n    const rp = obj;\n    if (!rp) {\n        return false;\n    }\n    return typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\nfunction parsedExpression(expression, options) {\n    const parsedPatterns = aggregateBasenameMatches(( Object.getOwnPropertyNames(expression)\n        .map(pattern => parseExpressionPattern(pattern, expression[pattern], options)))\n        .filter(pattern => pattern !== NULL));\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (!( parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings))) {\n        if (patternsLength === 1) {\n            return parsedPatterns[0];\n        }\n        const resultExpression = function (path, basename) {\n            let resultPromises = undefined;\n            for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n                const result = parsedPatterns[i](path, basename);\n                if (typeof result === 'string') {\n                    return result;\n                }\n                if (isThenable(result)) {\n                    if (!resultPromises) {\n                        resultPromises = [];\n                    }\n                    resultPromises.push(result);\n                }\n            }\n            if (resultPromises) {\n                return (async () => {\n                    for (const resultPromise of resultPromises) {\n                        const result = await resultPromise;\n                        if (typeof result === 'string') {\n                            return result;\n                        }\n                    }\n                    return null;\n                })();\n            }\n            return null;\n        };\n        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n        if (withBasenames) {\n            resultExpression.allBasenames = withBasenames.allBasenames;\n        }\n        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n        if (allPaths.length) {\n            resultExpression.allPaths = allPaths;\n        }\n        return resultExpression;\n    }\n    const resultExpression = function (path, base, hasSibling) {\n        let name = undefined;\n        let resultPromises = undefined;\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            const parsedPattern = parsedPatterns[i];\n            if (parsedPattern.requiresSiblings && hasSibling) {\n                if (!base) {\n                    base = basename(path);\n                }\n                if (!name) {\n                    name = base.substr(0, base.length - extname(path).length);\n                }\n            }\n            const result = parsedPattern(path, base, name, hasSibling);\n            if (typeof result === 'string') {\n                return result;\n            }\n            if (isThenable(result)) {\n                if (!resultPromises) {\n                    resultPromises = [];\n                }\n                resultPromises.push(result);\n            }\n        }\n        if (resultPromises) {\n            return (async () => {\n                for (const resultPromise of resultPromises) {\n                    const result = await resultPromise;\n                    if (typeof result === 'string') {\n                        return result;\n                    }\n                }\n                return null;\n            })();\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        resultExpression.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        resultExpression.allPaths = allPaths;\n    }\n    return resultExpression;\n}\nfunction parseExpressionPattern(pattern, value, options) {\n    if (value === false) {\n        return NULL;\n    }\n    const parsedPattern = parsePattern(pattern, options);\n    if (parsedPattern === NULL) {\n        return NULL;\n    }\n    if (typeof value === 'boolean') {\n        return parsedPattern;\n    }\n    if (value) {\n        const when = value.when;\n        if (typeof when === 'string') {\n            const result = (path, basename, name, hasSibling) => {\n                if (!hasSibling || !parsedPattern(path, basename)) {\n                    return null;\n                }\n                const clausePattern = when.replace('$(basename)', () => name);\n                const matched = hasSibling(clausePattern);\n                return isThenable(matched) ?\n                    matched.then(match => match ? pattern : null) :\n                    matched ? pattern : null;\n            };\n            result.requiresSiblings = true;\n            return result;\n        }\n    }\n    return parsedPattern;\n}\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\n    if (basenamePatterns.length < 2) {\n        return parsedPatterns;\n    }\n    const basenames = basenamePatterns.reduce((all, current) => {\n        const basenames = current.basenames;\n        return basenames ? all.concat(basenames) : all;\n    }, []);\n    let patterns;\n    if (result) {\n        patterns = [];\n        for (let i = 0, n = basenames.length; i < n; i++) {\n            patterns.push(result);\n        }\n    }\n    else {\n        patterns = basenamePatterns.reduce((all, current) => {\n            const patterns = current.patterns;\n            return patterns ? all.concat(patterns) : all;\n        }, []);\n    }\n    const aggregate = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (!basename) {\n            let i;\n            for (i = path.length; i > 0; i--) {\n                const ch = path.charCodeAt(i - 1);\n                if (ch === 47  || ch === 92 ) {\n                    break;\n                }\n            }\n            basename = path.substr(i);\n        }\n        const index = basenames.indexOf(basename);\n        return index !== -1 ? patterns[index] : null;\n    };\n    aggregate.basenames = basenames;\n    aggregate.patterns = patterns;\n    aggregate.allBasenames = basenames;\n    const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\n    aggregatedPatterns.push(aggregate);\n    return aggregatedPatterns;\n}\nexport { GLOBSTAR, GLOB_SPLIT, getEmptyExpression, isRelativePattern, match, parse, splitGlobAware };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}