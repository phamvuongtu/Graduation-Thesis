{"ast":null,"code":"import { compareBy, numberComparator } from './arrays.js';\nimport { groupBy } from './collections.js';\nimport { SetMap } from './map.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { Iterable } from './iterator.js';\nlet disposableTracker = null;\nclass DisposableTracker {\n  constructor() {\n    this.livingDisposables = new Map();\n  }\n  static {\n    this.idx = 0;\n  }\n  getDisposableData(d) {\n    let val = this.livingDisposables.get(d);\n    if (!val) {\n      val = {\n        parent: null,\n        source: null,\n        isSingleton: false,\n        value: d,\n        idx: DisposableTracker.idx++\n      };\n      this.livingDisposables.set(d, val);\n    }\n    return val;\n  }\n  trackDisposable(d) {\n    const data = this.getDisposableData(d);\n    if (!data.source) {\n      data.source = new Error().stack;\n    }\n  }\n  setParent(child, parent) {\n    const data = this.getDisposableData(child);\n    data.parent = parent;\n  }\n  markAsDisposed(x) {\n    this.livingDisposables.delete(x);\n  }\n  markAsSingleton(disposable) {\n    this.getDisposableData(disposable).isSingleton = true;\n  }\n  getRootParent(data, cache) {\n    const cacheValue = cache.get(data);\n    if (cacheValue) {\n      return cacheValue;\n    }\n    const result = data.parent ? this.getRootParent(this.getDisposableData(data.parent), cache) : data;\n    cache.set(data, result);\n    return result;\n  }\n  getTrackedDisposables() {\n    const rootParentCache = new Map();\n    const leaking = [...this.livingDisposables.entries()].filter(([, v]) => v.source !== null && !this.getRootParent(v, rootParentCache).isSingleton).flatMap(([k]) => k);\n    return leaking;\n  }\n  computeLeakingDisposables(maxReported = 10, preComputedLeaks) {\n    let uncoveredLeakingObjs;\n    if (preComputedLeaks) {\n      uncoveredLeakingObjs = preComputedLeaks;\n    } else {\n      const rootParentCache = new Map();\n      const leakingObjects = [...this.livingDisposables.values()].filter(info => info.source !== null && !this.getRootParent(info, rootParentCache).isSingleton);\n      if (leakingObjects.length === 0) {\n        return;\n      }\n      const leakingObjsSet = new Set(leakingObjects.map(o => o.value));\n      uncoveredLeakingObjs = leakingObjects.filter(l => {\n        return !(l.parent && leakingObjsSet.has(l.parent));\n      });\n      if (uncoveredLeakingObjs.length === 0) {\n        throw new Error('There are cyclic diposable chains!');\n      }\n    }\n    if (!uncoveredLeakingObjs) {\n      return undefined;\n    }\n    function getStackTracePath(leaking) {\n      function removePrefix(array, linesToRemove) {\n        while (array.length > 0 && linesToRemove.some(regexp => typeof regexp === 'string' ? regexp === array[0] : array[0].match(regexp))) {\n          array.shift();\n        }\n      }\n      const lines = leaking.source.split('\\n').map(p => p.trim().replace('at ', '')).filter(l => l !== '');\n      removePrefix(lines, ['Error', /^trackDisposable \\(.*\\)$/, /^DisposableTracker.trackDisposable \\(.*\\)$/]);\n      return lines.reverse();\n    }\n    const stackTraceStarts = new SetMap();\n    for (const leaking of uncoveredLeakingObjs) {\n      const stackTracePath = getStackTracePath(leaking);\n      for (let i = 0; i <= stackTracePath.length; i++) {\n        stackTraceStarts.add(stackTracePath.slice(0, i).join('\\n'), leaking);\n      }\n    }\n    uncoveredLeakingObjs.sort(compareBy(l => l.idx, numberComparator));\n    let message = '';\n    let i = 0;\n    for (const leaking of uncoveredLeakingObjs.slice(0, maxReported)) {\n      i++;\n      const stackTracePath = getStackTracePath(leaking);\n      const stackTraceFormattedLines = [];\n      for (let i = 0; i < stackTracePath.length; i++) {\n        let line = stackTracePath[i];\n        const starts = stackTraceStarts.get(stackTracePath.slice(0, i + 1).join('\\n'));\n        line = `(shared with ${starts.size}/${uncoveredLeakingObjs.length} leaks) at ${line}`;\n        const prevStarts = stackTraceStarts.get(stackTracePath.slice(0, i).join('\\n'));\n        const continuations = groupBy([...prevStarts].map(d => getStackTracePath(d)[i]), v => v);\n        delete continuations[stackTracePath[i]];\n        for (const [cont, set] of Object.entries(continuations)) {\n          stackTraceFormattedLines.unshift(`    - stacktraces of ${set.length} other leaks continue with ${cont}`);\n        }\n        stackTraceFormattedLines.unshift(line);\n      }\n      message += `\\n\\n\\n==================== Leaking disposable ${i}/${uncoveredLeakingObjs.length}: ${leaking.value.constructor.name} ====================\\n${stackTraceFormattedLines.join('\\n')}\\n============================================================\\n\\n`;\n    }\n    if (uncoveredLeakingObjs.length > maxReported) {\n      message += `\\n\\n\\n... and ${uncoveredLeakingObjs.length - maxReported} more leaking disposables\\n\\n`;\n    }\n    return {\n      leaks: uncoveredLeakingObjs,\n      details: message\n    };\n  }\n}\nfunction setDisposableTracker(tracker) {\n  disposableTracker = tracker;\n}\nfunction trackDisposable(x) {\n  disposableTracker?.trackDisposable(x);\n  return x;\n}\nfunction markAsDisposed(disposable) {\n  disposableTracker?.markAsDisposed(disposable);\n}\nfunction setParentOfDisposable(child, parent) {\n  disposableTracker?.setParent(child, parent);\n}\nfunction setParentOfDisposables(children, parent) {\n  if (!disposableTracker) {\n    return;\n  }\n  for (const child of children) {\n    disposableTracker.setParent(child, parent);\n  }\n}\nfunction markAsSingleton(singleton) {\n  disposableTracker?.markAsSingleton(singleton);\n  return singleton;\n}\nfunction isDisposable(thing) {\n  return typeof thing === 'object' && thing !== null && typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nfunction dispose(arg) {\n  if (Iterable.is(arg)) {\n    const errors = [];\n    for (const d of arg) {\n      if (d) {\n        try {\n          d.dispose();\n        } catch (e) {\n          errors.push(e);\n        }\n      }\n    }\n    if (errors.length === 1) {\n      throw errors[0];\n    } else if (errors.length > 1) {\n      throw new AggregateError(errors, 'Encountered errors while disposing of store');\n    }\n    return Array.isArray(arg) ? [] : arg;\n  } else if (arg) {\n    arg.dispose();\n    return arg;\n  }\n}\nfunction disposeIfDisposable(disposables) {\n  for (const d of disposables) {\n    if (isDisposable(d)) {\n      d.dispose();\n    }\n  }\n  return [];\n}\nfunction combinedDisposable(...disposables) {\n  const parent = toDisposable(() => dispose(disposables));\n  setParentOfDisposables(disposables, parent);\n  return parent;\n}\nfunction toDisposable(fn) {\n  const self = trackDisposable({\n    dispose: createSingleCallFunction(() => {\n      markAsDisposed(self);\n      fn();\n    })\n  });\n  return self;\n}\nclass DisposableStore {\n  static {\n    this.DISABLE_DISPOSED_WARNING = false;\n  }\n  constructor() {\n    this._toDispose = new Set();\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n  dispose() {\n    if (this._isDisposed) {\n      return;\n    }\n    markAsDisposed(this);\n    this._isDisposed = true;\n    this.clear();\n  }\n  get isDisposed() {\n    return this._isDisposed;\n  }\n  clear() {\n    if (this._toDispose.size === 0) {\n      return;\n    }\n    try {\n      dispose(this._toDispose);\n    } finally {\n      this._toDispose.clear();\n    }\n  }\n  add(o) {\n    if (!o) {\n      return o;\n    }\n    if (o === this) {\n      throw new Error('Cannot register a disposable on itself!');\n    }\n    setParentOfDisposable(o, this);\n    if (this._isDisposed) {\n      if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n        console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n      }\n    } else {\n      this._toDispose.add(o);\n    }\n    return o;\n  }\n  delete(o) {\n    if (!o) {\n      return;\n    }\n    if (o === this) {\n      throw new Error('Cannot dispose a disposable on itself!');\n    }\n    this._toDispose.delete(o);\n    o.dispose();\n  }\n  deleteAndLeak(o) {\n    if (!o) {\n      return;\n    }\n    if (this._toDispose.has(o)) {\n      this._toDispose.delete(o);\n      setParentOfDisposable(o, null);\n    }\n  }\n}\nclass Disposable {\n  static {\n    this.None = Object.freeze({\n      dispose() {}\n    });\n  }\n  constructor() {\n    this._store = new DisposableStore();\n    trackDisposable(this);\n    setParentOfDisposable(this._store, this);\n  }\n  dispose() {\n    markAsDisposed(this);\n    this._store.dispose();\n  }\n  _register(o) {\n    if (o === this) {\n      throw new Error('Cannot register a disposable on itself!');\n    }\n    return this._store.add(o);\n  }\n}\nclass MutableDisposable {\n  constructor() {\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n  get value() {\n    return this._isDisposed ? undefined : this._value;\n  }\n  set value(value) {\n    if (this._isDisposed || value === this._value) {\n      return;\n    }\n    this._value?.dispose();\n    if (value) {\n      setParentOfDisposable(value, this);\n    }\n    this._value = value;\n  }\n  clear() {\n    this.value = undefined;\n  }\n  dispose() {\n    this._isDisposed = true;\n    markAsDisposed(this);\n    this._value?.dispose();\n    this._value = undefined;\n  }\n  clearAndLeak() {\n    const oldValue = this._value;\n    this._value = undefined;\n    if (oldValue) {\n      setParentOfDisposable(oldValue, null);\n    }\n    return oldValue;\n  }\n}\nclass MandatoryMutableDisposable {\n  constructor(initialValue) {\n    this._disposable = new MutableDisposable();\n    this._isDisposed = false;\n    this._disposable.value = initialValue;\n  }\n  get value() {\n    return this._disposable.value;\n  }\n  set value(value) {\n    if (this._isDisposed || value === this._disposable.value) {\n      return;\n    }\n    this._disposable.value = value;\n  }\n  dispose() {\n    this._isDisposed = true;\n    this._disposable.dispose();\n  }\n}\nclass RefCountedDisposable {\n  constructor(_disposable) {\n    this._disposable = _disposable;\n    this._counter = 1;\n  }\n  acquire() {\n    this._counter++;\n    return this;\n  }\n  release() {\n    if (--this._counter === 0) {\n      this._disposable.dispose();\n    }\n    return this;\n  }\n}\nclass ReferenceCollection {\n  constructor() {\n    this.references = new Map();\n  }\n  acquire(key, ...args) {\n    let reference = this.references.get(key);\n    if (!reference) {\n      reference = {\n        counter: 0,\n        object: this.createReferencedObject(key, ...args)\n      };\n      this.references.set(key, reference);\n    }\n    const {\n      object\n    } = reference;\n    const dispose = createSingleCallFunction(() => {\n      if (--reference.counter === 0) {\n        this.destroyReferencedObject(key, reference.object);\n        this.references.delete(key);\n      }\n    });\n    reference.counter++;\n    return {\n      object,\n      dispose\n    };\n  }\n}\nclass AsyncReferenceCollection {\n  constructor(referenceCollection) {\n    this.referenceCollection = referenceCollection;\n  }\n  async acquire(key, ...args) {\n    const ref = this.referenceCollection.acquire(key, ...args);\n    try {\n      const object = await ref.object;\n      return {\n        object,\n        dispose: () => ref.dispose()\n      };\n    } catch (error) {\n      ref.dispose();\n      throw error;\n    }\n  }\n}\nclass ImmortalReference {\n  constructor(object) {\n    this.object = object;\n  }\n  dispose() {}\n}\nclass DisposableMap {\n  constructor() {\n    this._store = new Map();\n    this._isDisposed = false;\n    trackDisposable(this);\n  }\n  dispose() {\n    markAsDisposed(this);\n    this._isDisposed = true;\n    this.clearAndDisposeAll();\n  }\n  clearAndDisposeAll() {\n    if (!this._store.size) {\n      return;\n    }\n    try {\n      dispose(this._store.values());\n    } finally {\n      this._store.clear();\n    }\n  }\n  has(key) {\n    return this._store.has(key);\n  }\n  get size() {\n    return this._store.size;\n  }\n  get(key) {\n    return this._store.get(key);\n  }\n  set(key, value, skipDisposeOnOverwrite = false) {\n    if (this._isDisposed) {\n      console.warn(new Error('Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!').stack);\n    }\n    if (!skipDisposeOnOverwrite) {\n      this._store.get(key)?.dispose();\n    }\n    this._store.set(key, value);\n  }\n  deleteAndDispose(key) {\n    this._store.get(key)?.dispose();\n    this._store.delete(key);\n  }\n  keys() {\n    return this._store.keys();\n  }\n  values() {\n    return this._store.values();\n  }\n  [Symbol.iterator]() {\n    return this._store[Symbol.iterator]();\n  }\n}\nexport { AsyncReferenceCollection, Disposable, DisposableMap, DisposableStore, DisposableTracker, ImmortalReference, MandatoryMutableDisposable, MutableDisposable, RefCountedDisposable, ReferenceCollection, combinedDisposable, dispose, disposeIfDisposable, isDisposable, markAsDisposed, markAsSingleton, setDisposableTracker, toDisposable, trackDisposable };","map":{"version":3,"names":["compareBy","numberComparator","groupBy","SetMap","createSingleCallFunction","Iterable","disposableTracker","DisposableTracker","constructor","livingDisposables","Map","idx","getDisposableData","d","val","get","parent","source","isSingleton","value","set","trackDisposable","data","Error","stack","setParent","child","markAsDisposed","x","delete","markAsSingleton","disposable","getRootParent","cache","cacheValue","result","getTrackedDisposables","rootParentCache","leaking","entries","filter","v","flatMap","k","computeLeakingDisposables","maxReported","preComputedLeaks","uncoveredLeakingObjs","leakingObjects","values","info","length","leakingObjsSet","Set","map","o","l","has","undefined","getStackTracePath","removePrefix","array","linesToRemove","some","regexp","match","shift","lines","split","p","trim","replace","reverse","stackTraceStarts","stackTracePath","i","add","slice","join","sort","message","stackTraceFormattedLines","line","starts","size","prevStarts","continuations","cont","Object","unshift","name","leaks","details","setDisposableTracker","tracker","setParentOfDisposable","setParentOfDisposables","children","singleton","isDisposable","thing","dispose","arg","is","errors","e","push","AggregateError","Array","isArray","disposeIfDisposable","disposables","combinedDisposable","toDisposable","fn","self","DisposableStore","DISABLE_DISPOSED_WARNING","_toDispose","_isDisposed","clear","isDisposed","console","warn","deleteAndLeak","Disposable","None","freeze","_store","_register","MutableDisposable","_value","clearAndLeak","oldValue","MandatoryMutableDisposable","initialValue","_disposable","RefCountedDisposable","_counter","acquire","release","ReferenceCollection","references","key","args","reference","counter","object","createReferencedObject","destroyReferencedObject","AsyncReferenceCollection","referenceCollection","ref","error","ImmortalReference","DisposableMap","clearAndDisposeAll","skipDisposeOnOverwrite","deleteAndDispose","keys","Symbol","iterator"],"sources":["/Users/phamtu/Downloads/Code/OCE/oce-frontend/node_modules/vscode/vscode/src/vs/base/common/lifecycle.js"],"sourcesContent":["import { compareBy, numberComparator } from './arrays.js';\nimport { groupBy } from './collections.js';\nimport { SetMap } from './map.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { Iterable } from './iterator.js';\nlet disposableTracker = null;\nclass DisposableTracker {\n    constructor() {\n        this.livingDisposables = ( new Map());\n    }\n    static { this.idx = 0; }\n    getDisposableData(d) {\n        let val = this.livingDisposables.get(d);\n        if (!val) {\n            val = { parent: null, source: null, isSingleton: false, value: d, idx: DisposableTracker.idx++ };\n            this.livingDisposables.set(d, val);\n        }\n        return val;\n    }\n    trackDisposable(d) {\n        const data = this.getDisposableData(d);\n        if (!data.source) {\n            data.source =\n                ( new Error()).stack;\n        }\n    }\n    setParent(child, parent) {\n        const data = this.getDisposableData(child);\n        data.parent = parent;\n    }\n    markAsDisposed(x) {\n        this.livingDisposables.delete(x);\n    }\n    markAsSingleton(disposable) {\n        this.getDisposableData(disposable).isSingleton = true;\n    }\n    getRootParent(data, cache) {\n        const cacheValue = cache.get(data);\n        if (cacheValue) {\n            return cacheValue;\n        }\n        const result = data.parent ? this.getRootParent(this.getDisposableData(data.parent), cache) : data;\n        cache.set(data, result);\n        return result;\n    }\n    getTrackedDisposables() {\n        const rootParentCache = ( new Map());\n        const leaking = [...this.livingDisposables.entries()]\n            .filter(([, v]) => v.source !== null && !this.getRootParent(v, rootParentCache).isSingleton)\n            .flatMap(([k]) => k);\n        return leaking;\n    }\n    computeLeakingDisposables(maxReported = 10, preComputedLeaks) {\n        let uncoveredLeakingObjs;\n        if (preComputedLeaks) {\n            uncoveredLeakingObjs = preComputedLeaks;\n        }\n        else {\n            const rootParentCache = ( new Map());\n            const leakingObjects = [...( this.livingDisposables.values())]\n                .filter((info) => info.source !== null && !this.getRootParent(info, rootParentCache).isSingleton);\n            if (leakingObjects.length === 0) {\n                return;\n            }\n            const leakingObjsSet = ( new Set(( leakingObjects.map(o => o.value))));\n            uncoveredLeakingObjs = leakingObjects.filter(l => {\n                return !(l.parent && ( leakingObjsSet.has(l.parent)));\n            });\n            if (uncoveredLeakingObjs.length === 0) {\n                throw ( new Error('There are cyclic diposable chains!'));\n            }\n        }\n        if (!uncoveredLeakingObjs) {\n            return undefined;\n        }\n        function getStackTracePath(leaking) {\n            function removePrefix(array, linesToRemove) {\n                while (array.length > 0 && ( linesToRemove.some(\n                    regexp => typeof regexp === 'string' ? regexp === array[0] : array[0].match(regexp)\n                ))) {\n                    array.shift();\n                }\n            }\n            const lines = ( leaking.source.split('\\n').map(p => p.trim().replace('at ', ''))).filter(l => l !== '');\n            removePrefix(lines, ['Error', /^trackDisposable \\(.*\\)$/, /^DisposableTracker.trackDisposable \\(.*\\)$/]);\n            return lines.reverse();\n        }\n        const stackTraceStarts = ( new SetMap());\n        for (const leaking of uncoveredLeakingObjs) {\n            const stackTracePath = getStackTracePath(leaking);\n            for (let i = 0; i <= stackTracePath.length; i++) {\n                stackTraceStarts.add(stackTracePath.slice(0, i).join('\\n'), leaking);\n            }\n        }\n        uncoveredLeakingObjs.sort(compareBy(l => l.idx, numberComparator));\n        let message = '';\n        let i = 0;\n        for (const leaking of uncoveredLeakingObjs.slice(0, maxReported)) {\n            i++;\n            const stackTracePath = getStackTracePath(leaking);\n            const stackTraceFormattedLines = [];\n            for (let i = 0; i < stackTracePath.length; i++) {\n                let line = stackTracePath[i];\n                const starts = stackTraceStarts.get(stackTracePath.slice(0, i + 1).join('\\n'));\n                line = `(shared with ${starts.size}/${uncoveredLeakingObjs.length} leaks) at ${line}`;\n                const prevStarts = stackTraceStarts.get(stackTracePath.slice(0, i).join('\\n'));\n                const continuations = groupBy(( [...prevStarts].map(d => getStackTracePath(d)[i])), v => v);\n                delete continuations[stackTracePath[i]];\n                for (const [cont, set] of Object.entries(continuations)) {\n                    stackTraceFormattedLines.unshift(`    - stacktraces of ${set.length} other leaks continue with ${cont}`);\n                }\n                stackTraceFormattedLines.unshift(line);\n            }\n            message += `\\n\\n\\n==================== Leaking disposable ${i}/${uncoveredLeakingObjs.length}: ${leaking.value.constructor.name} ====================\\n${stackTraceFormattedLines.join('\\n')}\\n============================================================\\n\\n`;\n        }\n        if (uncoveredLeakingObjs.length > maxReported) {\n            message += `\\n\\n\\n... and ${uncoveredLeakingObjs.length - maxReported} more leaking disposables\\n\\n`;\n        }\n        return { leaks: uncoveredLeakingObjs, details: message };\n    }\n}\nfunction setDisposableTracker(tracker) {\n    disposableTracker = tracker;\n}\nfunction trackDisposable(x) {\n    disposableTracker?.trackDisposable(x);\n    return x;\n}\nfunction markAsDisposed(disposable) {\n    disposableTracker?.markAsDisposed(disposable);\n}\nfunction setParentOfDisposable(child, parent) {\n    disposableTracker?.setParent(child, parent);\n}\nfunction setParentOfDisposables(children, parent) {\n    if (!disposableTracker) {\n        return;\n    }\n    for (const child of children) {\n        disposableTracker.setParent(child, parent);\n    }\n}\nfunction markAsSingleton(singleton) {\n    disposableTracker?.markAsSingleton(singleton);\n    return singleton;\n}\nfunction isDisposable(thing) {\n    return typeof thing === 'object' && thing !== null && typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nfunction dispose(arg) {\n    if (Iterable.is(arg)) {\n        const errors = [];\n        for (const d of arg) {\n            if (d) {\n                try {\n                    d.dispose();\n                }\n                catch (e) {\n                    errors.push(e);\n                }\n            }\n        }\n        if (errors.length === 1) {\n            throw errors[0];\n        }\n        else if (errors.length > 1) {\n            throw ( new AggregateError(errors, 'Encountered errors while disposing of store'));\n        }\n        return Array.isArray(arg) ? [] : arg;\n    }\n    else if (arg) {\n        arg.dispose();\n        return arg;\n    }\n}\nfunction disposeIfDisposable(disposables) {\n    for (const d of disposables) {\n        if (isDisposable(d)) {\n            d.dispose();\n        }\n    }\n    return [];\n}\nfunction combinedDisposable(...disposables) {\n    const parent = toDisposable(() => dispose(disposables));\n    setParentOfDisposables(disposables, parent);\n    return parent;\n}\nfunction toDisposable(fn) {\n    const self = trackDisposable({\n        dispose: createSingleCallFunction(() => {\n            markAsDisposed(self);\n            fn();\n        })\n    });\n    return self;\n}\nclass DisposableStore {\n    static { this.DISABLE_DISPOSED_WARNING = false; }\n    constructor() {\n        this._toDispose = ( new Set());\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        markAsDisposed(this);\n        this._isDisposed = true;\n        this.clear();\n    }\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    clear() {\n        if (this._toDispose.size === 0) {\n            return;\n        }\n        try {\n            dispose(this._toDispose);\n        }\n        finally {\n            this._toDispose.clear();\n        }\n    }\n    add(o) {\n        if (!o) {\n            return o;\n        }\n        if (o === this) {\n            throw ( new Error('Cannot register a disposable on itself!'));\n        }\n        setParentOfDisposable(o, this);\n        if (this._isDisposed) {\n            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n                console.warn(( new Error(\n                    'Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!'\n                )).stack);\n            }\n        }\n        else {\n            this._toDispose.add(o);\n        }\n        return o;\n    }\n    delete(o) {\n        if (!o) {\n            return;\n        }\n        if (o === this) {\n            throw ( new Error('Cannot dispose a disposable on itself!'));\n        }\n        this._toDispose.delete(o);\n        o.dispose();\n    }\n    deleteAndLeak(o) {\n        if (!o) {\n            return;\n        }\n        if (( this._toDispose.has(o))) {\n            this._toDispose.delete(o);\n            setParentOfDisposable(o, null);\n        }\n    }\n}\nclass Disposable {\n    static { this.None = ( Object.freeze({ dispose() { } })); }\n    constructor() {\n        this._store = ( new DisposableStore());\n        trackDisposable(this);\n        setParentOfDisposable(this._store, this);\n    }\n    dispose() {\n        markAsDisposed(this);\n        this._store.dispose();\n    }\n    _register(o) {\n        if (o === this) {\n            throw ( new Error('Cannot register a disposable on itself!'));\n        }\n        return this._store.add(o);\n    }\n}\nclass MutableDisposable {\n    constructor() {\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    get value() {\n        return this._isDisposed ? undefined : this._value;\n    }\n    set value(value) {\n        if (this._isDisposed || value === this._value) {\n            return;\n        }\n        this._value?.dispose();\n        if (value) {\n            setParentOfDisposable(value, this);\n        }\n        this._value = value;\n    }\n    clear() {\n        this.value = undefined;\n    }\n    dispose() {\n        this._isDisposed = true;\n        markAsDisposed(this);\n        this._value?.dispose();\n        this._value = undefined;\n    }\n    clearAndLeak() {\n        const oldValue = this._value;\n        this._value = undefined;\n        if (oldValue) {\n            setParentOfDisposable(oldValue, null);\n        }\n        return oldValue;\n    }\n}\nclass MandatoryMutableDisposable {\n    constructor(initialValue) {\n        this._disposable = ( new MutableDisposable());\n        this._isDisposed = false;\n        this._disposable.value = initialValue;\n    }\n    get value() {\n        return this._disposable.value;\n    }\n    set value(value) {\n        if (this._isDisposed || value === this._disposable.value) {\n            return;\n        }\n        this._disposable.value = value;\n    }\n    dispose() {\n        this._isDisposed = true;\n        this._disposable.dispose();\n    }\n}\nclass RefCountedDisposable {\n    constructor(_disposable) {\n        this._disposable = _disposable;\n        this._counter = 1;\n    }\n    acquire() {\n        this._counter++;\n        return this;\n    }\n    release() {\n        if (--this._counter === 0) {\n            this._disposable.dispose();\n        }\n        return this;\n    }\n}\nclass ReferenceCollection {\n    constructor() {\n        this.references = ( new Map());\n    }\n    acquire(key, ...args) {\n        let reference = this.references.get(key);\n        if (!reference) {\n            reference = { counter: 0, object: this.createReferencedObject(key, ...args) };\n            this.references.set(key, reference);\n        }\n        const { object } = reference;\n        const dispose = createSingleCallFunction(() => {\n            if (--reference.counter === 0) {\n                this.destroyReferencedObject(key, reference.object);\n                this.references.delete(key);\n            }\n        });\n        reference.counter++;\n        return { object, dispose };\n    }\n}\nclass AsyncReferenceCollection {\n    constructor(referenceCollection) {\n        this.referenceCollection = referenceCollection;\n    }\n    async acquire(key, ...args) {\n        const ref = this.referenceCollection.acquire(key, ...args);\n        try {\n            const object = await ref.object;\n            return {\n                object,\n                dispose: () => ref.dispose()\n            };\n        }\n        catch (error) {\n            ref.dispose();\n            throw error;\n        }\n    }\n}\nclass ImmortalReference {\n    constructor(object) {\n        this.object = object;\n    }\n    dispose() { }\n}\nclass DisposableMap {\n    constructor() {\n        this._store = ( new Map());\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    dispose() {\n        markAsDisposed(this);\n        this._isDisposed = true;\n        this.clearAndDisposeAll();\n    }\n    clearAndDisposeAll() {\n        if (!this._store.size) {\n            return;\n        }\n        try {\n            dispose(( this._store.values()));\n        }\n        finally {\n            this._store.clear();\n        }\n    }\n    has(key) {\n        return ( this._store.has(key));\n    }\n    get size() {\n        return this._store.size;\n    }\n    get(key) {\n        return this._store.get(key);\n    }\n    set(key, value, skipDisposeOnOverwrite = false) {\n        if (this._isDisposed) {\n            console.warn(( new Error(\n                'Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!'\n            )).stack);\n        }\n        if (!skipDisposeOnOverwrite) {\n            this._store.get(key)?.dispose();\n        }\n        this._store.set(key, value);\n    }\n    deleteAndDispose(key) {\n        this._store.get(key)?.dispose();\n        this._store.delete(key);\n    }\n    keys() {\n        return ( this._store.keys());\n    }\n    values() {\n        return ( this._store.values());\n    }\n    [Symbol.iterator]() {\n        return this._store[Symbol.iterator]();\n    }\n}\nexport { AsyncReferenceCollection, Disposable, DisposableMap, DisposableStore, DisposableTracker, ImmortalReference, MandatoryMutableDisposable, MutableDisposable, RefCountedDisposable, ReferenceCollection, combinedDisposable, dispose, disposeIfDisposable, isDisposable, markAsDisposed, markAsSingleton, setDisposableTracker, toDisposable, trackDisposable };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}