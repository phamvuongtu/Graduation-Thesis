{"ast":null,"code":"import { CancellationTokenSource } from './cancellation.js';\nimport { CancellationError, BugIndicatingError } from './errors.js';\nimport { Emitter, Event } from './event.js';\nimport { toDisposable, DisposableMap } from './lifecycle.js';\nimport { extUri } from './resources.js';\nimport { setTimeout0 } from './platform.js';\nimport { MicrotaskDelay } from './symbols.js';\nimport { Lazy } from './lazy.js';\nfunction isThenable(obj) {\n  return !!obj && typeof obj.then === 'function';\n}\nfunction createCancelablePromise(callback) {\n  const source = new CancellationTokenSource();\n  const thenable = callback(source.token);\n  const promise = new Promise((resolve, reject) => {\n    const subscription = source.token.onCancellationRequested(() => {\n      subscription.dispose();\n      reject(new CancellationError());\n    });\n    Promise.resolve(thenable).then(value => {\n      subscription.dispose();\n      source.dispose();\n      resolve(value);\n    }, err => {\n      subscription.dispose();\n      source.dispose();\n      reject(err);\n    });\n  });\n  return new class {\n    cancel() {\n      source.cancel();\n      source.dispose();\n    }\n    then(resolve, reject) {\n      return promise.then(resolve, reject);\n    }\n    catch(reject) {\n      return this.then(undefined, reject);\n    }\n    finally(onfinally) {\n      return promise.finally(onfinally);\n    }\n  }();\n}\nfunction raceCancellation(promise, token, defaultValue) {\n  return new Promise((resolve, reject) => {\n    const ref = token.onCancellationRequested(() => {\n      ref.dispose();\n      resolve(defaultValue);\n    });\n    promise.then(resolve, reject).finally(() => ref.dispose());\n  });\n}\nfunction raceCancellationError(promise, token) {\n  return new Promise((resolve, reject) => {\n    const ref = token.onCancellationRequested(() => {\n      ref.dispose();\n      reject(new CancellationError());\n    });\n    promise.then(resolve, reject).finally(() => ref.dispose());\n  });\n}\nasync function raceCancellablePromises(cancellablePromises) {\n  let resolvedPromiseIndex = -1;\n  const promises = cancellablePromises.map((promise, index) => promise.then(result => {\n    resolvedPromiseIndex = index;\n    return result;\n  }));\n  try {\n    const result = await Promise.race(promises);\n    return result;\n  } finally {\n    cancellablePromises.forEach((cancellablePromise, index) => {\n      if (index !== resolvedPromiseIndex) {\n        cancellablePromise.cancel();\n      }\n    });\n  }\n}\nfunction raceTimeout(promise, timeout, onTimeout) {\n  let promiseResolve = undefined;\n  const timer = setTimeout(() => {\n    promiseResolve?.(undefined);\n    onTimeout?.();\n  }, timeout);\n  return Promise.race([promise.finally(() => clearTimeout(timer)), new Promise(resolve => promiseResolve = resolve)]);\n}\nfunction asPromise(callback) {\n  return new Promise((resolve, reject) => {\n    const item = callback();\n    if (isThenable(item)) {\n      item.then(resolve, reject);\n    } else {\n      resolve(item);\n    }\n  });\n}\nfunction promiseWithResolvers() {\n  let resolve;\n  let reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return {\n    promise,\n    resolve: resolve,\n    reject: reject\n  };\n}\nclass Throttler {\n  constructor() {\n    this.isDisposed = false;\n    this.activePromise = null;\n    this.queuedPromise = null;\n    this.queuedPromiseFactory = null;\n  }\n  queue(promiseFactory) {\n    if (this.isDisposed) {\n      return Promise.reject(new Error('Throttler is disposed'));\n    }\n    if (this.activePromise) {\n      this.queuedPromiseFactory = promiseFactory;\n      if (!this.queuedPromise) {\n        const onComplete = () => {\n          this.queuedPromise = null;\n          if (this.isDisposed) {\n            return;\n          }\n          const result = this.queue(this.queuedPromiseFactory);\n          this.queuedPromiseFactory = null;\n          return result;\n        };\n        this.queuedPromise = new Promise(resolve => {\n          this.activePromise.then(onComplete, onComplete).then(resolve);\n        });\n      }\n      return new Promise((resolve, reject) => {\n        this.queuedPromise.then(resolve, reject);\n      });\n    }\n    this.activePromise = promiseFactory();\n    return new Promise((resolve, reject) => {\n      this.activePromise.then(result => {\n        this.activePromise = null;\n        resolve(result);\n      }, err => {\n        this.activePromise = null;\n        reject(err);\n      });\n    });\n  }\n  dispose() {\n    this.isDisposed = true;\n  }\n}\nclass Sequencer {\n  constructor() {\n    this.current = Promise.resolve(null);\n  }\n  queue(promiseTask) {\n    return this.current = this.current.then(() => promiseTask(), () => promiseTask());\n  }\n}\nclass SequencerByKey {\n  constructor() {\n    this.promiseMap = new Map();\n  }\n  queue(key, promiseTask) {\n    const runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n    const newPromise = runningPromise.catch(() => {}).then(promiseTask).finally(() => {\n      if (this.promiseMap.get(key) === newPromise) {\n        this.promiseMap.delete(key);\n      }\n    });\n    this.promiseMap.set(key, newPromise);\n    return newPromise;\n  }\n}\nconst timeoutDeferred = (timeout, fn) => {\n  let scheduled = true;\n  const handle = setTimeout(() => {\n    scheduled = false;\n    fn();\n  }, timeout);\n  return {\n    isTriggered: () => scheduled,\n    dispose: () => {\n      clearTimeout(handle);\n      scheduled = false;\n    }\n  };\n};\nconst microtaskDeferred = fn => {\n  let scheduled = true;\n  queueMicrotask(() => {\n    if (scheduled) {\n      scheduled = false;\n      fn();\n    }\n  });\n  return {\n    isTriggered: () => scheduled,\n    dispose: () => {\n      scheduled = false;\n    }\n  };\n};\nclass Delayer {\n  constructor(defaultDelay) {\n    this.defaultDelay = defaultDelay;\n    this.deferred = null;\n    this.completionPromise = null;\n    this.doResolve = null;\n    this.doReject = null;\n    this.task = null;\n  }\n  trigger(task, delay = this.defaultDelay) {\n    this.task = task;\n    this.cancelTimeout();\n    if (!this.completionPromise) {\n      this.completionPromise = new Promise((resolve, reject) => {\n        this.doResolve = resolve;\n        this.doReject = reject;\n      }).then(() => {\n        this.completionPromise = null;\n        this.doResolve = null;\n        if (this.task) {\n          const task = this.task;\n          this.task = null;\n          return task();\n        }\n        return undefined;\n      });\n    }\n    const fn = () => {\n      this.deferred = null;\n      this.doResolve?.(null);\n    };\n    this.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n    return this.completionPromise;\n  }\n  isTriggered() {\n    return !!this.deferred?.isTriggered();\n  }\n  cancel() {\n    this.cancelTimeout();\n    if (this.completionPromise) {\n      this.doReject?.(new CancellationError());\n      this.completionPromise = null;\n    }\n  }\n  cancelTimeout() {\n    this.deferred?.dispose();\n    this.deferred = null;\n  }\n  dispose() {\n    this.cancel();\n  }\n}\nclass ThrottledDelayer {\n  constructor(defaultDelay) {\n    this.delayer = new Delayer(defaultDelay);\n    this.throttler = new Throttler();\n  }\n  trigger(promiseFactory, delay) {\n    return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);\n  }\n  isTriggered() {\n    return this.delayer.isTriggered();\n  }\n  cancel() {\n    this.delayer.cancel();\n  }\n  dispose() {\n    this.delayer.dispose();\n    this.throttler.dispose();\n  }\n}\nclass Barrier {\n  constructor() {\n    this._isOpen = false;\n    this._promise = new Promise((c, e) => {\n      this._completePromise = c;\n    });\n  }\n  isOpen() {\n    return this._isOpen;\n  }\n  open() {\n    this._isOpen = true;\n    this._completePromise(true);\n  }\n  wait() {\n    return this._promise;\n  }\n}\nclass AutoOpenBarrier extends Barrier {\n  constructor(autoOpenTimeMs) {\n    super();\n    this._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n  }\n  open() {\n    clearTimeout(this._timeout);\n    super.open();\n  }\n}\nfunction timeout(millis, token) {\n  if (!token) {\n    return createCancelablePromise(token => timeout(millis, token));\n  }\n  return new Promise((resolve, reject) => {\n    const handle = setTimeout(() => {\n      disposable.dispose();\n      resolve();\n    }, millis);\n    const disposable = token.onCancellationRequested(() => {\n      clearTimeout(handle);\n      disposable.dispose();\n      reject(new CancellationError());\n    });\n  });\n}\nfunction disposableTimeout(handler, timeout = 0, store) {\n  const timer = setTimeout(() => {\n    handler();\n    if (store) {\n      disposable.dispose();\n    }\n  }, timeout);\n  const disposable = toDisposable(() => {\n    clearTimeout(timer);\n    store?.deleteAndLeak(disposable);\n  });\n  store?.add(disposable);\n  return disposable;\n}\nfunction sequence(promiseFactories) {\n  const results = [];\n  let index = 0;\n  const len = promiseFactories.length;\n  function next() {\n    return index < len ? promiseFactories[index++]() : null;\n  }\n  function thenHandler(result) {\n    if (result !== undefined && result !== null) {\n      results.push(result);\n    }\n    const n = next();\n    if (n) {\n      return n.then(thenHandler);\n    }\n    return Promise.resolve(results);\n  }\n  return Promise.resolve(null).then(thenHandler);\n}\nfunction first(promiseFactories, shouldStop = t => !!t, defaultValue = null) {\n  let index = 0;\n  const len = promiseFactories.length;\n  const loop = () => {\n    if (index >= len) {\n      return Promise.resolve(defaultValue);\n    }\n    const factory = promiseFactories[index++];\n    const promise = Promise.resolve(factory());\n    return promise.then(result => {\n      if (shouldStop(result)) {\n        return Promise.resolve(result);\n      }\n      return loop();\n    });\n  };\n  return loop();\n}\nclass Limiter {\n  constructor(maxDegreeOfParalellism) {\n    this._size = 0;\n    this._isDisposed = false;\n    this.maxDegreeOfParalellism = maxDegreeOfParalellism;\n    this.outstandingPromises = [];\n    this.runningPromises = 0;\n    this._onDrained = new Emitter();\n  }\n  whenIdle() {\n    return this.size > 0 ? Event.toPromise(this.onDrained) : Promise.resolve();\n  }\n  get onDrained() {\n    return this._onDrained.event;\n  }\n  get size() {\n    return this._size;\n  }\n  queue(factory) {\n    if (this._isDisposed) {\n      throw new Error('Object has been disposed');\n    }\n    this._size++;\n    return new Promise((c, e) => {\n      this.outstandingPromises.push({\n        factory,\n        c,\n        e\n      });\n      this.consume();\n    });\n  }\n  consume() {\n    while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n      const iLimitedTask = this.outstandingPromises.shift();\n      this.runningPromises++;\n      const promise = iLimitedTask.factory();\n      promise.then(iLimitedTask.c, iLimitedTask.e);\n      promise.then(() => this.consumed(), () => this.consumed());\n    }\n  }\n  consumed() {\n    if (this._isDisposed) {\n      return;\n    }\n    this.runningPromises--;\n    if (--this._size === 0) {\n      this._onDrained.fire();\n    }\n    if (this.outstandingPromises.length > 0) {\n      this.consume();\n    }\n  }\n  clear() {\n    if (this._isDisposed) {\n      throw new Error('Object has been disposed');\n    }\n    this.outstandingPromises.length = 0;\n    this._size = this.runningPromises;\n  }\n  dispose() {\n    this._isDisposed = true;\n    this.outstandingPromises.length = 0;\n    this._size = 0;\n    this._onDrained.dispose();\n  }\n}\nclass Queue extends Limiter {\n  constructor() {\n    super(1);\n  }\n}\nclass ResourceQueue {\n  constructor() {\n    this.queues = new Map();\n    this.drainers = new Set();\n    this.drainListeners = undefined;\n    this.drainListenerCount = 0;\n  }\n  async whenDrained() {\n    if (this.isDrained()) {\n      return;\n    }\n    const promise = new DeferredPromise();\n    this.drainers.add(promise);\n    return promise.p;\n  }\n  isDrained() {\n    for (const [, queue] of this.queues) {\n      if (queue.size > 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n  queueSize(resource, extUri$1 = extUri) {\n    const key = extUri$1.getComparisonKey(resource);\n    return this.queues.get(key)?.size ?? 0;\n  }\n  queueFor(resource, factory, extUri$1 = extUri) {\n    const key = extUri$1.getComparisonKey(resource);\n    let queue = this.queues.get(key);\n    if (!queue) {\n      queue = new Queue();\n      const drainListenerId = this.drainListenerCount++;\n      const drainListener = Event.once(queue.onDrained)(() => {\n        queue?.dispose();\n        this.queues.delete(key);\n        this.onDidQueueDrain();\n        this.drainListeners?.deleteAndDispose(drainListenerId);\n        if (this.drainListeners?.size === 0) {\n          this.drainListeners.dispose();\n          this.drainListeners = undefined;\n        }\n      });\n      if (!this.drainListeners) {\n        this.drainListeners = new DisposableMap();\n      }\n      this.drainListeners.set(drainListenerId, drainListener);\n      this.queues.set(key, queue);\n    }\n    return queue.queue(factory);\n  }\n  onDidQueueDrain() {\n    if (!this.isDrained()) {\n      return;\n    }\n    this.releaseDrainers();\n  }\n  releaseDrainers() {\n    for (const drainer of this.drainers) {\n      drainer.complete();\n    }\n    this.drainers.clear();\n  }\n  dispose() {\n    for (const [, queue] of this.queues) {\n      queue.dispose();\n    }\n    this.queues.clear();\n    this.releaseDrainers();\n    this.drainListeners?.dispose();\n  }\n}\nclass TimeoutTimer {\n  constructor(runner, timeout) {\n    this._token = -1;\n    if (typeof runner === 'function' && typeof timeout === 'number') {\n      this.setIfNotSet(runner, timeout);\n    }\n  }\n  dispose() {\n    this.cancel();\n  }\n  cancel() {\n    if (this._token !== -1) {\n      clearTimeout(this._token);\n      this._token = -1;\n    }\n  }\n  cancelAndSet(runner, timeout) {\n    this.cancel();\n    this._token = setTimeout(() => {\n      this._token = -1;\n      runner();\n    }, timeout);\n  }\n  setIfNotSet(runner, timeout) {\n    if (this._token !== -1) {\n      return;\n    }\n    this._token = setTimeout(() => {\n      this._token = -1;\n      runner();\n    }, timeout);\n  }\n}\nclass IntervalTimer {\n  constructor() {\n    this.disposable = undefined;\n  }\n  cancel() {\n    this.disposable?.dispose();\n    this.disposable = undefined;\n  }\n  cancelAndSet(runner, interval, context = globalThis) {\n    this.cancel();\n    const handle = context.setInterval(() => {\n      runner();\n    }, interval);\n    this.disposable = toDisposable(() => {\n      context.clearInterval(handle);\n      this.disposable = undefined;\n    });\n  }\n  dispose() {\n    this.cancel();\n  }\n}\nclass RunOnceScheduler {\n  constructor(runner, delay) {\n    this.timeoutToken = -1;\n    this.runner = runner;\n    this.timeout = delay;\n    this.timeoutHandler = this.onTimeout.bind(this);\n  }\n  dispose() {\n    this.cancel();\n    this.runner = null;\n  }\n  cancel() {\n    if (this.isScheduled()) {\n      clearTimeout(this.timeoutToken);\n      this.timeoutToken = -1;\n    }\n  }\n  schedule(delay = this.timeout) {\n    this.cancel();\n    this.timeoutToken = setTimeout(this.timeoutHandler, delay);\n  }\n  get delay() {\n    return this.timeout;\n  }\n  set delay(value) {\n    this.timeout = value;\n  }\n  isScheduled() {\n    return this.timeoutToken !== -1;\n  }\n  flush() {\n    if (this.isScheduled()) {\n      this.cancel();\n      this.doRun();\n    }\n  }\n  onTimeout() {\n    this.timeoutToken = -1;\n    if (this.runner) {\n      this.doRun();\n    }\n  }\n  doRun() {\n    this.runner?.();\n  }\n}\nclass RunOnceWorker extends RunOnceScheduler {\n  constructor(runner, timeout) {\n    super(runner, timeout);\n    this.units = [];\n  }\n  work(unit) {\n    this.units.push(unit);\n    if (!this.isScheduled()) {\n      this.schedule();\n    }\n  }\n  doRun() {\n    const units = this.units;\n    this.units = [];\n    this.runner?.(units);\n  }\n  dispose() {\n    this.units = [];\n    super.dispose();\n  }\n}\nlet runWhenGlobalIdle;\nlet _runWhenIdle;\n(function () {\n  if (typeof globalThis.requestIdleCallback !== 'function' || typeof globalThis.cancelIdleCallback !== 'function') {\n    _runWhenIdle = (_targetWindow, runner) => {\n      setTimeout0(() => {\n        if (disposed) {\n          return;\n        }\n        const end = Date.now() + 15;\n        const deadline = {\n          didTimeout: true,\n          timeRemaining() {\n            return Math.max(0, end - Date.now());\n          }\n        };\n        runner(Object.freeze(deadline));\n      });\n      let disposed = false;\n      return {\n        dispose() {\n          if (disposed) {\n            return;\n          }\n          disposed = true;\n        }\n      };\n    };\n  } else {\n    _runWhenIdle = (targetWindow, runner, timeout) => {\n      const handle = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? {\n        timeout\n      } : undefined);\n      let disposed = false;\n      return {\n        dispose() {\n          if (disposed) {\n            return;\n          }\n          disposed = true;\n          targetWindow.cancelIdleCallback(handle);\n        }\n      };\n    };\n  }\n  runWhenGlobalIdle = runner => _runWhenIdle(globalThis, runner);\n})();\nclass AbstractIdleValue {\n  constructor(targetWindow, executor) {\n    this._didRun = false;\n    this._executor = () => {\n      try {\n        this._value = executor();\n      } catch (err) {\n        this._error = err;\n      } finally {\n        this._didRun = true;\n      }\n    };\n    this._handle = _runWhenIdle(targetWindow, () => this._executor());\n  }\n  dispose() {\n    this._handle.dispose();\n  }\n  get value() {\n    if (!this._didRun) {\n      this._handle.dispose();\n      this._executor();\n    }\n    if (this._error) {\n      throw this._error;\n    }\n    return this._value;\n  }\n  get isInitialized() {\n    return this._didRun;\n  }\n}\nclass GlobalIdleValue extends AbstractIdleValue {\n  constructor(executor) {\n    super(globalThis, executor);\n  }\n}\nasync function retry(task, delay, retries) {\n  let lastError;\n  for (let i = 0; i < retries; i++) {\n    try {\n      return await task();\n    } catch (error) {\n      lastError = error;\n      await timeout(delay);\n    }\n  }\n  throw lastError;\n}\nclass TaskSequentializer {\n  isRunning(taskId) {\n    if (typeof taskId === 'number') {\n      return this._running?.taskId === taskId;\n    }\n    return !!this._running;\n  }\n  get running() {\n    return this._running?.promise;\n  }\n  cancelRunning() {\n    this._running?.cancel();\n  }\n  run(taskId, promise, onCancel) {\n    this._running = {\n      taskId,\n      cancel: () => onCancel?.(),\n      promise\n    };\n    promise.then(() => this.doneRunning(taskId), () => this.doneRunning(taskId));\n    return promise;\n  }\n  doneRunning(taskId) {\n    if (this._running && taskId === this._running.taskId) {\n      this._running = undefined;\n      this.runQueued();\n    }\n  }\n  runQueued() {\n    if (this._queued) {\n      const queued = this._queued;\n      this._queued = undefined;\n      queued.run().then(queued.promiseResolve, queued.promiseReject);\n    }\n  }\n  queue(run) {\n    if (!this._queued) {\n      const {\n        promise,\n        resolve: promiseResolve,\n        reject: promiseReject\n      } = promiseWithResolvers();\n      this._queued = {\n        run,\n        promise,\n        promiseResolve: promiseResolve,\n        promiseReject: promiseReject\n      };\n    } else {\n      this._queued.run = run;\n    }\n    return this._queued.promise;\n  }\n  hasQueued() {\n    return !!this._queued;\n  }\n  async join() {\n    return this._queued?.promise ?? this._running?.promise;\n  }\n}\nclass IntervalCounter {\n  constructor(interval, nowFn = () => Date.now()) {\n    this.interval = interval;\n    this.nowFn = nowFn;\n    this.lastIncrementTime = 0;\n    this.value = 0;\n  }\n  increment() {\n    const now = this.nowFn();\n    if (now - this.lastIncrementTime > this.interval) {\n      this.lastIncrementTime = now;\n      this.value = 0;\n    }\n    this.value++;\n    return this.value;\n  }\n}\nclass DeferredPromise {\n  get isRejected() {\n    return this.outcome?.outcome === 1;\n  }\n  get isResolved() {\n    return this.outcome?.outcome === 0;\n  }\n  get isSettled() {\n    return !!this.outcome;\n  }\n  get value() {\n    return this.outcome?.outcome === 0 ? this.outcome?.value : undefined;\n  }\n  constructor() {\n    this.p = new Promise((c, e) => {\n      this.completeCallback = c;\n      this.errorCallback = e;\n    });\n  }\n  complete(value) {\n    return new Promise(resolve => {\n      this.completeCallback(value);\n      this.outcome = {\n        outcome: 0,\n        value\n      };\n      resolve();\n    });\n  }\n  error(err) {\n    return new Promise(resolve => {\n      this.errorCallback(err);\n      this.outcome = {\n        outcome: 1,\n        value: err\n      };\n      resolve();\n    });\n  }\n  cancel() {\n    return this.error(new CancellationError());\n  }\n}\nvar Promises;\n(function (Promises) {\n  async function settled(promises) {\n    let firstError = undefined;\n    const result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n      if (!firstError) {\n        firstError = error;\n      }\n      return undefined;\n    })));\n    if (typeof firstError !== 'undefined') {\n      throw firstError;\n    }\n    return result;\n  }\n  Promises.settled = settled;\n  function withAsyncBody(bodyFn) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        await bodyFn(resolve, reject);\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n  Promises.withAsyncBody = withAsyncBody;\n})(Promises || (Promises = {}));\nclass StatefulPromise {\n  get value() {\n    return this._value;\n  }\n  get error() {\n    return this._error;\n  }\n  get isResolved() {\n    return this._isResolved;\n  }\n  constructor(promise) {\n    this._value = undefined;\n    this._error = undefined;\n    this._isResolved = false;\n    this.promise = promise.then(value => {\n      this._value = value;\n      this._isResolved = true;\n      return value;\n    }, error => {\n      this._error = error;\n      this._isResolved = true;\n      throw error;\n    });\n  }\n  requireValue() {\n    if (!this._isResolved) {\n      throw new BugIndicatingError('Promise is not resolved yet');\n    }\n    if (this._error) {\n      throw this._error;\n    }\n    return this._value;\n  }\n}\nclass LazyStatefulPromise {\n  constructor(_compute) {\n    this._compute = _compute;\n    this._promise = new Lazy(() => new StatefulPromise(this._compute()));\n  }\n  requireValue() {\n    return this._promise.value.requireValue();\n  }\n  getPromise() {\n    return this._promise.value.promise;\n  }\n  get currentValue() {\n    return this._promise.rawValue?.value;\n  }\n}\nclass AsyncIterableObject {\n  static fromArray(items) {\n    return new AsyncIterableObject(writer => {\n      writer.emitMany(items);\n    });\n  }\n  static fromPromise(promise) {\n    return new AsyncIterableObject(async emitter => {\n      emitter.emitMany(await promise);\n    });\n  }\n  static fromPromises(promises) {\n    return new AsyncIterableObject(async emitter => {\n      await Promise.all(promises.map(async p => emitter.emitOne(await p)));\n    });\n  }\n  static merge(iterables) {\n    return new AsyncIterableObject(async emitter => {\n      await Promise.all(iterables.map(async iterable => {\n        for await (const item of iterable) {\n          emitter.emitOne(item);\n        }\n      }));\n    });\n  }\n  static {\n    this.EMPTY = AsyncIterableObject.fromArray([]);\n  }\n  constructor(executor, onReturn) {\n    this._state = 0;\n    this._results = [];\n    this._error = null;\n    this._onReturn = onReturn;\n    this._onStateChanged = new Emitter();\n    queueMicrotask(async () => {\n      const writer = {\n        emitOne: item => this.emitOne(item),\n        emitMany: items => this.emitMany(items),\n        reject: error => this.reject(error)\n      };\n      try {\n        await Promise.resolve(executor(writer));\n        this.resolve();\n      } catch (err) {\n        this.reject(err);\n      } finally {\n        writer.emitOne = undefined;\n        writer.emitMany = undefined;\n        writer.reject = undefined;\n      }\n    });\n  }\n  [Symbol.asyncIterator]() {\n    let i = 0;\n    return {\n      next: async () => {\n        do {\n          if (this._state === 2) {\n            throw this._error;\n          }\n          if (i < this._results.length) {\n            return {\n              done: false,\n              value: this._results[i++]\n            };\n          }\n          if (this._state === 1) {\n            return {\n              done: true,\n              value: undefined\n            };\n          }\n          await Event.toPromise(this._onStateChanged.event);\n        } while (true);\n      },\n      return: async () => {\n        this._onReturn?.();\n        return {\n          done: true,\n          value: undefined\n        };\n      }\n    };\n  }\n  static map(iterable, mapFn) {\n    return new AsyncIterableObject(async emitter => {\n      for await (const item of iterable) {\n        emitter.emitOne(mapFn(item));\n      }\n    });\n  }\n  map(mapFn) {\n    return AsyncIterableObject.map(this, mapFn);\n  }\n  static filter(iterable, filterFn) {\n    return new AsyncIterableObject(async emitter => {\n      for await (const item of iterable) {\n        if (filterFn(item)) {\n          emitter.emitOne(item);\n        }\n      }\n    });\n  }\n  filter(filterFn) {\n    return AsyncIterableObject.filter(this, filterFn);\n  }\n  static coalesce(iterable) {\n    return AsyncIterableObject.filter(iterable, item => !!item);\n  }\n  coalesce() {\n    return AsyncIterableObject.coalesce(this);\n  }\n  static async toPromise(iterable) {\n    const result = [];\n    for await (const item of iterable) {\n      result.push(item);\n    }\n    return result;\n  }\n  toPromise() {\n    return AsyncIterableObject.toPromise(this);\n  }\n  emitOne(value) {\n    if (this._state !== 0) {\n      return;\n    }\n    this._results.push(value);\n    this._onStateChanged.fire();\n  }\n  emitMany(values) {\n    if (this._state !== 0) {\n      return;\n    }\n    this._results = this._results.concat(values);\n    this._onStateChanged.fire();\n  }\n  resolve() {\n    if (this._state !== 0) {\n      return;\n    }\n    this._state = 1;\n    this._onStateChanged.fire();\n  }\n  reject(error) {\n    if (this._state !== 0) {\n      return;\n    }\n    this._state = 2;\n    this._error = error;\n    this._onStateChanged.fire();\n  }\n}\nclass CancelableAsyncIterableObject extends AsyncIterableObject {\n  constructor(_source, executor) {\n    super(executor);\n    this._source = _source;\n  }\n  cancel() {\n    this._source.cancel();\n  }\n}\nfunction createCancelableAsyncIterable(callback) {\n  const source = new CancellationTokenSource();\n  const innerIterable = callback(source.token);\n  return new CancelableAsyncIterableObject(source, async emitter => {\n    const subscription = source.token.onCancellationRequested(() => {\n      subscription.dispose();\n      source.dispose();\n      emitter.reject(new CancellationError());\n    });\n    try {\n      for await (const item of innerIterable) {\n        if (source.token.isCancellationRequested) {\n          return;\n        }\n        emitter.emitOne(item);\n      }\n      subscription.dispose();\n      source.dispose();\n    } catch (err) {\n      subscription.dispose();\n      source.dispose();\n      emitter.reject(err);\n    }\n  });\n}\nclass AsyncIterableSource {\n  constructor(onReturn) {\n    this._deferred = new DeferredPromise();\n    this._asyncIterable = new AsyncIterableObject(emitter => {\n      if (earlyError) {\n        emitter.reject(earlyError);\n        return;\n      }\n      if (earlyItems) {\n        emitter.emitMany(earlyItems);\n      }\n      this._errorFn = error => emitter.reject(error);\n      this._emitFn = item => emitter.emitOne(item);\n      return this._deferred.p;\n    }, onReturn);\n    let earlyError;\n    let earlyItems;\n    this._emitFn = item => {\n      if (!earlyItems) {\n        earlyItems = [];\n      }\n      earlyItems.push(item);\n    };\n    this._errorFn = error => {\n      if (!earlyError) {\n        earlyError = error;\n      }\n    };\n  }\n  get asyncIterable() {\n    return this._asyncIterable;\n  }\n  resolve() {\n    this._deferred.complete();\n  }\n  reject(error) {\n    this._errorFn(error);\n    this._deferred.complete();\n  }\n  emitOne(item) {\n    this._emitFn(item);\n  }\n}\nexport { AbstractIdleValue, AsyncIterableObject, AsyncIterableSource, AutoOpenBarrier, Barrier, CancelableAsyncIterableObject, DeferredPromise, Delayer, GlobalIdleValue, IntervalCounter, IntervalTimer, LazyStatefulPromise, Limiter, Promises, Queue, ResourceQueue, RunOnceScheduler, RunOnceWorker, Sequencer, SequencerByKey, StatefulPromise, TaskSequentializer, ThrottledDelayer, Throttler, TimeoutTimer, _runWhenIdle, asPromise, createCancelableAsyncIterable, createCancelablePromise, disposableTimeout, first, isThenable, promiseWithResolvers, raceCancellablePromises, raceCancellation, raceCancellationError, raceTimeout, retry, runWhenGlobalIdle, sequence, timeout };","map":{"version":3,"names":["CancellationTokenSource","CancellationError","BugIndicatingError","Emitter","Event","toDisposable","DisposableMap","extUri","setTimeout0","MicrotaskDelay","Lazy","isThenable","obj","then","createCancelablePromise","callback","source","thenable","token","promise","Promise","resolve","reject","subscription","onCancellationRequested","dispose","value","err","cancel","catch","undefined","finally","onfinally","raceCancellation","defaultValue","ref","raceCancellationError","raceCancellablePromises","cancellablePromises","resolvedPromiseIndex","promises","map","index","result","race","forEach","cancellablePromise","raceTimeout","timeout","onTimeout","promiseResolve","timer","setTimeout","clearTimeout","asPromise","item","promiseWithResolvers","res","rej","Throttler","constructor","isDisposed","activePromise","queuedPromise","queuedPromiseFactory","queue","promiseFactory","Error","onComplete","Sequencer","current","promiseTask","SequencerByKey","promiseMap","Map","key","runningPromise","get","newPromise","delete","set","timeoutDeferred","fn","scheduled","handle","isTriggered","microtaskDeferred","queueMicrotask","Delayer","defaultDelay","deferred","completionPromise","doResolve","doReject","task","trigger","delay","cancelTimeout","ThrottledDelayer","delayer","throttler","Barrier","_isOpen","_promise","c","e","_completePromise","isOpen","open","wait","AutoOpenBarrier","autoOpenTimeMs","_timeout","millis","disposable","disposableTimeout","handler","store","deleteAndLeak","add","sequence","promiseFactories","results","len","length","next","thenHandler","push","n","first","shouldStop","t","loop","factory","Limiter","maxDegreeOfParalellism","_size","_isDisposed","outstandingPromises","runningPromises","_onDrained","whenIdle","size","toPromise","onDrained","event","consume","iLimitedTask","shift","consumed","fire","clear","Queue","ResourceQueue","queues","drainers","Set","drainListeners","drainListenerCount","whenDrained","isDrained","DeferredPromise","p","queueSize","resource","extUri$1","getComparisonKey","queueFor","drainListenerId","drainListener","once","onDidQueueDrain","deleteAndDispose","releaseDrainers","drainer","complete","TimeoutTimer","runner","_token","setIfNotSet","cancelAndSet","IntervalTimer","interval","context","globalThis","setInterval","clearInterval","RunOnceScheduler","timeoutToken","timeoutHandler","bind","isScheduled","schedule","flush","doRun","RunOnceWorker","units","work","unit","runWhenGlobalIdle","_runWhenIdle","requestIdleCallback","cancelIdleCallback","_targetWindow","disposed","end","Date","now","deadline","didTimeout","timeRemaining","Math","max","Object","freeze","targetWindow","AbstractIdleValue","executor","_didRun","_executor","_value","_error","_handle","isInitialized","GlobalIdleValue","retry","retries","lastError","i","error","TaskSequentializer","isRunning","taskId","_running","running","cancelRunning","run","onCancel","doneRunning","runQueued","_queued","queued","promiseReject","hasQueued","join","IntervalCounter","nowFn","lastIncrementTime","increment","isRejected","outcome","isResolved","isSettled","completeCallback","errorCallback","Promises","settled","firstError","all","withAsyncBody","bodyFn","StatefulPromise","_isResolved","requireValue","LazyStatefulPromise","_compute","getPromise","currentValue","rawValue","AsyncIterableObject","fromArray","items","writer","emitMany","fromPromise","emitter","fromPromises","emitOne","merge","iterables","iterable","EMPTY","onReturn","_state","_results","_onReturn","_onStateChanged","Symbol","asyncIterator","done","return","mapFn","filter","filterFn","coalesce","values","concat","CancelableAsyncIterableObject","_source","createCancelableAsyncIterable","innerIterable","isCancellationRequested","AsyncIterableSource","_deferred","_asyncIterable","earlyError","earlyItems","_errorFn","_emitFn","asyncIterable"],"sources":["/Users/phamtu/Downloads/Code/OCE/oce-frontend/node_modules/vscode/vscode/src/vs/base/common/async.js"],"sourcesContent":["import { CancellationTokenSource } from './cancellation.js';\nimport { CancellationError, BugIndicatingError } from './errors.js';\nimport { Emitter, Event } from './event.js';\nimport { toDisposable, DisposableMap } from './lifecycle.js';\nimport { extUri } from './resources.js';\nimport { setTimeout0 } from './platform.js';\nimport { MicrotaskDelay } from './symbols.js';\nimport { Lazy } from './lazy.js';\nfunction isThenable(obj) {\n    return !!obj && typeof obj.then === 'function';\n}\nfunction createCancelablePromise(callback) {\n    const source = ( new CancellationTokenSource());\n    const thenable = callback(source.token);\n    const promise = ( new Promise((resolve, reject) => {\n        const subscription = source.token.onCancellationRequested(() => {\n            subscription.dispose();\n            reject(( new CancellationError()));\n        });\n        Promise.resolve(thenable).then(value => {\n            subscription.dispose();\n            source.dispose();\n            resolve(value);\n        }, err => {\n            subscription.dispose();\n            source.dispose();\n            reject(err);\n        });\n    }));\n    return new (class {\n        cancel() {\n            source.cancel();\n            source.dispose();\n        }\n        then(resolve, reject) {\n            return promise.then(resolve, reject);\n        }\n        catch(reject) {\n            return this.then(undefined, reject);\n        }\n        finally(onfinally) {\n            return promise.finally(onfinally);\n        }\n    });\n}\nfunction raceCancellation(promise, token, defaultValue) {\n    return ( new Promise((resolve, reject) => {\n        const ref = token.onCancellationRequested(() => {\n            ref.dispose();\n            resolve(defaultValue);\n        });\n        promise.then(resolve, reject).finally(() => ref.dispose());\n    }));\n}\nfunction raceCancellationError(promise, token) {\n    return ( new Promise((resolve, reject) => {\n        const ref = token.onCancellationRequested(() => {\n            ref.dispose();\n            reject(( new CancellationError()));\n        });\n        promise.then(resolve, reject).finally(() => ref.dispose());\n    }));\n}\nasync function raceCancellablePromises(cancellablePromises) {\n    let resolvedPromiseIndex = -1;\n    const promises = ( cancellablePromises.map(\n        (promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; })\n    ));\n    try {\n        const result = await Promise.race(promises);\n        return result;\n    }\n    finally {\n        cancellablePromises.forEach((cancellablePromise, index) => {\n            if (index !== resolvedPromiseIndex) {\n                cancellablePromise.cancel();\n            }\n        });\n    }\n}\nfunction raceTimeout(promise, timeout, onTimeout) {\n    let promiseResolve = undefined;\n    const timer = setTimeout(() => {\n        promiseResolve?.(undefined);\n        onTimeout?.();\n    }, timeout);\n    return Promise.race([\n        promise.finally(() => clearTimeout(timer)),\n        ( new Promise(resolve => promiseResolve = resolve))\n    ]);\n}\nfunction asPromise(callback) {\n    return ( new Promise((resolve, reject) => {\n        const item = callback();\n        if (isThenable(item)) {\n            item.then(resolve, reject);\n        }\n        else {\n            resolve(item);\n        }\n    }));\n}\nfunction promiseWithResolvers() {\n    let resolve;\n    let reject;\n    const promise = ( new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    }));\n    return { promise, resolve: resolve, reject: reject };\n}\nclass Throttler {\n    constructor() {\n        this.isDisposed = false;\n        this.activePromise = null;\n        this.queuedPromise = null;\n        this.queuedPromiseFactory = null;\n    }\n    queue(promiseFactory) {\n        if (this.isDisposed) {\n            return Promise.reject(( new Error('Throttler is disposed')));\n        }\n        if (this.activePromise) {\n            this.queuedPromiseFactory = promiseFactory;\n            if (!this.queuedPromise) {\n                const onComplete = () => {\n                    this.queuedPromise = null;\n                    if (this.isDisposed) {\n                        return;\n                    }\n                    const result = this.queue(this.queuedPromiseFactory);\n                    this.queuedPromiseFactory = null;\n                    return result;\n                };\n                this.queuedPromise = ( new Promise(resolve => {\n                    this.activePromise.then(onComplete, onComplete).then(resolve);\n                }));\n            }\n            return ( new Promise((resolve, reject) => {\n                this.queuedPromise.then(resolve, reject);\n            }));\n        }\n        this.activePromise = promiseFactory();\n        return ( new Promise((resolve, reject) => {\n            this.activePromise.then((result) => {\n                this.activePromise = null;\n                resolve(result);\n            }, (err) => {\n                this.activePromise = null;\n                reject(err);\n            });\n        }));\n    }\n    dispose() {\n        this.isDisposed = true;\n    }\n}\nclass Sequencer {\n    constructor() {\n        this.current = Promise.resolve(null);\n    }\n    queue(promiseTask) {\n        return this.current = this.current.then(() => promiseTask(), () => promiseTask());\n    }\n}\nclass SequencerByKey {\n    constructor() {\n        this.promiseMap = ( new Map());\n    }\n    queue(key, promiseTask) {\n        const runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n        const newPromise = runningPromise\n            .catch(() => { })\n            .then(promiseTask)\n            .finally(() => {\n            if (this.promiseMap.get(key) === newPromise) {\n                this.promiseMap.delete(key);\n            }\n        });\n        this.promiseMap.set(key, newPromise);\n        return newPromise;\n    }\n}\nconst timeoutDeferred = (timeout, fn) => {\n    let scheduled = true;\n    const handle = setTimeout(() => {\n        scheduled = false;\n        fn();\n    }, timeout);\n    return {\n        isTriggered: () => scheduled,\n        dispose: () => {\n            clearTimeout(handle);\n            scheduled = false;\n        },\n    };\n};\nconst microtaskDeferred = (fn) => {\n    let scheduled = true;\n    queueMicrotask(() => {\n        if (scheduled) {\n            scheduled = false;\n            fn();\n        }\n    });\n    return {\n        isTriggered: () => scheduled,\n        dispose: () => { scheduled = false; },\n    };\n};\nclass Delayer {\n    constructor(defaultDelay) {\n        this.defaultDelay = defaultDelay;\n        this.deferred = null;\n        this.completionPromise = null;\n        this.doResolve = null;\n        this.doReject = null;\n        this.task = null;\n    }\n    trigger(task, delay = this.defaultDelay) {\n        this.task = task;\n        this.cancelTimeout();\n        if (!this.completionPromise) {\n            this.completionPromise = ( new Promise((resolve, reject) => {\n                this.doResolve = resolve;\n                this.doReject = reject;\n            })).then(() => {\n                this.completionPromise = null;\n                this.doResolve = null;\n                if (this.task) {\n                    const task = this.task;\n                    this.task = null;\n                    return task();\n                }\n                return undefined;\n            });\n        }\n        const fn = () => {\n            this.deferred = null;\n            this.doResolve?.(null);\n        };\n        this.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n        return this.completionPromise;\n    }\n    isTriggered() {\n        return !!this.deferred?.isTriggered();\n    }\n    cancel() {\n        this.cancelTimeout();\n        if (this.completionPromise) {\n            this.doReject?.(( new CancellationError()));\n            this.completionPromise = null;\n        }\n    }\n    cancelTimeout() {\n        this.deferred?.dispose();\n        this.deferred = null;\n    }\n    dispose() {\n        this.cancel();\n    }\n}\nclass ThrottledDelayer {\n    constructor(defaultDelay) {\n        this.delayer = ( new Delayer(defaultDelay));\n        this.throttler = ( new Throttler());\n    }\n    trigger(promiseFactory, delay) {\n        return this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay);\n    }\n    isTriggered() {\n        return this.delayer.isTriggered();\n    }\n    cancel() {\n        this.delayer.cancel();\n    }\n    dispose() {\n        this.delayer.dispose();\n        this.throttler.dispose();\n    }\n}\nclass Barrier {\n    constructor() {\n        this._isOpen = false;\n        this._promise = ( new Promise((c, e) => {\n            this._completePromise = c;\n        }));\n    }\n    isOpen() {\n        return this._isOpen;\n    }\n    open() {\n        this._isOpen = true;\n        this._completePromise(true);\n    }\n    wait() {\n        return this._promise;\n    }\n}\nclass AutoOpenBarrier extends Barrier {\n    constructor(autoOpenTimeMs) {\n        super();\n        this._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n    }\n    open() {\n        clearTimeout(this._timeout);\n        super.open();\n    }\n}\nfunction timeout(millis, token) {\n    if (!token) {\n        return createCancelablePromise(token => timeout(millis, token));\n    }\n    return ( new Promise((resolve, reject) => {\n        const handle = setTimeout(() => {\n            disposable.dispose();\n            resolve();\n        }, millis);\n        const disposable = token.onCancellationRequested(() => {\n            clearTimeout(handle);\n            disposable.dispose();\n            reject(( new CancellationError()));\n        });\n    }));\n}\nfunction disposableTimeout(handler, timeout = 0, store) {\n    const timer = setTimeout(() => {\n        handler();\n        if (store) {\n            disposable.dispose();\n        }\n    }, timeout);\n    const disposable = toDisposable(() => {\n        clearTimeout(timer);\n        store?.deleteAndLeak(disposable);\n    });\n    store?.add(disposable);\n    return disposable;\n}\nfunction sequence(promiseFactories) {\n    const results = [];\n    let index = 0;\n    const len = promiseFactories.length;\n    function next() {\n        return index < len ? promiseFactories[index++]() : null;\n    }\n    function thenHandler(result) {\n        if (result !== undefined && result !== null) {\n            results.push(result);\n        }\n        const n = next();\n        if (n) {\n            return n.then(thenHandler);\n        }\n        return Promise.resolve(results);\n    }\n    return Promise.resolve(null).then(thenHandler);\n}\nfunction first(promiseFactories, shouldStop = t => !!t, defaultValue = null) {\n    let index = 0;\n    const len = promiseFactories.length;\n    const loop = () => {\n        if (index >= len) {\n            return Promise.resolve(defaultValue);\n        }\n        const factory = promiseFactories[index++];\n        const promise = Promise.resolve(factory());\n        return promise.then(result => {\n            if (shouldStop(result)) {\n                return Promise.resolve(result);\n            }\n            return loop();\n        });\n    };\n    return loop();\n}\nclass Limiter {\n    constructor(maxDegreeOfParalellism) {\n        this._size = 0;\n        this._isDisposed = false;\n        this.maxDegreeOfParalellism = maxDegreeOfParalellism;\n        this.outstandingPromises = [];\n        this.runningPromises = 0;\n        this._onDrained = ( new Emitter());\n    }\n    whenIdle() {\n        return this.size > 0\n            ? Event.toPromise(this.onDrained)\n            : Promise.resolve();\n    }\n    get onDrained() {\n        return this._onDrained.event;\n    }\n    get size() {\n        return this._size;\n    }\n    queue(factory) {\n        if (this._isDisposed) {\n            throw ( new Error('Object has been disposed'));\n        }\n        this._size++;\n        return ( new Promise((c, e) => {\n            this.outstandingPromises.push({ factory, c, e });\n            this.consume();\n        }));\n    }\n    consume() {\n        while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n            const iLimitedTask = this.outstandingPromises.shift();\n            this.runningPromises++;\n            const promise = iLimitedTask.factory();\n            promise.then(iLimitedTask.c, iLimitedTask.e);\n            promise.then(() => this.consumed(), () => this.consumed());\n        }\n    }\n    consumed() {\n        if (this._isDisposed) {\n            return;\n        }\n        this.runningPromises--;\n        if (--this._size === 0) {\n            this._onDrained.fire();\n        }\n        if (this.outstandingPromises.length > 0) {\n            this.consume();\n        }\n    }\n    clear() {\n        if (this._isDisposed) {\n            throw ( new Error('Object has been disposed'));\n        }\n        this.outstandingPromises.length = 0;\n        this._size = this.runningPromises;\n    }\n    dispose() {\n        this._isDisposed = true;\n        this.outstandingPromises.length = 0;\n        this._size = 0;\n        this._onDrained.dispose();\n    }\n}\nclass Queue extends Limiter {\n    constructor() {\n        super(1);\n    }\n}\nclass ResourceQueue {\n    constructor() {\n        this.queues = ( new Map());\n        this.drainers = ( new Set());\n        this.drainListeners = undefined;\n        this.drainListenerCount = 0;\n    }\n    async whenDrained() {\n        if (this.isDrained()) {\n            return;\n        }\n        const promise = ( new DeferredPromise());\n        this.drainers.add(promise);\n        return promise.p;\n    }\n    isDrained() {\n        for (const [, queue] of this.queues) {\n            if (queue.size > 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    queueSize(resource, extUri$1 = extUri) {\n        const key = extUri$1.getComparisonKey(resource);\n        return this.queues.get(key)?.size ?? 0;\n    }\n    queueFor(resource, factory, extUri$1 = extUri) {\n        const key = extUri$1.getComparisonKey(resource);\n        let queue = this.queues.get(key);\n        if (!queue) {\n            queue = ( new Queue());\n            const drainListenerId = this.drainListenerCount++;\n            const drainListener = Event.once(queue.onDrained)(() => {\n                queue?.dispose();\n                this.queues.delete(key);\n                this.onDidQueueDrain();\n                this.drainListeners?.deleteAndDispose(drainListenerId);\n                if (this.drainListeners?.size === 0) {\n                    this.drainListeners.dispose();\n                    this.drainListeners = undefined;\n                }\n            });\n            if (!this.drainListeners) {\n                this.drainListeners = ( new DisposableMap());\n            }\n            this.drainListeners.set(drainListenerId, drainListener);\n            this.queues.set(key, queue);\n        }\n        return queue.queue(factory);\n    }\n    onDidQueueDrain() {\n        if (!this.isDrained()) {\n            return;\n        }\n        this.releaseDrainers();\n    }\n    releaseDrainers() {\n        for (const drainer of this.drainers) {\n            drainer.complete();\n        }\n        this.drainers.clear();\n    }\n    dispose() {\n        for (const [, queue] of this.queues) {\n            queue.dispose();\n        }\n        this.queues.clear();\n        this.releaseDrainers();\n        this.drainListeners?.dispose();\n    }\n}\nclass TimeoutTimer {\n    constructor(runner, timeout) {\n        this._token = -1;\n        if (typeof runner === 'function' && typeof timeout === 'number') {\n            this.setIfNotSet(runner, timeout);\n        }\n    }\n    dispose() {\n        this.cancel();\n    }\n    cancel() {\n        if (this._token !== -1) {\n            clearTimeout(this._token);\n            this._token = -1;\n        }\n    }\n    cancelAndSet(runner, timeout) {\n        this.cancel();\n        this._token = setTimeout(() => {\n            this._token = -1;\n            runner();\n        }, timeout);\n    }\n    setIfNotSet(runner, timeout) {\n        if (this._token !== -1) {\n            return;\n        }\n        this._token = setTimeout(() => {\n            this._token = -1;\n            runner();\n        }, timeout);\n    }\n}\nclass IntervalTimer {\n    constructor() {\n        this.disposable = undefined;\n    }\n    cancel() {\n        this.disposable?.dispose();\n        this.disposable = undefined;\n    }\n    cancelAndSet(runner, interval, context = globalThis) {\n        this.cancel();\n        const handle = context.setInterval(() => {\n            runner();\n        }, interval);\n        this.disposable = toDisposable(() => {\n            context.clearInterval(handle);\n            this.disposable = undefined;\n        });\n    }\n    dispose() {\n        this.cancel();\n    }\n}\nclass RunOnceScheduler {\n    constructor(runner, delay) {\n        this.timeoutToken = -1;\n        this.runner = runner;\n        this.timeout = delay;\n        this.timeoutHandler = this.onTimeout.bind(this);\n    }\n    dispose() {\n        this.cancel();\n        this.runner = null;\n    }\n    cancel() {\n        if (this.isScheduled()) {\n            clearTimeout(this.timeoutToken);\n            this.timeoutToken = -1;\n        }\n    }\n    schedule(delay = this.timeout) {\n        this.cancel();\n        this.timeoutToken = setTimeout(this.timeoutHandler, delay);\n    }\n    get delay() {\n        return this.timeout;\n    }\n    set delay(value) {\n        this.timeout = value;\n    }\n    isScheduled() {\n        return this.timeoutToken !== -1;\n    }\n    flush() {\n        if (this.isScheduled()) {\n            this.cancel();\n            this.doRun();\n        }\n    }\n    onTimeout() {\n        this.timeoutToken = -1;\n        if (this.runner) {\n            this.doRun();\n        }\n    }\n    doRun() {\n        this.runner?.();\n    }\n}\nclass RunOnceWorker extends RunOnceScheduler {\n    constructor(runner, timeout) {\n        super(runner, timeout);\n        this.units = [];\n    }\n    work(unit) {\n        this.units.push(unit);\n        if (!this.isScheduled()) {\n            this.schedule();\n        }\n    }\n    doRun() {\n        const units = this.units;\n        this.units = [];\n        this.runner?.(units);\n    }\n    dispose() {\n        this.units = [];\n        super.dispose();\n    }\n}\nlet runWhenGlobalIdle;\nlet _runWhenIdle;\n(function () {\n    if (typeof globalThis.requestIdleCallback !== 'function' || typeof globalThis.cancelIdleCallback !== 'function') {\n        _runWhenIdle = (_targetWindow, runner) => {\n            setTimeout0(() => {\n                if (disposed) {\n                    return;\n                }\n                const end = Date.now() + 15;\n                const deadline = {\n                    didTimeout: true,\n                    timeRemaining() {\n                        return Math.max(0, end - Date.now());\n                    }\n                };\n                runner(( Object.freeze(deadline)));\n            });\n            let disposed = false;\n            return {\n                dispose() {\n                    if (disposed) {\n                        return;\n                    }\n                    disposed = true;\n                }\n            };\n        };\n    }\n    else {\n        _runWhenIdle = (targetWindow, runner, timeout) => {\n            const handle = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n            let disposed = false;\n            return {\n                dispose() {\n                    if (disposed) {\n                        return;\n                    }\n                    disposed = true;\n                    targetWindow.cancelIdleCallback(handle);\n                }\n            };\n        };\n    }\n    runWhenGlobalIdle = (runner) => _runWhenIdle(globalThis, runner);\n})();\nclass AbstractIdleValue {\n    constructor(targetWindow, executor) {\n        this._didRun = false;\n        this._executor = () => {\n            try {\n                this._value = executor();\n            }\n            catch (err) {\n                this._error = err;\n            }\n            finally {\n                this._didRun = true;\n            }\n        };\n        this._handle = _runWhenIdle(targetWindow, () => this._executor());\n    }\n    dispose() {\n        this._handle.dispose();\n    }\n    get value() {\n        if (!this._didRun) {\n            this._handle.dispose();\n            this._executor();\n        }\n        if (this._error) {\n            throw this._error;\n        }\n        return this._value;\n    }\n    get isInitialized() {\n        return this._didRun;\n    }\n}\nclass GlobalIdleValue extends AbstractIdleValue {\n    constructor(executor) {\n        super(globalThis, executor);\n    }\n}\nasync function retry(task, delay, retries) {\n    let lastError;\n    for (let i = 0; i < retries; i++) {\n        try {\n            return await task();\n        }\n        catch (error) {\n            lastError = error;\n            await timeout(delay);\n        }\n    }\n    throw lastError;\n}\nclass TaskSequentializer {\n    isRunning(taskId) {\n        if (typeof taskId === 'number') {\n            return this._running?.taskId === taskId;\n        }\n        return !!this._running;\n    }\n    get running() {\n        return this._running?.promise;\n    }\n    cancelRunning() {\n        this._running?.cancel();\n    }\n    run(taskId, promise, onCancel) {\n        this._running = { taskId, cancel: () => onCancel?.(), promise };\n        promise.then(() => this.doneRunning(taskId), () => this.doneRunning(taskId));\n        return promise;\n    }\n    doneRunning(taskId) {\n        if (this._running && taskId === this._running.taskId) {\n            this._running = undefined;\n            this.runQueued();\n        }\n    }\n    runQueued() {\n        if (this._queued) {\n            const queued = this._queued;\n            this._queued = undefined;\n            queued.run().then(queued.promiseResolve, queued.promiseReject);\n        }\n    }\n    queue(run) {\n        if (!this._queued) {\n            const { promise, resolve: promiseResolve, reject: promiseReject } = promiseWithResolvers();\n            this._queued = {\n                run,\n                promise,\n                promiseResolve: promiseResolve,\n                promiseReject: promiseReject\n            };\n        }\n        else {\n            this._queued.run = run;\n        }\n        return this._queued.promise;\n    }\n    hasQueued() {\n        return !!this._queued;\n    }\n    async join() {\n        return this._queued?.promise ?? this._running?.promise;\n    }\n}\nclass IntervalCounter {\n    constructor(interval, nowFn = () => Date.now()) {\n        this.interval = interval;\n        this.nowFn = nowFn;\n        this.lastIncrementTime = 0;\n        this.value = 0;\n    }\n    increment() {\n        const now = this.nowFn();\n        if (now - this.lastIncrementTime > this.interval) {\n            this.lastIncrementTime = now;\n            this.value = 0;\n        }\n        this.value++;\n        return this.value;\n    }\n}\nclass DeferredPromise {\n    get isRejected() {\n        return this.outcome?.outcome === 1 ;\n    }\n    get isResolved() {\n        return this.outcome?.outcome === 0 ;\n    }\n    get isSettled() {\n        return !!this.outcome;\n    }\n    get value() {\n        return this.outcome?.outcome === 0  ? this.outcome?.value : undefined;\n    }\n    constructor() {\n        this.p = ( new Promise((c, e) => {\n            this.completeCallback = c;\n            this.errorCallback = e;\n        }));\n    }\n    complete(value) {\n        return ( new Promise(resolve => {\n            this.completeCallback(value);\n            this.outcome = { outcome: 0 , value };\n            resolve();\n        }));\n    }\n    error(err) {\n        return ( new Promise(resolve => {\n            this.errorCallback(err);\n            this.outcome = { outcome: 1 , value: err };\n            resolve();\n        }));\n    }\n    cancel() {\n        return this.error(( new CancellationError()));\n    }\n}\nvar Promises;\n( (function(Promises) {\n    async function settled(promises) {\n        let firstError = undefined;\n        const result = await Promise.all(( promises.map(promise => promise.then(value => value, error => {\n            if (!firstError) {\n                firstError = error;\n            }\n            return undefined;\n        }))));\n        if (typeof firstError !== 'undefined') {\n            throw firstError;\n        }\n        return result;\n    }\n    Promises.settled = settled;\n    function withAsyncBody(bodyFn) {\n        return ( new Promise(async (resolve, reject) => {\n            try {\n                await bodyFn(resolve, reject);\n            }\n            catch (error) {\n                reject(error);\n            }\n        }));\n    }\n    Promises.withAsyncBody = withAsyncBody;\n})(Promises || (Promises = {})));\nclass StatefulPromise {\n    get value() { return this._value; }\n    get error() { return this._error; }\n    get isResolved() { return this._isResolved; }\n    constructor(promise) {\n        this._value = undefined;\n        this._error = undefined;\n        this._isResolved = false;\n        this.promise = promise.then(value => {\n            this._value = value;\n            this._isResolved = true;\n            return value;\n        }, error => {\n            this._error = error;\n            this._isResolved = true;\n            throw error;\n        });\n    }\n    requireValue() {\n        if (!this._isResolved) {\n            throw ( new BugIndicatingError('Promise is not resolved yet'));\n        }\n        if (this._error) {\n            throw this._error;\n        }\n        return this._value;\n    }\n}\nclass LazyStatefulPromise {\n    constructor(_compute) {\n        this._compute = _compute;\n        this._promise = ( new Lazy(() => ( new StatefulPromise(this._compute()))));\n    }\n    requireValue() {\n        return this._promise.value.requireValue();\n    }\n    getPromise() {\n        return this._promise.value.promise;\n    }\n    get currentValue() {\n        return this._promise.rawValue?.value;\n    }\n}\nclass AsyncIterableObject {\n    static fromArray(items) {\n        return ( new AsyncIterableObject((writer) => {\n            writer.emitMany(items);\n        }));\n    }\n    static fromPromise(promise) {\n        return ( new AsyncIterableObject(async (emitter) => {\n            emitter.emitMany(await promise);\n        }));\n    }\n    static fromPromises(promises) {\n        return ( new AsyncIterableObject(async (emitter) => {\n            await Promise.all(( promises.map(async (p) => emitter.emitOne(await p))));\n        }));\n    }\n    static merge(iterables) {\n        return ( new AsyncIterableObject(async (emitter) => {\n            await Promise.all(( iterables.map(async (iterable) => {\n                for await (const item of iterable) {\n                    emitter.emitOne(item);\n                }\n            })));\n        }));\n    }\n    static { this.EMPTY = AsyncIterableObject.fromArray([]); }\n    constructor(executor, onReturn) {\n        this._state = 0 ;\n        this._results = [];\n        this._error = null;\n        this._onReturn = onReturn;\n        this._onStateChanged = ( new Emitter());\n        queueMicrotask(async () => {\n            const writer = {\n                emitOne: (item) => this.emitOne(item),\n                emitMany: (items) => this.emitMany(items),\n                reject: (error) => this.reject(error)\n            };\n            try {\n                await Promise.resolve(executor(writer));\n                this.resolve();\n            }\n            catch (err) {\n                this.reject(err);\n            }\n            finally {\n                writer.emitOne = undefined;\n                writer.emitMany = undefined;\n                writer.reject = undefined;\n            }\n        });\n    }\n    [Symbol.asyncIterator]() {\n        let i = 0;\n        return {\n            next: async () => {\n                do {\n                    if (this._state === 2 ) {\n                        throw this._error;\n                    }\n                    if (i < this._results.length) {\n                        return { done: false, value: this._results[i++] };\n                    }\n                    if (this._state === 1 ) {\n                        return { done: true, value: undefined };\n                    }\n                    await Event.toPromise(this._onStateChanged.event);\n                } while (true);\n            },\n            return: async () => {\n                this._onReturn?.();\n                return { done: true, value: undefined };\n            }\n        };\n    }\n    static map(iterable, mapFn) {\n        return ( new AsyncIterableObject(async (emitter) => {\n            for await (const item of iterable) {\n                emitter.emitOne(mapFn(item));\n            }\n        }));\n    }\n    map(mapFn) {\n        return ( AsyncIterableObject.map(this, mapFn));\n    }\n    static filter(iterable, filterFn) {\n        return ( new AsyncIterableObject(async (emitter) => {\n            for await (const item of iterable) {\n                if (filterFn(item)) {\n                    emitter.emitOne(item);\n                }\n            }\n        }));\n    }\n    filter(filterFn) {\n        return AsyncIterableObject.filter(this, filterFn);\n    }\n    static coalesce(iterable) {\n        return AsyncIterableObject.filter(iterable, item => !!item);\n    }\n    coalesce() {\n        return AsyncIterableObject.coalesce(this);\n    }\n    static async toPromise(iterable) {\n        const result = [];\n        for await (const item of iterable) {\n            result.push(item);\n        }\n        return result;\n    }\n    toPromise() {\n        return AsyncIterableObject.toPromise(this);\n    }\n    emitOne(value) {\n        if (this._state !== 0 ) {\n            return;\n        }\n        this._results.push(value);\n        this._onStateChanged.fire();\n    }\n    emitMany(values) {\n        if (this._state !== 0 ) {\n            return;\n        }\n        this._results = this._results.concat(values);\n        this._onStateChanged.fire();\n    }\n    resolve() {\n        if (this._state !== 0 ) {\n            return;\n        }\n        this._state = 1 ;\n        this._onStateChanged.fire();\n    }\n    reject(error) {\n        if (this._state !== 0 ) {\n            return;\n        }\n        this._state = 2 ;\n        this._error = error;\n        this._onStateChanged.fire();\n    }\n}\nclass CancelableAsyncIterableObject extends AsyncIterableObject {\n    constructor(_source, executor) {\n        super(executor);\n        this._source = _source;\n    }\n    cancel() {\n        this._source.cancel();\n    }\n}\nfunction createCancelableAsyncIterable(callback) {\n    const source = ( new CancellationTokenSource());\n    const innerIterable = callback(source.token);\n    return ( new CancelableAsyncIterableObject(source, async (emitter) => {\n        const subscription = source.token.onCancellationRequested(() => {\n            subscription.dispose();\n            source.dispose();\n            emitter.reject(( new CancellationError()));\n        });\n        try {\n            for await (const item of innerIterable) {\n                if (source.token.isCancellationRequested) {\n                    return;\n                }\n                emitter.emitOne(item);\n            }\n            subscription.dispose();\n            source.dispose();\n        }\n        catch (err) {\n            subscription.dispose();\n            source.dispose();\n            emitter.reject(err);\n        }\n    }));\n}\nclass AsyncIterableSource {\n    constructor(onReturn) {\n        this._deferred = ( new DeferredPromise());\n        this._asyncIterable = ( new AsyncIterableObject(emitter => {\n            if (earlyError) {\n                emitter.reject(earlyError);\n                return;\n            }\n            if (earlyItems) {\n                emitter.emitMany(earlyItems);\n            }\n            this._errorFn = (error) => emitter.reject(error);\n            this._emitFn = (item) => emitter.emitOne(item);\n            return this._deferred.p;\n        }, onReturn));\n        let earlyError;\n        let earlyItems;\n        this._emitFn = (item) => {\n            if (!earlyItems) {\n                earlyItems = [];\n            }\n            earlyItems.push(item);\n        };\n        this._errorFn = (error) => {\n            if (!earlyError) {\n                earlyError = error;\n            }\n        };\n    }\n    get asyncIterable() {\n        return this._asyncIterable;\n    }\n    resolve() {\n        this._deferred.complete();\n    }\n    reject(error) {\n        this._errorFn(error);\n        this._deferred.complete();\n    }\n    emitOne(item) {\n        this._emitFn(item);\n    }\n}\nexport { AbstractIdleValue, AsyncIterableObject, AsyncIterableSource, AutoOpenBarrier, Barrier, CancelableAsyncIterableObject, DeferredPromise, Delayer, GlobalIdleValue, IntervalCounter, IntervalTimer, LazyStatefulPromise, Limiter, Promises, Queue, ResourceQueue, RunOnceScheduler, RunOnceWorker, Sequencer, SequencerByKey, StatefulPromise, TaskSequentializer, ThrottledDelayer, Throttler, TimeoutTimer, _runWhenIdle, asPromise, createCancelableAsyncIterable, createCancelablePromise, disposableTimeout, first, isThenable, promiseWithResolvers, raceCancellablePromises, raceCancellation, raceCancellationError, raceTimeout, retry, runWhenGlobalIdle, sequence, timeout };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}