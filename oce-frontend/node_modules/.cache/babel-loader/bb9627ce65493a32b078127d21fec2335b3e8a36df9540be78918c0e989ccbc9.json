{"ast":null,"code":"import { LRUCache } from './map.js';\nimport { getKoreanAltChars } from './naturalLanguage/korean.js';\nimport { startsWithIgnoreCase, convertSimple2RegExpPattern, isEmojiImprecise } from './strings.js';\nfunction or(...filter) {\n  return function (word, wordToMatchAgainst) {\n    for (let i = 0, len = filter.length; i < len; i++) {\n      const match = filter[i](word, wordToMatchAgainst);\n      if (match) {\n        return match;\n      }\n    }\n    return null;\n  };\n}\n_matchesPrefix.bind(undefined, false);\nconst matchesPrefix = _matchesPrefix.bind(undefined, true);\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\n  if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n    return null;\n  }\n  let matches;\n  if (ignoreCase) {\n    matches = startsWithIgnoreCase(wordToMatchAgainst, word);\n  } else {\n    matches = wordToMatchAgainst.indexOf(word) === 0;\n  }\n  if (!matches) {\n    return null;\n  }\n  return word.length > 0 ? [{\n    start: 0,\n    end: word.length\n  }] : [];\n}\nfunction matchesContiguousSubString(word, wordToMatchAgainst) {\n  const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n  if (index === -1) {\n    return null;\n  }\n  return [{\n    start: index,\n    end: index + word.length\n  }];\n}\nfunction matchesSubString(word, wordToMatchAgainst) {\n  return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\n  if (i === word.length) {\n    return [];\n  } else if (j === wordToMatchAgainst.length) {\n    return null;\n  } else {\n    if (word[i] === wordToMatchAgainst[j]) {\n      let result = null;\n      if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n        return join({\n          start: j,\n          end: j + 1\n        }, result);\n      }\n      return null;\n    }\n    return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n  }\n}\nfunction isLower(code) {\n  return 97 <= code && code <= 122;\n}\nfunction isUpper(code) {\n  return 65 <= code && code <= 90;\n}\nfunction isNumber(code) {\n  return 48 <= code && code <= 57;\n}\nfunction isWhitespace(code) {\n  return code === 32 || code === 9 || code === 10 || code === 13;\n}\nconst wordSeparators = new Set();\n'()[]{}<>`\\'\"-/;:,.?!'.split('').forEach(s => wordSeparators.add(s.charCodeAt(0)));\nfunction isWordSeparator(code) {\n  return isWhitespace(code) || wordSeparators.has(code);\n}\nfunction charactersMatch(codeA, codeB) {\n  return codeA === codeB || isWordSeparator(codeA) && isWordSeparator(codeB);\n}\nconst alternateCharsCache = new Map();\nfunction getAlternateCodes(code) {\n  if (alternateCharsCache.has(code)) {\n    return alternateCharsCache.get(code);\n  }\n  let result;\n  const codes = getKoreanAltChars(code);\n  if (codes) {\n    result = codes;\n  }\n  alternateCharsCache.set(code, result);\n  return result;\n}\nfunction isAlphanumeric(code) {\n  return isLower(code) || isUpper(code) || isNumber(code);\n}\nfunction join(head, tail) {\n  if (tail.length === 0) {\n    tail = [head];\n  } else if (head.end === tail[0].start) {\n    tail[0].start = head.start;\n  } else {\n    tail.unshift(head);\n  }\n  return tail;\n}\nfunction nextAnchor(camelCaseWord, start) {\n  for (let i = start; i < camelCaseWord.length; i++) {\n    const c = camelCaseWord.charCodeAt(i);\n    if (isUpper(c) || isNumber(c) || i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1))) {\n      return i;\n    }\n  }\n  return camelCaseWord.length;\n}\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\n  if (i === word.length) {\n    return [];\n  } else if (j === camelCaseWord.length) {\n    return null;\n  } else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n    return null;\n  } else {\n    let result = null;\n    let nextUpperIndex = j + 1;\n    result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n    while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n      result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n      nextUpperIndex++;\n    }\n    return result === null ? null : join({\n      start: j,\n      end: j + 1\n    }, result);\n  }\n}\nfunction analyzeCamelCaseWord(word) {\n  let upper = 0,\n    lower = 0,\n    alpha = 0,\n    numeric = 0,\n    code = 0;\n  for (let i = 0; i < word.length; i++) {\n    code = word.charCodeAt(i);\n    if (isUpper(code)) {\n      upper++;\n    }\n    if (isLower(code)) {\n      lower++;\n    }\n    if (isAlphanumeric(code)) {\n      alpha++;\n    }\n    if (isNumber(code)) {\n      numeric++;\n    }\n  }\n  const upperPercent = upper / word.length;\n  const lowerPercent = lower / word.length;\n  const alphaPercent = alpha / word.length;\n  const numericPercent = numeric / word.length;\n  return {\n    upperPercent,\n    lowerPercent,\n    alphaPercent,\n    numericPercent\n  };\n}\nfunction isUpperCaseWord(analysis) {\n  const {\n    upperPercent,\n    lowerPercent\n  } = analysis;\n  return lowerPercent === 0 && upperPercent > 0.6;\n}\nfunction isCamelCaseWord(analysis) {\n  const {\n    upperPercent,\n    lowerPercent,\n    alphaPercent,\n    numericPercent\n  } = analysis;\n  return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\nfunction isCamelCasePattern(word) {\n  let upper = 0,\n    lower = 0,\n    code = 0,\n    whitespace = 0;\n  for (let i = 0; i < word.length; i++) {\n    code = word.charCodeAt(i);\n    if (isUpper(code)) {\n      upper++;\n    }\n    if (isLower(code)) {\n      lower++;\n    }\n    if (isWhitespace(code)) {\n      whitespace++;\n    }\n  }\n  if ((upper === 0 || lower === 0) && whitespace === 0) {\n    return word.length <= 30;\n  } else {\n    return upper <= 5;\n  }\n}\nfunction matchesCamelCase(word, camelCaseWord) {\n  if (!camelCaseWord) {\n    return null;\n  }\n  camelCaseWord = camelCaseWord.trim();\n  if (camelCaseWord.length === 0) {\n    return null;\n  }\n  if (!isCamelCasePattern(word)) {\n    return null;\n  }\n  if (camelCaseWord.length > 60) {\n    camelCaseWord = camelCaseWord.substring(0, 60);\n  }\n  const analysis = analyzeCamelCaseWord(camelCaseWord);\n  if (!isCamelCaseWord(analysis)) {\n    if (!isUpperCaseWord(analysis)) {\n      return null;\n    }\n    camelCaseWord = camelCaseWord.toLowerCase();\n  }\n  let result = null;\n  let i = 0;\n  word = word.toLowerCase();\n  while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n    i = nextAnchor(camelCaseWord, i + 1);\n  }\n  return result;\n}\nfunction matchesWords(word, target, contiguous = false) {\n  if (!target || target.length === 0) {\n    return null;\n  }\n  let result = null;\n  let targetIndex = 0;\n  word = word.toLowerCase();\n  target = target.toLowerCase();\n  while (targetIndex < target.length) {\n    result = _matchesWords(word, target, 0, targetIndex, contiguous);\n    if (result !== null) {\n      break;\n    }\n    targetIndex = nextWord(target, targetIndex + 1);\n  }\n  return result;\n}\nfunction _matchesWords(word, target, wordIndex, targetIndex, contiguous) {\n  let targetIndexOffset = 0;\n  if (wordIndex === word.length) {\n    return [];\n  } else if (targetIndex === target.length) {\n    return null;\n  } else if (!charactersMatch(word.charCodeAt(wordIndex), target.charCodeAt(targetIndex))) {\n    const altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n    if (!altChars) {\n      return null;\n    }\n    for (let k = 0; k < altChars.length; k++) {\n      if (!charactersMatch(altChars[k], target.charCodeAt(targetIndex + k))) {\n        return null;\n      }\n    }\n    targetIndexOffset += altChars.length - 1;\n  }\n  let result = null;\n  let nextWordIndex = targetIndex + targetIndexOffset + 1;\n  result = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);\n  if (!contiguous) {\n    while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n      result = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);\n      nextWordIndex++;\n    }\n  }\n  if (!result) {\n    return null;\n  }\n  if (word.charCodeAt(wordIndex) !== target.charCodeAt(targetIndex)) {\n    const altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n    if (!altChars) {\n      return result;\n    }\n    for (let k = 0; k < altChars.length; k++) {\n      if (altChars[k] !== target.charCodeAt(targetIndex + k)) {\n        return result;\n      }\n    }\n  }\n  return join({\n    start: targetIndex,\n    end: targetIndex + targetIndexOffset + 1\n  }, result);\n}\nfunction nextWord(word, start) {\n  for (let i = start; i < word.length; i++) {\n    if (isWordSeparator(word.charCodeAt(i)) || i > 0 && isWordSeparator(word.charCodeAt(i - 1))) {\n      return i;\n    }\n  }\n  return word.length;\n}\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = new LRUCache(10000);\nfunction matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching = false) {\n  if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n    return null;\n  }\n  let regexp = fuzzyRegExpCache.get(word);\n  if (!regexp) {\n    regexp = new RegExp(convertSimple2RegExpPattern(word), 'i');\n    fuzzyRegExpCache.set(word, regexp);\n  }\n  const match = regexp.exec(wordToMatchAgainst);\n  if (match) {\n    return [{\n      start: match.index,\n      end: match.index + match[0].length\n    }];\n  }\n  return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\nfunction matchesFuzzy2(pattern, word) {\n  const score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, {\n    firstMatchCanBeWeak: true,\n    boostFullMatch: true\n  });\n  return score ? createMatches(score) : null;\n}\nfunction anyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos) {\n  const max = Math.min(13, pattern.length);\n  for (; patternPos < max; patternPos++) {\n    const result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, {\n      firstMatchCanBeWeak: true,\n      boostFullMatch: true\n    });\n    if (result) {\n      return result;\n    }\n  }\n  return [0, wordPos];\n}\nfunction createMatches(score) {\n  if (typeof score === 'undefined') {\n    return [];\n  }\n  const res = [];\n  const wordPos = score[1];\n  for (let i = score.length - 1; i > 1; i--) {\n    const pos = score[i] + wordPos;\n    const last = res[res.length - 1];\n    if (last && last.end === pos) {\n      last.end = pos + 1;\n    } else {\n      res.push({\n        start: pos,\n        end: pos + 1\n      });\n    }\n  }\n  return res;\n}\nconst _maxLen = 128;\nfunction initTable() {\n  const table = [];\n  const row = [];\n  for (let i = 0; i <= _maxLen; i++) {\n    row[i] = 0;\n  }\n  for (let i = 0; i <= _maxLen; i++) {\n    table.push(row.slice(0));\n  }\n  return table;\n}\nfunction initArr(maxLen) {\n  const row = [];\n  for (let i = 0; i <= maxLen; i++) {\n    row[i] = 0;\n  }\n  return row;\n}\nconst _minWordMatchPos = initArr(2 * _maxLen);\nconst _maxWordMatchPos = initArr(2 * _maxLen);\nconst _diag = initTable();\nconst _table = initTable();\nconst _arrows = initTable();\nfunction isSeparatorAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n  const code = value.codePointAt(index);\n  switch (code) {\n    case 95:\n    case 45:\n    case 46:\n    case 32:\n    case 47:\n    case 92:\n    case 39:\n    case 34:\n    case 58:\n    case 36:\n    case 60:\n    case 62:\n    case 40:\n    case 41:\n    case 91:\n    case 93:\n    case 123:\n    case 125:\n      return true;\n    case undefined:\n      return false;\n    default:\n      if (isEmojiImprecise(code)) {\n        return true;\n      }\n      return false;\n  }\n}\nfunction isWhitespaceAtPos(value, index) {\n  if (index < 0 || index >= value.length) {\n    return false;\n  }\n  const code = value.charCodeAt(index);\n  switch (code) {\n    case 32:\n    case 9:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n  return word[pos] !== wordLow[pos];\n}\nfunction isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {\n  while (patternPos < patternLen && wordPos < wordLen) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      if (fillMinWordPosArr) {\n        _minWordMatchPos[patternPos] = wordPos;\n      }\n      patternPos += 1;\n    }\n    wordPos += 1;\n  }\n  return patternPos === patternLen;\n}\nvar FuzzyScore;\n(function (FuzzyScore) {\n  FuzzyScore.Default = [-100, 0];\n  function isDefault(score) {\n    return !score || score.length === 2 && score[0] === -100 && score[1] === 0;\n  }\n  FuzzyScore.isDefault = isDefault;\n})(FuzzyScore || (FuzzyScore = {}));\nclass FuzzyScoreOptions {\n  static {\n    this.default = {\n      boostFullMatch: true,\n      firstMatchCanBeWeak: false\n    };\n  }\n  constructor(firstMatchCanBeWeak, boostFullMatch) {\n    this.firstMatchCanBeWeak = firstMatchCanBeWeak;\n    this.boostFullMatch = boostFullMatch;\n  }\n}\nfunction fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, options = FuzzyScoreOptions.default) {\n  const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n  const wordLen = word.length > _maxLen ? _maxLen : word.length;\n  if (patternStart >= patternLen || wordStart >= wordLen || patternLen - patternStart > wordLen - wordStart) {\n    return undefined;\n  }\n  if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\n    return undefined;\n  }\n  _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\n  let row = 1;\n  let column = 1;\n  let patternPos = patternStart;\n  let wordPos = wordStart;\n  const hasStrongFirstMatch = [false];\n  for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n    const minWordMatchPos = _minWordMatchPos[patternPos];\n    const maxWordMatchPos = _maxWordMatchPos[patternPos];\n    const nextMaxWordMatchPos = patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen;\n    for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\n      let score = Number.MIN_SAFE_INTEGER;\n      let canComeDiag = false;\n      if (wordPos <= maxWordMatchPos) {\n        score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);\n      }\n      let diagScore = 0;\n      if (score !== Number.MAX_SAFE_INTEGER) {\n        canComeDiag = true;\n        diagScore = score + _table[row - 1][column - 1];\n      }\n      const canComeLeft = wordPos > minWordMatchPos;\n      const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0;\n      const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n      const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0;\n      if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\n        _table[row][column] = leftLeftScore;\n        _arrows[row][column] = 3;\n        _diag[row][column] = 0;\n      } else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n        _table[row][column] = leftScore;\n        _arrows[row][column] = 2;\n        _diag[row][column] = 0;\n      } else if (canComeDiag) {\n        _table[row][column] = diagScore;\n        _arrows[row][column] = 1;\n        _diag[row][column] = _diag[row - 1][column - 1] + 1;\n      } else {\n        throw new Error(`not possible`);\n      }\n    }\n  }\n  if (!hasStrongFirstMatch[0] && !options.firstMatchCanBeWeak) {\n    return undefined;\n  }\n  row--;\n  column--;\n  const result = [_table[row][column], wordStart];\n  let backwardsDiagLength = 0;\n  let maxMatchColumn = 0;\n  while (row >= 1) {\n    let diagColumn = column;\n    do {\n      const arrow = _arrows[row][diagColumn];\n      if (arrow === 3) {\n        diagColumn = diagColumn - 2;\n      } else if (arrow === 2) {\n        diagColumn = diagColumn - 1;\n      } else {\n        break;\n      }\n    } while (diagColumn >= 1);\n    if (backwardsDiagLength > 1 && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1] && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow) && backwardsDiagLength + 1 > _diag[row][diagColumn]) {\n      diagColumn = column;\n    }\n    if (diagColumn === column) {\n      backwardsDiagLength++;\n    } else {\n      backwardsDiagLength = 1;\n    }\n    if (!maxMatchColumn) {\n      maxMatchColumn = diagColumn;\n    }\n    row--;\n    column = diagColumn - 1;\n    result.push(column);\n  }\n  if (wordLen === patternLen && options.boostFullMatch) {\n    result[0] += 2;\n  }\n  const skippedCharsCount = maxMatchColumn - patternLen;\n  result[0] -= skippedCharsCount;\n  return result;\n}\nfunction _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {\n  let patternPos = patternLen - 1;\n  let wordPos = wordLen - 1;\n  while (patternPos >= patternStart && wordPos >= wordStart) {\n    if (patternLow[patternPos] === wordLow[wordPos]) {\n      _maxWordMatchPos[patternPos] = wordPos;\n      patternPos--;\n    }\n    wordPos--;\n  }\n}\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {\n  if (patternLow[patternPos] !== wordLow[wordPos]) {\n    return Number.MIN_SAFE_INTEGER;\n  }\n  let score = 1;\n  let isGapLocation = false;\n  if (wordPos === patternPos - patternStart) {\n    score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n  } else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n    score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n    isGapLocation = true;\n  } else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n    score = 5;\n  } else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n    score = 5;\n    isGapLocation = true;\n  }\n  if (score > 1 && patternPos === patternStart) {\n    outFirstMatchStrong[0] = true;\n  }\n  if (!isGapLocation) {\n    isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\n  }\n  if (patternPos === patternStart) {\n    if (wordPos > wordStart) {\n      score -= isGapLocation ? 3 : 5;\n    }\n  } else {\n    if (newMatchStart) {\n      score += isGapLocation ? 2 : 0;\n    } else {\n      score += isGapLocation ? 0 : 1;\n    }\n  }\n  if (wordPos + 1 === wordLen) {\n    score -= isGapLocation ? 3 : 5;\n  }\n  return score;\n}\nfunction fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, options) {\n  return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options);\n}\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, options) {\n  let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options);\n  if (top && !aggressive) {\n    return top;\n  }\n  if (pattern.length >= 3) {\n    const tries = Math.min(7, pattern.length - 1);\n    for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n      const newPattern = nextTypoPermutation(pattern, movingPatternPos);\n      if (newPattern) {\n        const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, options);\n        if (candidate) {\n          candidate[0] -= 3;\n          if (!top || candidate[0] > top[0]) {\n            top = candidate;\n          }\n        }\n      }\n    }\n  }\n  return top;\n}\nfunction nextTypoPermutation(pattern, patternPos) {\n  if (patternPos + 1 >= pattern.length) {\n    return undefined;\n  }\n  const swap1 = pattern[patternPos];\n  const swap2 = pattern[patternPos + 1];\n  if (swap1 === swap2) {\n    return undefined;\n  }\n  return pattern.slice(0, patternPos) + swap2 + swap1 + pattern.slice(patternPos + 2);\n}\nexport { FuzzyScore, FuzzyScoreOptions, anyScore, createMatches, fuzzyScore, fuzzyScoreGracefulAggressive, isPatternInWord, isUpper, matchesCamelCase, matchesContiguousSubString, matchesFuzzy, matchesFuzzy2, matchesPrefix, matchesSubString, matchesWords, or };","map":{"version":3,"names":["LRUCache","getKoreanAltChars","startsWithIgnoreCase","convertSimple2RegExpPattern","isEmojiImprecise","or","filter","word","wordToMatchAgainst","i","len","length","match","_matchesPrefix","bind","undefined","matchesPrefix","ignoreCase","matches","indexOf","start","end","matchesContiguousSubString","index","toLowerCase","matchesSubString","_matchesSubString","j","result","join","isLower","code","isUpper","isNumber","isWhitespace","wordSeparators","Set","split","forEach","s","add","charCodeAt","isWordSeparator","has","charactersMatch","codeA","codeB","alternateCharsCache","Map","getAlternateCodes","get","codes","set","isAlphanumeric","head","tail","unshift","nextAnchor","camelCaseWord","c","_matchesCamelCase","nextUpperIndex","analyzeCamelCaseWord","upper","lower","alpha","numeric","upperPercent","lowerPercent","alphaPercent","numericPercent","isUpperCaseWord","analysis","isCamelCaseWord","isCamelCasePattern","whitespace","matchesCamelCase","trim","substring","matchesWords","target","contiguous","targetIndex","_matchesWords","nextWord","wordIndex","targetIndexOffset","altChars","k","nextWordIndex","fuzzyContiguousFilter","fuzzySeparateFilter","fuzzyRegExpCache","matchesFuzzy","enableSeparateSubstringMatching","regexp","RegExp","exec","matchesFuzzy2","pattern","score","fuzzyScore","firstMatchCanBeWeak","boostFullMatch","createMatches","anyScore","lowPattern","patternPos","lowWord","wordPos","max","Math","min","res","pos","last","push","_maxLen","initTable","table","row","slice","initArr","maxLen","_minWordMatchPos","_maxWordMatchPos","_diag","_table","_arrows","isSeparatorAtPos","value","codePointAt","isWhitespaceAtPos","isUpperCaseAtPos","wordLow","isPatternInWord","patternLow","patternLen","wordLen","fillMinWordPosArr","FuzzyScore","Default","isDefault","FuzzyScoreOptions","default","constructor","patternStart","wordStart","options","_fillInMaxWordMatchPos","column","hasStrongFirstMatch","minWordMatchPos","maxWordMatchPos","nextMaxWordMatchPos","Number","MIN_SAFE_INTEGER","canComeDiag","_doScore","diagScore","MAX_SAFE_INTEGER","canComeLeft","leftScore","canComeLeftLeft","leftLeftScore","Error","backwardsDiagLength","maxMatchColumn","diagColumn","arrow","skippedCharsCount","newMatchStart","outFirstMatchStrong","isGapLocation","fuzzyScoreGracefulAggressive","fuzzyScoreWithPermutations","aggressive","top","tries","movingPatternPos","newPattern","nextTypoPermutation","candidate","swap1","swap2"],"sources":["/Users/phamtu/Downloads/Code/OCE/oce-frontend/node_modules/vscode/vscode/src/vs/base/common/filters.js"],"sourcesContent":["import { LRUCache } from './map.js';\nimport { getKoreanAltChars } from './naturalLanguage/korean.js';\nimport { startsWithIgnoreCase, convertSimple2RegExpPattern, isEmojiImprecise } from './strings.js';\nfunction or(...filter) {\n    return function (word, wordToMatchAgainst) {\n        for (let i = 0, len = filter.length; i < len; i++) {\n            const match = filter[i](word, wordToMatchAgainst);\n            if (match) {\n                return match;\n            }\n        }\n        return null;\n    };\n}\n_matchesPrefix.bind(undefined, false);\nconst matchesPrefix = _matchesPrefix.bind(undefined, true);\nfunction _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {\n    if (!wordToMatchAgainst || wordToMatchAgainst.length < word.length) {\n        return null;\n    }\n    let matches;\n    if (ignoreCase) {\n        matches = startsWithIgnoreCase(wordToMatchAgainst, word);\n    }\n    else {\n        matches = wordToMatchAgainst.indexOf(word) === 0;\n    }\n    if (!matches) {\n        return null;\n    }\n    return word.length > 0 ? [{ start: 0, end: word.length }] : [];\n}\nfunction matchesContiguousSubString(word, wordToMatchAgainst) {\n    const index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());\n    if (index === -1) {\n        return null;\n    }\n    return [{ start: index, end: index + word.length }];\n}\nfunction matchesSubString(word, wordToMatchAgainst) {\n    return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);\n}\nfunction _matchesSubString(word, wordToMatchAgainst, i, j) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === wordToMatchAgainst.length) {\n        return null;\n    }\n    else {\n        if (word[i] === wordToMatchAgainst[j]) {\n            let result = null;\n            if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {\n                return join({ start: j, end: j + 1 }, result);\n            }\n            return null;\n        }\n        return _matchesSubString(word, wordToMatchAgainst, i, j + 1);\n    }\n}\nfunction isLower(code) {\n    return 97  <= code && code <= 122 ;\n}\nfunction isUpper(code) {\n    return 65  <= code && code <= 90 ;\n}\nfunction isNumber(code) {\n    return 48  <= code && code <= 57 ;\n}\nfunction isWhitespace(code) {\n    return (code === 32\n        || code === 9\n        || code === 10  || code === 13) ;\n}\nconst wordSeparators = ( new Set());\n'()[]{}<>`\\'\"-/;:,.?!'\n    .split('')\n    .forEach(s => wordSeparators.add(s.charCodeAt(0)));\nfunction isWordSeparator(code) {\n    return isWhitespace(code) || ( wordSeparators.has(code));\n}\nfunction charactersMatch(codeA, codeB) {\n    return (codeA === codeB) || (isWordSeparator(codeA) && isWordSeparator(codeB));\n}\nconst alternateCharsCache = ( new Map());\nfunction getAlternateCodes(code) {\n    if (( alternateCharsCache.has(code))) {\n        return alternateCharsCache.get(code);\n    }\n    let result;\n    const codes = getKoreanAltChars(code);\n    if (codes) {\n        result = codes;\n    }\n    alternateCharsCache.set(code, result);\n    return result;\n}\nfunction isAlphanumeric(code) {\n    return isLower(code) || isUpper(code) || isNumber(code);\n}\nfunction join(head, tail) {\n    if (tail.length === 0) {\n        tail = [head];\n    }\n    else if (head.end === tail[0].start) {\n        tail[0].start = head.start;\n    }\n    else {\n        tail.unshift(head);\n    }\n    return tail;\n}\nfunction nextAnchor(camelCaseWord, start) {\n    for (let i = start; i < camelCaseWord.length; i++) {\n        const c = camelCaseWord.charCodeAt(i);\n        if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {\n            return i;\n        }\n    }\n    return camelCaseWord.length;\n}\nfunction _matchesCamelCase(word, camelCaseWord, i, j) {\n    if (i === word.length) {\n        return [];\n    }\n    else if (j === camelCaseWord.length) {\n        return null;\n    }\n    else if (word[i] !== camelCaseWord[j].toLowerCase()) {\n        return null;\n    }\n    else {\n        let result = null;\n        let nextUpperIndex = j + 1;\n        result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);\n        while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {\n            result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);\n            nextUpperIndex++;\n        }\n        return result === null ? null : join({ start: j, end: j + 1 }, result);\n    }\n}\nfunction analyzeCamelCaseWord(word) {\n    let upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;\n    for (let i = 0; i < word.length; i++) {\n        code = word.charCodeAt(i);\n        if (isUpper(code)) {\n            upper++;\n        }\n        if (isLower(code)) {\n            lower++;\n        }\n        if (isAlphanumeric(code)) {\n            alpha++;\n        }\n        if (isNumber(code)) {\n            numeric++;\n        }\n    }\n    const upperPercent = upper / word.length;\n    const lowerPercent = lower / word.length;\n    const alphaPercent = alpha / word.length;\n    const numericPercent = numeric / word.length;\n    return { upperPercent, lowerPercent, alphaPercent, numericPercent };\n}\nfunction isUpperCaseWord(analysis) {\n    const { upperPercent, lowerPercent } = analysis;\n    return lowerPercent === 0 && upperPercent > 0.6;\n}\nfunction isCamelCaseWord(analysis) {\n    const { upperPercent, lowerPercent, alphaPercent, numericPercent } = analysis;\n    return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;\n}\nfunction isCamelCasePattern(word) {\n    let upper = 0, lower = 0, code = 0, whitespace = 0;\n    for (let i = 0; i < word.length; i++) {\n        code = word.charCodeAt(i);\n        if (isUpper(code)) {\n            upper++;\n        }\n        if (isLower(code)) {\n            lower++;\n        }\n        if (isWhitespace(code)) {\n            whitespace++;\n        }\n    }\n    if ((upper === 0 || lower === 0) && whitespace === 0) {\n        return word.length <= 30;\n    }\n    else {\n        return upper <= 5;\n    }\n}\nfunction matchesCamelCase(word, camelCaseWord) {\n    if (!camelCaseWord) {\n        return null;\n    }\n    camelCaseWord = camelCaseWord.trim();\n    if (camelCaseWord.length === 0) {\n        return null;\n    }\n    if (!isCamelCasePattern(word)) {\n        return null;\n    }\n    if (camelCaseWord.length > 60) {\n        camelCaseWord = camelCaseWord.substring(0, 60);\n    }\n    const analysis = analyzeCamelCaseWord(camelCaseWord);\n    if (!isCamelCaseWord(analysis)) {\n        if (!isUpperCaseWord(analysis)) {\n            return null;\n        }\n        camelCaseWord = camelCaseWord.toLowerCase();\n    }\n    let result = null;\n    let i = 0;\n    word = word.toLowerCase();\n    while (i < camelCaseWord.length && (result = _matchesCamelCase(word, camelCaseWord, 0, i)) === null) {\n        i = nextAnchor(camelCaseWord, i + 1);\n    }\n    return result;\n}\nfunction matchesWords(word, target, contiguous = false) {\n    if (!target || target.length === 0) {\n        return null;\n    }\n    let result = null;\n    let targetIndex = 0;\n    word = word.toLowerCase();\n    target = target.toLowerCase();\n    while (targetIndex < target.length) {\n        result = _matchesWords(word, target, 0, targetIndex, contiguous);\n        if (result !== null) {\n            break;\n        }\n        targetIndex = nextWord(target, targetIndex + 1);\n    }\n    return result;\n}\nfunction _matchesWords(word, target, wordIndex, targetIndex, contiguous) {\n    let targetIndexOffset = 0;\n    if (wordIndex === word.length) {\n        return [];\n    }\n    else if (targetIndex === target.length) {\n        return null;\n    }\n    else if (!charactersMatch(word.charCodeAt(wordIndex), target.charCodeAt(targetIndex))) {\n        const altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n        if (!altChars) {\n            return null;\n        }\n        for (let k = 0; k < altChars.length; k++) {\n            if (!charactersMatch(altChars[k], target.charCodeAt(targetIndex + k))) {\n                return null;\n            }\n        }\n        targetIndexOffset += altChars.length - 1;\n    }\n    let result = null;\n    let nextWordIndex = targetIndex + targetIndexOffset + 1;\n    result = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);\n    if (!contiguous) {\n        while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {\n            result = _matchesWords(word, target, wordIndex + 1, nextWordIndex, contiguous);\n            nextWordIndex++;\n        }\n    }\n    if (!result) {\n        return null;\n    }\n    if (word.charCodeAt(wordIndex) !== target.charCodeAt(targetIndex)) {\n        const altChars = getAlternateCodes(word.charCodeAt(wordIndex));\n        if (!altChars) {\n            return result;\n        }\n        for (let k = 0; k < altChars.length; k++) {\n            if (altChars[k] !== target.charCodeAt(targetIndex + k)) {\n                return result;\n            }\n        }\n    }\n    return join({ start: targetIndex, end: targetIndex + targetIndexOffset + 1 }, result);\n}\nfunction nextWord(word, start) {\n    for (let i = start; i < word.length; i++) {\n        if (isWordSeparator(word.charCodeAt(i)) ||\n            (i > 0 && isWordSeparator(word.charCodeAt(i - 1)))) {\n            return i;\n        }\n    }\n    return word.length;\n}\nconst fuzzyContiguousFilter = or(matchesPrefix, matchesCamelCase, matchesContiguousSubString);\nconst fuzzySeparateFilter = or(matchesPrefix, matchesCamelCase, matchesSubString);\nconst fuzzyRegExpCache = ( new LRUCache(10000));\nfunction matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching = false) {\n    if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {\n        return null;\n    }\n    let regexp = fuzzyRegExpCache.get(word);\n    if (!regexp) {\n        regexp = ( new RegExp(convertSimple2RegExpPattern(word), 'i'));\n        fuzzyRegExpCache.set(word, regexp);\n    }\n    const match = regexp.exec(wordToMatchAgainst);\n    if (match) {\n        return [{ start: match.index, end: match.index + match[0].length }];\n    }\n    return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : fuzzyContiguousFilter(word, wordToMatchAgainst);\n}\nfunction matchesFuzzy2(pattern, word) {\n    const score = fuzzyScore(pattern, pattern.toLowerCase(), 0, word, word.toLowerCase(), 0, { firstMatchCanBeWeak: true, boostFullMatch: true });\n    return score ? createMatches(score) : null;\n}\nfunction anyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos) {\n    const max = Math.min(13, pattern.length);\n    for (; patternPos < max; patternPos++) {\n        const result = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, { firstMatchCanBeWeak: true, boostFullMatch: true });\n        if (result) {\n            return result;\n        }\n    }\n    return [0, wordPos];\n}\nfunction createMatches(score) {\n    if (typeof score === 'undefined') {\n        return [];\n    }\n    const res = [];\n    const wordPos = score[1];\n    for (let i = score.length - 1; i > 1; i--) {\n        const pos = score[i] + wordPos;\n        const last = res[res.length - 1];\n        if (last && last.end === pos) {\n            last.end = pos + 1;\n        }\n        else {\n            res.push({ start: pos, end: pos + 1 });\n        }\n    }\n    return res;\n}\nconst _maxLen = 128;\nfunction initTable() {\n    const table = [];\n    const row = [];\n    for (let i = 0; i <= _maxLen; i++) {\n        row[i] = 0;\n    }\n    for (let i = 0; i <= _maxLen; i++) {\n        table.push(row.slice(0));\n    }\n    return table;\n}\nfunction initArr(maxLen) {\n    const row = [];\n    for (let i = 0; i <= maxLen; i++) {\n        row[i] = 0;\n    }\n    return row;\n}\nconst _minWordMatchPos = initArr(2 * _maxLen);\nconst _maxWordMatchPos = initArr(2 * _maxLen);\nconst _diag = initTable();\nconst _table = initTable();\nconst _arrows = initTable();\nfunction isSeparatorAtPos(value, index) {\n    if (index < 0 || index >= value.length) {\n        return false;\n    }\n    const code = value.codePointAt(index);\n    switch (code) {\n        case 95 :\n        case 45 :\n        case 46 :\n        case 32 :\n        case 47 :\n        case 92 :\n        case 39 :\n        case 34 :\n        case 58 :\n        case 36 :\n        case 60 :\n        case 62 :\n        case 40 :\n        case 41 :\n        case 91 :\n        case 93 :\n        case 123 :\n        case 125 :\n            return true;\n        case undefined:\n            return false;\n        default:\n            if (isEmojiImprecise(code)) {\n                return true;\n            }\n            return false;\n    }\n}\nfunction isWhitespaceAtPos(value, index) {\n    if (index < 0 || index >= value.length) {\n        return false;\n    }\n    const code = value.charCodeAt(index);\n    switch (code) {\n        case 32 :\n        case 9 :\n            return true;\n        default:\n            return false;\n    }\n}\nfunction isUpperCaseAtPos(pos, word, wordLow) {\n    return word[pos] !== wordLow[pos];\n}\nfunction isPatternInWord(patternLow, patternPos, patternLen, wordLow, wordPos, wordLen, fillMinWordPosArr = false) {\n    while (patternPos < patternLen && wordPos < wordLen) {\n        if (patternLow[patternPos] === wordLow[wordPos]) {\n            if (fillMinWordPosArr) {\n                _minWordMatchPos[patternPos] = wordPos;\n            }\n            patternPos += 1;\n        }\n        wordPos += 1;\n    }\n    return patternPos === patternLen;\n}\nvar FuzzyScore;\n( (function(FuzzyScore) {\n    FuzzyScore.Default = ([-100, 0]);\n    function isDefault(score) {\n        return !score || (score.length === 2 && score[0] === -100 && score[1] === 0);\n    }\n    FuzzyScore.isDefault = isDefault;\n})(FuzzyScore || (FuzzyScore = {})));\nclass FuzzyScoreOptions {\n    static { this.default = { boostFullMatch: true, firstMatchCanBeWeak: false }; }\n    constructor(firstMatchCanBeWeak, boostFullMatch) {\n        this.firstMatchCanBeWeak = firstMatchCanBeWeak;\n        this.boostFullMatch = boostFullMatch;\n    }\n}\nfunction fuzzyScore(pattern, patternLow, patternStart, word, wordLow, wordStart, options = FuzzyScoreOptions.default) {\n    const patternLen = pattern.length > _maxLen ? _maxLen : pattern.length;\n    const wordLen = word.length > _maxLen ? _maxLen : word.length;\n    if (patternStart >= patternLen || wordStart >= wordLen || (patternLen - patternStart) > (wordLen - wordStart)) {\n        return undefined;\n    }\n    if (!isPatternInWord(patternLow, patternStart, patternLen, wordLow, wordStart, wordLen, true)) {\n        return undefined;\n    }\n    _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow);\n    let row = 1;\n    let column = 1;\n    let patternPos = patternStart;\n    let wordPos = wordStart;\n    const hasStrongFirstMatch = [false];\n    for (row = 1, patternPos = patternStart; patternPos < patternLen; row++, patternPos++) {\n        const minWordMatchPos = _minWordMatchPos[patternPos];\n        const maxWordMatchPos = _maxWordMatchPos[patternPos];\n        const nextMaxWordMatchPos = (patternPos + 1 < patternLen ? _maxWordMatchPos[patternPos + 1] : wordLen);\n        for (column = minWordMatchPos - wordStart + 1, wordPos = minWordMatchPos; wordPos < nextMaxWordMatchPos; column++, wordPos++) {\n            let score = Number.MIN_SAFE_INTEGER;\n            let canComeDiag = false;\n            if (wordPos <= maxWordMatchPos) {\n                score = _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, _diag[row - 1][column - 1] === 0, hasStrongFirstMatch);\n            }\n            let diagScore = 0;\n            if (score !== Number.MAX_SAFE_INTEGER) {\n                canComeDiag = true;\n                diagScore = score + _table[row - 1][column - 1];\n            }\n            const canComeLeft = wordPos > minWordMatchPos;\n            const leftScore = canComeLeft ? _table[row][column - 1] + (_diag[row][column - 1] > 0 ? -5 : 0) : 0;\n            const canComeLeftLeft = wordPos > minWordMatchPos + 1 && _diag[row][column - 1] > 0;\n            const leftLeftScore = canComeLeftLeft ? _table[row][column - 2] + (_diag[row][column - 2] > 0 ? -5 : 0) : 0;\n            if (canComeLeftLeft && (!canComeLeft || leftLeftScore >= leftScore) && (!canComeDiag || leftLeftScore >= diagScore)) {\n                _table[row][column] = leftLeftScore;\n                _arrows[row][column] = 3 ;\n                _diag[row][column] = 0;\n            }\n            else if (canComeLeft && (!canComeDiag || leftScore >= diagScore)) {\n                _table[row][column] = leftScore;\n                _arrows[row][column] = 2 ;\n                _diag[row][column] = 0;\n            }\n            else if (canComeDiag) {\n                _table[row][column] = diagScore;\n                _arrows[row][column] = 1 ;\n                _diag[row][column] = _diag[row - 1][column - 1] + 1;\n            }\n            else {\n                throw ( new Error(`not possible`));\n            }\n        }\n    }\n    if (!hasStrongFirstMatch[0] && !options.firstMatchCanBeWeak) {\n        return undefined;\n    }\n    row--;\n    column--;\n    const result = [_table[row][column], wordStart];\n    let backwardsDiagLength = 0;\n    let maxMatchColumn = 0;\n    while (row >= 1) {\n        let diagColumn = column;\n        do {\n            const arrow = _arrows[row][diagColumn];\n            if (arrow === 3 ) {\n                diagColumn = diagColumn - 2;\n            }\n            else if (arrow === 2 ) {\n                diagColumn = diagColumn - 1;\n            }\n            else {\n                break;\n            }\n        } while (diagColumn >= 1);\n        if (backwardsDiagLength > 1\n            && patternLow[patternStart + row - 1] === wordLow[wordStart + column - 1]\n            && !isUpperCaseAtPos(diagColumn + wordStart - 1, word, wordLow)\n            && backwardsDiagLength + 1 > _diag[row][diagColumn]\n        ) {\n            diagColumn = column;\n        }\n        if (diagColumn === column) {\n            backwardsDiagLength++;\n        }\n        else {\n            backwardsDiagLength = 1;\n        }\n        if (!maxMatchColumn) {\n            maxMatchColumn = diagColumn;\n        }\n        row--;\n        column = diagColumn - 1;\n        result.push(column);\n    }\n    if (wordLen === patternLen && options.boostFullMatch) {\n        result[0] += 2;\n    }\n    const skippedCharsCount = maxMatchColumn - patternLen;\n    result[0] -= skippedCharsCount;\n    return result;\n}\nfunction _fillInMaxWordMatchPos(patternLen, wordLen, patternStart, wordStart, patternLow, wordLow) {\n    let patternPos = patternLen - 1;\n    let wordPos = wordLen - 1;\n    while (patternPos >= patternStart && wordPos >= wordStart) {\n        if (patternLow[patternPos] === wordLow[wordPos]) {\n            _maxWordMatchPos[patternPos] = wordPos;\n            patternPos--;\n        }\n        wordPos--;\n    }\n}\nfunction _doScore(pattern, patternLow, patternPos, patternStart, word, wordLow, wordPos, wordLen, wordStart, newMatchStart, outFirstMatchStrong) {\n    if (patternLow[patternPos] !== wordLow[wordPos]) {\n        return Number.MIN_SAFE_INTEGER;\n    }\n    let score = 1;\n    let isGapLocation = false;\n    if (wordPos === (patternPos - patternStart)) {\n        score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n    }\n    else if (isUpperCaseAtPos(wordPos, word, wordLow) && (wordPos === 0 || !isUpperCaseAtPos(wordPos - 1, word, wordLow))) {\n        score = pattern[patternPos] === word[wordPos] ? 7 : 5;\n        isGapLocation = true;\n    }\n    else if (isSeparatorAtPos(wordLow, wordPos) && (wordPos === 0 || !isSeparatorAtPos(wordLow, wordPos - 1))) {\n        score = 5;\n    }\n    else if (isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1)) {\n        score = 5;\n        isGapLocation = true;\n    }\n    if (score > 1 && patternPos === patternStart) {\n        outFirstMatchStrong[0] = true;\n    }\n    if (!isGapLocation) {\n        isGapLocation = isUpperCaseAtPos(wordPos, word, wordLow) || isSeparatorAtPos(wordLow, wordPos - 1) || isWhitespaceAtPos(wordLow, wordPos - 1);\n    }\n    if (patternPos === patternStart) {\n        if (wordPos > wordStart) {\n            score -= isGapLocation ? 3 : 5;\n        }\n    }\n    else {\n        if (newMatchStart) {\n            score += isGapLocation ? 2 : 0;\n        }\n        else {\n            score += isGapLocation ? 0 : 1;\n        }\n    }\n    if (wordPos + 1 === wordLen) {\n        score -= isGapLocation ? 3 : 5;\n    }\n    return score;\n}\nfunction fuzzyScoreGracefulAggressive(pattern, lowPattern, patternPos, word, lowWord, wordPos, options) {\n    return fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, true, options);\n}\nfunction fuzzyScoreWithPermutations(pattern, lowPattern, patternPos, word, lowWord, wordPos, aggressive, options) {\n    let top = fuzzyScore(pattern, lowPattern, patternPos, word, lowWord, wordPos, options);\n    if (top && !aggressive) {\n        return top;\n    }\n    if (pattern.length >= 3) {\n        const tries = Math.min(7, pattern.length - 1);\n        for (let movingPatternPos = patternPos + 1; movingPatternPos < tries; movingPatternPos++) {\n            const newPattern = nextTypoPermutation(pattern, movingPatternPos);\n            if (newPattern) {\n                const candidate = fuzzyScore(newPattern, newPattern.toLowerCase(), patternPos, word, lowWord, wordPos, options);\n                if (candidate) {\n                    candidate[0] -= 3;\n                    if (!top || candidate[0] > top[0]) {\n                        top = candidate;\n                    }\n                }\n            }\n        }\n    }\n    return top;\n}\nfunction nextTypoPermutation(pattern, patternPos) {\n    if (patternPos + 1 >= pattern.length) {\n        return undefined;\n    }\n    const swap1 = pattern[patternPos];\n    const swap2 = pattern[patternPos + 1];\n    if (swap1 === swap2) {\n        return undefined;\n    }\n    return pattern.slice(0, patternPos)\n        + swap2\n        + swap1\n        + pattern.slice(patternPos + 2);\n}\nexport { FuzzyScore, FuzzyScoreOptions, anyScore, createMatches, fuzzyScore, fuzzyScoreGracefulAggressive, isPatternInWord, isUpper, matchesCamelCase, matchesContiguousSubString, matchesFuzzy, matchesFuzzy2, matchesPrefix, matchesSubString, matchesWords, or };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}