{"ast":null,"code":"\"use strict\";\n\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DiagnosticFeature = exports.DiagnosticPullMode = exports.vsdiag = void 0;\nconst minimatch = require(\"minimatch\");\nconst vscode_1 = require(\"vscode\");\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst uuid_1 = require(\"./utils/uuid\");\nconst features_1 = require(\"./features\");\nfunction ensure(target, key) {\n  if (target[key] === void 0) {\n    target[key] = {};\n  }\n  return target[key];\n}\nvar vsdiag;\n(function (vsdiag) {\n  let DocumentDiagnosticReportKind;\n  (function (DocumentDiagnosticReportKind) {\n    DocumentDiagnosticReportKind[\"full\"] = \"full\";\n    DocumentDiagnosticReportKind[\"unChanged\"] = \"unChanged\";\n  })(DocumentDiagnosticReportKind = vsdiag.DocumentDiagnosticReportKind || (vsdiag.DocumentDiagnosticReportKind = {}));\n})(vsdiag || (exports.vsdiag = vsdiag = {}));\nvar DiagnosticPullMode;\n(function (DiagnosticPullMode) {\n  DiagnosticPullMode[\"onType\"] = \"onType\";\n  DiagnosticPullMode[\"onSave\"] = \"onSave\";\n})(DiagnosticPullMode || (exports.DiagnosticPullMode = DiagnosticPullMode = {}));\nvar RequestStateKind;\n(function (RequestStateKind) {\n  RequestStateKind[\"active\"] = \"open\";\n  RequestStateKind[\"reschedule\"] = \"reschedule\";\n  RequestStateKind[\"outDated\"] = \"drop\";\n})(RequestStateKind || (RequestStateKind = {}));\n/**\n * Manages the open tabs. We don't directly use the tab API since for\n * diagnostics we need to de-dupe tabs that show the same resources since\n * we pull on the model not the UI.\n */\nclass Tabs {\n  constructor() {\n    this.open = new Set();\n    this._onOpen = new vscode_1.EventEmitter();\n    this._onClose = new vscode_1.EventEmitter();\n    Tabs.fillTabResources(this.open);\n    const openTabsHandler = event => {\n      if (event.closed.length === 0 && event.opened.length === 0) {\n        return;\n      }\n      const oldTabs = this.open;\n      const currentTabs = new Set();\n      Tabs.fillTabResources(currentTabs);\n      const closed = new Set();\n      const opened = new Set(currentTabs);\n      for (const tab of oldTabs.values()) {\n        if (currentTabs.has(tab)) {\n          opened.delete(tab);\n        } else {\n          closed.add(tab);\n        }\n      }\n      this.open = currentTabs;\n      if (closed.size > 0) {\n        const toFire = new Set();\n        for (const item of closed) {\n          toFire.add(vscode_1.Uri.parse(item));\n        }\n        this._onClose.fire(toFire);\n      }\n      if (opened.size > 0) {\n        const toFire = new Set();\n        for (const item of opened) {\n          toFire.add(vscode_1.Uri.parse(item));\n        }\n        this._onOpen.fire(toFire);\n      }\n    };\n    if (vscode_1.window.tabGroups.onDidChangeTabs !== undefined) {\n      this.disposable = vscode_1.window.tabGroups.onDidChangeTabs(openTabsHandler);\n    } else {\n      this.disposable = {\n        dispose: () => {}\n      };\n    }\n  }\n  get onClose() {\n    return this._onClose.event;\n  }\n  get onOpen() {\n    return this._onOpen.event;\n  }\n  dispose() {\n    this.disposable.dispose();\n  }\n  isActive(document) {\n    return document instanceof vscode_1.Uri ? vscode_1.window.activeTextEditor?.document.uri === document : vscode_1.window.activeTextEditor?.document === document;\n  }\n  isVisible(document) {\n    const uri = document instanceof vscode_1.Uri ? document : document.uri;\n    return this.open.has(uri.toString());\n  }\n  getTabResources() {\n    const result = new Set();\n    Tabs.fillTabResources(new Set(), result);\n    return result;\n  }\n  static fillTabResources(strings, uris) {\n    const seen = strings ?? new Set();\n    for (const group of vscode_1.window.tabGroups.all) {\n      for (const tab of group.tabs) {\n        const input = tab.input;\n        let uri;\n        if (input instanceof vscode_1.TabInputText) {\n          uri = input.uri;\n        } else if (input instanceof vscode_1.TabInputTextDiff) {\n          uri = input.modified;\n        } else if (input instanceof vscode_1.TabInputCustom) {\n          uri = input.uri;\n        }\n        if (uri !== undefined && !seen.has(uri.toString())) {\n          seen.add(uri.toString());\n          uris !== undefined && uris.add(uri);\n        }\n      }\n    }\n  }\n}\nvar PullState;\n(function (PullState) {\n  PullState[PullState[\"document\"] = 1] = \"document\";\n  PullState[PullState[\"workspace\"] = 2] = \"workspace\";\n})(PullState || (PullState = {}));\nvar DocumentOrUri;\n(function (DocumentOrUri) {\n  function asKey(document) {\n    return document instanceof vscode_1.Uri ? document.toString() : document.uri.toString();\n  }\n  DocumentOrUri.asKey = asKey;\n})(DocumentOrUri || (DocumentOrUri = {}));\nclass DocumentPullStateTracker {\n  constructor() {\n    this.documentPullStates = new Map();\n    this.workspacePullStates = new Map();\n  }\n  track(kind, document, arg1) {\n    const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;\n    const [key, uri, version] = document instanceof vscode_1.Uri ? [document.toString(), document, arg1] : [document.uri.toString(), document.uri, document.version];\n    let state = states.get(key);\n    if (state === undefined) {\n      state = {\n        document: uri,\n        pulledVersion: version,\n        resultId: undefined\n      };\n      states.set(key, state);\n    }\n    return state;\n  }\n  update(kind, document, arg1, arg2) {\n    const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;\n    const [key, uri, version, resultId] = document instanceof vscode_1.Uri ? [document.toString(), document, arg1, arg2] : [document.uri.toString(), document.uri, document.version, arg1];\n    let state = states.get(key);\n    if (state === undefined) {\n      state = {\n        document: uri,\n        pulledVersion: version,\n        resultId\n      };\n      states.set(key, state);\n    } else {\n      state.pulledVersion = version;\n      state.resultId = resultId;\n    }\n  }\n  unTrack(kind, document) {\n    const key = DocumentOrUri.asKey(document);\n    const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;\n    states.delete(key);\n  }\n  tracks(kind, document) {\n    const key = DocumentOrUri.asKey(document);\n    const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;\n    return states.has(key);\n  }\n  getResultId(kind, document) {\n    const key = DocumentOrUri.asKey(document);\n    const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;\n    return states.get(key)?.resultId;\n  }\n  getAllResultIds() {\n    const result = [];\n    for (let [uri, value] of this.workspacePullStates) {\n      if (this.documentPullStates.has(uri)) {\n        value = this.documentPullStates.get(uri);\n      }\n      if (value.resultId !== undefined) {\n        result.push({\n          uri,\n          value: value.resultId\n        });\n      }\n    }\n    return result;\n  }\n}\nclass DiagnosticRequestor {\n  constructor(client, tabs, options) {\n    this.client = client;\n    this.tabs = tabs;\n    this.options = options;\n    this.isDisposed = false;\n    this.onDidChangeDiagnosticsEmitter = new vscode_1.EventEmitter();\n    this.provider = this.createProvider();\n    this.diagnostics = vscode_1.languages.createDiagnosticCollection(options.identifier);\n    this.openRequests = new Map();\n    this.documentStates = new DocumentPullStateTracker();\n    this.workspaceErrorCounter = 0;\n  }\n  knows(kind, document) {\n    const uri = document instanceof vscode_1.Uri ? document : document.uri;\n    return this.documentStates.tracks(kind, document) || this.openRequests.has(uri.toString());\n  }\n  forget(kind, document) {\n    this.documentStates.unTrack(kind, document);\n  }\n  pull(document, cb) {\n    if (this.isDisposed) {\n      return;\n    }\n    const uri = document instanceof vscode_1.Uri ? document : document.uri;\n    this.pullAsync(document).then(() => {\n      if (cb) {\n        cb();\n      }\n    }, error => {\n      this.client.error(`Document pull failed for text document ${uri.toString()}`, error, false);\n    });\n  }\n  async pullAsync(document, version) {\n    if (this.isDisposed) {\n      return;\n    }\n    const isUri = document instanceof vscode_1.Uri;\n    const uri = isUri ? document : document.uri;\n    const key = uri.toString();\n    version = isUri ? version : document.version;\n    const currentRequestState = this.openRequests.get(key);\n    const documentState = isUri ? this.documentStates.track(PullState.document, document, version) : this.documentStates.track(PullState.document, document);\n    if (currentRequestState === undefined) {\n      const tokenSource = new vscode_1.CancellationTokenSource();\n      this.openRequests.set(key, {\n        state: RequestStateKind.active,\n        document: document,\n        version: version,\n        tokenSource\n      });\n      let report;\n      let afterState;\n      try {\n        report = (await this.provider.provideDiagnostics(document, documentState.resultId, tokenSource.token)) ?? {\n          kind: vsdiag.DocumentDiagnosticReportKind.full,\n          items: []\n        };\n      } catch (error) {\n        if (error instanceof features_1.LSPCancellationError && vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data) && error.data.retriggerRequest === false) {\n          afterState = {\n            state: RequestStateKind.outDated,\n            document\n          };\n        }\n        if (afterState === undefined && error instanceof vscode_1.CancellationError) {\n          afterState = {\n            state: RequestStateKind.reschedule,\n            document\n          };\n        } else {\n          throw error;\n        }\n      }\n      afterState = afterState ?? this.openRequests.get(key);\n      if (afterState === undefined) {\n        // This shouldn't happen. Log it\n        this.client.error(`Lost request state in diagnostic pull model. Clearing diagnostics for ${key}`);\n        this.diagnostics.delete(uri);\n        return;\n      }\n      this.openRequests.delete(key);\n      if (!this.tabs.isVisible(document)) {\n        this.documentStates.unTrack(PullState.document, document);\n        return;\n      }\n      if (afterState.state === RequestStateKind.outDated) {\n        return;\n      }\n      // report is only undefined if the request has thrown.\n      if (report !== undefined) {\n        if (report.kind === vsdiag.DocumentDiagnosticReportKind.full) {\n          this.diagnostics.set(uri, report.items);\n        }\n        documentState.pulledVersion = version;\n        documentState.resultId = report.resultId;\n      }\n      if (afterState.state === RequestStateKind.reschedule) {\n        this.pull(document);\n      }\n    } else {\n      if (currentRequestState.state === RequestStateKind.active) {\n        // Cancel the current request and reschedule a new one when the old one returned.\n        currentRequestState.tokenSource.cancel();\n        this.openRequests.set(key, {\n          state: RequestStateKind.reschedule,\n          document: currentRequestState.document\n        });\n      } else if (currentRequestState.state === RequestStateKind.outDated) {\n        this.openRequests.set(key, {\n          state: RequestStateKind.reschedule,\n          document: currentRequestState.document\n        });\n      }\n    }\n  }\n  forgetDocument(document) {\n    const uri = document instanceof vscode_1.Uri ? document : document.uri;\n    const key = uri.toString();\n    const request = this.openRequests.get(key);\n    if (this.options.workspaceDiagnostics) {\n      // If we run workspace diagnostic pull a last time for the diagnostics\n      // and the rely on getting them from the workspace result.\n      if (request !== undefined) {\n        this.openRequests.set(key, {\n          state: RequestStateKind.reschedule,\n          document: document\n        });\n      } else {\n        this.pull(document, () => {\n          this.forget(PullState.document, document);\n        });\n      }\n    } else {\n      // We have normal pull or inter file dependencies. In this case we\n      // clear the diagnostics (to have the same start as after startup).\n      // We also cancel outstanding requests.\n      if (request !== undefined) {\n        if (request.state === RequestStateKind.active) {\n          request.tokenSource.cancel();\n        }\n        this.openRequests.set(key, {\n          state: RequestStateKind.outDated,\n          document: document\n        });\n      }\n      this.diagnostics.delete(uri);\n      this.forget(PullState.document, document);\n    }\n  }\n  pullWorkspace() {\n    if (this.isDisposed) {\n      return;\n    }\n    this.pullWorkspaceAsync().then(() => {\n      this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {\n        this.pullWorkspace();\n      }, 2000);\n    }, error => {\n      if (!(error instanceof features_1.LSPCancellationError) && !vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data)) {\n        this.client.error(`Workspace diagnostic pull failed.`, error, false);\n        this.workspaceErrorCounter++;\n      }\n      if (this.workspaceErrorCounter <= 5) {\n        this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {\n          this.pullWorkspace();\n        }, 2000);\n      }\n    });\n  }\n  async pullWorkspaceAsync() {\n    if (!this.provider.provideWorkspaceDiagnostics || this.isDisposed) {\n      return;\n    }\n    if (this.workspaceCancellation !== undefined) {\n      this.workspaceCancellation.cancel();\n      this.workspaceCancellation = undefined;\n    }\n    this.workspaceCancellation = new vscode_1.CancellationTokenSource();\n    const previousResultIds = this.documentStates.getAllResultIds().map(item => {\n      return {\n        uri: this.client.protocol2CodeConverter.asUri(item.uri),\n        value: item.value\n      };\n    });\n    await this.provider.provideWorkspaceDiagnostics(previousResultIds, this.workspaceCancellation.token, chunk => {\n      if (!chunk || this.isDisposed) {\n        return;\n      }\n      for (const item of chunk.items) {\n        if (item.kind === vsdiag.DocumentDiagnosticReportKind.full) {\n          // Favour document pull result over workspace results. So skip if it is tracked\n          // as a document result.\n          if (!this.documentStates.tracks(PullState.document, item.uri)) {\n            this.diagnostics.set(item.uri, item.items);\n          }\n        }\n        this.documentStates.update(PullState.workspace, item.uri, item.version ?? undefined, item.resultId);\n      }\n    });\n  }\n  createProvider() {\n    const result = {\n      onDidChangeDiagnostics: this.onDidChangeDiagnosticsEmitter.event,\n      provideDiagnostics: (document, previousResultId, token) => {\n        const provideDiagnostics = (document, previousResultId, token) => {\n          const params = {\n            identifier: this.options.identifier,\n            textDocument: {\n              uri: this.client.code2ProtocolConverter.asUri(document instanceof vscode_1.Uri ? document : document.uri)\n            },\n            previousResultId: previousResultId\n          };\n          if (this.isDisposed === true || !this.client.isRunning()) {\n            return {\n              kind: vsdiag.DocumentDiagnosticReportKind.full,\n              items: []\n            };\n          }\n          return this.client.sendRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, params, token).then(async result => {\n            if (result === undefined || result === null || this.isDisposed || token.isCancellationRequested) {\n              return {\n                kind: vsdiag.DocumentDiagnosticReportKind.full,\n                items: []\n              };\n            }\n            if (result.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {\n              return {\n                kind: vsdiag.DocumentDiagnosticReportKind.full,\n                resultId: result.resultId,\n                items: await this.client.protocol2CodeConverter.asDiagnostics(result.items, token)\n              };\n            } else {\n              return {\n                kind: vsdiag.DocumentDiagnosticReportKind.unChanged,\n                resultId: result.resultId\n              };\n            }\n          }, error => {\n            return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token, error, {\n              kind: vsdiag.DocumentDiagnosticReportKind.full,\n              items: []\n            });\n          });\n        };\n        const middleware = this.client.middleware;\n        return middleware.provideDiagnostics ? middleware.provideDiagnostics(document, previousResultId, token, provideDiagnostics) : provideDiagnostics(document, previousResultId, token);\n      }\n    };\n    if (this.options.workspaceDiagnostics) {\n      result.provideWorkspaceDiagnostics = (resultIds, token, resultReporter) => {\n        const convertReport = async report => {\n          if (report.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {\n            return {\n              kind: vsdiag.DocumentDiagnosticReportKind.full,\n              uri: this.client.protocol2CodeConverter.asUri(report.uri),\n              resultId: report.resultId,\n              version: report.version,\n              items: await this.client.protocol2CodeConverter.asDiagnostics(report.items, token)\n            };\n          } else {\n            return {\n              kind: vsdiag.DocumentDiagnosticReportKind.unChanged,\n              uri: this.client.protocol2CodeConverter.asUri(report.uri),\n              resultId: report.resultId,\n              version: report.version\n            };\n          }\n        };\n        const convertPreviousResultIds = resultIds => {\n          const converted = [];\n          for (const item of resultIds) {\n            converted.push({\n              uri: this.client.code2ProtocolConverter.asUri(item.uri),\n              value: item.value\n            });\n          }\n          return converted;\n        };\n        const provideDiagnostics = (resultIds, token) => {\n          const partialResultToken = (0, uuid_1.generateUuid)();\n          const disposable = this.client.onProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, partialResultToken, async partialResult => {\n            if (partialResult === undefined || partialResult === null) {\n              resultReporter(null);\n              return;\n            }\n            const converted = {\n              items: []\n            };\n            for (const item of partialResult.items) {\n              try {\n                converted.items.push(await convertReport(item));\n              } catch (error) {\n                this.client.error(`Converting workspace diagnostics failed.`, error);\n              }\n            }\n            resultReporter(converted);\n          });\n          const params = {\n            identifier: this.options.identifier,\n            previousResultIds: convertPreviousResultIds(resultIds),\n            partialResultToken: partialResultToken\n          };\n          if (this.isDisposed === true || !this.client.isRunning()) {\n            return {\n              items: []\n            };\n          }\n          return this.client.sendRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, params, token).then(async result => {\n            if (token.isCancellationRequested) {\n              return {\n                items: []\n              };\n            }\n            const converted = {\n              items: []\n            };\n            for (const item of result.items) {\n              converted.items.push(await convertReport(item));\n            }\n            disposable.dispose();\n            resultReporter(converted);\n            return {\n              items: []\n            };\n          }, error => {\n            disposable.dispose();\n            return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token, error, {\n              items: []\n            });\n          });\n        };\n        const middleware = this.client.middleware;\n        return middleware.provideWorkspaceDiagnostics ? middleware.provideWorkspaceDiagnostics(resultIds, token, resultReporter, provideDiagnostics) : provideDiagnostics(resultIds, token, resultReporter);\n      };\n    }\n    return result;\n  }\n  dispose() {\n    this.isDisposed = true;\n    // Cancel and clear workspace pull if present.\n    this.workspaceCancellation?.cancel();\n    this.workspaceTimeout?.dispose();\n    // Cancel all request and mark open requests as outdated.\n    for (const [key, request] of this.openRequests) {\n      if (request.state === RequestStateKind.active) {\n        request.tokenSource.cancel();\n      }\n      this.openRequests.set(key, {\n        state: RequestStateKind.outDated,\n        document: request.document\n      });\n    }\n    // cleanup old diagnostics\n    this.diagnostics.dispose();\n  }\n}\nclass BackgroundScheduler {\n  constructor(diagnosticRequestor) {\n    this.diagnosticRequestor = diagnosticRequestor;\n    this.documents = new vscode_languageserver_protocol_1.LinkedMap();\n    this.isDisposed = false;\n  }\n  add(document) {\n    if (this.isDisposed === true) {\n      return;\n    }\n    const key = DocumentOrUri.asKey(document);\n    if (this.documents.has(key)) {\n      return;\n    }\n    this.documents.set(key, document, vscode_languageserver_protocol_1.Touch.Last);\n    this.trigger();\n  }\n  remove(document) {\n    const key = DocumentOrUri.asKey(document);\n    this.documents.delete(key);\n    // No more documents. Stop background activity.\n    if (this.documents.size === 0) {\n      this.stop();\n    } else if (key === this.endDocumentKey()) {\n      // Make sure we have a correct last document. It could have\n      this.endDocument = this.documents.last;\n    }\n  }\n  trigger() {\n    if (this.isDisposed === true) {\n      return;\n    }\n    // We have a round running. So simply make sure we run up to the\n    // last document\n    if (this.intervalHandle !== undefined) {\n      this.endDocument = this.documents.last;\n      return;\n    }\n    this.endDocument = this.documents.last;\n    this.intervalHandle = (0, vscode_languageserver_protocol_1.RAL)().timer.setInterval(() => {\n      const document = this.documents.first;\n      if (document !== undefined) {\n        const key = DocumentOrUri.asKey(document);\n        this.diagnosticRequestor.pull(document);\n        this.documents.set(key, document, vscode_languageserver_protocol_1.Touch.Last);\n        if (key === this.endDocumentKey()) {\n          this.stop();\n        }\n      }\n    }, 200);\n  }\n  dispose() {\n    this.isDisposed = true;\n    this.stop();\n    this.documents.clear();\n  }\n  stop() {\n    this.intervalHandle?.dispose();\n    this.intervalHandle = undefined;\n    this.endDocument = undefined;\n  }\n  endDocumentKey() {\n    return this.endDocument !== undefined ? DocumentOrUri.asKey(this.endDocument) : undefined;\n  }\n}\nclass DiagnosticFeatureProviderImpl {\n  constructor(client, tabs, options) {\n    const diagnosticPullOptions = client.clientOptions.diagnosticPullOptions ?? {\n      onChange: true,\n      onSave: false\n    };\n    const documentSelector = client.protocol2CodeConverter.asDocumentSelector(options.documentSelector);\n    const disposables = [];\n    const matchResource = resource => {\n      const selector = options.documentSelector;\n      if (diagnosticPullOptions.match !== undefined) {\n        return diagnosticPullOptions.match(selector, resource);\n      }\n      for (const filter of selector) {\n        if (!vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {\n          continue;\n        }\n        // The filter is a language id. We can't determine if it matches\n        // so we return false.\n        if (typeof filter === 'string') {\n          return false;\n        }\n        if (filter.language !== undefined && filter.language !== '*') {\n          return false;\n        }\n        if (filter.scheme !== undefined && filter.scheme !== '*' && filter.scheme !== resource.scheme) {\n          return false;\n        }\n        if (filter.pattern !== undefined) {\n          const matcher = new minimatch.Minimatch(filter.pattern, {\n            noext: true\n          });\n          if (!matcher.makeRe()) {\n            return false;\n          }\n          if (!matcher.match(resource.fsPath)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n    const matches = document => {\n      return document instanceof vscode_1.Uri ? matchResource(document) : vscode_1.languages.match(documentSelector, document) > 0 && tabs.isVisible(document);\n    };\n    const isActiveDocument = document => {\n      return document instanceof vscode_1.Uri ? this.activeTextDocument?.uri.toString() === document.toString() : this.activeTextDocument === document;\n    };\n    this.diagnosticRequestor = new DiagnosticRequestor(client, tabs, options);\n    this.backgroundScheduler = new BackgroundScheduler(this.diagnosticRequestor);\n    const addToBackgroundIfNeeded = document => {\n      if (!matches(document) || !options.interFileDependencies || isActiveDocument(document)) {\n        return;\n      }\n      this.backgroundScheduler.add(document);\n    };\n    this.activeTextDocument = vscode_1.window.activeTextEditor?.document;\n    vscode_1.window.onDidChangeActiveTextEditor(editor => {\n      const oldActive = this.activeTextDocument;\n      this.activeTextDocument = editor?.document;\n      if (oldActive !== undefined) {\n        addToBackgroundIfNeeded(oldActive);\n      }\n      if (this.activeTextDocument !== undefined) {\n        this.backgroundScheduler.remove(this.activeTextDocument);\n      }\n    });\n    // For pull model diagnostics we pull for documents visible in the UI.\n    // From an eventing point of view we still rely on open document events\n    // and filter the documents that are not visible in the UI instead of\n    // listening to Tab events. Major reason is event timing since we need\n    // to ensure that the pull is send after the document open has reached\n    // the server.\n    // We always pull on open.\n    const openFeature = client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);\n    disposables.push(openFeature.onNotificationSent(event => {\n      const textDocument = event.textDocument;\n      // We already know about this document. This can happen via a tab open.\n      if (this.diagnosticRequestor.knows(PullState.document, textDocument)) {\n        return;\n      }\n      if (matches(textDocument)) {\n        this.diagnosticRequestor.pull(textDocument, () => {\n          addToBackgroundIfNeeded(textDocument);\n        });\n      }\n    }));\n    disposables.push(tabs.onOpen(opened => {\n      for (const resource of opened) {\n        // We already know about this document. This can happen via a document open.\n        if (this.diagnosticRequestor.knows(PullState.document, resource)) {\n          continue;\n        }\n        const uriStr = resource.toString();\n        let textDocument;\n        for (const item of vscode_1.workspace.textDocuments) {\n          if (uriStr === item.uri.toString()) {\n            textDocument = item;\n            break;\n          }\n        }\n        // In VS Code the event timing is as follows:\n        // 1. tab events are fired.\n        // 2. open document events are fired and internal data structures like\n        //    workspace.textDocuments and Window.activeTextEditor are updated.\n        //\n        // This means: for newly created tab/editors we don't find the underlying\n        // document yet. So we do nothing an rely on the underlying open document event\n        // to be fired.\n        if (textDocument !== undefined && matches(textDocument)) {\n          this.diagnosticRequestor.pull(textDocument, () => {\n            addToBackgroundIfNeeded(textDocument);\n          });\n        }\n      }\n    }));\n    // Pull all diagnostics for documents that are already open\n    const pulledTextDocuments = new Set();\n    for (const textDocument of vscode_1.workspace.textDocuments) {\n      if (matches(textDocument)) {\n        this.diagnosticRequestor.pull(textDocument, () => {\n          addToBackgroundIfNeeded(textDocument);\n        });\n        pulledTextDocuments.add(textDocument.uri.toString());\n      }\n    }\n    // Pull all tabs if not already pulled as text document\n    if (diagnosticPullOptions.onTabs === true) {\n      for (const resource of tabs.getTabResources()) {\n        if (!pulledTextDocuments.has(resource.toString()) && matches(resource)) {\n          this.diagnosticRequestor.pull(resource, () => {\n            addToBackgroundIfNeeded(resource);\n          });\n        }\n      }\n    }\n    // We don't need to pull on tab open since we will receive a document open as well later on\n    // and that event allows us to use a document for a match check which will have a set\n    // language id.\n    if (diagnosticPullOptions.onChange === true) {\n      const changeFeature = client.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method);\n      disposables.push(changeFeature.onNotificationSent(async event => {\n        const textDocument = event.textDocument;\n        if ((diagnosticPullOptions.filter === undefined || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onType)) && this.diagnosticRequestor.knows(PullState.document, textDocument)) {\n          this.diagnosticRequestor.pull(textDocument, () => {\n            this.backgroundScheduler.trigger();\n          });\n        }\n      }));\n    }\n    if (diagnosticPullOptions.onSave === true) {\n      const saveFeature = client.getFeature(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.method);\n      disposables.push(saveFeature.onNotificationSent(event => {\n        const textDocument = event.textDocument;\n        if ((diagnosticPullOptions.filter === undefined || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onSave)) && this.diagnosticRequestor.knows(PullState.document, textDocument)) {\n          this.diagnosticRequestor.pull(event.textDocument, () => {\n            this.backgroundScheduler.trigger();\n          });\n        }\n      }));\n    }\n    // When the document closes clear things up\n    const closeFeature = client.getFeature(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.method);\n    disposables.push(closeFeature.onNotificationSent(event => {\n      this.cleanUpDocument(event.textDocument);\n    }));\n    // Same when a tabs closes.\n    tabs.onClose(closed => {\n      for (const document of closed) {\n        this.cleanUpDocument(document);\n      }\n    });\n    // We received a did change from the server.\n    this.diagnosticRequestor.onDidChangeDiagnosticsEmitter.event(() => {\n      for (const textDocument of vscode_1.workspace.textDocuments) {\n        if (matches(textDocument)) {\n          this.diagnosticRequestor.pull(textDocument);\n        }\n      }\n    });\n    // da348dc5-c30a-4515-9d98-31ff3be38d14 is the test UUID to test the middle ware. So don't auto trigger pulls.\n    if (options.workspaceDiagnostics === true && options.identifier !== 'da348dc5-c30a-4515-9d98-31ff3be38d14') {\n      this.diagnosticRequestor.pullWorkspace();\n    }\n    this.disposable = vscode_1.Disposable.from(...disposables, this.backgroundScheduler, this.diagnosticRequestor);\n  }\n  get onDidChangeDiagnosticsEmitter() {\n    return this.diagnosticRequestor.onDidChangeDiagnosticsEmitter;\n  }\n  get diagnostics() {\n    return this.diagnosticRequestor.provider;\n  }\n  cleanUpDocument(document) {\n    if (this.diagnosticRequestor.knows(PullState.document, document)) {\n      this.diagnosticRequestor.forgetDocument(document);\n      this.backgroundScheduler.remove(document);\n    }\n  }\n}\nclass DiagnosticFeature extends features_1.TextDocumentLanguageFeature {\n  constructor(client) {\n    super(client, vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type);\n  }\n  fillClientCapabilities(capabilities) {\n    let capability = ensure(ensure(capabilities, 'textDocument'), 'diagnostic');\n    capability.dynamicRegistration = true;\n    // We first need to decide how a UI will look with related documents.\n    // An easy implementation would be to only show related diagnostics for\n    // the active editor.\n    capability.relatedDocumentSupport = false;\n    ensure(ensure(capabilities, 'workspace'), 'diagnostics').refreshSupport = true;\n  }\n  initialize(capabilities, documentSelector) {\n    const client = this._client;\n    client.onRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type, async () => {\n      for (const provider of this.getAllProviders()) {\n        provider.onDidChangeDiagnosticsEmitter.fire();\n      }\n    });\n    let [id, options] = this.getRegistration(documentSelector, capabilities.diagnosticProvider);\n    if (!id || !options) {\n      return;\n    }\n    this.register({\n      id: id,\n      registerOptions: options\n    });\n  }\n  clear() {\n    if (this.tabs !== undefined) {\n      this.tabs.dispose();\n      this.tabs = undefined;\n    }\n    super.clear();\n  }\n  registerLanguageProvider(options) {\n    if (this.tabs === undefined) {\n      this.tabs = new Tabs();\n    }\n    const provider = new DiagnosticFeatureProviderImpl(this._client, this.tabs, options);\n    return [provider.disposable, provider];\n  }\n}\nexports.DiagnosticFeature = DiagnosticFeature;","map":{"version":3,"names":["Object","defineProperty","exports","value","DiagnosticFeature","DiagnosticPullMode","vsdiag","minimatch","require","vscode_1","vscode_languageserver_protocol_1","uuid_1","features_1","ensure","target","key","DocumentDiagnosticReportKind","RequestStateKind","Tabs","constructor","open","Set","_onOpen","EventEmitter","_onClose","fillTabResources","openTabsHandler","event","closed","length","opened","oldTabs","currentTabs","tab","values","has","delete","add","size","toFire","item","Uri","parse","fire","window","tabGroups","onDidChangeTabs","undefined","disposable","dispose","onClose","onOpen","isActive","document","activeTextEditor","uri","isVisible","toString","getTabResources","result","strings","uris","seen","group","all","tabs","input","TabInputText","TabInputTextDiff","modified","TabInputCustom","PullState","DocumentOrUri","asKey","DocumentPullStateTracker","documentPullStates","Map","workspacePullStates","track","kind","arg1","states","version","state","get","pulledVersion","resultId","set","update","arg2","unTrack","tracks","getResultId","getAllResultIds","push","DiagnosticRequestor","client","options","isDisposed","onDidChangeDiagnosticsEmitter","provider","createProvider","diagnostics","languages","createDiagnosticCollection","identifier","openRequests","documentStates","workspaceErrorCounter","knows","forget","pull","cb","pullAsync","then","error","isUri","currentRequestState","documentState","tokenSource","CancellationTokenSource","active","report","afterState","provideDiagnostics","token","full","items","LSPCancellationError","DiagnosticServerCancellationData","is","data","retriggerRequest","outDated","CancellationError","reschedule","cancel","forgetDocument","request","workspaceDiagnostics","pullWorkspace","pullWorkspaceAsync","workspaceTimeout","RAL","timer","setTimeout","provideWorkspaceDiagnostics","workspaceCancellation","previousResultIds","map","protocol2CodeConverter","asUri","chunk","workspace","onDidChangeDiagnostics","previousResultId","params","textDocument","code2ProtocolConverter","isRunning","sendRequest","DocumentDiagnosticRequest","type","isCancellationRequested","Full","asDiagnostics","unChanged","handleFailedRequest","middleware","resultIds","resultReporter","convertReport","convertPreviousResultIds","converted","partialResultToken","generateUuid","onProgress","WorkspaceDiagnosticRequest","partialResult","BackgroundScheduler","diagnosticRequestor","documents","LinkedMap","Touch","Last","trigger","remove","stop","endDocumentKey","endDocument","last","intervalHandle","setInterval","first","clear","DiagnosticFeatureProviderImpl","diagnosticPullOptions","clientOptions","onChange","onSave","documentSelector","asDocumentSelector","disposables","matchResource","resource","selector","match","filter","TextDocumentFilter","language","scheme","pattern","matcher","Minimatch","noext","makeRe","fsPath","matches","isActiveDocument","activeTextDocument","backgroundScheduler","addToBackgroundIfNeeded","interFileDependencies","onDidChangeActiveTextEditor","editor","oldActive","openFeature","getFeature","DidOpenTextDocumentNotification","method","onNotificationSent","uriStr","textDocuments","pulledTextDocuments","onTabs","changeFeature","DidChangeTextDocumentNotification","onType","saveFeature","DidSaveTextDocumentNotification","closeFeature","DidCloseTextDocumentNotification","cleanUpDocument","Disposable","from","TextDocumentLanguageFeature","fillClientCapabilities","capabilities","capability","dynamicRegistration","relatedDocumentSupport","refreshSupport","initialize","_client","onRequest","DiagnosticRefreshRequest","getAllProviders","id","getRegistration","diagnosticProvider","register","registerOptions","registerLanguageProvider"],"sources":["/Users/phamtu/Downloads/Code/OCE/oce-frontend/node_modules/vscode-languageclient/lib/common/diagnostic.js"],"sourcesContent":["\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DiagnosticFeature = exports.DiagnosticPullMode = exports.vsdiag = void 0;\nconst minimatch = require(\"minimatch\");\nconst vscode_1 = require(\"vscode\");\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst uuid_1 = require(\"./utils/uuid\");\nconst features_1 = require(\"./features\");\nfunction ensure(target, key) {\n    if (target[key] === void 0) {\n        target[key] = {};\n    }\n    return target[key];\n}\nvar vsdiag;\n(function (vsdiag) {\n    let DocumentDiagnosticReportKind;\n    (function (DocumentDiagnosticReportKind) {\n        DocumentDiagnosticReportKind[\"full\"] = \"full\";\n        DocumentDiagnosticReportKind[\"unChanged\"] = \"unChanged\";\n    })(DocumentDiagnosticReportKind = vsdiag.DocumentDiagnosticReportKind || (vsdiag.DocumentDiagnosticReportKind = {}));\n})(vsdiag || (exports.vsdiag = vsdiag = {}));\nvar DiagnosticPullMode;\n(function (DiagnosticPullMode) {\n    DiagnosticPullMode[\"onType\"] = \"onType\";\n    DiagnosticPullMode[\"onSave\"] = \"onSave\";\n})(DiagnosticPullMode || (exports.DiagnosticPullMode = DiagnosticPullMode = {}));\nvar RequestStateKind;\n(function (RequestStateKind) {\n    RequestStateKind[\"active\"] = \"open\";\n    RequestStateKind[\"reschedule\"] = \"reschedule\";\n    RequestStateKind[\"outDated\"] = \"drop\";\n})(RequestStateKind || (RequestStateKind = {}));\n/**\n * Manages the open tabs. We don't directly use the tab API since for\n * diagnostics we need to de-dupe tabs that show the same resources since\n * we pull on the model not the UI.\n */\nclass Tabs {\n    constructor() {\n        this.open = new Set();\n        this._onOpen = new vscode_1.EventEmitter();\n        this._onClose = new vscode_1.EventEmitter();\n        Tabs.fillTabResources(this.open);\n        const openTabsHandler = (event) => {\n            if (event.closed.length === 0 && event.opened.length === 0) {\n                return;\n            }\n            const oldTabs = this.open;\n            const currentTabs = new Set();\n            Tabs.fillTabResources(currentTabs);\n            const closed = new Set();\n            const opened = new Set(currentTabs);\n            for (const tab of oldTabs.values()) {\n                if (currentTabs.has(tab)) {\n                    opened.delete(tab);\n                }\n                else {\n                    closed.add(tab);\n                }\n            }\n            this.open = currentTabs;\n            if (closed.size > 0) {\n                const toFire = new Set();\n                for (const item of closed) {\n                    toFire.add(vscode_1.Uri.parse(item));\n                }\n                this._onClose.fire(toFire);\n            }\n            if (opened.size > 0) {\n                const toFire = new Set();\n                for (const item of opened) {\n                    toFire.add(vscode_1.Uri.parse(item));\n                }\n                this._onOpen.fire(toFire);\n            }\n        };\n        if (vscode_1.window.tabGroups.onDidChangeTabs !== undefined) {\n            this.disposable = vscode_1.window.tabGroups.onDidChangeTabs(openTabsHandler);\n        }\n        else {\n            this.disposable = { dispose: () => { } };\n        }\n    }\n    get onClose() {\n        return this._onClose.event;\n    }\n    get onOpen() {\n        return this._onOpen.event;\n    }\n    dispose() {\n        this.disposable.dispose();\n    }\n    isActive(document) {\n        return document instanceof vscode_1.Uri\n            ? vscode_1.window.activeTextEditor?.document.uri === document\n            : vscode_1.window.activeTextEditor?.document === document;\n    }\n    isVisible(document) {\n        const uri = document instanceof vscode_1.Uri ? document : document.uri;\n        return this.open.has(uri.toString());\n    }\n    getTabResources() {\n        const result = new Set();\n        Tabs.fillTabResources(new Set(), result);\n        return result;\n    }\n    static fillTabResources(strings, uris) {\n        const seen = strings ?? new Set();\n        for (const group of vscode_1.window.tabGroups.all) {\n            for (const tab of group.tabs) {\n                const input = tab.input;\n                let uri;\n                if (input instanceof vscode_1.TabInputText) {\n                    uri = input.uri;\n                }\n                else if (input instanceof vscode_1.TabInputTextDiff) {\n                    uri = input.modified;\n                }\n                else if (input instanceof vscode_1.TabInputCustom) {\n                    uri = input.uri;\n                }\n                if (uri !== undefined && !seen.has(uri.toString())) {\n                    seen.add(uri.toString());\n                    uris !== undefined && uris.add(uri);\n                }\n            }\n        }\n    }\n}\nvar PullState;\n(function (PullState) {\n    PullState[PullState[\"document\"] = 1] = \"document\";\n    PullState[PullState[\"workspace\"] = 2] = \"workspace\";\n})(PullState || (PullState = {}));\nvar DocumentOrUri;\n(function (DocumentOrUri) {\n    function asKey(document) {\n        return document instanceof vscode_1.Uri ? document.toString() : document.uri.toString();\n    }\n    DocumentOrUri.asKey = asKey;\n})(DocumentOrUri || (DocumentOrUri = {}));\nclass DocumentPullStateTracker {\n    constructor() {\n        this.documentPullStates = new Map();\n        this.workspacePullStates = new Map();\n    }\n    track(kind, document, arg1) {\n        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;\n        const [key, uri, version] = document instanceof vscode_1.Uri\n            ? [document.toString(), document, arg1]\n            : [document.uri.toString(), document.uri, document.version];\n        let state = states.get(key);\n        if (state === undefined) {\n            state = { document: uri, pulledVersion: version, resultId: undefined };\n            states.set(key, state);\n        }\n        return state;\n    }\n    update(kind, document, arg1, arg2) {\n        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;\n        const [key, uri, version, resultId] = document instanceof vscode_1.Uri\n            ? [document.toString(), document, arg1, arg2]\n            : [document.uri.toString(), document.uri, document.version, arg1];\n        let state = states.get(key);\n        if (state === undefined) {\n            state = { document: uri, pulledVersion: version, resultId };\n            states.set(key, state);\n        }\n        else {\n            state.pulledVersion = version;\n            state.resultId = resultId;\n        }\n    }\n    unTrack(kind, document) {\n        const key = DocumentOrUri.asKey(document);\n        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;\n        states.delete(key);\n    }\n    tracks(kind, document) {\n        const key = DocumentOrUri.asKey(document);\n        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;\n        return states.has(key);\n    }\n    getResultId(kind, document) {\n        const key = DocumentOrUri.asKey(document);\n        const states = kind === PullState.document ? this.documentPullStates : this.workspacePullStates;\n        return states.get(key)?.resultId;\n    }\n    getAllResultIds() {\n        const result = [];\n        for (let [uri, value] of this.workspacePullStates) {\n            if (this.documentPullStates.has(uri)) {\n                value = this.documentPullStates.get(uri);\n            }\n            if (value.resultId !== undefined) {\n                result.push({ uri, value: value.resultId });\n            }\n        }\n        return result;\n    }\n}\nclass DiagnosticRequestor {\n    constructor(client, tabs, options) {\n        this.client = client;\n        this.tabs = tabs;\n        this.options = options;\n        this.isDisposed = false;\n        this.onDidChangeDiagnosticsEmitter = new vscode_1.EventEmitter();\n        this.provider = this.createProvider();\n        this.diagnostics = vscode_1.languages.createDiagnosticCollection(options.identifier);\n        this.openRequests = new Map();\n        this.documentStates = new DocumentPullStateTracker();\n        this.workspaceErrorCounter = 0;\n    }\n    knows(kind, document) {\n        const uri = document instanceof vscode_1.Uri ? document : document.uri;\n        return this.documentStates.tracks(kind, document) || this.openRequests.has(uri.toString());\n    }\n    forget(kind, document) {\n        this.documentStates.unTrack(kind, document);\n    }\n    pull(document, cb) {\n        if (this.isDisposed) {\n            return;\n        }\n        const uri = document instanceof vscode_1.Uri ? document : document.uri;\n        this.pullAsync(document).then(() => {\n            if (cb) {\n                cb();\n            }\n        }, (error) => {\n            this.client.error(`Document pull failed for text document ${uri.toString()}`, error, false);\n        });\n    }\n    async pullAsync(document, version) {\n        if (this.isDisposed) {\n            return;\n        }\n        const isUri = document instanceof vscode_1.Uri;\n        const uri = isUri ? document : document.uri;\n        const key = uri.toString();\n        version = isUri ? version : document.version;\n        const currentRequestState = this.openRequests.get(key);\n        const documentState = isUri\n            ? this.documentStates.track(PullState.document, document, version)\n            : this.documentStates.track(PullState.document, document);\n        if (currentRequestState === undefined) {\n            const tokenSource = new vscode_1.CancellationTokenSource();\n            this.openRequests.set(key, { state: RequestStateKind.active, document: document, version: version, tokenSource });\n            let report;\n            let afterState;\n            try {\n                report = await this.provider.provideDiagnostics(document, documentState.resultId, tokenSource.token) ?? { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };\n            }\n            catch (error) {\n                if (error instanceof features_1.LSPCancellationError && vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data) && error.data.retriggerRequest === false) {\n                    afterState = { state: RequestStateKind.outDated, document };\n                }\n                if (afterState === undefined && error instanceof vscode_1.CancellationError) {\n                    afterState = { state: RequestStateKind.reschedule, document };\n                }\n                else {\n                    throw error;\n                }\n            }\n            afterState = afterState ?? this.openRequests.get(key);\n            if (afterState === undefined) {\n                // This shouldn't happen. Log it\n                this.client.error(`Lost request state in diagnostic pull model. Clearing diagnostics for ${key}`);\n                this.diagnostics.delete(uri);\n                return;\n            }\n            this.openRequests.delete(key);\n            if (!this.tabs.isVisible(document)) {\n                this.documentStates.unTrack(PullState.document, document);\n                return;\n            }\n            if (afterState.state === RequestStateKind.outDated) {\n                return;\n            }\n            // report is only undefined if the request has thrown.\n            if (report !== undefined) {\n                if (report.kind === vsdiag.DocumentDiagnosticReportKind.full) {\n                    this.diagnostics.set(uri, report.items);\n                }\n                documentState.pulledVersion = version;\n                documentState.resultId = report.resultId;\n            }\n            if (afterState.state === RequestStateKind.reschedule) {\n                this.pull(document);\n            }\n        }\n        else {\n            if (currentRequestState.state === RequestStateKind.active) {\n                // Cancel the current request and reschedule a new one when the old one returned.\n                currentRequestState.tokenSource.cancel();\n                this.openRequests.set(key, { state: RequestStateKind.reschedule, document: currentRequestState.document });\n            }\n            else if (currentRequestState.state === RequestStateKind.outDated) {\n                this.openRequests.set(key, { state: RequestStateKind.reschedule, document: currentRequestState.document });\n            }\n        }\n    }\n    forgetDocument(document) {\n        const uri = document instanceof vscode_1.Uri ? document : document.uri;\n        const key = uri.toString();\n        const request = this.openRequests.get(key);\n        if (this.options.workspaceDiagnostics) {\n            // If we run workspace diagnostic pull a last time for the diagnostics\n            // and the rely on getting them from the workspace result.\n            if (request !== undefined) {\n                this.openRequests.set(key, { state: RequestStateKind.reschedule, document: document });\n            }\n            else {\n                this.pull(document, () => {\n                    this.forget(PullState.document, document);\n                });\n            }\n        }\n        else {\n            // We have normal pull or inter file dependencies. In this case we\n            // clear the diagnostics (to have the same start as after startup).\n            // We also cancel outstanding requests.\n            if (request !== undefined) {\n                if (request.state === RequestStateKind.active) {\n                    request.tokenSource.cancel();\n                }\n                this.openRequests.set(key, { state: RequestStateKind.outDated, document: document });\n            }\n            this.diagnostics.delete(uri);\n            this.forget(PullState.document, document);\n        }\n    }\n    pullWorkspace() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.pullWorkspaceAsync().then(() => {\n            this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {\n                this.pullWorkspace();\n            }, 2000);\n        }, (error) => {\n            if (!(error instanceof features_1.LSPCancellationError) && !vscode_languageserver_protocol_1.DiagnosticServerCancellationData.is(error.data)) {\n                this.client.error(`Workspace diagnostic pull failed.`, error, false);\n                this.workspaceErrorCounter++;\n            }\n            if (this.workspaceErrorCounter <= 5) {\n                this.workspaceTimeout = (0, vscode_languageserver_protocol_1.RAL)().timer.setTimeout(() => {\n                    this.pullWorkspace();\n                }, 2000);\n            }\n        });\n    }\n    async pullWorkspaceAsync() {\n        if (!this.provider.provideWorkspaceDiagnostics || this.isDisposed) {\n            return;\n        }\n        if (this.workspaceCancellation !== undefined) {\n            this.workspaceCancellation.cancel();\n            this.workspaceCancellation = undefined;\n        }\n        this.workspaceCancellation = new vscode_1.CancellationTokenSource();\n        const previousResultIds = this.documentStates.getAllResultIds().map((item) => {\n            return {\n                uri: this.client.protocol2CodeConverter.asUri(item.uri),\n                value: item.value\n            };\n        });\n        await this.provider.provideWorkspaceDiagnostics(previousResultIds, this.workspaceCancellation.token, (chunk) => {\n            if (!chunk || this.isDisposed) {\n                return;\n            }\n            for (const item of chunk.items) {\n                if (item.kind === vsdiag.DocumentDiagnosticReportKind.full) {\n                    // Favour document pull result over workspace results. So skip if it is tracked\n                    // as a document result.\n                    if (!this.documentStates.tracks(PullState.document, item.uri)) {\n                        this.diagnostics.set(item.uri, item.items);\n                    }\n                }\n                this.documentStates.update(PullState.workspace, item.uri, item.version ?? undefined, item.resultId);\n            }\n        });\n    }\n    createProvider() {\n        const result = {\n            onDidChangeDiagnostics: this.onDidChangeDiagnosticsEmitter.event,\n            provideDiagnostics: (document, previousResultId, token) => {\n                const provideDiagnostics = (document, previousResultId, token) => {\n                    const params = {\n                        identifier: this.options.identifier,\n                        textDocument: { uri: this.client.code2ProtocolConverter.asUri(document instanceof vscode_1.Uri ? document : document.uri) },\n                        previousResultId: previousResultId\n                    };\n                    if (this.isDisposed === true || !this.client.isRunning()) {\n                        return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };\n                    }\n                    return this.client.sendRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, params, token).then(async (result) => {\n                        if (result === undefined || result === null || this.isDisposed || token.isCancellationRequested) {\n                            return { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] };\n                        }\n                        if (result.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {\n                            return { kind: vsdiag.DocumentDiagnosticReportKind.full, resultId: result.resultId, items: await this.client.protocol2CodeConverter.asDiagnostics(result.items, token) };\n                        }\n                        else {\n                            return { kind: vsdiag.DocumentDiagnosticReportKind.unChanged, resultId: result.resultId };\n                        }\n                    }, (error) => {\n                        return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token, error, { kind: vsdiag.DocumentDiagnosticReportKind.full, items: [] });\n                    });\n                };\n                const middleware = this.client.middleware;\n                return middleware.provideDiagnostics\n                    ? middleware.provideDiagnostics(document, previousResultId, token, provideDiagnostics)\n                    : provideDiagnostics(document, previousResultId, token);\n            }\n        };\n        if (this.options.workspaceDiagnostics) {\n            result.provideWorkspaceDiagnostics = (resultIds, token, resultReporter) => {\n                const convertReport = async (report) => {\n                    if (report.kind === vscode_languageserver_protocol_1.DocumentDiagnosticReportKind.Full) {\n                        return {\n                            kind: vsdiag.DocumentDiagnosticReportKind.full,\n                            uri: this.client.protocol2CodeConverter.asUri(report.uri),\n                            resultId: report.resultId,\n                            version: report.version,\n                            items: await this.client.protocol2CodeConverter.asDiagnostics(report.items, token)\n                        };\n                    }\n                    else {\n                        return {\n                            kind: vsdiag.DocumentDiagnosticReportKind.unChanged,\n                            uri: this.client.protocol2CodeConverter.asUri(report.uri),\n                            resultId: report.resultId,\n                            version: report.version\n                        };\n                    }\n                };\n                const convertPreviousResultIds = (resultIds) => {\n                    const converted = [];\n                    for (const item of resultIds) {\n                        converted.push({ uri: this.client.code2ProtocolConverter.asUri(item.uri), value: item.value });\n                    }\n                    return converted;\n                };\n                const provideDiagnostics = (resultIds, token) => {\n                    const partialResultToken = (0, uuid_1.generateUuid)();\n                    const disposable = this.client.onProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, partialResultToken, async (partialResult) => {\n                        if (partialResult === undefined || partialResult === null) {\n                            resultReporter(null);\n                            return;\n                        }\n                        const converted = {\n                            items: []\n                        };\n                        for (const item of partialResult.items) {\n                            try {\n                                converted.items.push(await convertReport(item));\n                            }\n                            catch (error) {\n                                this.client.error(`Converting workspace diagnostics failed.`, error);\n                            }\n                        }\n                        resultReporter(converted);\n                    });\n                    const params = {\n                        identifier: this.options.identifier,\n                        previousResultIds: convertPreviousResultIds(resultIds),\n                        partialResultToken: partialResultToken\n                    };\n                    if (this.isDisposed === true || !this.client.isRunning()) {\n                        return { items: [] };\n                    }\n                    return this.client.sendRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, params, token).then(async (result) => {\n                        if (token.isCancellationRequested) {\n                            return { items: [] };\n                        }\n                        const converted = {\n                            items: []\n                        };\n                        for (const item of result.items) {\n                            converted.items.push(await convertReport(item));\n                        }\n                        disposable.dispose();\n                        resultReporter(converted);\n                        return { items: [] };\n                    }, (error) => {\n                        disposable.dispose();\n                        return this.client.handleFailedRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, token, error, { items: [] });\n                    });\n                };\n                const middleware = this.client.middleware;\n                return middleware.provideWorkspaceDiagnostics\n                    ? middleware.provideWorkspaceDiagnostics(resultIds, token, resultReporter, provideDiagnostics)\n                    : provideDiagnostics(resultIds, token, resultReporter);\n            };\n        }\n        return result;\n    }\n    dispose() {\n        this.isDisposed = true;\n        // Cancel and clear workspace pull if present.\n        this.workspaceCancellation?.cancel();\n        this.workspaceTimeout?.dispose();\n        // Cancel all request and mark open requests as outdated.\n        for (const [key, request] of this.openRequests) {\n            if (request.state === RequestStateKind.active) {\n                request.tokenSource.cancel();\n            }\n            this.openRequests.set(key, { state: RequestStateKind.outDated, document: request.document });\n        }\n        // cleanup old diagnostics\n        this.diagnostics.dispose();\n    }\n}\nclass BackgroundScheduler {\n    constructor(diagnosticRequestor) {\n        this.diagnosticRequestor = diagnosticRequestor;\n        this.documents = new vscode_languageserver_protocol_1.LinkedMap();\n        this.isDisposed = false;\n    }\n    add(document) {\n        if (this.isDisposed === true) {\n            return;\n        }\n        const key = DocumentOrUri.asKey(document);\n        if (this.documents.has(key)) {\n            return;\n        }\n        this.documents.set(key, document, vscode_languageserver_protocol_1.Touch.Last);\n        this.trigger();\n    }\n    remove(document) {\n        const key = DocumentOrUri.asKey(document);\n        this.documents.delete(key);\n        // No more documents. Stop background activity.\n        if (this.documents.size === 0) {\n            this.stop();\n        }\n        else if (key === this.endDocumentKey()) {\n            // Make sure we have a correct last document. It could have\n            this.endDocument = this.documents.last;\n        }\n    }\n    trigger() {\n        if (this.isDisposed === true) {\n            return;\n        }\n        // We have a round running. So simply make sure we run up to the\n        // last document\n        if (this.intervalHandle !== undefined) {\n            this.endDocument = this.documents.last;\n            return;\n        }\n        this.endDocument = this.documents.last;\n        this.intervalHandle = (0, vscode_languageserver_protocol_1.RAL)().timer.setInterval(() => {\n            const document = this.documents.first;\n            if (document !== undefined) {\n                const key = DocumentOrUri.asKey(document);\n                this.diagnosticRequestor.pull(document);\n                this.documents.set(key, document, vscode_languageserver_protocol_1.Touch.Last);\n                if (key === this.endDocumentKey()) {\n                    this.stop();\n                }\n            }\n        }, 200);\n    }\n    dispose() {\n        this.isDisposed = true;\n        this.stop();\n        this.documents.clear();\n    }\n    stop() {\n        this.intervalHandle?.dispose();\n        this.intervalHandle = undefined;\n        this.endDocument = undefined;\n    }\n    endDocumentKey() {\n        return this.endDocument !== undefined ? DocumentOrUri.asKey(this.endDocument) : undefined;\n    }\n}\nclass DiagnosticFeatureProviderImpl {\n    constructor(client, tabs, options) {\n        const diagnosticPullOptions = client.clientOptions.diagnosticPullOptions ?? { onChange: true, onSave: false };\n        const documentSelector = client.protocol2CodeConverter.asDocumentSelector(options.documentSelector);\n        const disposables = [];\n        const matchResource = (resource) => {\n            const selector = options.documentSelector;\n            if (diagnosticPullOptions.match !== undefined) {\n                return diagnosticPullOptions.match(selector, resource);\n            }\n            for (const filter of selector) {\n                if (!vscode_languageserver_protocol_1.TextDocumentFilter.is(filter)) {\n                    continue;\n                }\n                // The filter is a language id. We can't determine if it matches\n                // so we return false.\n                if (typeof filter === 'string') {\n                    return false;\n                }\n                if (filter.language !== undefined && filter.language !== '*') {\n                    return false;\n                }\n                if (filter.scheme !== undefined && filter.scheme !== '*' && filter.scheme !== resource.scheme) {\n                    return false;\n                }\n                if (filter.pattern !== undefined) {\n                    const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });\n                    if (!matcher.makeRe()) {\n                        return false;\n                    }\n                    if (!matcher.match(resource.fsPath)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        };\n        const matches = (document) => {\n            return document instanceof vscode_1.Uri\n                ? matchResource(document)\n                : vscode_1.languages.match(documentSelector, document) > 0 && tabs.isVisible(document);\n        };\n        const isActiveDocument = (document) => {\n            return document instanceof vscode_1.Uri\n                ? this.activeTextDocument?.uri.toString() === document.toString()\n                : this.activeTextDocument === document;\n        };\n        this.diagnosticRequestor = new DiagnosticRequestor(client, tabs, options);\n        this.backgroundScheduler = new BackgroundScheduler(this.diagnosticRequestor);\n        const addToBackgroundIfNeeded = (document) => {\n            if (!matches(document) || !options.interFileDependencies || isActiveDocument(document)) {\n                return;\n            }\n            this.backgroundScheduler.add(document);\n        };\n        this.activeTextDocument = vscode_1.window.activeTextEditor?.document;\n        vscode_1.window.onDidChangeActiveTextEditor((editor) => {\n            const oldActive = this.activeTextDocument;\n            this.activeTextDocument = editor?.document;\n            if (oldActive !== undefined) {\n                addToBackgroundIfNeeded(oldActive);\n            }\n            if (this.activeTextDocument !== undefined) {\n                this.backgroundScheduler.remove(this.activeTextDocument);\n            }\n        });\n        // For pull model diagnostics we pull for documents visible in the UI.\n        // From an eventing point of view we still rely on open document events\n        // and filter the documents that are not visible in the UI instead of\n        // listening to Tab events. Major reason is event timing since we need\n        // to ensure that the pull is send after the document open has reached\n        // the server.\n        // We always pull on open.\n        const openFeature = client.getFeature(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.method);\n        disposables.push(openFeature.onNotificationSent((event) => {\n            const textDocument = event.textDocument;\n            // We already know about this document. This can happen via a tab open.\n            if (this.diagnosticRequestor.knows(PullState.document, textDocument)) {\n                return;\n            }\n            if (matches(textDocument)) {\n                this.diagnosticRequestor.pull(textDocument, () => { addToBackgroundIfNeeded(textDocument); });\n            }\n        }));\n        disposables.push(tabs.onOpen((opened) => {\n            for (const resource of opened) {\n                // We already know about this document. This can happen via a document open.\n                if (this.diagnosticRequestor.knows(PullState.document, resource)) {\n                    continue;\n                }\n                const uriStr = resource.toString();\n                let textDocument;\n                for (const item of vscode_1.workspace.textDocuments) {\n                    if (uriStr === item.uri.toString()) {\n                        textDocument = item;\n                        break;\n                    }\n                }\n                // In VS Code the event timing is as follows:\n                // 1. tab events are fired.\n                // 2. open document events are fired and internal data structures like\n                //    workspace.textDocuments and Window.activeTextEditor are updated.\n                //\n                // This means: for newly created tab/editors we don't find the underlying\n                // document yet. So we do nothing an rely on the underlying open document event\n                // to be fired.\n                if (textDocument !== undefined && matches(textDocument)) {\n                    this.diagnosticRequestor.pull(textDocument, () => { addToBackgroundIfNeeded(textDocument); });\n                }\n            }\n        }));\n        // Pull all diagnostics for documents that are already open\n        const pulledTextDocuments = new Set();\n        for (const textDocument of vscode_1.workspace.textDocuments) {\n            if (matches(textDocument)) {\n                this.diagnosticRequestor.pull(textDocument, () => { addToBackgroundIfNeeded(textDocument); });\n                pulledTextDocuments.add(textDocument.uri.toString());\n            }\n        }\n        // Pull all tabs if not already pulled as text document\n        if (diagnosticPullOptions.onTabs === true) {\n            for (const resource of tabs.getTabResources()) {\n                if (!pulledTextDocuments.has(resource.toString()) && matches(resource)) {\n                    this.diagnosticRequestor.pull(resource, () => { addToBackgroundIfNeeded(resource); });\n                }\n            }\n        }\n        // We don't need to pull on tab open since we will receive a document open as well later on\n        // and that event allows us to use a document for a match check which will have a set\n        // language id.\n        if (diagnosticPullOptions.onChange === true) {\n            const changeFeature = client.getFeature(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.method);\n            disposables.push(changeFeature.onNotificationSent(async (event) => {\n                const textDocument = event.textDocument;\n                if ((diagnosticPullOptions.filter === undefined || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onType)) && this.diagnosticRequestor.knows(PullState.document, textDocument)) {\n                    this.diagnosticRequestor.pull(textDocument, () => { this.backgroundScheduler.trigger(); });\n                }\n            }));\n        }\n        if (diagnosticPullOptions.onSave === true) {\n            const saveFeature = client.getFeature(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.method);\n            disposables.push(saveFeature.onNotificationSent((event) => {\n                const textDocument = event.textDocument;\n                if ((diagnosticPullOptions.filter === undefined || !diagnosticPullOptions.filter(textDocument, DiagnosticPullMode.onSave)) && this.diagnosticRequestor.knows(PullState.document, textDocument)) {\n                    this.diagnosticRequestor.pull(event.textDocument, () => { this.backgroundScheduler.trigger(); });\n                }\n            }));\n        }\n        // When the document closes clear things up\n        const closeFeature = client.getFeature(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.method);\n        disposables.push(closeFeature.onNotificationSent((event) => {\n            this.cleanUpDocument(event.textDocument);\n        }));\n        // Same when a tabs closes.\n        tabs.onClose((closed) => {\n            for (const document of closed) {\n                this.cleanUpDocument(document);\n            }\n        });\n        // We received a did change from the server.\n        this.diagnosticRequestor.onDidChangeDiagnosticsEmitter.event(() => {\n            for (const textDocument of vscode_1.workspace.textDocuments) {\n                if (matches(textDocument)) {\n                    this.diagnosticRequestor.pull(textDocument);\n                }\n            }\n        });\n        // da348dc5-c30a-4515-9d98-31ff3be38d14 is the test UUID to test the middle ware. So don't auto trigger pulls.\n        if (options.workspaceDiagnostics === true && options.identifier !== 'da348dc5-c30a-4515-9d98-31ff3be38d14') {\n            this.diagnosticRequestor.pullWorkspace();\n        }\n        this.disposable = vscode_1.Disposable.from(...disposables, this.backgroundScheduler, this.diagnosticRequestor);\n    }\n    get onDidChangeDiagnosticsEmitter() {\n        return this.diagnosticRequestor.onDidChangeDiagnosticsEmitter;\n    }\n    get diagnostics() {\n        return this.diagnosticRequestor.provider;\n    }\n    cleanUpDocument(document) {\n        if (this.diagnosticRequestor.knows(PullState.document, document)) {\n            this.diagnosticRequestor.forgetDocument(document);\n            this.backgroundScheduler.remove(document);\n        }\n    }\n}\nclass DiagnosticFeature extends features_1.TextDocumentLanguageFeature {\n    constructor(client) {\n        super(client, vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type);\n    }\n    fillClientCapabilities(capabilities) {\n        let capability = ensure(ensure(capabilities, 'textDocument'), 'diagnostic');\n        capability.dynamicRegistration = true;\n        // We first need to decide how a UI will look with related documents.\n        // An easy implementation would be to only show related diagnostics for\n        // the active editor.\n        capability.relatedDocumentSupport = false;\n        ensure(ensure(capabilities, 'workspace'), 'diagnostics').refreshSupport = true;\n    }\n    initialize(capabilities, documentSelector) {\n        const client = this._client;\n        client.onRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type, async () => {\n            for (const provider of this.getAllProviders()) {\n                provider.onDidChangeDiagnosticsEmitter.fire();\n            }\n        });\n        let [id, options] = this.getRegistration(documentSelector, capabilities.diagnosticProvider);\n        if (!id || !options) {\n            return;\n        }\n        this.register({ id: id, registerOptions: options });\n    }\n    clear() {\n        if (this.tabs !== undefined) {\n            this.tabs.dispose();\n            this.tabs = undefined;\n        }\n        super.clear();\n    }\n    registerLanguageProvider(options) {\n        if (this.tabs === undefined) {\n            this.tabs = new Tabs();\n        }\n        const provider = new DiagnosticFeatureProviderImpl(this._client, this.tabs, options);\n        return [provider.disposable, provider];\n    }\n}\nexports.DiagnosticFeature = DiagnosticFeature;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}