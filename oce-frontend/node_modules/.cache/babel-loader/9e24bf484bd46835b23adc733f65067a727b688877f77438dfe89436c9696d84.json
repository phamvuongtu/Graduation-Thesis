{"ast":null,"code":"\"use strict\";\n\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;\nconst ral_1 = require(\"./ral\");\nconst Is = require(\"./is\");\nconst messages_1 = require(\"./messages\");\nconst linkedMap_1 = require(\"./linkedMap\");\nconst events_1 = require(\"./events\");\nconst cancellation_1 = require(\"./cancellation\");\nvar CancelNotification;\n(function (CancelNotification) {\n  CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');\n})(CancelNotification || (CancelNotification = {}));\nvar ProgressToken;\n(function (ProgressToken) {\n  function is(value) {\n    return typeof value === 'string' || typeof value === 'number';\n  }\n  ProgressToken.is = is;\n})(ProgressToken || (exports.ProgressToken = ProgressToken = {}));\nvar ProgressNotification;\n(function (ProgressNotification) {\n  ProgressNotification.type = new messages_1.NotificationType('$/progress');\n})(ProgressNotification || (ProgressNotification = {}));\nclass ProgressType {\n  constructor() {}\n}\nexports.ProgressType = ProgressType;\nvar StarRequestHandler;\n(function (StarRequestHandler) {\n  function is(value) {\n    return Is.func(value);\n  }\n  StarRequestHandler.is = is;\n})(StarRequestHandler || (StarRequestHandler = {}));\nexports.NullLogger = Object.freeze({\n  error: () => {},\n  warn: () => {},\n  info: () => {},\n  log: () => {}\n});\nvar Trace;\n(function (Trace) {\n  Trace[Trace[\"Off\"] = 0] = \"Off\";\n  Trace[Trace[\"Messages\"] = 1] = \"Messages\";\n  Trace[Trace[\"Compact\"] = 2] = \"Compact\";\n  Trace[Trace[\"Verbose\"] = 3] = \"Verbose\";\n})(Trace || (exports.Trace = Trace = {}));\nvar TraceValues;\n(function (TraceValues) {\n  /**\n   * Turn tracing off.\n   */\n  TraceValues.Off = 'off';\n  /**\n   * Trace messages only.\n   */\n  TraceValues.Messages = 'messages';\n  /**\n   * Compact message tracing.\n   */\n  TraceValues.Compact = 'compact';\n  /**\n   * Verbose message tracing.\n   */\n  TraceValues.Verbose = 'verbose';\n})(TraceValues || (exports.TraceValues = TraceValues = {}));\n(function (Trace) {\n  function fromString(value) {\n    if (!Is.string(value)) {\n      return Trace.Off;\n    }\n    value = value.toLowerCase();\n    switch (value) {\n      case 'off':\n        return Trace.Off;\n      case 'messages':\n        return Trace.Messages;\n      case 'compact':\n        return Trace.Compact;\n      case 'verbose':\n        return Trace.Verbose;\n      default:\n        return Trace.Off;\n    }\n  }\n  Trace.fromString = fromString;\n  function toString(value) {\n    switch (value) {\n      case Trace.Off:\n        return 'off';\n      case Trace.Messages:\n        return 'messages';\n      case Trace.Compact:\n        return 'compact';\n      case Trace.Verbose:\n        return 'verbose';\n      default:\n        return 'off';\n    }\n  }\n  Trace.toString = toString;\n})(Trace || (exports.Trace = Trace = {}));\nvar TraceFormat;\n(function (TraceFormat) {\n  TraceFormat[\"Text\"] = \"text\";\n  TraceFormat[\"JSON\"] = \"json\";\n})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));\n(function (TraceFormat) {\n  function fromString(value) {\n    if (!Is.string(value)) {\n      return TraceFormat.Text;\n    }\n    value = value.toLowerCase();\n    if (value === 'json') {\n      return TraceFormat.JSON;\n    } else {\n      return TraceFormat.Text;\n    }\n  }\n  TraceFormat.fromString = fromString;\n})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));\nvar SetTraceNotification;\n(function (SetTraceNotification) {\n  SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');\n})(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));\nvar LogTraceNotification;\n(function (LogTraceNotification) {\n  LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');\n})(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));\nvar ConnectionErrors;\n(function (ConnectionErrors) {\n  /**\n   * The connection is closed.\n   */\n  ConnectionErrors[ConnectionErrors[\"Closed\"] = 1] = \"Closed\";\n  /**\n   * The connection got disposed.\n   */\n  ConnectionErrors[ConnectionErrors[\"Disposed\"] = 2] = \"Disposed\";\n  /**\n   * The connection is already in listening mode.\n   */\n  ConnectionErrors[ConnectionErrors[\"AlreadyListening\"] = 3] = \"AlreadyListening\";\n})(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));\nclass ConnectionError extends Error {\n  constructor(code, message) {\n    super(message);\n    this.code = code;\n    Object.setPrototypeOf(this, ConnectionError.prototype);\n  }\n}\nexports.ConnectionError = ConnectionError;\nvar ConnectionStrategy;\n(function (ConnectionStrategy) {\n  function is(value) {\n    const candidate = value;\n    return candidate && Is.func(candidate.cancelUndispatched);\n  }\n  ConnectionStrategy.is = is;\n})(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));\nvar IdCancellationReceiverStrategy;\n(function (IdCancellationReceiverStrategy) {\n  function is(value) {\n    const candidate = value;\n    return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));\n  }\n  IdCancellationReceiverStrategy.is = is;\n})(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));\nvar RequestCancellationReceiverStrategy;\n(function (RequestCancellationReceiverStrategy) {\n  function is(value) {\n    const candidate = value;\n    return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));\n  }\n  RequestCancellationReceiverStrategy.is = is;\n})(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));\nvar CancellationReceiverStrategy;\n(function (CancellationReceiverStrategy) {\n  CancellationReceiverStrategy.Message = Object.freeze({\n    createCancellationTokenSource(_) {\n      return new cancellation_1.CancellationTokenSource();\n    }\n  });\n  function is(value) {\n    return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);\n  }\n  CancellationReceiverStrategy.is = is;\n})(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));\nvar CancellationSenderStrategy;\n(function (CancellationSenderStrategy) {\n  CancellationSenderStrategy.Message = Object.freeze({\n    sendCancellation(conn, id) {\n      return conn.sendNotification(CancelNotification.type, {\n        id\n      });\n    },\n    cleanup(_) {}\n  });\n  function is(value) {\n    const candidate = value;\n    return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);\n  }\n  CancellationSenderStrategy.is = is;\n})(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));\nvar CancellationStrategy;\n(function (CancellationStrategy) {\n  CancellationStrategy.Message = Object.freeze({\n    receiver: CancellationReceiverStrategy.Message,\n    sender: CancellationSenderStrategy.Message\n  });\n  function is(value) {\n    const candidate = value;\n    return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);\n  }\n  CancellationStrategy.is = is;\n})(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));\nvar MessageStrategy;\n(function (MessageStrategy) {\n  function is(value) {\n    const candidate = value;\n    return candidate && Is.func(candidate.handleMessage);\n  }\n  MessageStrategy.is = is;\n})(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));\nvar ConnectionOptions;\n(function (ConnectionOptions) {\n  function is(value) {\n    const candidate = value;\n    return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));\n  }\n  ConnectionOptions.is = is;\n})(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));\nvar ConnectionState;\n(function (ConnectionState) {\n  ConnectionState[ConnectionState[\"New\"] = 1] = \"New\";\n  ConnectionState[ConnectionState[\"Listening\"] = 2] = \"Listening\";\n  ConnectionState[ConnectionState[\"Closed\"] = 3] = \"Closed\";\n  ConnectionState[ConnectionState[\"Disposed\"] = 4] = \"Disposed\";\n})(ConnectionState || (ConnectionState = {}));\nfunction createMessageConnection(messageReader, messageWriter, _logger, options) {\n  const logger = _logger !== undefined ? _logger : exports.NullLogger;\n  let sequenceNumber = 0;\n  let notificationSequenceNumber = 0;\n  let unknownResponseSequenceNumber = 0;\n  const version = '2.0';\n  let starRequestHandler = undefined;\n  const requestHandlers = new Map();\n  let starNotificationHandler = undefined;\n  const notificationHandlers = new Map();\n  const progressHandlers = new Map();\n  let timer;\n  let messageQueue = new linkedMap_1.LinkedMap();\n  let responsePromises = new Map();\n  let knownCanceledRequests = new Set();\n  let requestTokens = new Map();\n  let trace = Trace.Off;\n  let traceFormat = TraceFormat.Text;\n  let tracer;\n  let state = ConnectionState.New;\n  const errorEmitter = new events_1.Emitter();\n  const closeEmitter = new events_1.Emitter();\n  const unhandledNotificationEmitter = new events_1.Emitter();\n  const unhandledProgressEmitter = new events_1.Emitter();\n  const disposeEmitter = new events_1.Emitter();\n  const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;\n  function createRequestQueueKey(id) {\n    if (id === null) {\n      throw new Error(`Can't send requests with id null since the response can't be correlated.`);\n    }\n    return 'req-' + id.toString();\n  }\n  function createResponseQueueKey(id) {\n    if (id === null) {\n      return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();\n    } else {\n      return 'res-' + id.toString();\n    }\n  }\n  function createNotificationQueueKey() {\n    return 'not-' + (++notificationSequenceNumber).toString();\n  }\n  function addMessageToQueue(queue, message) {\n    if (messages_1.Message.isRequest(message)) {\n      queue.set(createRequestQueueKey(message.id), message);\n    } else if (messages_1.Message.isResponse(message)) {\n      queue.set(createResponseQueueKey(message.id), message);\n    } else {\n      queue.set(createNotificationQueueKey(), message);\n    }\n  }\n  function cancelUndispatched(_message) {\n    return undefined;\n  }\n  function isListening() {\n    return state === ConnectionState.Listening;\n  }\n  function isClosed() {\n    return state === ConnectionState.Closed;\n  }\n  function isDisposed() {\n    return state === ConnectionState.Disposed;\n  }\n  function closeHandler() {\n    if (state === ConnectionState.New || state === ConnectionState.Listening) {\n      state = ConnectionState.Closed;\n      closeEmitter.fire(undefined);\n    }\n    // If the connection is disposed don't sent close events.\n  }\n  function readErrorHandler(error) {\n    errorEmitter.fire([error, undefined, undefined]);\n  }\n  function writeErrorHandler(data) {\n    errorEmitter.fire(data);\n  }\n  messageReader.onClose(closeHandler);\n  messageReader.onError(readErrorHandler);\n  messageWriter.onClose(closeHandler);\n  messageWriter.onError(writeErrorHandler);\n  function triggerMessageQueue() {\n    if (timer || messageQueue.size === 0) {\n      return;\n    }\n    timer = (0, ral_1.default)().timer.setImmediate(() => {\n      timer = undefined;\n      processMessageQueue();\n    });\n  }\n  function handleMessage(message) {\n    if (messages_1.Message.isRequest(message)) {\n      handleRequest(message);\n    } else if (messages_1.Message.isNotification(message)) {\n      handleNotification(message);\n    } else if (messages_1.Message.isResponse(message)) {\n      handleResponse(message);\n    } else {\n      handleInvalidMessage(message);\n    }\n  }\n  function processMessageQueue() {\n    if (messageQueue.size === 0) {\n      return;\n    }\n    const message = messageQueue.shift();\n    try {\n      const messageStrategy = options?.messageStrategy;\n      if (MessageStrategy.is(messageStrategy)) {\n        messageStrategy.handleMessage(message, handleMessage);\n      } else {\n        handleMessage(message);\n      }\n    } finally {\n      triggerMessageQueue();\n    }\n  }\n  const callback = message => {\n    try {\n      // We have received a cancellation message. Check if the message is still in the queue\n      // and cancel it if allowed to do so.\n      if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {\n        const cancelId = message.params.id;\n        const key = createRequestQueueKey(cancelId);\n        const toCancel = messageQueue.get(key);\n        if (messages_1.Message.isRequest(toCancel)) {\n          const strategy = options?.connectionStrategy;\n          const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);\n          if (response && (response.error !== undefined || response.result !== undefined)) {\n            messageQueue.delete(key);\n            requestTokens.delete(cancelId);\n            response.id = toCancel.id;\n            traceSendingResponse(response, message.method, Date.now());\n            messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));\n            return;\n          }\n        }\n        const cancellationToken = requestTokens.get(cancelId);\n        // The request is already running. Cancel the token\n        if (cancellationToken !== undefined) {\n          cancellationToken.cancel();\n          traceReceivedNotification(message);\n          return;\n        } else {\n          // Remember the cancel but still queue the message to\n          // clean up state in process message.\n          knownCanceledRequests.add(cancelId);\n        }\n      }\n      addMessageToQueue(messageQueue, message);\n    } finally {\n      triggerMessageQueue();\n    }\n  };\n  function handleRequest(requestMessage) {\n    if (isDisposed()) {\n      // we return here silently since we fired an event when the\n      // connection got disposed.\n      return;\n    }\n    function reply(resultOrError, method, startTime) {\n      const message = {\n        jsonrpc: version,\n        id: requestMessage.id\n      };\n      if (resultOrError instanceof messages_1.ResponseError) {\n        message.error = resultOrError.toJson();\n      } else {\n        message.result = resultOrError === undefined ? null : resultOrError;\n      }\n      traceSendingResponse(message, method, startTime);\n      messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));\n    }\n    function replyError(error, method, startTime) {\n      const message = {\n        jsonrpc: version,\n        id: requestMessage.id,\n        error: error.toJson()\n      };\n      traceSendingResponse(message, method, startTime);\n      messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));\n    }\n    function replySuccess(result, method, startTime) {\n      // The JSON RPC defines that a response must either have a result or an error\n      // So we can't treat undefined as a valid response result.\n      if (result === undefined) {\n        result = null;\n      }\n      const message = {\n        jsonrpc: version,\n        id: requestMessage.id,\n        result: result\n      };\n      traceSendingResponse(message, method, startTime);\n      messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));\n    }\n    traceReceivedRequest(requestMessage);\n    const element = requestHandlers.get(requestMessage.method);\n    let type;\n    let requestHandler;\n    if (element) {\n      type = element.type;\n      requestHandler = element.handler;\n    }\n    const startTime = Date.now();\n    if (requestHandler || starRequestHandler) {\n      const tokenKey = requestMessage.id ?? String(Date.now()); //\n      const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver) ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey) : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);\n      if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {\n        cancellationSource.cancel();\n      }\n      if (requestMessage.id !== null) {\n        requestTokens.set(tokenKey, cancellationSource);\n      }\n      try {\n        let handlerResult;\n        if (requestHandler) {\n          if (requestMessage.params === undefined) {\n            if (type !== undefined && type.numberOfParams !== 0) {\n              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);\n              return;\n            }\n            handlerResult = requestHandler(cancellationSource.token);\n          } else if (Array.isArray(requestMessage.params)) {\n            if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {\n              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);\n              return;\n            }\n            handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);\n          } else {\n            if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {\n              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);\n              return;\n            }\n            handlerResult = requestHandler(requestMessage.params, cancellationSource.token);\n          }\n        } else if (starRequestHandler) {\n          handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);\n        }\n        const promise = handlerResult;\n        if (!handlerResult) {\n          requestTokens.delete(tokenKey);\n          replySuccess(handlerResult, requestMessage.method, startTime);\n        } else if (promise.then) {\n          promise.then(resultOrError => {\n            requestTokens.delete(tokenKey);\n            reply(resultOrError, requestMessage.method, startTime);\n          }, error => {\n            requestTokens.delete(tokenKey);\n            if (error instanceof messages_1.ResponseError) {\n              replyError(error, requestMessage.method, startTime);\n            } else if (error && Is.string(error.message)) {\n              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\n            } else {\n              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\n            }\n          });\n        } else {\n          requestTokens.delete(tokenKey);\n          reply(handlerResult, requestMessage.method, startTime);\n        }\n      } catch (error) {\n        requestTokens.delete(tokenKey);\n        if (error instanceof messages_1.ResponseError) {\n          reply(error, requestMessage.method, startTime);\n        } else if (error && Is.string(error.message)) {\n          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\n        } else {\n          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\n        }\n      }\n    } else {\n      replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);\n    }\n  }\n  function handleResponse(responseMessage) {\n    if (isDisposed()) {\n      // See handle request.\n      return;\n    }\n    if (responseMessage.id === null) {\n      if (responseMessage.error) {\n        logger.error(`Received response message without id: Error is: \\n${JSON.stringify(responseMessage.error, undefined, 4)}`);\n      } else {\n        logger.error(`Received response message without id. No further error information provided.`);\n      }\n    } else {\n      const key = responseMessage.id;\n      const responsePromise = responsePromises.get(key);\n      traceReceivedResponse(responseMessage, responsePromise);\n      if (responsePromise !== undefined) {\n        responsePromises.delete(key);\n        try {\n          if (responseMessage.error) {\n            const error = responseMessage.error;\n            responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));\n          } else if (responseMessage.result !== undefined) {\n            responsePromise.resolve(responseMessage.result);\n          } else {\n            throw new Error('Should never happen.');\n          }\n        } catch (error) {\n          if (error.message) {\n            logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);\n          } else {\n            logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);\n          }\n        }\n      }\n    }\n  }\n  function handleNotification(message) {\n    if (isDisposed()) {\n      // See handle request.\n      return;\n    }\n    let type = undefined;\n    let notificationHandler;\n    if (message.method === CancelNotification.type.method) {\n      const cancelId = message.params.id;\n      knownCanceledRequests.delete(cancelId);\n      traceReceivedNotification(message);\n      return;\n    } else {\n      const element = notificationHandlers.get(message.method);\n      if (element) {\n        notificationHandler = element.handler;\n        type = element.type;\n      }\n    }\n    if (notificationHandler || starNotificationHandler) {\n      try {\n        traceReceivedNotification(message);\n        if (notificationHandler) {\n          if (message.params === undefined) {\n            if (type !== undefined) {\n              if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {\n                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);\n              }\n            }\n            notificationHandler();\n          } else if (Array.isArray(message.params)) {\n            // There are JSON-RPC libraries that send progress message as positional params although\n            // specified as named. So convert them if this is the case.\n            const params = message.params;\n            if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {\n              notificationHandler({\n                token: params[0],\n                value: params[1]\n              });\n            } else {\n              if (type !== undefined) {\n                if (type.parameterStructures === messages_1.ParameterStructures.byName) {\n                  logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);\n                }\n                if (type.numberOfParams !== message.params.length) {\n                  logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);\n                }\n              }\n              notificationHandler(...params);\n            }\n          } else {\n            if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {\n              logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);\n            }\n            notificationHandler(message.params);\n          }\n        } else if (starNotificationHandler) {\n          starNotificationHandler(message.method, message.params);\n        }\n      } catch (error) {\n        if (error.message) {\n          logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);\n        } else {\n          logger.error(`Notification handler '${message.method}' failed unexpectedly.`);\n        }\n      }\n    } else {\n      unhandledNotificationEmitter.fire(message);\n    }\n  }\n  function handleInvalidMessage(message) {\n    if (!message) {\n      logger.error('Received empty message.');\n      return;\n    }\n    logger.error(`Received message which is neither a response nor a notification message:\\n${JSON.stringify(message, null, 4)}`);\n    // Test whether we find an id to reject the promise\n    const responseMessage = message;\n    if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {\n      const key = responseMessage.id;\n      const responseHandler = responsePromises.get(key);\n      if (responseHandler) {\n        responseHandler.reject(new Error('The received response has neither a result nor an error property.'));\n      }\n    }\n  }\n  function stringifyTrace(params) {\n    if (params === undefined || params === null) {\n      return undefined;\n    }\n    switch (trace) {\n      case Trace.Verbose:\n        return JSON.stringify(params, null, 4);\n      case Trace.Compact:\n        return JSON.stringify(params);\n      default:\n        return undefined;\n    }\n  }\n  function traceSendingRequest(message) {\n    if (trace === Trace.Off || !tracer) {\n      return;\n    }\n    if (traceFormat === TraceFormat.Text) {\n      let data = undefined;\n      if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {\n        data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n      }\n      tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);\n    } else {\n      logLSPMessage('send-request', message);\n    }\n  }\n  function traceSendingNotification(message) {\n    if (trace === Trace.Off || !tracer) {\n      return;\n    }\n    if (traceFormat === TraceFormat.Text) {\n      let data = undefined;\n      if (trace === Trace.Verbose || trace === Trace.Compact) {\n        if (message.params) {\n          data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n        } else {\n          data = 'No parameters provided.\\n\\n';\n        }\n      }\n      tracer.log(`Sending notification '${message.method}'.`, data);\n    } else {\n      logLSPMessage('send-notification', message);\n    }\n  }\n  function traceSendingResponse(message, method, startTime) {\n    if (trace === Trace.Off || !tracer) {\n      return;\n    }\n    if (traceFormat === TraceFormat.Text) {\n      let data = undefined;\n      if (trace === Trace.Verbose || trace === Trace.Compact) {\n        if (message.error && message.error.data) {\n          data = `Error data: ${stringifyTrace(message.error.data)}\\n\\n`;\n        } else {\n          if (message.result) {\n            data = `Result: ${stringifyTrace(message.result)}\\n\\n`;\n          } else if (message.error === undefined) {\n            data = 'No result returned.\\n\\n';\n          }\n        }\n      }\n      tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);\n    } else {\n      logLSPMessage('send-response', message);\n    }\n  }\n  function traceReceivedRequest(message) {\n    if (trace === Trace.Off || !tracer) {\n      return;\n    }\n    if (traceFormat === TraceFormat.Text) {\n      let data = undefined;\n      if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {\n        data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n      }\n      tracer.log(`Received request '${message.method} - (${message.id})'.`, data);\n    } else {\n      logLSPMessage('receive-request', message);\n    }\n  }\n  function traceReceivedNotification(message) {\n    if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {\n      return;\n    }\n    if (traceFormat === TraceFormat.Text) {\n      let data = undefined;\n      if (trace === Trace.Verbose || trace === Trace.Compact) {\n        if (message.params) {\n          data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n        } else {\n          data = 'No parameters provided.\\n\\n';\n        }\n      }\n      tracer.log(`Received notification '${message.method}'.`, data);\n    } else {\n      logLSPMessage('receive-notification', message);\n    }\n  }\n  function traceReceivedResponse(message, responsePromise) {\n    if (trace === Trace.Off || !tracer) {\n      return;\n    }\n    if (traceFormat === TraceFormat.Text) {\n      let data = undefined;\n      if (trace === Trace.Verbose || trace === Trace.Compact) {\n        if (message.error && message.error.data) {\n          data = `Error data: ${stringifyTrace(message.error.data)}\\n\\n`;\n        } else {\n          if (message.result) {\n            data = `Result: ${stringifyTrace(message.result)}\\n\\n`;\n          } else if (message.error === undefined) {\n            data = 'No result returned.\\n\\n';\n          }\n        }\n      }\n      if (responsePromise) {\n        const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';\n        tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);\n      } else {\n        tracer.log(`Received response ${message.id} without active response promise.`, data);\n      }\n    } else {\n      logLSPMessage('receive-response', message);\n    }\n  }\n  function logLSPMessage(type, message) {\n    if (!tracer || trace === Trace.Off) {\n      return;\n    }\n    const lspMessage = {\n      isLSPMessage: true,\n      type,\n      message,\n      timestamp: Date.now()\n    };\n    tracer.log(lspMessage);\n  }\n  function throwIfClosedOrDisposed() {\n    if (isClosed()) {\n      throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');\n    }\n    if (isDisposed()) {\n      throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');\n    }\n  }\n  function throwIfListening() {\n    if (isListening()) {\n      throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');\n    }\n  }\n  function throwIfNotListening() {\n    if (!isListening()) {\n      throw new Error('Call listen() first.');\n    }\n  }\n  function undefinedToNull(param) {\n    if (param === undefined) {\n      return null;\n    } else {\n      return param;\n    }\n  }\n  function nullToUndefined(param) {\n    if (param === null) {\n      return undefined;\n    } else {\n      return param;\n    }\n  }\n  function isNamedParam(param) {\n    return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';\n  }\n  function computeSingleParam(parameterStructures, param) {\n    switch (parameterStructures) {\n      case messages_1.ParameterStructures.auto:\n        if (isNamedParam(param)) {\n          return nullToUndefined(param);\n        } else {\n          return [undefinedToNull(param)];\n        }\n      case messages_1.ParameterStructures.byName:\n        if (!isNamedParam(param)) {\n          throw new Error(`Received parameters by name but param is not an object literal.`);\n        }\n        return nullToUndefined(param);\n      case messages_1.ParameterStructures.byPosition:\n        return [undefinedToNull(param)];\n      default:\n        throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);\n    }\n  }\n  function computeMessageParams(type, params) {\n    let result;\n    const numberOfParams = type.numberOfParams;\n    switch (numberOfParams) {\n      case 0:\n        result = undefined;\n        break;\n      case 1:\n        result = computeSingleParam(type.parameterStructures, params[0]);\n        break;\n      default:\n        result = [];\n        for (let i = 0; i < params.length && i < numberOfParams; i++) {\n          result.push(undefinedToNull(params[i]));\n        }\n        if (params.length < numberOfParams) {\n          for (let i = params.length; i < numberOfParams; i++) {\n            result.push(null);\n          }\n        }\n        break;\n    }\n    return result;\n  }\n  const connection = {\n    sendNotification: (type, ...args) => {\n      throwIfClosedOrDisposed();\n      let method;\n      let messageParams;\n      if (Is.string(type)) {\n        method = type;\n        const first = args[0];\n        let paramStart = 0;\n        let parameterStructures = messages_1.ParameterStructures.auto;\n        if (messages_1.ParameterStructures.is(first)) {\n          paramStart = 1;\n          parameterStructures = first;\n        }\n        let paramEnd = args.length;\n        const numberOfParams = paramEnd - paramStart;\n        switch (numberOfParams) {\n          case 0:\n            messageParams = undefined;\n            break;\n          case 1:\n            messageParams = computeSingleParam(parameterStructures, args[paramStart]);\n            break;\n          default:\n            if (parameterStructures === messages_1.ParameterStructures.byName) {\n              throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);\n            }\n            messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));\n            break;\n        }\n      } else {\n        const params = args;\n        method = type.method;\n        messageParams = computeMessageParams(type, params);\n      }\n      const notificationMessage = {\n        jsonrpc: version,\n        method: method,\n        params: messageParams\n      };\n      traceSendingNotification(notificationMessage);\n      return messageWriter.write(notificationMessage).catch(error => {\n        logger.error(`Sending notification failed.`);\n        throw error;\n      });\n    },\n    onNotification: (type, handler) => {\n      throwIfClosedOrDisposed();\n      let method;\n      if (Is.func(type)) {\n        starNotificationHandler = type;\n      } else if (handler) {\n        if (Is.string(type)) {\n          method = type;\n          notificationHandlers.set(type, {\n            type: undefined,\n            handler\n          });\n        } else {\n          method = type.method;\n          notificationHandlers.set(type.method, {\n            type,\n            handler\n          });\n        }\n      }\n      return {\n        dispose: () => {\n          if (method !== undefined) {\n            notificationHandlers.delete(method);\n          } else {\n            starNotificationHandler = undefined;\n          }\n        }\n      };\n    },\n    onProgress: (_type, token, handler) => {\n      if (progressHandlers.has(token)) {\n        throw new Error(`Progress handler for token ${token} already registered`);\n      }\n      progressHandlers.set(token, handler);\n      return {\n        dispose: () => {\n          progressHandlers.delete(token);\n        }\n      };\n    },\n    sendProgress: (_type, token, value) => {\n      // This should not await but simple return to ensure that we don't have another\n      // async scheduling. Otherwise one send could overtake another send.\n      return connection.sendNotification(ProgressNotification.type, {\n        token,\n        value\n      });\n    },\n    onUnhandledProgress: unhandledProgressEmitter.event,\n    sendRequest: (type, ...args) => {\n      throwIfClosedOrDisposed();\n      throwIfNotListening();\n      let method;\n      let messageParams;\n      let token = undefined;\n      if (Is.string(type)) {\n        method = type;\n        const first = args[0];\n        const last = args[args.length - 1];\n        let paramStart = 0;\n        let parameterStructures = messages_1.ParameterStructures.auto;\n        if (messages_1.ParameterStructures.is(first)) {\n          paramStart = 1;\n          parameterStructures = first;\n        }\n        let paramEnd = args.length;\n        if (cancellation_1.CancellationToken.is(last)) {\n          paramEnd = paramEnd - 1;\n          token = last;\n        }\n        const numberOfParams = paramEnd - paramStart;\n        switch (numberOfParams) {\n          case 0:\n            messageParams = undefined;\n            break;\n          case 1:\n            messageParams = computeSingleParam(parameterStructures, args[paramStart]);\n            break;\n          default:\n            if (parameterStructures === messages_1.ParameterStructures.byName) {\n              throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);\n            }\n            messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));\n            break;\n        }\n      } else {\n        const params = args;\n        method = type.method;\n        messageParams = computeMessageParams(type, params);\n        const numberOfParams = type.numberOfParams;\n        token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;\n      }\n      const id = sequenceNumber++;\n      let disposable;\n      if (token) {\n        disposable = token.onCancellationRequested(() => {\n          const p = cancellationStrategy.sender.sendCancellation(connection, id);\n          if (p === undefined) {\n            logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);\n            return Promise.resolve();\n          } else {\n            return p.catch(() => {\n              logger.log(`Sending cancellation messages for id ${id} failed`);\n            });\n          }\n        });\n      }\n      const requestMessage = {\n        jsonrpc: version,\n        id: id,\n        method: method,\n        params: messageParams\n      };\n      traceSendingRequest(requestMessage);\n      if (typeof cancellationStrategy.sender.enableCancellation === 'function') {\n        cancellationStrategy.sender.enableCancellation(requestMessage);\n      }\n      return new Promise(async (resolve, reject) => {\n        const resolveWithCleanup = r => {\n          resolve(r);\n          cancellationStrategy.sender.cleanup(id);\n          disposable?.dispose();\n        };\n        const rejectWithCleanup = r => {\n          reject(r);\n          cancellationStrategy.sender.cleanup(id);\n          disposable?.dispose();\n        };\n        const responsePromise = {\n          method: method,\n          timerStart: Date.now(),\n          resolve: resolveWithCleanup,\n          reject: rejectWithCleanup\n        };\n        try {\n          await messageWriter.write(requestMessage);\n          responsePromises.set(id, responsePromise);\n        } catch (error) {\n          logger.error(`Sending request failed.`);\n          // Writing the message failed. So we need to reject the promise.\n          responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));\n          throw error;\n        }\n      });\n    },\n    onRequest: (type, handler) => {\n      throwIfClosedOrDisposed();\n      let method = null;\n      if (StarRequestHandler.is(type)) {\n        method = undefined;\n        starRequestHandler = type;\n      } else if (Is.string(type)) {\n        method = null;\n        if (handler !== undefined) {\n          method = type;\n          requestHandlers.set(type, {\n            handler: handler,\n            type: undefined\n          });\n        }\n      } else {\n        if (handler !== undefined) {\n          method = type.method;\n          requestHandlers.set(type.method, {\n            type,\n            handler\n          });\n        }\n      }\n      return {\n        dispose: () => {\n          if (method === null) {\n            return;\n          }\n          if (method !== undefined) {\n            requestHandlers.delete(method);\n          } else {\n            starRequestHandler = undefined;\n          }\n        }\n      };\n    },\n    hasPendingResponse: () => {\n      return responsePromises.size > 0;\n    },\n    trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {\n      let _sendNotification = false;\n      let _traceFormat = TraceFormat.Text;\n      if (sendNotificationOrTraceOptions !== undefined) {\n        if (Is.boolean(sendNotificationOrTraceOptions)) {\n          _sendNotification = sendNotificationOrTraceOptions;\n        } else {\n          _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;\n          _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;\n        }\n      }\n      trace = _value;\n      traceFormat = _traceFormat;\n      if (trace === Trace.Off) {\n        tracer = undefined;\n      } else {\n        tracer = _tracer;\n      }\n      if (_sendNotification && !isClosed() && !isDisposed()) {\n        await connection.sendNotification(SetTraceNotification.type, {\n          value: Trace.toString(_value)\n        });\n      }\n    },\n    onError: errorEmitter.event,\n    onClose: closeEmitter.event,\n    onUnhandledNotification: unhandledNotificationEmitter.event,\n    onDispose: disposeEmitter.event,\n    end: () => {\n      messageWriter.end();\n    },\n    dispose: () => {\n      if (isDisposed()) {\n        return;\n      }\n      state = ConnectionState.Disposed;\n      disposeEmitter.fire(undefined);\n      const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');\n      for (const promise of responsePromises.values()) {\n        promise.reject(error);\n      }\n      responsePromises = new Map();\n      requestTokens = new Map();\n      knownCanceledRequests = new Set();\n      messageQueue = new linkedMap_1.LinkedMap();\n      // Test for backwards compatibility\n      if (Is.func(messageWriter.dispose)) {\n        messageWriter.dispose();\n      }\n      if (Is.func(messageReader.dispose)) {\n        messageReader.dispose();\n      }\n    },\n    listen: () => {\n      throwIfClosedOrDisposed();\n      throwIfListening();\n      state = ConnectionState.Listening;\n      messageReader.listen(callback);\n    },\n    inspect: () => {\n      // eslint-disable-next-line no-console\n      (0, ral_1.default)().console.log('inspect');\n    }\n  };\n  connection.onNotification(LogTraceNotification.type, params => {\n    if (trace === Trace.Off || !tracer) {\n      return;\n    }\n    const verbose = trace === Trace.Verbose || trace === Trace.Compact;\n    tracer.log(params.message, verbose ? params.verbose : undefined);\n  });\n  connection.onNotification(ProgressNotification.type, params => {\n    const handler = progressHandlers.get(params.token);\n    if (handler) {\n      handler(params.value);\n    } else {\n      unhandledProgressEmitter.fire(params);\n    }\n  });\n  return connection;\n}\nexports.createMessageConnection = createMessageConnection;","map":{"version":3,"names":["Object","defineProperty","exports","value","createMessageConnection","ConnectionOptions","MessageStrategy","CancellationStrategy","CancellationSenderStrategy","CancellationReceiverStrategy","RequestCancellationReceiverStrategy","IdCancellationReceiverStrategy","ConnectionStrategy","ConnectionError","ConnectionErrors","LogTraceNotification","SetTraceNotification","TraceFormat","TraceValues","Trace","NullLogger","ProgressType","ProgressToken","ral_1","require","Is","messages_1","linkedMap_1","events_1","cancellation_1","CancelNotification","type","NotificationType","is","ProgressNotification","constructor","StarRequestHandler","func","freeze","error","warn","info","log","Off","Messages","Compact","Verbose","fromString","string","toLowerCase","toString","Text","JSON","Error","code","message","setPrototypeOf","prototype","candidate","cancelUndispatched","kind","undefined","createCancellationTokenSource","dispose","Message","_","CancellationTokenSource","sendCancellation","conn","id","sendNotification","cleanup","receiver","sender","handleMessage","cancellationStrategy","connectionStrategy","messageStrategy","ConnectionState","messageReader","messageWriter","_logger","options","logger","sequenceNumber","notificationSequenceNumber","unknownResponseSequenceNumber","version","starRequestHandler","requestHandlers","Map","starNotificationHandler","notificationHandlers","progressHandlers","timer","messageQueue","LinkedMap","responsePromises","knownCanceledRequests","Set","requestTokens","trace","traceFormat","tracer","state","New","errorEmitter","Emitter","closeEmitter","unhandledNotificationEmitter","unhandledProgressEmitter","disposeEmitter","createRequestQueueKey","createResponseQueueKey","createNotificationQueueKey","addMessageToQueue","queue","isRequest","set","isResponse","_message","isListening","Listening","isClosed","Closed","isDisposed","Disposed","closeHandler","fire","readErrorHandler","writeErrorHandler","data","onClose","onError","triggerMessageQueue","size","default","setImmediate","processMessageQueue","handleRequest","isNotification","handleNotification","handleResponse","handleInvalidMessage","shift","callback","method","cancelId","params","key","toCancel","get","strategy","response","result","delete","traceSendingResponse","Date","now","write","catch","cancellationToken","cancel","traceReceivedNotification","add","requestMessage","reply","resultOrError","startTime","jsonrpc","ResponseError","toJson","replyError","replySuccess","traceReceivedRequest","element","requestHandler","handler","tokenKey","String","cancellationSource","has","handlerResult","numberOfParams","ErrorCodes","InvalidParams","token","Array","isArray","parameterStructures","ParameterStructures","byName","byPosition","promise","then","InternalError","MethodNotFound","responseMessage","stringify","responsePromise","traceReceivedResponse","reject","resolve","notificationHandler","length","number","responseHandler","stringifyTrace","traceSendingRequest","logLSPMessage","traceSendingNotification","timerStart","lspMessage","isLSPMessage","timestamp","throwIfClosedOrDisposed","throwIfListening","AlreadyListening","throwIfNotListening","undefinedToNull","param","nullToUndefined","isNamedParam","computeSingleParam","auto","computeMessageParams","i","push","connection","args","messageParams","first","paramStart","paramEnd","slice","map","notificationMessage","onNotification","onProgress","_type","sendProgress","onUnhandledProgress","event","sendRequest","last","CancellationToken","disposable","onCancellationRequested","p","Promise","enableCancellation","resolveWithCleanup","r","rejectWithCleanup","MessageWriteError","onRequest","hasPendingResponse","_value","_tracer","sendNotificationOrTraceOptions","_sendNotification","_traceFormat","boolean","onUnhandledNotification","onDispose","end","PendingResponseRejected","values","listen","inspect","console","verbose"],"sources":["/Users/phamtu/Downloads/Code/OCE/oce-frontend/node_modules/vscode-jsonrpc/lib/common/connection.js"],"sourcesContent":["\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;\nconst ral_1 = require(\"./ral\");\nconst Is = require(\"./is\");\nconst messages_1 = require(\"./messages\");\nconst linkedMap_1 = require(\"./linkedMap\");\nconst events_1 = require(\"./events\");\nconst cancellation_1 = require(\"./cancellation\");\nvar CancelNotification;\n(function (CancelNotification) {\n    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');\n})(CancelNotification || (CancelNotification = {}));\nvar ProgressToken;\n(function (ProgressToken) {\n    function is(value) {\n        return typeof value === 'string' || typeof value === 'number';\n    }\n    ProgressToken.is = is;\n})(ProgressToken || (exports.ProgressToken = ProgressToken = {}));\nvar ProgressNotification;\n(function (ProgressNotification) {\n    ProgressNotification.type = new messages_1.NotificationType('$/progress');\n})(ProgressNotification || (ProgressNotification = {}));\nclass ProgressType {\n    constructor() {\n    }\n}\nexports.ProgressType = ProgressType;\nvar StarRequestHandler;\n(function (StarRequestHandler) {\n    function is(value) {\n        return Is.func(value);\n    }\n    StarRequestHandler.is = is;\n})(StarRequestHandler || (StarRequestHandler = {}));\nexports.NullLogger = Object.freeze({\n    error: () => { },\n    warn: () => { },\n    info: () => { },\n    log: () => { }\n});\nvar Trace;\n(function (Trace) {\n    Trace[Trace[\"Off\"] = 0] = \"Off\";\n    Trace[Trace[\"Messages\"] = 1] = \"Messages\";\n    Trace[Trace[\"Compact\"] = 2] = \"Compact\";\n    Trace[Trace[\"Verbose\"] = 3] = \"Verbose\";\n})(Trace || (exports.Trace = Trace = {}));\nvar TraceValues;\n(function (TraceValues) {\n    /**\n     * Turn tracing off.\n     */\n    TraceValues.Off = 'off';\n    /**\n     * Trace messages only.\n     */\n    TraceValues.Messages = 'messages';\n    /**\n     * Compact message tracing.\n     */\n    TraceValues.Compact = 'compact';\n    /**\n     * Verbose message tracing.\n     */\n    TraceValues.Verbose = 'verbose';\n})(TraceValues || (exports.TraceValues = TraceValues = {}));\n(function (Trace) {\n    function fromString(value) {\n        if (!Is.string(value)) {\n            return Trace.Off;\n        }\n        value = value.toLowerCase();\n        switch (value) {\n            case 'off':\n                return Trace.Off;\n            case 'messages':\n                return Trace.Messages;\n            case 'compact':\n                return Trace.Compact;\n            case 'verbose':\n                return Trace.Verbose;\n            default:\n                return Trace.Off;\n        }\n    }\n    Trace.fromString = fromString;\n    function toString(value) {\n        switch (value) {\n            case Trace.Off:\n                return 'off';\n            case Trace.Messages:\n                return 'messages';\n            case Trace.Compact:\n                return 'compact';\n            case Trace.Verbose:\n                return 'verbose';\n            default:\n                return 'off';\n        }\n    }\n    Trace.toString = toString;\n})(Trace || (exports.Trace = Trace = {}));\nvar TraceFormat;\n(function (TraceFormat) {\n    TraceFormat[\"Text\"] = \"text\";\n    TraceFormat[\"JSON\"] = \"json\";\n})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));\n(function (TraceFormat) {\n    function fromString(value) {\n        if (!Is.string(value)) {\n            return TraceFormat.Text;\n        }\n        value = value.toLowerCase();\n        if (value === 'json') {\n            return TraceFormat.JSON;\n        }\n        else {\n            return TraceFormat.Text;\n        }\n    }\n    TraceFormat.fromString = fromString;\n})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));\nvar SetTraceNotification;\n(function (SetTraceNotification) {\n    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');\n})(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));\nvar LogTraceNotification;\n(function (LogTraceNotification) {\n    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');\n})(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));\nvar ConnectionErrors;\n(function (ConnectionErrors) {\n    /**\n     * The connection is closed.\n     */\n    ConnectionErrors[ConnectionErrors[\"Closed\"] = 1] = \"Closed\";\n    /**\n     * The connection got disposed.\n     */\n    ConnectionErrors[ConnectionErrors[\"Disposed\"] = 2] = \"Disposed\";\n    /**\n     * The connection is already in listening mode.\n     */\n    ConnectionErrors[ConnectionErrors[\"AlreadyListening\"] = 3] = \"AlreadyListening\";\n})(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));\nclass ConnectionError extends Error {\n    constructor(code, message) {\n        super(message);\n        this.code = code;\n        Object.setPrototypeOf(this, ConnectionError.prototype);\n    }\n}\nexports.ConnectionError = ConnectionError;\nvar ConnectionStrategy;\n(function (ConnectionStrategy) {\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.func(candidate.cancelUndispatched);\n    }\n    ConnectionStrategy.is = is;\n})(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));\nvar IdCancellationReceiverStrategy;\n(function (IdCancellationReceiverStrategy) {\n    function is(value) {\n        const candidate = value;\n        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));\n    }\n    IdCancellationReceiverStrategy.is = is;\n})(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));\nvar RequestCancellationReceiverStrategy;\n(function (RequestCancellationReceiverStrategy) {\n    function is(value) {\n        const candidate = value;\n        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));\n    }\n    RequestCancellationReceiverStrategy.is = is;\n})(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));\nvar CancellationReceiverStrategy;\n(function (CancellationReceiverStrategy) {\n    CancellationReceiverStrategy.Message = Object.freeze({\n        createCancellationTokenSource(_) {\n            return new cancellation_1.CancellationTokenSource();\n        }\n    });\n    function is(value) {\n        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);\n    }\n    CancellationReceiverStrategy.is = is;\n})(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));\nvar CancellationSenderStrategy;\n(function (CancellationSenderStrategy) {\n    CancellationSenderStrategy.Message = Object.freeze({\n        sendCancellation(conn, id) {\n            return conn.sendNotification(CancelNotification.type, { id });\n        },\n        cleanup(_) { }\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);\n    }\n    CancellationSenderStrategy.is = is;\n})(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));\nvar CancellationStrategy;\n(function (CancellationStrategy) {\n    CancellationStrategy.Message = Object.freeze({\n        receiver: CancellationReceiverStrategy.Message,\n        sender: CancellationSenderStrategy.Message\n    });\n    function is(value) {\n        const candidate = value;\n        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);\n    }\n    CancellationStrategy.is = is;\n})(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));\nvar MessageStrategy;\n(function (MessageStrategy) {\n    function is(value) {\n        const candidate = value;\n        return candidate && Is.func(candidate.handleMessage);\n    }\n    MessageStrategy.is = is;\n})(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));\nvar ConnectionOptions;\n(function (ConnectionOptions) {\n    function is(value) {\n        const candidate = value;\n        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));\n    }\n    ConnectionOptions.is = is;\n})(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));\nvar ConnectionState;\n(function (ConnectionState) {\n    ConnectionState[ConnectionState[\"New\"] = 1] = \"New\";\n    ConnectionState[ConnectionState[\"Listening\"] = 2] = \"Listening\";\n    ConnectionState[ConnectionState[\"Closed\"] = 3] = \"Closed\";\n    ConnectionState[ConnectionState[\"Disposed\"] = 4] = \"Disposed\";\n})(ConnectionState || (ConnectionState = {}));\nfunction createMessageConnection(messageReader, messageWriter, _logger, options) {\n    const logger = _logger !== undefined ? _logger : exports.NullLogger;\n    let sequenceNumber = 0;\n    let notificationSequenceNumber = 0;\n    let unknownResponseSequenceNumber = 0;\n    const version = '2.0';\n    let starRequestHandler = undefined;\n    const requestHandlers = new Map();\n    let starNotificationHandler = undefined;\n    const notificationHandlers = new Map();\n    const progressHandlers = new Map();\n    let timer;\n    let messageQueue = new linkedMap_1.LinkedMap();\n    let responsePromises = new Map();\n    let knownCanceledRequests = new Set();\n    let requestTokens = new Map();\n    let trace = Trace.Off;\n    let traceFormat = TraceFormat.Text;\n    let tracer;\n    let state = ConnectionState.New;\n    const errorEmitter = new events_1.Emitter();\n    const closeEmitter = new events_1.Emitter();\n    const unhandledNotificationEmitter = new events_1.Emitter();\n    const unhandledProgressEmitter = new events_1.Emitter();\n    const disposeEmitter = new events_1.Emitter();\n    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;\n    function createRequestQueueKey(id) {\n        if (id === null) {\n            throw new Error(`Can't send requests with id null since the response can't be correlated.`);\n        }\n        return 'req-' + id.toString();\n    }\n    function createResponseQueueKey(id) {\n        if (id === null) {\n            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();\n        }\n        else {\n            return 'res-' + id.toString();\n        }\n    }\n    function createNotificationQueueKey() {\n        return 'not-' + (++notificationSequenceNumber).toString();\n    }\n    function addMessageToQueue(queue, message) {\n        if (messages_1.Message.isRequest(message)) {\n            queue.set(createRequestQueueKey(message.id), message);\n        }\n        else if (messages_1.Message.isResponse(message)) {\n            queue.set(createResponseQueueKey(message.id), message);\n        }\n        else {\n            queue.set(createNotificationQueueKey(), message);\n        }\n    }\n    function cancelUndispatched(_message) {\n        return undefined;\n    }\n    function isListening() {\n        return state === ConnectionState.Listening;\n    }\n    function isClosed() {\n        return state === ConnectionState.Closed;\n    }\n    function isDisposed() {\n        return state === ConnectionState.Disposed;\n    }\n    function closeHandler() {\n        if (state === ConnectionState.New || state === ConnectionState.Listening) {\n            state = ConnectionState.Closed;\n            closeEmitter.fire(undefined);\n        }\n        // If the connection is disposed don't sent close events.\n    }\n    function readErrorHandler(error) {\n        errorEmitter.fire([error, undefined, undefined]);\n    }\n    function writeErrorHandler(data) {\n        errorEmitter.fire(data);\n    }\n    messageReader.onClose(closeHandler);\n    messageReader.onError(readErrorHandler);\n    messageWriter.onClose(closeHandler);\n    messageWriter.onError(writeErrorHandler);\n    function triggerMessageQueue() {\n        if (timer || messageQueue.size === 0) {\n            return;\n        }\n        timer = (0, ral_1.default)().timer.setImmediate(() => {\n            timer = undefined;\n            processMessageQueue();\n        });\n    }\n    function handleMessage(message) {\n        if (messages_1.Message.isRequest(message)) {\n            handleRequest(message);\n        }\n        else if (messages_1.Message.isNotification(message)) {\n            handleNotification(message);\n        }\n        else if (messages_1.Message.isResponse(message)) {\n            handleResponse(message);\n        }\n        else {\n            handleInvalidMessage(message);\n        }\n    }\n    function processMessageQueue() {\n        if (messageQueue.size === 0) {\n            return;\n        }\n        const message = messageQueue.shift();\n        try {\n            const messageStrategy = options?.messageStrategy;\n            if (MessageStrategy.is(messageStrategy)) {\n                messageStrategy.handleMessage(message, handleMessage);\n            }\n            else {\n                handleMessage(message);\n            }\n        }\n        finally {\n            triggerMessageQueue();\n        }\n    }\n    const callback = (message) => {\n        try {\n            // We have received a cancellation message. Check if the message is still in the queue\n            // and cancel it if allowed to do so.\n            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {\n                const cancelId = message.params.id;\n                const key = createRequestQueueKey(cancelId);\n                const toCancel = messageQueue.get(key);\n                if (messages_1.Message.isRequest(toCancel)) {\n                    const strategy = options?.connectionStrategy;\n                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);\n                    if (response && (response.error !== undefined || response.result !== undefined)) {\n                        messageQueue.delete(key);\n                        requestTokens.delete(cancelId);\n                        response.id = toCancel.id;\n                        traceSendingResponse(response, message.method, Date.now());\n                        messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));\n                        return;\n                    }\n                }\n                const cancellationToken = requestTokens.get(cancelId);\n                // The request is already running. Cancel the token\n                if (cancellationToken !== undefined) {\n                    cancellationToken.cancel();\n                    traceReceivedNotification(message);\n                    return;\n                }\n                else {\n                    // Remember the cancel but still queue the message to\n                    // clean up state in process message.\n                    knownCanceledRequests.add(cancelId);\n                }\n            }\n            addMessageToQueue(messageQueue, message);\n        }\n        finally {\n            triggerMessageQueue();\n        }\n    };\n    function handleRequest(requestMessage) {\n        if (isDisposed()) {\n            // we return here silently since we fired an event when the\n            // connection got disposed.\n            return;\n        }\n        function reply(resultOrError, method, startTime) {\n            const message = {\n                jsonrpc: version,\n                id: requestMessage.id\n            };\n            if (resultOrError instanceof messages_1.ResponseError) {\n                message.error = resultOrError.toJson();\n            }\n            else {\n                message.result = resultOrError === undefined ? null : resultOrError;\n            }\n            traceSendingResponse(message, method, startTime);\n            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));\n        }\n        function replyError(error, method, startTime) {\n            const message = {\n                jsonrpc: version,\n                id: requestMessage.id,\n                error: error.toJson()\n            };\n            traceSendingResponse(message, method, startTime);\n            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));\n        }\n        function replySuccess(result, method, startTime) {\n            // The JSON RPC defines that a response must either have a result or an error\n            // So we can't treat undefined as a valid response result.\n            if (result === undefined) {\n                result = null;\n            }\n            const message = {\n                jsonrpc: version,\n                id: requestMessage.id,\n                result: result\n            };\n            traceSendingResponse(message, method, startTime);\n            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));\n        }\n        traceReceivedRequest(requestMessage);\n        const element = requestHandlers.get(requestMessage.method);\n        let type;\n        let requestHandler;\n        if (element) {\n            type = element.type;\n            requestHandler = element.handler;\n        }\n        const startTime = Date.now();\n        if (requestHandler || starRequestHandler) {\n            const tokenKey = requestMessage.id ?? String(Date.now()); //\n            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver)\n                ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey)\n                : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);\n            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {\n                cancellationSource.cancel();\n            }\n            if (requestMessage.id !== null) {\n                requestTokens.set(tokenKey, cancellationSource);\n            }\n            try {\n                let handlerResult;\n                if (requestHandler) {\n                    if (requestMessage.params === undefined) {\n                        if (type !== undefined && type.numberOfParams !== 0) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);\n                            return;\n                        }\n                        handlerResult = requestHandler(cancellationSource.token);\n                    }\n                    else if (Array.isArray(requestMessage.params)) {\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);\n                            return;\n                        }\n                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);\n                    }\n                    else {\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);\n                            return;\n                        }\n                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);\n                    }\n                }\n                else if (starRequestHandler) {\n                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);\n                }\n                const promise = handlerResult;\n                if (!handlerResult) {\n                    requestTokens.delete(tokenKey);\n                    replySuccess(handlerResult, requestMessage.method, startTime);\n                }\n                else if (promise.then) {\n                    promise.then((resultOrError) => {\n                        requestTokens.delete(tokenKey);\n                        reply(resultOrError, requestMessage.method, startTime);\n                    }, error => {\n                        requestTokens.delete(tokenKey);\n                        if (error instanceof messages_1.ResponseError) {\n                            replyError(error, requestMessage.method, startTime);\n                        }\n                        else if (error && Is.string(error.message)) {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\n                        }\n                        else {\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\n                        }\n                    });\n                }\n                else {\n                    requestTokens.delete(tokenKey);\n                    reply(handlerResult, requestMessage.method, startTime);\n                }\n            }\n            catch (error) {\n                requestTokens.delete(tokenKey);\n                if (error instanceof messages_1.ResponseError) {\n                    reply(error, requestMessage.method, startTime);\n                }\n                else if (error && Is.string(error.message)) {\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\n                }\n                else {\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\n                }\n            }\n        }\n        else {\n            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);\n        }\n    }\n    function handleResponse(responseMessage) {\n        if (isDisposed()) {\n            // See handle request.\n            return;\n        }\n        if (responseMessage.id === null) {\n            if (responseMessage.error) {\n                logger.error(`Received response message without id: Error is: \\n${JSON.stringify(responseMessage.error, undefined, 4)}`);\n            }\n            else {\n                logger.error(`Received response message without id. No further error information provided.`);\n            }\n        }\n        else {\n            const key = responseMessage.id;\n            const responsePromise = responsePromises.get(key);\n            traceReceivedResponse(responseMessage, responsePromise);\n            if (responsePromise !== undefined) {\n                responsePromises.delete(key);\n                try {\n                    if (responseMessage.error) {\n                        const error = responseMessage.error;\n                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));\n                    }\n                    else if (responseMessage.result !== undefined) {\n                        responsePromise.resolve(responseMessage.result);\n                    }\n                    else {\n                        throw new Error('Should never happen.');\n                    }\n                }\n                catch (error) {\n                    if (error.message) {\n                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);\n                    }\n                    else {\n                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);\n                    }\n                }\n            }\n        }\n    }\n    function handleNotification(message) {\n        if (isDisposed()) {\n            // See handle request.\n            return;\n        }\n        let type = undefined;\n        let notificationHandler;\n        if (message.method === CancelNotification.type.method) {\n            const cancelId = message.params.id;\n            knownCanceledRequests.delete(cancelId);\n            traceReceivedNotification(message);\n            return;\n        }\n        else {\n            const element = notificationHandlers.get(message.method);\n            if (element) {\n                notificationHandler = element.handler;\n                type = element.type;\n            }\n        }\n        if (notificationHandler || starNotificationHandler) {\n            try {\n                traceReceivedNotification(message);\n                if (notificationHandler) {\n                    if (message.params === undefined) {\n                        if (type !== undefined) {\n                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {\n                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);\n                            }\n                        }\n                        notificationHandler();\n                    }\n                    else if (Array.isArray(message.params)) {\n                        // There are JSON-RPC libraries that send progress message as positional params although\n                        // specified as named. So convert them if this is the case.\n                        const params = message.params;\n                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {\n                            notificationHandler({ token: params[0], value: params[1] });\n                        }\n                        else {\n                            if (type !== undefined) {\n                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {\n                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);\n                                }\n                                if (type.numberOfParams !== message.params.length) {\n                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);\n                                }\n                            }\n                            notificationHandler(...params);\n                        }\n                    }\n                    else {\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {\n                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);\n                        }\n                        notificationHandler(message.params);\n                    }\n                }\n                else if (starNotificationHandler) {\n                    starNotificationHandler(message.method, message.params);\n                }\n            }\n            catch (error) {\n                if (error.message) {\n                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);\n                }\n                else {\n                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);\n                }\n            }\n        }\n        else {\n            unhandledNotificationEmitter.fire(message);\n        }\n    }\n    function handleInvalidMessage(message) {\n        if (!message) {\n            logger.error('Received empty message.');\n            return;\n        }\n        logger.error(`Received message which is neither a response nor a notification message:\\n${JSON.stringify(message, null, 4)}`);\n        // Test whether we find an id to reject the promise\n        const responseMessage = message;\n        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {\n            const key = responseMessage.id;\n            const responseHandler = responsePromises.get(key);\n            if (responseHandler) {\n                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));\n            }\n        }\n    }\n    function stringifyTrace(params) {\n        if (params === undefined || params === null) {\n            return undefined;\n        }\n        switch (trace) {\n            case Trace.Verbose:\n                return JSON.stringify(params, null, 4);\n            case Trace.Compact:\n                return JSON.stringify(params);\n            default:\n                return undefined;\n        }\n    }\n    function traceSendingRequest(message) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {\n                data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n            }\n            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);\n        }\n        else {\n            logLSPMessage('send-request', message);\n        }\n    }\n    function traceSendingNotification(message) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\n                if (message.params) {\n                    data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n                }\n                else {\n                    data = 'No parameters provided.\\n\\n';\n                }\n            }\n            tracer.log(`Sending notification '${message.method}'.`, data);\n        }\n        else {\n            logLSPMessage('send-notification', message);\n        }\n    }\n    function traceSendingResponse(message, method, startTime) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\n                if (message.error && message.error.data) {\n                    data = `Error data: ${stringifyTrace(message.error.data)}\\n\\n`;\n                }\n                else {\n                    if (message.result) {\n                        data = `Result: ${stringifyTrace(message.result)}\\n\\n`;\n                    }\n                    else if (message.error === undefined) {\n                        data = 'No result returned.\\n\\n';\n                    }\n                }\n            }\n            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);\n        }\n        else {\n            logLSPMessage('send-response', message);\n        }\n    }\n    function traceReceivedRequest(message) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {\n                data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n            }\n            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);\n        }\n        else {\n            logLSPMessage('receive-request', message);\n        }\n    }\n    function traceReceivedNotification(message) {\n        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\n                if (message.params) {\n                    data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\n                }\n                else {\n                    data = 'No parameters provided.\\n\\n';\n                }\n            }\n            tracer.log(`Received notification '${message.method}'.`, data);\n        }\n        else {\n            logLSPMessage('receive-notification', message);\n        }\n    }\n    function traceReceivedResponse(message, responsePromise) {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        if (traceFormat === TraceFormat.Text) {\n            let data = undefined;\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\n                if (message.error && message.error.data) {\n                    data = `Error data: ${stringifyTrace(message.error.data)}\\n\\n`;\n                }\n                else {\n                    if (message.result) {\n                        data = `Result: ${stringifyTrace(message.result)}\\n\\n`;\n                    }\n                    else if (message.error === undefined) {\n                        data = 'No result returned.\\n\\n';\n                    }\n                }\n            }\n            if (responsePromise) {\n                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';\n                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);\n            }\n            else {\n                tracer.log(`Received response ${message.id} without active response promise.`, data);\n            }\n        }\n        else {\n            logLSPMessage('receive-response', message);\n        }\n    }\n    function logLSPMessage(type, message) {\n        if (!tracer || trace === Trace.Off) {\n            return;\n        }\n        const lspMessage = {\n            isLSPMessage: true,\n            type,\n            message,\n            timestamp: Date.now()\n        };\n        tracer.log(lspMessage);\n    }\n    function throwIfClosedOrDisposed() {\n        if (isClosed()) {\n            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');\n        }\n        if (isDisposed()) {\n            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');\n        }\n    }\n    function throwIfListening() {\n        if (isListening()) {\n            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');\n        }\n    }\n    function throwIfNotListening() {\n        if (!isListening()) {\n            throw new Error('Call listen() first.');\n        }\n    }\n    function undefinedToNull(param) {\n        if (param === undefined) {\n            return null;\n        }\n        else {\n            return param;\n        }\n    }\n    function nullToUndefined(param) {\n        if (param === null) {\n            return undefined;\n        }\n        else {\n            return param;\n        }\n    }\n    function isNamedParam(param) {\n        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';\n    }\n    function computeSingleParam(parameterStructures, param) {\n        switch (parameterStructures) {\n            case messages_1.ParameterStructures.auto:\n                if (isNamedParam(param)) {\n                    return nullToUndefined(param);\n                }\n                else {\n                    return [undefinedToNull(param)];\n                }\n            case messages_1.ParameterStructures.byName:\n                if (!isNamedParam(param)) {\n                    throw new Error(`Received parameters by name but param is not an object literal.`);\n                }\n                return nullToUndefined(param);\n            case messages_1.ParameterStructures.byPosition:\n                return [undefinedToNull(param)];\n            default:\n                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);\n        }\n    }\n    function computeMessageParams(type, params) {\n        let result;\n        const numberOfParams = type.numberOfParams;\n        switch (numberOfParams) {\n            case 0:\n                result = undefined;\n                break;\n            case 1:\n                result = computeSingleParam(type.parameterStructures, params[0]);\n                break;\n            default:\n                result = [];\n                for (let i = 0; i < params.length && i < numberOfParams; i++) {\n                    result.push(undefinedToNull(params[i]));\n                }\n                if (params.length < numberOfParams) {\n                    for (let i = params.length; i < numberOfParams; i++) {\n                        result.push(null);\n                    }\n                }\n                break;\n        }\n        return result;\n    }\n    const connection = {\n        sendNotification: (type, ...args) => {\n            throwIfClosedOrDisposed();\n            let method;\n            let messageParams;\n            if (Is.string(type)) {\n                method = type;\n                const first = args[0];\n                let paramStart = 0;\n                let parameterStructures = messages_1.ParameterStructures.auto;\n                if (messages_1.ParameterStructures.is(first)) {\n                    paramStart = 1;\n                    parameterStructures = first;\n                }\n                let paramEnd = args.length;\n                const numberOfParams = paramEnd - paramStart;\n                switch (numberOfParams) {\n                    case 0:\n                        messageParams = undefined;\n                        break;\n                    case 1:\n                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);\n                        break;\n                    default:\n                        if (parameterStructures === messages_1.ParameterStructures.byName) {\n                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);\n                        }\n                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));\n                        break;\n                }\n            }\n            else {\n                const params = args;\n                method = type.method;\n                messageParams = computeMessageParams(type, params);\n            }\n            const notificationMessage = {\n                jsonrpc: version,\n                method: method,\n                params: messageParams\n            };\n            traceSendingNotification(notificationMessage);\n            return messageWriter.write(notificationMessage).catch((error) => {\n                logger.error(`Sending notification failed.`);\n                throw error;\n            });\n        },\n        onNotification: (type, handler) => {\n            throwIfClosedOrDisposed();\n            let method;\n            if (Is.func(type)) {\n                starNotificationHandler = type;\n            }\n            else if (handler) {\n                if (Is.string(type)) {\n                    method = type;\n                    notificationHandlers.set(type, { type: undefined, handler });\n                }\n                else {\n                    method = type.method;\n                    notificationHandlers.set(type.method, { type, handler });\n                }\n            }\n            return {\n                dispose: () => {\n                    if (method !== undefined) {\n                        notificationHandlers.delete(method);\n                    }\n                    else {\n                        starNotificationHandler = undefined;\n                    }\n                }\n            };\n        },\n        onProgress: (_type, token, handler) => {\n            if (progressHandlers.has(token)) {\n                throw new Error(`Progress handler for token ${token} already registered`);\n            }\n            progressHandlers.set(token, handler);\n            return {\n                dispose: () => {\n                    progressHandlers.delete(token);\n                }\n            };\n        },\n        sendProgress: (_type, token, value) => {\n            // This should not await but simple return to ensure that we don't have another\n            // async scheduling. Otherwise one send could overtake another send.\n            return connection.sendNotification(ProgressNotification.type, { token, value });\n        },\n        onUnhandledProgress: unhandledProgressEmitter.event,\n        sendRequest: (type, ...args) => {\n            throwIfClosedOrDisposed();\n            throwIfNotListening();\n            let method;\n            let messageParams;\n            let token = undefined;\n            if (Is.string(type)) {\n                method = type;\n                const first = args[0];\n                const last = args[args.length - 1];\n                let paramStart = 0;\n                let parameterStructures = messages_1.ParameterStructures.auto;\n                if (messages_1.ParameterStructures.is(first)) {\n                    paramStart = 1;\n                    parameterStructures = first;\n                }\n                let paramEnd = args.length;\n                if (cancellation_1.CancellationToken.is(last)) {\n                    paramEnd = paramEnd - 1;\n                    token = last;\n                }\n                const numberOfParams = paramEnd - paramStart;\n                switch (numberOfParams) {\n                    case 0:\n                        messageParams = undefined;\n                        break;\n                    case 1:\n                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);\n                        break;\n                    default:\n                        if (parameterStructures === messages_1.ParameterStructures.byName) {\n                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);\n                        }\n                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));\n                        break;\n                }\n            }\n            else {\n                const params = args;\n                method = type.method;\n                messageParams = computeMessageParams(type, params);\n                const numberOfParams = type.numberOfParams;\n                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;\n            }\n            const id = sequenceNumber++;\n            let disposable;\n            if (token) {\n                disposable = token.onCancellationRequested(() => {\n                    const p = cancellationStrategy.sender.sendCancellation(connection, id);\n                    if (p === undefined) {\n                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);\n                        return Promise.resolve();\n                    }\n                    else {\n                        return p.catch(() => {\n                            logger.log(`Sending cancellation messages for id ${id} failed`);\n                        });\n                    }\n                });\n            }\n            const requestMessage = {\n                jsonrpc: version,\n                id: id,\n                method: method,\n                params: messageParams\n            };\n            traceSendingRequest(requestMessage);\n            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {\n                cancellationStrategy.sender.enableCancellation(requestMessage);\n            }\n            return new Promise(async (resolve, reject) => {\n                const resolveWithCleanup = (r) => {\n                    resolve(r);\n                    cancellationStrategy.sender.cleanup(id);\n                    disposable?.dispose();\n                };\n                const rejectWithCleanup = (r) => {\n                    reject(r);\n                    cancellationStrategy.sender.cleanup(id);\n                    disposable?.dispose();\n                };\n                const responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };\n                try {\n                    await messageWriter.write(requestMessage);\n                    responsePromises.set(id, responsePromise);\n                }\n                catch (error) {\n                    logger.error(`Sending request failed.`);\n                    // Writing the message failed. So we need to reject the promise.\n                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));\n                    throw error;\n                }\n            });\n        },\n        onRequest: (type, handler) => {\n            throwIfClosedOrDisposed();\n            let method = null;\n            if (StarRequestHandler.is(type)) {\n                method = undefined;\n                starRequestHandler = type;\n            }\n            else if (Is.string(type)) {\n                method = null;\n                if (handler !== undefined) {\n                    method = type;\n                    requestHandlers.set(type, { handler: handler, type: undefined });\n                }\n            }\n            else {\n                if (handler !== undefined) {\n                    method = type.method;\n                    requestHandlers.set(type.method, { type, handler });\n                }\n            }\n            return {\n                dispose: () => {\n                    if (method === null) {\n                        return;\n                    }\n                    if (method !== undefined) {\n                        requestHandlers.delete(method);\n                    }\n                    else {\n                        starRequestHandler = undefined;\n                    }\n                }\n            };\n        },\n        hasPendingResponse: () => {\n            return responsePromises.size > 0;\n        },\n        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {\n            let _sendNotification = false;\n            let _traceFormat = TraceFormat.Text;\n            if (sendNotificationOrTraceOptions !== undefined) {\n                if (Is.boolean(sendNotificationOrTraceOptions)) {\n                    _sendNotification = sendNotificationOrTraceOptions;\n                }\n                else {\n                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;\n                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;\n                }\n            }\n            trace = _value;\n            traceFormat = _traceFormat;\n            if (trace === Trace.Off) {\n                tracer = undefined;\n            }\n            else {\n                tracer = _tracer;\n            }\n            if (_sendNotification && !isClosed() && !isDisposed()) {\n                await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });\n            }\n        },\n        onError: errorEmitter.event,\n        onClose: closeEmitter.event,\n        onUnhandledNotification: unhandledNotificationEmitter.event,\n        onDispose: disposeEmitter.event,\n        end: () => {\n            messageWriter.end();\n        },\n        dispose: () => {\n            if (isDisposed()) {\n                return;\n            }\n            state = ConnectionState.Disposed;\n            disposeEmitter.fire(undefined);\n            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');\n            for (const promise of responsePromises.values()) {\n                promise.reject(error);\n            }\n            responsePromises = new Map();\n            requestTokens = new Map();\n            knownCanceledRequests = new Set();\n            messageQueue = new linkedMap_1.LinkedMap();\n            // Test for backwards compatibility\n            if (Is.func(messageWriter.dispose)) {\n                messageWriter.dispose();\n            }\n            if (Is.func(messageReader.dispose)) {\n                messageReader.dispose();\n            }\n        },\n        listen: () => {\n            throwIfClosedOrDisposed();\n            throwIfListening();\n            state = ConnectionState.Listening;\n            messageReader.listen(callback);\n        },\n        inspect: () => {\n            // eslint-disable-next-line no-console\n            (0, ral_1.default)().console.log('inspect');\n        }\n    };\n    connection.onNotification(LogTraceNotification.type, (params) => {\n        if (trace === Trace.Off || !tracer) {\n            return;\n        }\n        const verbose = trace === Trace.Verbose || trace === Trace.Compact;\n        tracer.log(params.message, verbose ? params.verbose : undefined);\n    });\n    connection.onNotification(ProgressNotification.type, (params) => {\n        const handler = progressHandlers.get(params.token);\n        if (handler) {\n            handler(params.value);\n        }\n        else {\n            unhandledProgressEmitter.fire(params);\n        }\n    });\n    return connection;\n}\nexports.createMessageConnection = createMessageConnection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}