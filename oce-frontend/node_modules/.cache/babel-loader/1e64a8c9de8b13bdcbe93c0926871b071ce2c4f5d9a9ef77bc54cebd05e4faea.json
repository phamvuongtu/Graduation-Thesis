{"ast":null,"code":"\"use strict\";\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LRUCache = exports.LinkedMap = exports.Touch = void 0;\nvar Touch;\n(function (Touch) {\n  Touch.None = 0;\n  Touch.First = 1;\n  Touch.AsOld = Touch.First;\n  Touch.Last = 2;\n  Touch.AsNew = Touch.Last;\n})(Touch || (exports.Touch = Touch = {}));\nclass LinkedMap {\n  constructor() {\n    this[_a] = 'LinkedMap';\n    this._map = new Map();\n    this._head = undefined;\n    this._tail = undefined;\n    this._size = 0;\n    this._state = 0;\n  }\n  clear() {\n    this._map.clear();\n    this._head = undefined;\n    this._tail = undefined;\n    this._size = 0;\n    this._state++;\n  }\n  isEmpty() {\n    return !this._head && !this._tail;\n  }\n  get size() {\n    return this._size;\n  }\n  get first() {\n    return this._head?.value;\n  }\n  get last() {\n    return this._tail?.value;\n  }\n  has(key) {\n    return this._map.has(key);\n  }\n  get(key, touch = Touch.None) {\n    const item = this._map.get(key);\n    if (!item) {\n      return undefined;\n    }\n    if (touch !== Touch.None) {\n      this.touch(item, touch);\n    }\n    return item.value;\n  }\n  set(key, value, touch = Touch.None) {\n    let item = this._map.get(key);\n    if (item) {\n      item.value = value;\n      if (touch !== Touch.None) {\n        this.touch(item, touch);\n      }\n    } else {\n      item = {\n        key,\n        value,\n        next: undefined,\n        previous: undefined\n      };\n      switch (touch) {\n        case Touch.None:\n          this.addItemLast(item);\n          break;\n        case Touch.First:\n          this.addItemFirst(item);\n          break;\n        case Touch.Last:\n          this.addItemLast(item);\n          break;\n        default:\n          this.addItemLast(item);\n          break;\n      }\n      this._map.set(key, item);\n      this._size++;\n    }\n    return this;\n  }\n  delete(key) {\n    return !!this.remove(key);\n  }\n  remove(key) {\n    const item = this._map.get(key);\n    if (!item) {\n      return undefined;\n    }\n    this._map.delete(key);\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  }\n  shift() {\n    if (!this._head && !this._tail) {\n      return undefined;\n    }\n    if (!this._head || !this._tail) {\n      throw new Error('Invalid list');\n    }\n    const item = this._head;\n    this._map.delete(item.key);\n    this.removeItem(item);\n    this._size--;\n    return item.value;\n  }\n  forEach(callbackfn, thisArg) {\n    const state = this._state;\n    let current = this._head;\n    while (current) {\n      if (thisArg) {\n        callbackfn.bind(thisArg)(current.value, current.key, this);\n      } else {\n        callbackfn(current.value, current.key, this);\n      }\n      if (this._state !== state) {\n        throw new Error(`LinkedMap got modified during iteration.`);\n      }\n      current = current.next;\n    }\n  }\n  keys() {\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]: () => {\n        return iterator;\n      },\n      next: () => {\n        if (this._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n        if (current) {\n          const result = {\n            value: current.key,\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n    };\n    return iterator;\n  }\n  values() {\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]: () => {\n        return iterator;\n      },\n      next: () => {\n        if (this._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n        if (current) {\n          const result = {\n            value: current.value,\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n    };\n    return iterator;\n  }\n  entries() {\n    const state = this._state;\n    let current = this._head;\n    const iterator = {\n      [Symbol.iterator]: () => {\n        return iterator;\n      },\n      next: () => {\n        if (this._state !== state) {\n          throw new Error(`LinkedMap got modified during iteration.`);\n        }\n        if (current) {\n          const result = {\n            value: [current.key, current.value],\n            done: false\n          };\n          current = current.next;\n          return result;\n        } else {\n          return {\n            value: undefined,\n            done: true\n          };\n        }\n      }\n    };\n    return iterator;\n  }\n  [(_a = Symbol.toStringTag, Symbol.iterator)]() {\n    return this.entries();\n  }\n  trimOld(newSize) {\n    if (newSize >= this.size) {\n      return;\n    }\n    if (newSize === 0) {\n      this.clear();\n      return;\n    }\n    let current = this._head;\n    let currentSize = this.size;\n    while (current && currentSize > newSize) {\n      this._map.delete(current.key);\n      current = current.next;\n      currentSize--;\n    }\n    this._head = current;\n    this._size = currentSize;\n    if (current) {\n      current.previous = undefined;\n    }\n    this._state++;\n  }\n  addItemFirst(item) {\n    // First time Insert\n    if (!this._head && !this._tail) {\n      this._tail = item;\n    } else if (!this._head) {\n      throw new Error('Invalid list');\n    } else {\n      item.next = this._head;\n      this._head.previous = item;\n    }\n    this._head = item;\n    this._state++;\n  }\n  addItemLast(item) {\n    // First time Insert\n    if (!this._head && !this._tail) {\n      this._head = item;\n    } else if (!this._tail) {\n      throw new Error('Invalid list');\n    } else {\n      item.previous = this._tail;\n      this._tail.next = item;\n    }\n    this._tail = item;\n    this._state++;\n  }\n  removeItem(item) {\n    if (item === this._head && item === this._tail) {\n      this._head = undefined;\n      this._tail = undefined;\n    } else if (item === this._head) {\n      // This can only happened if size === 1 which is handle\n      // by the case above.\n      if (!item.next) {\n        throw new Error('Invalid list');\n      }\n      item.next.previous = undefined;\n      this._head = item.next;\n    } else if (item === this._tail) {\n      // This can only happened if size === 1 which is handle\n      // by the case above.\n      if (!item.previous) {\n        throw new Error('Invalid list');\n      }\n      item.previous.next = undefined;\n      this._tail = item.previous;\n    } else {\n      const next = item.next;\n      const previous = item.previous;\n      if (!next || !previous) {\n        throw new Error('Invalid list');\n      }\n      next.previous = previous;\n      previous.next = next;\n    }\n    item.next = undefined;\n    item.previous = undefined;\n    this._state++;\n  }\n  touch(item, touch) {\n    if (!this._head || !this._tail) {\n      throw new Error('Invalid list');\n    }\n    if (touch !== Touch.First && touch !== Touch.Last) {\n      return;\n    }\n    if (touch === Touch.First) {\n      if (item === this._head) {\n        return;\n      }\n      const next = item.next;\n      const previous = item.previous;\n      // Unlink the item\n      if (item === this._tail) {\n        // previous must be defined since item was not head but is tail\n        // So there are more than on item in the map\n        previous.next = undefined;\n        this._tail = previous;\n      } else {\n        // Both next and previous are not undefined since item was neither head nor tail.\n        next.previous = previous;\n        previous.next = next;\n      }\n      // Insert the node at head\n      item.previous = undefined;\n      item.next = this._head;\n      this._head.previous = item;\n      this._head = item;\n      this._state++;\n    } else if (touch === Touch.Last) {\n      if (item === this._tail) {\n        return;\n      }\n      const next = item.next;\n      const previous = item.previous;\n      // Unlink the item.\n      if (item === this._head) {\n        // next must be defined since item was not tail but is head\n        // So there are more than on item in the map\n        next.previous = undefined;\n        this._head = next;\n      } else {\n        // Both next and previous are not undefined since item was neither head nor tail.\n        next.previous = previous;\n        previous.next = next;\n      }\n      item.next = undefined;\n      item.previous = this._tail;\n      this._tail.next = item;\n      this._tail = item;\n      this._state++;\n    }\n  }\n  toJSON() {\n    const data = [];\n    this.forEach((value, key) => {\n      data.push([key, value]);\n    });\n    return data;\n  }\n  fromJSON(data) {\n    this.clear();\n    for (const [key, value] of data) {\n      this.set(key, value);\n    }\n  }\n}\nexports.LinkedMap = LinkedMap;\nclass LRUCache extends LinkedMap {\n  constructor(limit, ratio = 1) {\n    super();\n    this._limit = limit;\n    this._ratio = Math.min(Math.max(0, ratio), 1);\n  }\n  get limit() {\n    return this._limit;\n  }\n  set limit(limit) {\n    this._limit = limit;\n    this.checkTrim();\n  }\n  get ratio() {\n    return this._ratio;\n  }\n  set ratio(ratio) {\n    this._ratio = Math.min(Math.max(0, ratio), 1);\n    this.checkTrim();\n  }\n  get(key, touch = Touch.AsNew) {\n    return super.get(key, touch);\n  }\n  peek(key) {\n    return super.get(key, Touch.None);\n  }\n  set(key, value) {\n    super.set(key, value, Touch.Last);\n    this.checkTrim();\n    return this;\n  }\n  checkTrim() {\n    if (this.size > this._limit) {\n      this.trimOld(Math.round(this._limit * this._ratio));\n    }\n  }\n}\nexports.LRUCache = LRUCache;","map":{"version":3,"names":["_a","Object","defineProperty","exports","value","LRUCache","LinkedMap","Touch","None","First","AsOld","Last","AsNew","constructor","_map","Map","_head","undefined","_tail","_size","_state","clear","isEmpty","size","first","last","has","key","get","touch","item","set","next","previous","addItemLast","addItemFirst","delete","remove","removeItem","shift","Error","forEach","callbackfn","thisArg","state","current","bind","keys","iterator","Symbol","result","done","values","entries","toStringTag","trimOld","newSize","currentSize","toJSON","data","push","fromJSON","limit","ratio","_limit","_ratio","Math","min","max","checkTrim","peek","round"],"sources":["/Users/phamtu/Downloads/Code/OCE/oce-frontend/node_modules/vscode-jsonrpc/lib/common/linkedMap.js"],"sourcesContent":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LRUCache = exports.LinkedMap = exports.Touch = void 0;\nvar Touch;\n(function (Touch) {\n    Touch.None = 0;\n    Touch.First = 1;\n    Touch.AsOld = Touch.First;\n    Touch.Last = 2;\n    Touch.AsNew = Touch.Last;\n})(Touch || (exports.Touch = Touch = {}));\nclass LinkedMap {\n    constructor() {\n        this[_a] = 'LinkedMap';\n        this._map = new Map();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state = 0;\n    }\n    clear() {\n        this._map.clear();\n        this._head = undefined;\n        this._tail = undefined;\n        this._size = 0;\n        this._state++;\n    }\n    isEmpty() {\n        return !this._head && !this._tail;\n    }\n    get size() {\n        return this._size;\n    }\n    get first() {\n        return this._head?.value;\n    }\n    get last() {\n        return this._tail?.value;\n    }\n    has(key) {\n        return this._map.has(key);\n    }\n    get(key, touch = Touch.None) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        if (touch !== Touch.None) {\n            this.touch(item, touch);\n        }\n        return item.value;\n    }\n    set(key, value, touch = Touch.None) {\n        let item = this._map.get(key);\n        if (item) {\n            item.value = value;\n            if (touch !== Touch.None) {\n                this.touch(item, touch);\n            }\n        }\n        else {\n            item = { key, value, next: undefined, previous: undefined };\n            switch (touch) {\n                case Touch.None:\n                    this.addItemLast(item);\n                    break;\n                case Touch.First:\n                    this.addItemFirst(item);\n                    break;\n                case Touch.Last:\n                    this.addItemLast(item);\n                    break;\n                default:\n                    this.addItemLast(item);\n                    break;\n            }\n            this._map.set(key, item);\n            this._size++;\n        }\n        return this;\n    }\n    delete(key) {\n        return !!this.remove(key);\n    }\n    remove(key) {\n        const item = this._map.get(key);\n        if (!item) {\n            return undefined;\n        }\n        this._map.delete(key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    shift() {\n        if (!this._head && !this._tail) {\n            return undefined;\n        }\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        const item = this._head;\n        this._map.delete(item.key);\n        this.removeItem(item);\n        this._size--;\n        return item.value;\n    }\n    forEach(callbackfn, thisArg) {\n        const state = this._state;\n        let current = this._head;\n        while (current) {\n            if (thisArg) {\n                callbackfn.bind(thisArg)(current.value, current.key, this);\n            }\n            else {\n                callbackfn(current.value, current.key, this);\n            }\n            if (this._state !== state) {\n                throw new Error(`LinkedMap got modified during iteration.`);\n            }\n            current = current.next;\n        }\n    }\n    keys() {\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]: () => {\n                return iterator;\n            },\n            next: () => {\n                if (this._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.key, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    values() {\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]: () => {\n                return iterator;\n            },\n            next: () => {\n                if (this._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: current.value, done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    entries() {\n        const state = this._state;\n        let current = this._head;\n        const iterator = {\n            [Symbol.iterator]: () => {\n                return iterator;\n            },\n            next: () => {\n                if (this._state !== state) {\n                    throw new Error(`LinkedMap got modified during iteration.`);\n                }\n                if (current) {\n                    const result = { value: [current.key, current.value], done: false };\n                    current = current.next;\n                    return result;\n                }\n                else {\n                    return { value: undefined, done: true };\n                }\n            }\n        };\n        return iterator;\n    }\n    [(_a = Symbol.toStringTag, Symbol.iterator)]() {\n        return this.entries();\n    }\n    trimOld(newSize) {\n        if (newSize >= this.size) {\n            return;\n        }\n        if (newSize === 0) {\n            this.clear();\n            return;\n        }\n        let current = this._head;\n        let currentSize = this.size;\n        while (current && currentSize > newSize) {\n            this._map.delete(current.key);\n            current = current.next;\n            currentSize--;\n        }\n        this._head = current;\n        this._size = currentSize;\n        if (current) {\n            current.previous = undefined;\n        }\n        this._state++;\n    }\n    addItemFirst(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._tail = item;\n        }\n        else if (!this._head) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.next = this._head;\n            this._head.previous = item;\n        }\n        this._head = item;\n        this._state++;\n    }\n    addItemLast(item) {\n        // First time Insert\n        if (!this._head && !this._tail) {\n            this._head = item;\n        }\n        else if (!this._tail) {\n            throw new Error('Invalid list');\n        }\n        else {\n            item.previous = this._tail;\n            this._tail.next = item;\n        }\n        this._tail = item;\n        this._state++;\n    }\n    removeItem(item) {\n        if (item === this._head && item === this._tail) {\n            this._head = undefined;\n            this._tail = undefined;\n        }\n        else if (item === this._head) {\n            // This can only happened if size === 1 which is handle\n            // by the case above.\n            if (!item.next) {\n                throw new Error('Invalid list');\n            }\n            item.next.previous = undefined;\n            this._head = item.next;\n        }\n        else if (item === this._tail) {\n            // This can only happened if size === 1 which is handle\n            // by the case above.\n            if (!item.previous) {\n                throw new Error('Invalid list');\n            }\n            item.previous.next = undefined;\n            this._tail = item.previous;\n        }\n        else {\n            const next = item.next;\n            const previous = item.previous;\n            if (!next || !previous) {\n                throw new Error('Invalid list');\n            }\n            next.previous = previous;\n            previous.next = next;\n        }\n        item.next = undefined;\n        item.previous = undefined;\n        this._state++;\n    }\n    touch(item, touch) {\n        if (!this._head || !this._tail) {\n            throw new Error('Invalid list');\n        }\n        if ((touch !== Touch.First && touch !== Touch.Last)) {\n            return;\n        }\n        if (touch === Touch.First) {\n            if (item === this._head) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item\n            if (item === this._tail) {\n                // previous must be defined since item was not head but is tail\n                // So there are more than on item in the map\n                previous.next = undefined;\n                this._tail = previous;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            // Insert the node at head\n            item.previous = undefined;\n            item.next = this._head;\n            this._head.previous = item;\n            this._head = item;\n            this._state++;\n        }\n        else if (touch === Touch.Last) {\n            if (item === this._tail) {\n                return;\n            }\n            const next = item.next;\n            const previous = item.previous;\n            // Unlink the item.\n            if (item === this._head) {\n                // next must be defined since item was not tail but is head\n                // So there are more than on item in the map\n                next.previous = undefined;\n                this._head = next;\n            }\n            else {\n                // Both next and previous are not undefined since item was neither head nor tail.\n                next.previous = previous;\n                previous.next = next;\n            }\n            item.next = undefined;\n            item.previous = this._tail;\n            this._tail.next = item;\n            this._tail = item;\n            this._state++;\n        }\n    }\n    toJSON() {\n        const data = [];\n        this.forEach((value, key) => {\n            data.push([key, value]);\n        });\n        return data;\n    }\n    fromJSON(data) {\n        this.clear();\n        for (const [key, value] of data) {\n            this.set(key, value);\n        }\n    }\n}\nexports.LinkedMap = LinkedMap;\nclass LRUCache extends LinkedMap {\n    constructor(limit, ratio = 1) {\n        super();\n        this._limit = limit;\n        this._ratio = Math.min(Math.max(0, ratio), 1);\n    }\n    get limit() {\n        return this._limit;\n    }\n    set limit(limit) {\n        this._limit = limit;\n        this.checkTrim();\n    }\n    get ratio() {\n        return this._ratio;\n    }\n    set ratio(ratio) {\n        this._ratio = Math.min(Math.max(0, ratio), 1);\n        this.checkTrim();\n    }\n    get(key, touch = Touch.AsNew) {\n        return super.get(key, touch);\n    }\n    peek(key) {\n        return super.get(key, Touch.None);\n    }\n    set(key, value) {\n        super.set(key, value, Touch.Last);\n        this.checkTrim();\n        return this;\n    }\n    checkTrim() {\n        if (this.size > this._limit) {\n            this.trimOld(Math.round(this._limit * this._ratio));\n        }\n    }\n}\nexports.LRUCache = LRUCache;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}