{"ast":null,"code":"import { onUnexpectedError } from './errors.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { Disposable, DisposableStore, toDisposable, DisposableMap, combinedDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\nvar Event;\n(function (Event) {\n  Event.None = () => Disposable.None;\n  function defer(event, disposable) {\n    return debounce(event, () => void 0, 0, undefined, true, undefined, disposable);\n  }\n  Event.defer = defer;\n  function once(event) {\n    return (listener, thisArgs = null, disposables) => {\n      let didFire = false;\n      let result = undefined;\n      result = event(e => {\n        if (didFire) {\n          return;\n        } else if (result) {\n          result.dispose();\n        } else {\n          didFire = true;\n        }\n        return listener.call(thisArgs, e);\n      }, null, disposables);\n      if (didFire) {\n        result.dispose();\n      }\n      return result;\n    };\n  }\n  Event.once = once;\n  function map(event, map, disposable) {\n    return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n  }\n  Event.map = map;\n  function forEach(event, each, disposable) {\n    return snapshot((listener, thisArgs = null, disposables) => event(i => {\n      each(i);\n      listener.call(thisArgs, i);\n    }, null, disposables), disposable);\n  }\n  Event.forEach = forEach;\n  function filter(event, filter, disposable) {\n    return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n  }\n  Event.filter = filter;\n  function signal(event) {\n    return event;\n  }\n  Event.signal = signal;\n  function any(...events) {\n    return (listener, thisArgs = null, disposables) => {\n      const disposable = combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e))));\n      return addAndReturnDisposable(disposable, disposables);\n    };\n  }\n  Event.any = any;\n  function reduce(event, merge, initial, disposable) {\n    let output = initial;\n    return map(event, e => {\n      output = merge(output, e);\n      return output;\n    }, disposable);\n  }\n  Event.reduce = reduce;\n  function snapshot(event, disposable) {\n    let listener;\n    const options = {\n      onWillAddFirstListener() {\n        listener = event(emitter.fire, emitter);\n      },\n      onDidRemoveLastListener() {\n        listener?.dispose();\n      }\n    };\n    const emitter = new Emitter(options);\n    disposable?.add(emitter);\n    return emitter.event;\n  }\n  function addAndReturnDisposable(d, store) {\n    if (store instanceof Array) {\n      store.push(d);\n    } else if (store) {\n      store.add(d);\n    }\n    return d;\n  }\n  function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {\n    let subscription;\n    let output = undefined;\n    let handle = undefined;\n    let numDebouncedCalls = 0;\n    let doFire;\n    const options = {\n      leakWarningThreshold,\n      onWillAddFirstListener() {\n        subscription = event(cur => {\n          numDebouncedCalls++;\n          output = merge(output, cur);\n          if (leading && !handle) {\n            emitter.fire(output);\n            output = undefined;\n          }\n          doFire = () => {\n            const _output = output;\n            output = undefined;\n            handle = undefined;\n            if (!leading || numDebouncedCalls > 1) {\n              emitter.fire(_output);\n            }\n            numDebouncedCalls = 0;\n          };\n          if (typeof delay === 'number') {\n            clearTimeout(handle);\n            handle = setTimeout(doFire, delay);\n          } else {\n            if (handle === undefined) {\n              handle = 0;\n              queueMicrotask(doFire);\n            }\n          }\n        });\n      },\n      onWillRemoveListener() {\n        if (flushOnListenerRemove && numDebouncedCalls > 0) {\n          doFire?.();\n        }\n      },\n      onDidRemoveLastListener() {\n        doFire = undefined;\n        subscription.dispose();\n      }\n    };\n    const emitter = new Emitter(options);\n    disposable?.add(emitter);\n    return emitter.event;\n  }\n  Event.debounce = debounce;\n  function accumulate(event, delay = 0, disposable) {\n    return Event.debounce(event, (last, e) => {\n      if (!last) {\n        return [e];\n      }\n      last.push(e);\n      return last;\n    }, delay, undefined, true, undefined, disposable);\n  }\n  Event.accumulate = accumulate;\n  function latch(event, equals = (a, b) => a === b, disposable) {\n    let firstCall = true;\n    let cache;\n    return filter(event, value => {\n      const shouldEmit = firstCall || !equals(value, cache);\n      firstCall = false;\n      cache = value;\n      return shouldEmit;\n    }, disposable);\n  }\n  Event.latch = latch;\n  function split(event, isT, disposable) {\n    return [Event.filter(event, isT, disposable), Event.filter(event, e => !isT(e), disposable)];\n  }\n  Event.split = split;\n  function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {\n    let buffer = _buffer.slice();\n    let listener = event(e => {\n      if (buffer) {\n        buffer.push(e);\n      } else {\n        emitter.fire(e);\n      }\n    });\n    if (disposable) {\n      disposable.add(listener);\n    }\n    const flush = () => {\n      buffer?.forEach(e => emitter.fire(e));\n      buffer = null;\n    };\n    const emitter = new Emitter({\n      onWillAddFirstListener() {\n        if (!listener) {\n          listener = event(e => emitter.fire(e));\n          if (disposable) {\n            disposable.add(listener);\n          }\n        }\n      },\n      onDidAddFirstListener() {\n        if (buffer) {\n          if (flushAfterTimeout) {\n            setTimeout(flush);\n          } else {\n            flush();\n          }\n        }\n      },\n      onDidRemoveLastListener() {\n        if (listener) {\n          listener.dispose();\n        }\n        listener = null;\n      }\n    });\n    if (disposable) {\n      disposable.add(emitter);\n    }\n    return emitter.event;\n  }\n  Event.buffer = buffer;\n  function chain(event, sythensize) {\n    const fn = (listener, thisArgs, disposables) => {\n      const cs = sythensize(new ChainableSynthesis());\n      return event(function (value) {\n        const result = cs.evaluate(value);\n        if (result !== HaltChainable) {\n          listener.call(thisArgs, result);\n        }\n      }, undefined, disposables);\n    };\n    return fn;\n  }\n  Event.chain = chain;\n  const HaltChainable = Symbol('HaltChainable');\n  class ChainableSynthesis {\n    constructor() {\n      this.steps = [];\n    }\n    map(fn) {\n      this.steps.push(fn);\n      return this;\n    }\n    forEach(fn) {\n      this.steps.push(v => {\n        fn(v);\n        return v;\n      });\n      return this;\n    }\n    filter(fn) {\n      this.steps.push(v => fn(v) ? v : HaltChainable);\n      return this;\n    }\n    reduce(merge, initial) {\n      let last = initial;\n      this.steps.push(v => {\n        last = merge(last, v);\n        return last;\n      });\n      return this;\n    }\n    latch(equals = (a, b) => a === b) {\n      let firstCall = true;\n      let cache;\n      this.steps.push(value => {\n        const shouldEmit = firstCall || !equals(value, cache);\n        firstCall = false;\n        cache = value;\n        return shouldEmit ? value : HaltChainable;\n      });\n      return this;\n    }\n    evaluate(value) {\n      for (const step of this.steps) {\n        value = step(value);\n        if (value === HaltChainable) {\n          break;\n        }\n      }\n      return value;\n    }\n  }\n  function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n    const fn = (...args) => result.fire(map(...args));\n    const onFirstListenerAdd = () => emitter.on(eventName, fn);\n    const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n    const result = new Emitter({\n      onWillAddFirstListener: onFirstListenerAdd,\n      onDidRemoveLastListener: onLastListenerRemove\n    });\n    return result.event;\n  }\n  Event.fromNodeEventEmitter = fromNodeEventEmitter;\n  function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n    const fn = (...args) => result.fire(map(...args));\n    const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n    const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n    const result = new Emitter({\n      onWillAddFirstListener: onFirstListenerAdd,\n      onDidRemoveLastListener: onLastListenerRemove\n    });\n    return result.event;\n  }\n  Event.fromDOMEventEmitter = fromDOMEventEmitter;\n  function toPromise(event) {\n    return new Promise(resolve => once(event)(resolve));\n  }\n  Event.toPromise = toPromise;\n  function fromPromise(promise) {\n    const result = new Emitter();\n    promise.then(res => {\n      result.fire(res);\n    }, () => {\n      result.fire(undefined);\n    }).finally(() => {\n      result.dispose();\n    });\n    return result.event;\n  }\n  Event.fromPromise = fromPromise;\n  function runAndSubscribe(event, handler, initial) {\n    handler(initial);\n    return event(e => handler(e));\n  }\n  Event.runAndSubscribe = runAndSubscribe;\n  class EmitterObserver {\n    constructor(_observable, store) {\n      this._observable = _observable;\n      this._counter = 0;\n      this._hasChanged = false;\n      const options = {\n        onWillAddFirstListener: () => {\n          _observable.addObserver(this);\n        },\n        onDidRemoveLastListener: () => {\n          _observable.removeObserver(this);\n        }\n      };\n      this.emitter = new Emitter(options);\n      if (store) {\n        store.add(this.emitter);\n      }\n    }\n    beginUpdate(_observable) {\n      this._counter++;\n    }\n    handlePossibleChange(_observable) {}\n    handleChange(_observable, _change) {\n      this._hasChanged = true;\n    }\n    endUpdate(_observable) {\n      this._counter--;\n      if (this._counter === 0) {\n        this._observable.reportChanges();\n        if (this._hasChanged) {\n          this._hasChanged = false;\n          this.emitter.fire(this._observable.get());\n        }\n      }\n    }\n  }\n  function fromObservable(obs, store) {\n    const observer = new EmitterObserver(obs, store);\n    return observer.emitter.event;\n  }\n  Event.fromObservable = fromObservable;\n  function fromObservableLight(observable) {\n    return (listener, thisArgs, disposables) => {\n      let count = 0;\n      let didChange = false;\n      const observer = {\n        beginUpdate() {\n          count++;\n        },\n        endUpdate() {\n          count--;\n          if (count === 0) {\n            observable.reportChanges();\n            if (didChange) {\n              didChange = false;\n              listener.call(thisArgs);\n            }\n          }\n        },\n        handlePossibleChange() {},\n        handleChange() {\n          didChange = true;\n        }\n      };\n      observable.addObserver(observer);\n      observable.reportChanges();\n      const disposable = {\n        dispose() {\n          observable.removeObserver(observer);\n        }\n      };\n      if (disposables instanceof DisposableStore) {\n        disposables.add(disposable);\n      } else if (Array.isArray(disposables)) {\n        disposables.push(disposable);\n      }\n      return disposable;\n    };\n  }\n  Event.fromObservableLight = fromObservableLight;\n})(Event || (Event = {}));\nclass EventProfiling {\n  static {\n    this.all = new Set();\n  }\n  static {\n    this._idPool = 0;\n  }\n  constructor(name) {\n    this.listenerCount = 0;\n    this.invocationCount = 0;\n    this.elapsedOverall = 0;\n    this.durations = [];\n    this.name = `${name}_${EventProfiling._idPool++}`;\n    EventProfiling.all.add(this);\n  }\n  start(listenerCount) {\n    this._stopWatch = new StopWatch();\n    this.listenerCount = listenerCount;\n  }\n  stop() {\n    if (this._stopWatch) {\n      const elapsed = this._stopWatch.elapsed();\n      this.durations.push(elapsed);\n      this.elapsedOverall += elapsed;\n      this.invocationCount += 1;\n      this._stopWatch = undefined;\n    }\n  }\n}\nlet _globalLeakWarningThreshold = -1;\nfunction setGlobalLeakWarningThreshold(n) {\n  const oldValue = _globalLeakWarningThreshold;\n  _globalLeakWarningThreshold = n;\n  return {\n    dispose() {\n      _globalLeakWarningThreshold = oldValue;\n    }\n  };\n}\nclass LeakageMonitor {\n  constructor(threshold, name = Math.random().toString(18).slice(2, 5)) {\n    this.threshold = threshold;\n    this.name = name;\n    this._warnCountdown = 0;\n  }\n  dispose() {\n    this._stacks?.clear();\n  }\n  check(stack, listenerCount) {\n    const threshold = this.threshold;\n    if (threshold <= 0 || listenerCount < threshold) {\n      return undefined;\n    }\n    if (!this._stacks) {\n      this._stacks = new Map();\n    }\n    const count = this._stacks.get(stack.value) || 0;\n    this._stacks.set(stack.value, count + 1);\n    this._warnCountdown -= 1;\n    if (this._warnCountdown <= 0) {\n      this._warnCountdown = threshold * 0.5;\n      let topStack;\n      let topCount = 0;\n      for (const [stack, count] of this._stacks) {\n        if (!topStack || topCount < count) {\n          topStack = stack;\n          topCount = count;\n        }\n      }\n      console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n      console.warn(topStack);\n    }\n    return () => {\n      const count = this._stacks.get(stack.value) || 0;\n      this._stacks.set(stack.value, count - 1);\n    };\n  }\n}\nclass Stacktrace {\n  static create() {\n    return new Stacktrace(new Error().stack ?? '');\n  }\n  constructor(value) {\n    this.value = value;\n  }\n  print() {\n    console.warn(this.value.split('\\n').slice(2).join('\\n'));\n  }\n}\nlet id = 0;\nclass UniqueContainer {\n  constructor(value) {\n    this.value = value;\n    this.id = id++;\n  }\n}\nconst compactionThreshold = 2;\nconst forEachListener = (listeners, fn) => {\n  if (listeners instanceof UniqueContainer) {\n    fn(listeners);\n  } else {\n    for (let i = 0; i < listeners.length; i++) {\n      const l = listeners[i];\n      if (l) {\n        fn(l);\n      }\n    }\n  }\n};\nclass Emitter {\n  constructor(options) {\n    this._size = 0;\n    this._options = options;\n    this._leakageMon = _globalLeakWarningThreshold > 0 || this._options?.leakWarningThreshold ? new LeakageMonitor(this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold) : undefined;\n    this._perfMon = this._options?._profName ? new EventProfiling(this._options._profName) : undefined;\n    this._deliveryQueue = this._options?.deliveryQueue;\n  }\n  dispose() {\n    if (!this._disposed) {\n      this._disposed = true;\n      if (this._deliveryQueue?.current === this) {\n        this._deliveryQueue.reset();\n      }\n      if (this._listeners) {\n        this._listeners = undefined;\n        this._size = 0;\n      }\n      this._options?.onDidRemoveLastListener?.();\n      this._leakageMon?.dispose();\n    }\n  }\n  get event() {\n    this._event ??= (callback, thisArgs, disposables) => {\n      if (this._leakageMon && this._size > this._leakageMon.threshold * 3) {\n        console.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`);\n        return Disposable.None;\n      }\n      if (this._disposed) {\n        return Disposable.None;\n      }\n      if (thisArgs) {\n        callback = callback.bind(thisArgs);\n      }\n      const contained = new UniqueContainer(callback);\n      let removeMonitor;\n      if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n        contained.stack = Stacktrace.create();\n        removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n      }\n      if (!this._listeners) {\n        this._options?.onWillAddFirstListener?.(this);\n        this._listeners = contained;\n        this._options?.onDidAddFirstListener?.(this);\n      } else if (this._listeners instanceof UniqueContainer) {\n        this._deliveryQueue ??= new EventDeliveryQueuePrivate();\n        this._listeners = [this._listeners, contained];\n      } else {\n        this._listeners.push(contained);\n      }\n      this._size++;\n      const result = toDisposable(() => {\n        removeMonitor?.();\n        this._removeListener(contained);\n      });\n      if (disposables instanceof DisposableStore) {\n        disposables.add(result);\n      } else if (Array.isArray(disposables)) {\n        disposables.push(result);\n      }\n      return result;\n    };\n    return this._event;\n  }\n  _removeListener(listener) {\n    this._options?.onWillRemoveListener?.(this);\n    if (!this._listeners) {\n      return;\n    }\n    if (this._size === 1) {\n      this._listeners = undefined;\n      this._options?.onDidRemoveLastListener?.(this);\n      this._size = 0;\n      return;\n    }\n    const listeners = this._listeners;\n    const index = listeners.indexOf(listener);\n    if (index === -1) {\n      console.log('disposed?', this._disposed);\n      console.log('size?', this._size);\n      console.log('arr?', JSON.stringify(this._listeners));\n      throw new Error('Attempted to dispose unknown listener');\n    }\n    this._size--;\n    listeners[index] = undefined;\n    const adjustDeliveryQueue = this._deliveryQueue.current === this;\n    if (this._size * compactionThreshold <= listeners.length) {\n      let n = 0;\n      for (let i = 0; i < listeners.length; i++) {\n        if (listeners[i]) {\n          listeners[n++] = listeners[i];\n        } else if (adjustDeliveryQueue) {\n          this._deliveryQueue.end--;\n          if (n < this._deliveryQueue.i) {\n            this._deliveryQueue.i--;\n          }\n        }\n      }\n      listeners.length = n;\n    }\n  }\n  _deliver(listener, value) {\n    if (!listener) {\n      return;\n    }\n    const errorHandler = this._options?.onListenerError || onUnexpectedError;\n    if (!errorHandler) {\n      listener.value(value);\n      return;\n    }\n    try {\n      listener.value(value);\n    } catch (e) {\n      errorHandler(e);\n    }\n  }\n  _deliverQueue(dq) {\n    const listeners = dq.current._listeners;\n    while (dq.i < dq.end) {\n      this._deliver(listeners[dq.i++], dq.value);\n    }\n    dq.reset();\n  }\n  fire(event) {\n    if (this._deliveryQueue?.current) {\n      this._deliverQueue(this._deliveryQueue);\n      this._perfMon?.stop();\n    }\n    this._perfMon?.start(this._size);\n    if (!this._listeners) ;else if (this._listeners instanceof UniqueContainer) {\n      this._deliver(this._listeners, event);\n    } else {\n      const dq = this._deliveryQueue;\n      dq.enqueue(this, event, this._listeners.length);\n      this._deliverQueue(dq);\n    }\n    this._perfMon?.stop();\n  }\n  hasListeners() {\n    return this._size > 0;\n  }\n}\nconst createEventDeliveryQueue = () => new EventDeliveryQueuePrivate();\nclass EventDeliveryQueuePrivate {\n  constructor() {\n    this.i = -1;\n    this.end = 0;\n  }\n  enqueue(emitter, value, end) {\n    this.i = 0;\n    this.end = end;\n    this.current = emitter;\n    this.value = value;\n  }\n  reset() {\n    this.i = this.end;\n    this.current = undefined;\n    this.value = undefined;\n  }\n}\nclass AsyncEmitter extends Emitter {\n  async fireAsync(data, token, promiseJoin) {\n    if (!this._listeners) {\n      return;\n    }\n    if (!this._asyncDeliveryQueue) {\n      this._asyncDeliveryQueue = new LinkedList();\n    }\n    forEachListener(this._listeners, listener => this._asyncDeliveryQueue.push([listener.value, data]));\n    while (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {\n      const [listener, data] = this._asyncDeliveryQueue.shift();\n      const thenables = [];\n      const event = {\n        ...data,\n        token,\n        waitUntil: p => {\n          if (Object.isFrozen(thenables)) {\n            throw new Error('waitUntil can NOT be called asynchronous');\n          }\n          if (promiseJoin) {\n            p = promiseJoin(p, listener);\n          }\n          thenables.push(p);\n        }\n      };\n      try {\n        listener(event);\n      } catch (e) {\n        onUnexpectedError(e);\n        continue;\n      }\n      await Promise.allSettled(thenables).then(values => {\n        for (const value of values) {\n          if (value.status === 'rejected') {\n            onUnexpectedError(value.reason);\n          }\n        }\n      });\n    }\n  }\n}\nclass PauseableEmitter extends Emitter {\n  get isPaused() {\n    return this._isPaused !== 0;\n  }\n  constructor(options) {\n    super(options);\n    this._isPaused = 0;\n    this._eventQueue = new LinkedList();\n    this._mergeFn = options?.merge;\n  }\n  pause() {\n    this._isPaused++;\n  }\n  resume() {\n    if (this._isPaused !== 0 && --this._isPaused === 0) {\n      if (this._mergeFn) {\n        if (this._eventQueue.size > 0) {\n          const events = Array.from(this._eventQueue);\n          this._eventQueue.clear();\n          super.fire(this._mergeFn(events));\n        }\n      } else {\n        while (!this._isPaused && this._eventQueue.size !== 0) {\n          super.fire(this._eventQueue.shift());\n        }\n      }\n    }\n  }\n  fire(event) {\n    if (this._size) {\n      if (this._isPaused !== 0) {\n        this._eventQueue.push(event);\n      } else {\n        super.fire(event);\n      }\n    }\n  }\n}\nclass DebounceEmitter extends PauseableEmitter {\n  constructor(options) {\n    super(options);\n    this._delay = options.delay ?? 100;\n  }\n  fire(event) {\n    if (!this._handle) {\n      this.pause();\n      this._handle = setTimeout(() => {\n        this._handle = undefined;\n        this.resume();\n      }, this._delay);\n    }\n    super.fire(event);\n  }\n}\nclass MicrotaskEmitter extends Emitter {\n  constructor(options) {\n    super(options);\n    this._queuedEvents = [];\n    this._mergeFn = options?.merge;\n  }\n  fire(event) {\n    if (!this.hasListeners()) {\n      return;\n    }\n    this._queuedEvents.push(event);\n    if (this._queuedEvents.length === 1) {\n      queueMicrotask(() => {\n        if (this._mergeFn) {\n          super.fire(this._mergeFn(this._queuedEvents));\n        } else {\n          this._queuedEvents.forEach(e => super.fire(e));\n        }\n        this._queuedEvents = [];\n      });\n    }\n  }\n}\nclass EventMultiplexer {\n  constructor() {\n    this.hasListeners = false;\n    this.events = [];\n    this.emitter = new Emitter({\n      onWillAddFirstListener: () => this.onFirstListenerAdd(),\n      onDidRemoveLastListener: () => this.onLastListenerRemove()\n    });\n  }\n  get event() {\n    return this.emitter.event;\n  }\n  add(event) {\n    const e = {\n      event: event,\n      listener: null\n    };\n    this.events.push(e);\n    if (this.hasListeners) {\n      this.hook(e);\n    }\n    const dispose = () => {\n      if (this.hasListeners) {\n        this.unhook(e);\n      }\n      const idx = this.events.indexOf(e);\n      this.events.splice(idx, 1);\n    };\n    return toDisposable(createSingleCallFunction(dispose));\n  }\n  onFirstListenerAdd() {\n    this.hasListeners = true;\n    this.events.forEach(e => this.hook(e));\n  }\n  onLastListenerRemove() {\n    this.hasListeners = false;\n    this.events.forEach(e => this.unhook(e));\n  }\n  hook(e) {\n    e.listener = e.event(r => this.emitter.fire(r));\n  }\n  unhook(e) {\n    e.listener?.dispose();\n    e.listener = null;\n  }\n  dispose() {\n    this.emitter.dispose();\n    for (const e of this.events) {\n      e.listener?.dispose();\n    }\n    this.events = [];\n  }\n}\nclass DynamicListEventMultiplexer {\n  constructor(items, onAddItem, onRemoveItem, getEvent) {\n    this._store = new DisposableStore();\n    const multiplexer = this._store.add(new EventMultiplexer());\n    const itemListeners = this._store.add(new DisposableMap());\n    function addItem(instance) {\n      itemListeners.set(instance, multiplexer.add(getEvent(instance)));\n    }\n    for (const instance of items) {\n      addItem(instance);\n    }\n    this._store.add(onAddItem(instance => {\n      addItem(instance);\n    }));\n    this._store.add(onRemoveItem(instance => {\n      itemListeners.deleteAndDispose(instance);\n    }));\n    this.event = multiplexer.event;\n  }\n  dispose() {\n    this._store.dispose();\n  }\n}\nclass EventBufferer {\n  constructor() {\n    this.buffers = [];\n  }\n  wrapEvent(event) {\n    return (listener, thisArgs, disposables) => {\n      return event(i => {\n        const buffer = this.buffers[this.buffers.length - 1];\n        if (buffer) {\n          buffer.push(() => listener.call(thisArgs, i));\n        } else {\n          listener.call(thisArgs, i);\n        }\n      }, undefined, disposables);\n    };\n  }\n  bufferEvents(fn) {\n    const buffer = [];\n    this.buffers.push(buffer);\n    const r = fn();\n    this.buffers.pop();\n    buffer.forEach(flush => flush());\n    return r;\n  }\n}\nclass Relay {\n  constructor() {\n    this.listening = false;\n    this.inputEvent = Event.None;\n    this.inputEventListener = Disposable.None;\n    this.emitter = new Emitter({\n      onDidAddFirstListener: () => {\n        this.listening = true;\n        this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n      },\n      onDidRemoveLastListener: () => {\n        this.listening = false;\n        this.inputEventListener.dispose();\n      }\n    });\n    this.event = this.emitter.event;\n  }\n  set input(event) {\n    this.inputEvent = event;\n    if (this.listening) {\n      this.inputEventListener.dispose();\n      this.inputEventListener = event(this.emitter.fire, this.emitter);\n    }\n  }\n  dispose() {\n    this.inputEventListener.dispose();\n    this.emitter.dispose();\n  }\n}\nclass ValueWithChangeEvent {\n  static const(value) {\n    return new ConstValueWithChangeEvent(value);\n  }\n  constructor(_value) {\n    this._value = _value;\n    this._onDidChange = new Emitter();\n    this.onDidChange = this._onDidChange.event;\n  }\n  get value() {\n    return this._value;\n  }\n  set value(value) {\n    if (value !== this._value) {\n      this._value = value;\n      this._onDidChange.fire(undefined);\n    }\n  }\n}\nclass ConstValueWithChangeEvent {\n  constructor(value) {\n    this.value = value;\n    this.onDidChange = Event.None;\n  }\n}\nexport { AsyncEmitter, DebounceEmitter, DynamicListEventMultiplexer, Emitter, Event, EventBufferer, EventMultiplexer, EventProfiling, MicrotaskEmitter, PauseableEmitter, Relay, ValueWithChangeEvent, createEventDeliveryQueue, setGlobalLeakWarningThreshold };","map":{"version":3,"names":["onUnexpectedError","createSingleCallFunction","Disposable","DisposableStore","toDisposable","DisposableMap","combinedDisposable","LinkedList","StopWatch","Event","None","defer","event","disposable","debounce","undefined","once","listener","thisArgs","disposables","didFire","result","e","dispose","call","map","snapshot","i","forEach","each","filter","signal","any","events","addAndReturnDisposable","reduce","merge","initial","output","options","onWillAddFirstListener","emitter","fire","onDidRemoveLastListener","Emitter","add","d","store","Array","push","delay","leading","flushOnListenerRemove","leakWarningThreshold","subscription","handle","numDebouncedCalls","doFire","cur","_output","clearTimeout","setTimeout","queueMicrotask","onWillRemoveListener","accumulate","last","latch","equals","a","b","firstCall","cache","value","shouldEmit","split","isT","buffer","flushAfterTimeout","_buffer","slice","flush","onDidAddFirstListener","chain","sythensize","fn","cs","ChainableSynthesis","evaluate","HaltChainable","Symbol","constructor","steps","v","step","fromNodeEventEmitter","eventName","id","args","onFirstListenerAdd","on","onLastListenerRemove","removeListener","fromDOMEventEmitter","addEventListener","removeEventListener","toPromise","Promise","resolve","fromPromise","promise","then","res","finally","runAndSubscribe","handler","EmitterObserver","_observable","_counter","_hasChanged","addObserver","removeObserver","beginUpdate","handlePossibleChange","handleChange","_change","endUpdate","reportChanges","get","fromObservable","obs","observer","fromObservableLight","observable","count","didChange","isArray","EventProfiling","all","Set","_idPool","name","listenerCount","invocationCount","elapsedOverall","durations","start","_stopWatch","stop","elapsed","_globalLeakWarningThreshold","setGlobalLeakWarningThreshold","n","oldValue","LeakageMonitor","threshold","Math","random","toString","_warnCountdown","_stacks","clear","check","stack","Map","set","topStack","topCount","console","warn","Stacktrace","create","Error","print","join","UniqueContainer","compactionThreshold","forEachListener","listeners","length","l","_size","_options","_leakageMon","_perfMon","_profName","_deliveryQueue","deliveryQueue","_disposed","current","reset","_listeners","_event","callback","bind","contained","removeMonitor","ceil","EventDeliveryQueuePrivate","_removeListener","index","indexOf","log","JSON","stringify","adjustDeliveryQueue","end","_deliver","errorHandler","onListenerError","_deliverQueue","dq","enqueue","hasListeners","createEventDeliveryQueue","AsyncEmitter","fireAsync","data","token","promiseJoin","_asyncDeliveryQueue","size","isCancellationRequested","shift","thenables","waitUntil","p","Object","isFrozen","allSettled","values","status","reason","PauseableEmitter","isPaused","_isPaused","_eventQueue","_mergeFn","pause","resume","from","DebounceEmitter","_delay","_handle","MicrotaskEmitter","_queuedEvents","EventMultiplexer","hook","unhook","idx","splice","r","DynamicListEventMultiplexer","items","onAddItem","onRemoveItem","getEvent","_store","multiplexer","itemListeners","addItem","instance","deleteAndDispose","EventBufferer","buffers","wrapEvent","bufferEvents","pop","Relay","listening","inputEvent","inputEventListener","input","ValueWithChangeEvent","const","ConstValueWithChangeEvent","_value","_onDidChange","onDidChange"],"sources":["/Users/phamtu/Downloads/Code/OCE/oce-frontend/node_modules/vscode/vscode/src/vs/base/common/event.js"],"sourcesContent":["import { onUnexpectedError } from './errors.js';\nimport { createSingleCallFunction } from './functional.js';\nimport { Disposable, DisposableStore, toDisposable, DisposableMap, combinedDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\nvar Event;\n( (function(Event) {\n    Event.None = () => Disposable.None;\n    function defer(event, disposable) {\n        return debounce(event, () => void 0, 0, undefined, true, undefined, disposable);\n    }\n    Event.defer = defer;\n    function once(event) {\n        return (listener, thisArgs = null, disposables) => {\n            let didFire = false;\n            let result = undefined;\n            result = event(e => {\n                if (didFire) {\n                    return;\n                }\n                else if (result) {\n                    result.dispose();\n                }\n                else {\n                    didFire = true;\n                }\n                return listener.call(thisArgs, e);\n            }, null, disposables);\n            if (didFire) {\n                result.dispose();\n            }\n            return result;\n        };\n    }\n    Event.once = once;\n    function map(event, map, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, ( map(i))), null, disposables), disposable);\n    }\n    Event.map = map;\n    function forEach(event, each, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n    }\n    Event.forEach = forEach;\n    function filter(event, filter, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n    }\n    Event.filter = filter;\n    function signal(event) {\n        return event;\n    }\n    Event.signal = signal;\n    function any(...events) {\n        return (listener, thisArgs = null, disposables) => {\n            const disposable = combinedDisposable(...( events.map(event => event(e => listener.call(thisArgs, e)))));\n            return addAndReturnDisposable(disposable, disposables);\n        };\n    }\n    Event.any = any;\n    function reduce(event, merge, initial, disposable) {\n        let output = initial;\n        return ( map(event, e => {\n            output = merge(output, e);\n            return output;\n        }, disposable));\n    }\n    Event.reduce = reduce;\n    function snapshot(event, disposable) {\n        let listener;\n        const options = {\n            onWillAddFirstListener() {\n                listener = event(emitter.fire, emitter);\n            },\n            onDidRemoveLastListener() {\n                listener?.dispose();\n            }\n        };\n        const emitter = ( new Emitter(options));\n        disposable?.add(emitter);\n        return emitter.event;\n    }\n    function addAndReturnDisposable(d, store) {\n        if (store instanceof Array) {\n            store.push(d);\n        }\n        else if (store) {\n            store.add(d);\n        }\n        return d;\n    }\n    function debounce(event, merge, delay = 100, leading = false, flushOnListenerRemove = false, leakWarningThreshold, disposable) {\n        let subscription;\n        let output = undefined;\n        let handle = undefined;\n        let numDebouncedCalls = 0;\n        let doFire;\n        const options = {\n            leakWarningThreshold,\n            onWillAddFirstListener() {\n                subscription = event(cur => {\n                    numDebouncedCalls++;\n                    output = merge(output, cur);\n                    if (leading && !handle) {\n                        emitter.fire(output);\n                        output = undefined;\n                    }\n                    doFire = () => {\n                        const _output = output;\n                        output = undefined;\n                        handle = undefined;\n                        if (!leading || numDebouncedCalls > 1) {\n                            emitter.fire(_output);\n                        }\n                        numDebouncedCalls = 0;\n                    };\n                    if (typeof delay === 'number') {\n                        clearTimeout(handle);\n                        handle = setTimeout(doFire, delay);\n                    }\n                    else {\n                        if (handle === undefined) {\n                            handle = 0;\n                            queueMicrotask(doFire);\n                        }\n                    }\n                });\n            },\n            onWillRemoveListener() {\n                if (flushOnListenerRemove && numDebouncedCalls > 0) {\n                    doFire?.();\n                }\n            },\n            onDidRemoveLastListener() {\n                doFire = undefined;\n                subscription.dispose();\n            }\n        };\n        const emitter = ( new Emitter(options));\n        disposable?.add(emitter);\n        return emitter.event;\n    }\n    Event.debounce = debounce;\n    function accumulate(event, delay = 0, disposable) {\n        return Event.debounce(event, (last, e) => {\n            if (!last) {\n                return [e];\n            }\n            last.push(e);\n            return last;\n        }, delay, undefined, true, undefined, disposable);\n    }\n    Event.accumulate = accumulate;\n    function latch(event, equals = (a, b) => a === b, disposable) {\n        let firstCall = true;\n        let cache;\n        return filter(event, value => {\n            const shouldEmit = firstCall || !equals(value, cache);\n            firstCall = false;\n            cache = value;\n            return shouldEmit;\n        }, disposable);\n    }\n    Event.latch = latch;\n    function split(event, isT, disposable) {\n        return [\n            Event.filter(event, isT, disposable),\n            Event.filter(event, e => !isT(e), disposable),\n        ];\n    }\n    Event.split = split;\n    function buffer(event, flushAfterTimeout = false, _buffer = [], disposable) {\n        let buffer = _buffer.slice();\n        let listener = event(e => {\n            if (buffer) {\n                buffer.push(e);\n            }\n            else {\n                emitter.fire(e);\n            }\n        });\n        if (disposable) {\n            disposable.add(listener);\n        }\n        const flush = () => {\n            buffer?.forEach(e => emitter.fire(e));\n            buffer = null;\n        };\n        const emitter = ( new Emitter({\n            onWillAddFirstListener() {\n                if (!listener) {\n                    listener = event(e => emitter.fire(e));\n                    if (disposable) {\n                        disposable.add(listener);\n                    }\n                }\n            },\n            onDidAddFirstListener() {\n                if (buffer) {\n                    if (flushAfterTimeout) {\n                        setTimeout(flush);\n                    }\n                    else {\n                        flush();\n                    }\n                }\n            },\n            onDidRemoveLastListener() {\n                if (listener) {\n                    listener.dispose();\n                }\n                listener = null;\n            }\n        }));\n        if (disposable) {\n            disposable.add(emitter);\n        }\n        return emitter.event;\n    }\n    Event.buffer = buffer;\n    function chain(event, sythensize) {\n        const fn = (listener, thisArgs, disposables) => {\n            const cs = sythensize(( new ChainableSynthesis()));\n            return event(function (value) {\n                const result = cs.evaluate(value);\n                if (result !== HaltChainable) {\n                    listener.call(thisArgs, result);\n                }\n            }, undefined, disposables);\n        };\n        return fn;\n    }\n    Event.chain = chain;\n    const HaltChainable = Symbol('HaltChainable');\n    class ChainableSynthesis {\n        constructor() {\n            this.steps = [];\n        }\n        map(fn) {\n            this.steps.push(fn);\n            return this;\n        }\n        forEach(fn) {\n            this.steps.push(v => {\n                fn(v);\n                return v;\n            });\n            return this;\n        }\n        filter(fn) {\n            this.steps.push(v => fn(v) ? v : HaltChainable);\n            return this;\n        }\n        reduce(merge, initial) {\n            let last = initial;\n            this.steps.push(v => {\n                last = merge(last, v);\n                return last;\n            });\n            return this;\n        }\n        latch(equals = (a, b) => a === b) {\n            let firstCall = true;\n            let cache;\n            this.steps.push(value => {\n                const shouldEmit = firstCall || !equals(value, cache);\n                firstCall = false;\n                cache = value;\n                return shouldEmit ? value : HaltChainable;\n            });\n            return this;\n        }\n        evaluate(value) {\n            for (const step of this.steps) {\n                value = step(value);\n                if (value === HaltChainable) {\n                    break;\n                }\n            }\n            return value;\n        }\n    }\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(( map(...args)));\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n        const result = ( new Emitter(\n            { onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove }\n        ));\n        return result.event;\n    }\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(( map(...args)));\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n        const result = ( new Emitter(\n            { onWillAddFirstListener: onFirstListenerAdd, onDidRemoveLastListener: onLastListenerRemove }\n        ));\n        return result.event;\n    }\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\n    function toPromise(event) {\n        return ( new Promise(resolve => once(event)(resolve)));\n    }\n    Event.toPromise = toPromise;\n    function fromPromise(promise) {\n        const result = ( new Emitter());\n        promise.then(res => {\n            result.fire(res);\n        }, () => {\n            result.fire(undefined);\n        }).finally(() => {\n            result.dispose();\n        });\n        return result.event;\n    }\n    Event.fromPromise = fromPromise;\n    function runAndSubscribe(event, handler, initial) {\n        handler(initial);\n        return event(e => handler(e));\n    }\n    Event.runAndSubscribe = runAndSubscribe;\n    class EmitterObserver {\n        constructor(_observable, store) {\n            this._observable = _observable;\n            this._counter = 0;\n            this._hasChanged = false;\n            const options = {\n                onWillAddFirstListener: () => {\n                    _observable.addObserver(this);\n                },\n                onDidRemoveLastListener: () => {\n                    _observable.removeObserver(this);\n                }\n            };\n            this.emitter = ( new Emitter(options));\n            if (store) {\n                store.add(this.emitter);\n            }\n        }\n        beginUpdate(_observable) {\n            this._counter++;\n        }\n        handlePossibleChange(_observable) {\n        }\n        handleChange(_observable, _change) {\n            this._hasChanged = true;\n        }\n        endUpdate(_observable) {\n            this._counter--;\n            if (this._counter === 0) {\n                this._observable.reportChanges();\n                if (this._hasChanged) {\n                    this._hasChanged = false;\n                    this.emitter.fire(this._observable.get());\n                }\n            }\n        }\n    }\n    function fromObservable(obs, store) {\n        const observer = ( new EmitterObserver(obs, store));\n        return observer.emitter.event;\n    }\n    Event.fromObservable = fromObservable;\n    function fromObservableLight(observable) {\n        return (listener, thisArgs, disposables) => {\n            let count = 0;\n            let didChange = false;\n            const observer = {\n                beginUpdate() {\n                    count++;\n                },\n                endUpdate() {\n                    count--;\n                    if (count === 0) {\n                        observable.reportChanges();\n                        if (didChange) {\n                            didChange = false;\n                            listener.call(thisArgs);\n                        }\n                    }\n                },\n                handlePossibleChange() {\n                },\n                handleChange() {\n                    didChange = true;\n                }\n            };\n            observable.addObserver(observer);\n            observable.reportChanges();\n            const disposable = {\n                dispose() {\n                    observable.removeObserver(observer);\n                }\n            };\n            if (disposables instanceof DisposableStore) {\n                disposables.add(disposable);\n            }\n            else if (Array.isArray(disposables)) {\n                disposables.push(disposable);\n            }\n            return disposable;\n        };\n    }\n    Event.fromObservableLight = fromObservableLight;\n})(Event || (Event = {})));\nclass EventProfiling {\n    static { this.all = ( new Set()); }\n    static { this._idPool = 0; }\n    constructor(name) {\n        this.listenerCount = 0;\n        this.invocationCount = 0;\n        this.elapsedOverall = 0;\n        this.durations = [];\n        this.name = `${name}_${EventProfiling._idPool++}`;\n        EventProfiling.all.add(this);\n    }\n    start(listenerCount) {\n        this._stopWatch = ( new StopWatch());\n        this.listenerCount = listenerCount;\n    }\n    stop() {\n        if (this._stopWatch) {\n            const elapsed = this._stopWatch.elapsed();\n            this.durations.push(elapsed);\n            this.elapsedOverall += elapsed;\n            this.invocationCount += 1;\n            this._stopWatch = undefined;\n        }\n    }\n}\nlet _globalLeakWarningThreshold = -1;\nfunction setGlobalLeakWarningThreshold(n) {\n    const oldValue = _globalLeakWarningThreshold;\n    _globalLeakWarningThreshold = n;\n    return {\n        dispose() {\n            _globalLeakWarningThreshold = oldValue;\n        }\n    };\n}\nclass LeakageMonitor {\n    constructor(threshold, name = ( Math.random().toString(18)).slice(2, 5)) {\n        this.threshold = threshold;\n        this.name = name;\n        this._warnCountdown = 0;\n    }\n    dispose() {\n        this._stacks?.clear();\n    }\n    check(stack, listenerCount) {\n        const threshold = this.threshold;\n        if (threshold <= 0 || listenerCount < threshold) {\n            return undefined;\n        }\n        if (!this._stacks) {\n            this._stacks = ( new Map());\n        }\n        const count = (this._stacks.get(stack.value) || 0);\n        this._stacks.set(stack.value, count + 1);\n        this._warnCountdown -= 1;\n        if (this._warnCountdown <= 0) {\n            this._warnCountdown = threshold * 0.5;\n            let topStack;\n            let topCount = 0;\n            for (const [stack, count] of this._stacks) {\n                if (!topStack || topCount < count) {\n                    topStack = stack;\n                    topCount = count;\n                }\n            }\n            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n            console.warn(topStack);\n        }\n        return () => {\n            const count = (this._stacks.get(stack.value) || 0);\n            this._stacks.set(stack.value, count - 1);\n        };\n    }\n}\nclass Stacktrace {\n    static create() {\n        return ( new Stacktrace(( new Error()).stack ?? ''));\n    }\n    constructor(value) {\n        this.value = value;\n    }\n    print() {\n        console.warn(this.value.split('\\n').slice(2).join('\\n'));\n    }\n}\nlet id = 0;\nclass UniqueContainer {\n    constructor(value) {\n        this.value = value;\n        this.id = id++;\n    }\n}\nconst compactionThreshold = 2;\nconst forEachListener = (listeners, fn) => {\n    if (listeners instanceof UniqueContainer) {\n        fn(listeners);\n    }\n    else {\n        for (let i = 0; i < listeners.length; i++) {\n            const l = listeners[i];\n            if (l) {\n                fn(l);\n            }\n        }\n    }\n};\nclass Emitter {\n    constructor(options) {\n        this._size = 0;\n        this._options = options;\n        this._leakageMon = _globalLeakWarningThreshold > 0 || this._options?.leakWarningThreshold ? ( new LeakageMonitor(this._options?.leakWarningThreshold ?? _globalLeakWarningThreshold)) : undefined;\n        this._perfMon = this._options?._profName ? ( new EventProfiling(this._options._profName)) : undefined;\n        this._deliveryQueue = this._options?.deliveryQueue;\n    }\n    dispose() {\n        if (!this._disposed) {\n            this._disposed = true;\n            if (this._deliveryQueue?.current === this) {\n                this._deliveryQueue.reset();\n            }\n            if (this._listeners) {\n                this._listeners = undefined;\n                this._size = 0;\n            }\n            this._options?.onDidRemoveLastListener?.();\n            this._leakageMon?.dispose();\n        }\n    }\n    get event() {\n        this._event ??= (callback, thisArgs, disposables) => {\n            if (this._leakageMon && this._size > this._leakageMon.threshold * 3) {\n                console.warn(`[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far`);\n                return Disposable.None;\n            }\n            if (this._disposed) {\n                return Disposable.None;\n            }\n            if (thisArgs) {\n                callback = callback.bind(thisArgs);\n            }\n            const contained = ( new UniqueContainer(callback));\n            let removeMonitor;\n            if (this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2)) {\n                contained.stack = Stacktrace.create();\n                removeMonitor = this._leakageMon.check(contained.stack, this._size + 1);\n            }\n            if (!this._listeners) {\n                this._options?.onWillAddFirstListener?.(this);\n                this._listeners = contained;\n                this._options?.onDidAddFirstListener?.(this);\n            }\n            else if (this._listeners instanceof UniqueContainer) {\n                this._deliveryQueue ??= ( new EventDeliveryQueuePrivate());\n                this._listeners = [this._listeners, contained];\n            }\n            else {\n                this._listeners.push(contained);\n            }\n            this._size++;\n            const result = toDisposable(() => {\n                removeMonitor?.();\n                this._removeListener(contained);\n            });\n            if (disposables instanceof DisposableStore) {\n                disposables.add(result);\n            }\n            else if (Array.isArray(disposables)) {\n                disposables.push(result);\n            }\n            return result;\n        };\n        return this._event;\n    }\n    _removeListener(listener) {\n        this._options?.onWillRemoveListener?.(this);\n        if (!this._listeners) {\n            return;\n        }\n        if (this._size === 1) {\n            this._listeners = undefined;\n            this._options?.onDidRemoveLastListener?.(this);\n            this._size = 0;\n            return;\n        }\n        const listeners = this._listeners;\n        const index = listeners.indexOf(listener);\n        if (index === -1) {\n            console.log('disposed?', this._disposed);\n            console.log('size?', this._size);\n            console.log('arr?', JSON.stringify(this._listeners));\n            throw ( new Error('Attempted to dispose unknown listener'));\n        }\n        this._size--;\n        listeners[index] = undefined;\n        const adjustDeliveryQueue = this._deliveryQueue.current === this;\n        if (this._size * compactionThreshold <= listeners.length) {\n            let n = 0;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listeners[i]) {\n                    listeners[n++] = listeners[i];\n                }\n                else if (adjustDeliveryQueue) {\n                    this._deliveryQueue.end--;\n                    if (n < this._deliveryQueue.i) {\n                        this._deliveryQueue.i--;\n                    }\n                }\n            }\n            listeners.length = n;\n        }\n    }\n    _deliver(listener, value) {\n        if (!listener) {\n            return;\n        }\n        const errorHandler = this._options?.onListenerError || onUnexpectedError;\n        if (!errorHandler) {\n            listener.value(value);\n            return;\n        }\n        try {\n            listener.value(value);\n        }\n        catch (e) {\n            errorHandler(e);\n        }\n    }\n    _deliverQueue(dq) {\n        const listeners = dq.current._listeners;\n        while (dq.i < dq.end) {\n            this._deliver(listeners[dq.i++], dq.value);\n        }\n        dq.reset();\n    }\n    fire(event) {\n        if (this._deliveryQueue?.current) {\n            this._deliverQueue(this._deliveryQueue);\n            this._perfMon?.stop();\n        }\n        this._perfMon?.start(this._size);\n        if (!this._listeners) ;\n        else if (this._listeners instanceof UniqueContainer) {\n            this._deliver(this._listeners, event);\n        }\n        else {\n            const dq = this._deliveryQueue;\n            dq.enqueue(this, event, this._listeners.length);\n            this._deliverQueue(dq);\n        }\n        this._perfMon?.stop();\n    }\n    hasListeners() {\n        return this._size > 0;\n    }\n}\nconst createEventDeliveryQueue = () => ( new EventDeliveryQueuePrivate());\nclass EventDeliveryQueuePrivate {\n    constructor() {\n        this.i = -1;\n        this.end = 0;\n    }\n    enqueue(emitter, value, end) {\n        this.i = 0;\n        this.end = end;\n        this.current = emitter;\n        this.value = value;\n    }\n    reset() {\n        this.i = this.end;\n        this.current = undefined;\n        this.value = undefined;\n    }\n}\nclass AsyncEmitter extends Emitter {\n    async fireAsync(data, token, promiseJoin) {\n        if (!this._listeners) {\n            return;\n        }\n        if (!this._asyncDeliveryQueue) {\n            this._asyncDeliveryQueue = ( new LinkedList());\n        }\n        forEachListener(this._listeners, listener => this._asyncDeliveryQueue.push([listener.value, data]));\n        while (this._asyncDeliveryQueue.size > 0 && !token.isCancellationRequested) {\n            const [listener, data] = this._asyncDeliveryQueue.shift();\n            const thenables = [];\n            const event = {\n                ...data,\n                token,\n                waitUntil: (p) => {\n                    if (Object.isFrozen(thenables)) {\n                        throw ( new Error('waitUntil can NOT be called asynchronous'));\n                    }\n                    if (promiseJoin) {\n                        p = promiseJoin(p, listener);\n                    }\n                    thenables.push(p);\n                }\n            };\n            try {\n                listener(event);\n            }\n            catch (e) {\n                onUnexpectedError(e);\n                continue;\n            }\n            await Promise.allSettled(thenables).then(values => {\n                for (const value of values) {\n                    if (value.status === 'rejected') {\n                        onUnexpectedError(value.reason);\n                    }\n                }\n            });\n        }\n    }\n}\nclass PauseableEmitter extends Emitter {\n    get isPaused() {\n        return this._isPaused !== 0;\n    }\n    constructor(options) {\n        super(options);\n        this._isPaused = 0;\n        this._eventQueue = ( new LinkedList());\n        this._mergeFn = options?.merge;\n    }\n    pause() {\n        this._isPaused++;\n    }\n    resume() {\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\n            if (this._mergeFn) {\n                if (this._eventQueue.size > 0) {\n                    const events = Array.from(this._eventQueue);\n                    this._eventQueue.clear();\n                    super.fire(this._mergeFn(events));\n                }\n            }\n            else {\n                while (!this._isPaused && this._eventQueue.size !== 0) {\n                    super.fire(this._eventQueue.shift());\n                }\n            }\n        }\n    }\n    fire(event) {\n        if (this._size) {\n            if (this._isPaused !== 0) {\n                this._eventQueue.push(event);\n            }\n            else {\n                super.fire(event);\n            }\n        }\n    }\n}\nclass DebounceEmitter extends PauseableEmitter {\n    constructor(options) {\n        super(options);\n        this._delay = options.delay ?? 100;\n    }\n    fire(event) {\n        if (!this._handle) {\n            this.pause();\n            this._handle = setTimeout(() => {\n                this._handle = undefined;\n                this.resume();\n            }, this._delay);\n        }\n        super.fire(event);\n    }\n}\nclass MicrotaskEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._queuedEvents = [];\n        this._mergeFn = options?.merge;\n    }\n    fire(event) {\n        if (!this.hasListeners()) {\n            return;\n        }\n        this._queuedEvents.push(event);\n        if (this._queuedEvents.length === 1) {\n            queueMicrotask(() => {\n                if (this._mergeFn) {\n                    super.fire(this._mergeFn(this._queuedEvents));\n                }\n                else {\n                    this._queuedEvents.forEach(e => super.fire(e));\n                }\n                this._queuedEvents = [];\n            });\n        }\n    }\n}\nclass EventMultiplexer {\n    constructor() {\n        this.hasListeners = false;\n        this.events = [];\n        this.emitter = ( new Emitter({\n            onWillAddFirstListener: () => this.onFirstListenerAdd(),\n            onDidRemoveLastListener: () => this.onLastListenerRemove()\n        }));\n    }\n    get event() {\n        return this.emitter.event;\n    }\n    add(event) {\n        const e = { event: event, listener: null };\n        this.events.push(e);\n        if (this.hasListeners) {\n            this.hook(e);\n        }\n        const dispose = () => {\n            if (this.hasListeners) {\n                this.unhook(e);\n            }\n            const idx = this.events.indexOf(e);\n            this.events.splice(idx, 1);\n        };\n        return toDisposable(createSingleCallFunction(dispose));\n    }\n    onFirstListenerAdd() {\n        this.hasListeners = true;\n        this.events.forEach(e => this.hook(e));\n    }\n    onLastListenerRemove() {\n        this.hasListeners = false;\n        this.events.forEach(e => this.unhook(e));\n    }\n    hook(e) {\n        e.listener = e.event(r => this.emitter.fire(r));\n    }\n    unhook(e) {\n        e.listener?.dispose();\n        e.listener = null;\n    }\n    dispose() {\n        this.emitter.dispose();\n        for (const e of this.events) {\n            e.listener?.dispose();\n        }\n        this.events = [];\n    }\n}\nclass DynamicListEventMultiplexer {\n    constructor(items, onAddItem, onRemoveItem, getEvent) {\n        this._store = ( new DisposableStore());\n        const multiplexer = this._store.add(( new EventMultiplexer()));\n        const itemListeners = this._store.add(( new DisposableMap()));\n        function addItem(instance) {\n            itemListeners.set(instance, multiplexer.add(getEvent(instance)));\n        }\n        for (const instance of items) {\n            addItem(instance);\n        }\n        this._store.add(onAddItem(instance => {\n            addItem(instance);\n        }));\n        this._store.add(onRemoveItem(instance => {\n            itemListeners.deleteAndDispose(instance);\n        }));\n        this.event = multiplexer.event;\n    }\n    dispose() {\n        this._store.dispose();\n    }\n}\nclass EventBufferer {\n    constructor() {\n        this.buffers = [];\n    }\n    wrapEvent(event) {\n        return (listener, thisArgs, disposables) => {\n            return event(i => {\n                const buffer = this.buffers[this.buffers.length - 1];\n                if (buffer) {\n                    buffer.push(() => listener.call(thisArgs, i));\n                }\n                else {\n                    listener.call(thisArgs, i);\n                }\n            }, undefined, disposables);\n        };\n    }\n    bufferEvents(fn) {\n        const buffer = [];\n        this.buffers.push(buffer);\n        const r = fn();\n        this.buffers.pop();\n        buffer.forEach(flush => flush());\n        return r;\n    }\n}\nclass Relay {\n    constructor() {\n        this.listening = false;\n        this.inputEvent = Event.None;\n        this.inputEventListener = Disposable.None;\n        this.emitter = ( new Emitter({\n            onDidAddFirstListener: () => {\n                this.listening = true;\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n            },\n            onDidRemoveLastListener: () => {\n                this.listening = false;\n                this.inputEventListener.dispose();\n            }\n        }));\n        this.event = this.emitter.event;\n    }\n    set input(event) {\n        this.inputEvent = event;\n        if (this.listening) {\n            this.inputEventListener.dispose();\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\n        }\n    }\n    dispose() {\n        this.inputEventListener.dispose();\n        this.emitter.dispose();\n    }\n}\nclass ValueWithChangeEvent {\n    static const(value) {\n        return ( new ConstValueWithChangeEvent(value));\n    }\n    constructor(_value) {\n        this._value = _value;\n        this._onDidChange = ( new Emitter());\n        this.onDidChange = this._onDidChange.event;\n    }\n    get value() {\n        return this._value;\n    }\n    set value(value) {\n        if (value !== this._value) {\n            this._value = value;\n            this._onDidChange.fire(undefined);\n        }\n    }\n}\nclass ConstValueWithChangeEvent {\n    constructor(value) {\n        this.value = value;\n        this.onDidChange = Event.None;\n    }\n}\nexport { AsyncEmitter, DebounceEmitter, DynamicListEventMultiplexer, Emitter, Event, EventBufferer, EventMultiplexer, EventProfiling, MicrotaskEmitter, PauseableEmitter, Relay, ValueWithChangeEvent, createEventDeliveryQueue, setGlobalLeakWarningThreshold };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}