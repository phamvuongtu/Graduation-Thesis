{"ast":null,"code":"\"use strict\";\n\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WillDeleteFilesFeature = exports.WillRenameFilesFeature = exports.WillCreateFilesFeature = exports.DidDeleteFilesFeature = exports.DidRenameFilesFeature = exports.DidCreateFilesFeature = void 0;\nconst code = require(\"vscode\");\nconst minimatch = require(\"minimatch\");\nconst proto = require(\"vscode-languageserver-protocol\");\nconst UUID = require(\"./utils/uuid\");\nfunction ensure(target, key) {\n  if (target[key] === void 0) {\n    target[key] = {};\n  }\n  return target[key];\n}\nfunction access(target, key) {\n  return target[key];\n}\nfunction assign(target, key, value) {\n  target[key] = value;\n}\nclass FileOperationFeature {\n  constructor(client, event, registrationType, clientCapability, serverCapability) {\n    this._client = client;\n    this._event = event;\n    this._registrationType = registrationType;\n    this._clientCapability = clientCapability;\n    this._serverCapability = serverCapability;\n    this._filters = new Map();\n  }\n  getState() {\n    return {\n      kind: 'workspace',\n      id: this._registrationType.method,\n      registrations: this._filters.size > 0\n    };\n  }\n  filterSize() {\n    return this._filters.size;\n  }\n  get registrationType() {\n    return this._registrationType;\n  }\n  fillClientCapabilities(capabilities) {\n    const value = ensure(ensure(capabilities, 'workspace'), 'fileOperations');\n    // this happens n times but it is the same value so we tolerate this.\n    assign(value, 'dynamicRegistration', true);\n    assign(value, this._clientCapability, true);\n  }\n  initialize(capabilities) {\n    const options = capabilities.workspace?.fileOperations;\n    const capability = options !== undefined ? access(options, this._serverCapability) : undefined;\n    if (capability?.filters !== undefined) {\n      try {\n        this.register({\n          id: UUID.generateUuid(),\n          registerOptions: {\n            filters: capability.filters\n          }\n        });\n      } catch (e) {\n        this._client.warn(`Ignoring invalid glob pattern for ${this._serverCapability} registration: ${e}`);\n      }\n    }\n  }\n  register(data) {\n    if (!this._listener) {\n      this._listener = this._event(this.send, this);\n    }\n    const minimatchFilter = data.registerOptions.filters.map(filter => {\n      const matcher = new minimatch.Minimatch(filter.pattern.glob, FileOperationFeature.asMinimatchOptions(filter.pattern.options));\n      if (!matcher.makeRe()) {\n        throw new Error(`Invalid pattern ${filter.pattern.glob}!`);\n      }\n      return {\n        scheme: filter.scheme,\n        matcher,\n        kind: filter.pattern.matches\n      };\n    });\n    this._filters.set(data.id, minimatchFilter);\n  }\n  unregister(id) {\n    this._filters.delete(id);\n    if (this._filters.size === 0 && this._listener) {\n      this._listener.dispose();\n      this._listener = undefined;\n    }\n  }\n  clear() {\n    this._filters.clear();\n    if (this._listener) {\n      this._listener.dispose();\n      this._listener = undefined;\n    }\n  }\n  getFileType(uri) {\n    return FileOperationFeature.getFileType(uri);\n  }\n  async filter(event, prop) {\n    // (Asynchronously) map each file onto a boolean of whether it matches\n    // any of the globs.\n    const fileMatches = await Promise.all(event.files.map(async item => {\n      const uri = prop(item);\n      // Use fsPath to make this consistent with file system watchers but help\n      // minimatch to use '/' instead of `\\\\` if present.\n      const path = uri.fsPath.replace(/\\\\/g, '/');\n      for (const filters of this._filters.values()) {\n        for (const filter of filters) {\n          if (filter.scheme !== undefined && filter.scheme !== uri.scheme) {\n            continue;\n          }\n          if (filter.matcher.match(path)) {\n            // The pattern matches. If kind is undefined then everything is ok\n            if (filter.kind === undefined) {\n              return true;\n            }\n            const fileType = await this.getFileType(uri);\n            // If we can't determine the file type than we treat it as a match.\n            // Dropping it would be another alternative.\n            if (fileType === undefined) {\n              this._client.error(`Failed to determine file type for ${uri.toString()}.`);\n              return true;\n            }\n            if (fileType === code.FileType.File && filter.kind === proto.FileOperationPatternKind.file || fileType === code.FileType.Directory && filter.kind === proto.FileOperationPatternKind.folder) {\n              return true;\n            }\n          } else if (filter.kind === proto.FileOperationPatternKind.folder) {\n            const fileType = await FileOperationFeature.getFileType(uri);\n            if (fileType === code.FileType.Directory && filter.matcher.match(`${path}/`)) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    }));\n    // Filter the files to those that matched.\n    const files = event.files.filter((_, index) => fileMatches[index]);\n    return {\n      ...event,\n      files\n    };\n  }\n  static async getFileType(uri) {\n    try {\n      return (await code.workspace.fs.stat(uri)).type;\n    } catch (e) {\n      return undefined;\n    }\n  }\n  static asMinimatchOptions(options) {\n    // The spec doesn't state that dot files don't match. So we make\n    // matching those the default.\n    const result = {\n      dot: true\n    };\n    if (options?.ignoreCase === true) {\n      result.nocase = true;\n    }\n    return result;\n  }\n}\nclass NotificationFileOperationFeature extends FileOperationFeature {\n  constructor(client, event, notificationType, clientCapability, serverCapability, accessUri, createParams) {\n    super(client, event, notificationType, clientCapability, serverCapability);\n    this._notificationType = notificationType;\n    this._accessUri = accessUri;\n    this._createParams = createParams;\n  }\n  async send(originalEvent) {\n    // Create a copy of the event that has the files filtered to match what the\n    // server wants.\n    const filteredEvent = await this.filter(originalEvent, this._accessUri);\n    if (filteredEvent.files.length) {\n      const next = async event => {\n        return this._client.sendNotification(this._notificationType, this._createParams(event));\n      };\n      return this.doSend(filteredEvent, next);\n    }\n  }\n}\nclass CachingNotificationFileOperationFeature extends NotificationFileOperationFeature {\n  constructor() {\n    super(...arguments);\n    this._fsPathFileTypes = new Map();\n  }\n  async getFileType(uri) {\n    const fsPath = uri.fsPath;\n    if (this._fsPathFileTypes.has(fsPath)) {\n      return this._fsPathFileTypes.get(fsPath);\n    }\n    const type = await FileOperationFeature.getFileType(uri);\n    if (type) {\n      this._fsPathFileTypes.set(fsPath, type);\n    }\n    return type;\n  }\n  async cacheFileTypes(event, prop) {\n    // Calling filter will force the matching logic to run. For any item\n    // that requires a getFileType lookup, the overriden getFileType will\n    // be called that will cache the result so that when onDidRename fires,\n    // it can still be checked even though the item no longer exists on disk\n    // in its original location.\n    await this.filter(event, prop);\n  }\n  clearFileTypeCache() {\n    this._fsPathFileTypes.clear();\n  }\n  unregister(id) {\n    super.unregister(id);\n    if (this.filterSize() === 0 && this._willListener) {\n      this._willListener.dispose();\n      this._willListener = undefined;\n    }\n  }\n  clear() {\n    super.clear();\n    if (this._willListener) {\n      this._willListener.dispose();\n      this._willListener = undefined;\n    }\n  }\n}\nclass DidCreateFilesFeature extends NotificationFileOperationFeature {\n  constructor(client) {\n    super(client, code.workspace.onDidCreateFiles, proto.DidCreateFilesNotification.type, 'didCreate', 'didCreate', i => i, client.code2ProtocolConverter.asDidCreateFilesParams);\n  }\n  doSend(event, next) {\n    const middleware = this._client.middleware.workspace;\n    return middleware?.didCreateFiles ? middleware.didCreateFiles(event, next) : next(event);\n  }\n}\nexports.DidCreateFilesFeature = DidCreateFilesFeature;\nclass DidRenameFilesFeature extends CachingNotificationFileOperationFeature {\n  constructor(client) {\n    super(client, code.workspace.onDidRenameFiles, proto.DidRenameFilesNotification.type, 'didRename', 'didRename', i => i.oldUri, client.code2ProtocolConverter.asDidRenameFilesParams);\n  }\n  register(data) {\n    if (!this._willListener) {\n      this._willListener = code.workspace.onWillRenameFiles(this.willRename, this);\n    }\n    super.register(data);\n  }\n  willRename(e) {\n    e.waitUntil(this.cacheFileTypes(e, i => i.oldUri));\n  }\n  doSend(event, next) {\n    this.clearFileTypeCache();\n    const middleware = this._client.middleware.workspace;\n    return middleware?.didRenameFiles ? middleware.didRenameFiles(event, next) : next(event);\n  }\n}\nexports.DidRenameFilesFeature = DidRenameFilesFeature;\nclass DidDeleteFilesFeature extends CachingNotificationFileOperationFeature {\n  constructor(client) {\n    super(client, code.workspace.onDidDeleteFiles, proto.DidDeleteFilesNotification.type, 'didDelete', 'didDelete', i => i, client.code2ProtocolConverter.asDidDeleteFilesParams);\n  }\n  register(data) {\n    if (!this._willListener) {\n      this._willListener = code.workspace.onWillDeleteFiles(this.willDelete, this);\n    }\n    super.register(data);\n  }\n  willDelete(e) {\n    e.waitUntil(this.cacheFileTypes(e, i => i));\n  }\n  doSend(event, next) {\n    this.clearFileTypeCache();\n    const middleware = this._client.middleware.workspace;\n    return middleware?.didDeleteFiles ? middleware.didDeleteFiles(event, next) : next(event);\n  }\n}\nexports.DidDeleteFilesFeature = DidDeleteFilesFeature;\nclass RequestFileOperationFeature extends FileOperationFeature {\n  constructor(client, event, requestType, clientCapability, serverCapability, accessUri, createParams) {\n    super(client, event, requestType, clientCapability, serverCapability);\n    this._requestType = requestType;\n    this._accessUri = accessUri;\n    this._createParams = createParams;\n  }\n  async send(originalEvent) {\n    const waitUntil = this.waitUntil(originalEvent);\n    originalEvent.waitUntil(waitUntil);\n  }\n  async waitUntil(originalEvent) {\n    // Create a copy of the event that has the files filtered to match what the\n    // server wants.\n    const filteredEvent = await this.filter(originalEvent, this._accessUri);\n    if (filteredEvent.files.length) {\n      const next = event => {\n        return this._client.sendRequest(this._requestType, this._createParams(event), event.token).then(this._client.protocol2CodeConverter.asWorkspaceEdit);\n      };\n      return this.doSend(filteredEvent, next);\n    } else {\n      return undefined;\n    }\n  }\n}\nclass WillCreateFilesFeature extends RequestFileOperationFeature {\n  constructor(client) {\n    super(client, code.workspace.onWillCreateFiles, proto.WillCreateFilesRequest.type, 'willCreate', 'willCreate', i => i, client.code2ProtocolConverter.asWillCreateFilesParams);\n  }\n  doSend(event, next) {\n    const middleware = this._client.middleware.workspace;\n    return middleware?.willCreateFiles ? middleware.willCreateFiles(event, next) : next(event);\n  }\n}\nexports.WillCreateFilesFeature = WillCreateFilesFeature;\nclass WillRenameFilesFeature extends RequestFileOperationFeature {\n  constructor(client) {\n    super(client, code.workspace.onWillRenameFiles, proto.WillRenameFilesRequest.type, 'willRename', 'willRename', i => i.oldUri, client.code2ProtocolConverter.asWillRenameFilesParams);\n  }\n  doSend(event, next) {\n    const middleware = this._client.middleware.workspace;\n    return middleware?.willRenameFiles ? middleware.willRenameFiles(event, next) : next(event);\n  }\n}\nexports.WillRenameFilesFeature = WillRenameFilesFeature;\nclass WillDeleteFilesFeature extends RequestFileOperationFeature {\n  constructor(client) {\n    super(client, code.workspace.onWillDeleteFiles, proto.WillDeleteFilesRequest.type, 'willDelete', 'willDelete', i => i, client.code2ProtocolConverter.asWillDeleteFilesParams);\n  }\n  doSend(event, next) {\n    const middleware = this._client.middleware.workspace;\n    return middleware?.willDeleteFiles ? middleware.willDeleteFiles(event, next) : next(event);\n  }\n}\nexports.WillDeleteFilesFeature = WillDeleteFilesFeature;","map":{"version":3,"names":["Object","defineProperty","exports","value","WillDeleteFilesFeature","WillRenameFilesFeature","WillCreateFilesFeature","DidDeleteFilesFeature","DidRenameFilesFeature","DidCreateFilesFeature","code","require","minimatch","proto","UUID","ensure","target","key","access","assign","FileOperationFeature","constructor","client","event","registrationType","clientCapability","serverCapability","_client","_event","_registrationType","_clientCapability","_serverCapability","_filters","Map","getState","kind","id","method","registrations","size","filterSize","fillClientCapabilities","capabilities","initialize","options","workspace","fileOperations","capability","undefined","filters","register","generateUuid","registerOptions","e","warn","data","_listener","send","minimatchFilter","map","filter","matcher","Minimatch","pattern","glob","asMinimatchOptions","makeRe","Error","scheme","matches","set","unregister","delete","dispose","clear","getFileType","uri","prop","fileMatches","Promise","all","files","item","path","fsPath","replace","values","match","fileType","error","toString","FileType","File","FileOperationPatternKind","file","Directory","folder","_","index","fs","stat","type","result","dot","ignoreCase","nocase","NotificationFileOperationFeature","notificationType","accessUri","createParams","_notificationType","_accessUri","_createParams","originalEvent","filteredEvent","length","next","sendNotification","doSend","CachingNotificationFileOperationFeature","arguments","_fsPathFileTypes","has","get","cacheFileTypes","clearFileTypeCache","_willListener","onDidCreateFiles","DidCreateFilesNotification","i","code2ProtocolConverter","asDidCreateFilesParams","middleware","didCreateFiles","onDidRenameFiles","DidRenameFilesNotification","oldUri","asDidRenameFilesParams","onWillRenameFiles","willRename","waitUntil","didRenameFiles","onDidDeleteFiles","DidDeleteFilesNotification","asDidDeleteFilesParams","onWillDeleteFiles","willDelete","didDeleteFiles","RequestFileOperationFeature","requestType","_requestType","sendRequest","token","then","protocol2CodeConverter","asWorkspaceEdit","onWillCreateFiles","WillCreateFilesRequest","asWillCreateFilesParams","willCreateFiles","WillRenameFilesRequest","asWillRenameFilesParams","willRenameFiles","WillDeleteFilesRequest","asWillDeleteFilesParams","willDeleteFiles"],"sources":["/Users/phamtu/Downloads/Code/OCE/oce-frontend/node_modules/vscode-languageclient/lib/common/fileOperations.js"],"sourcesContent":["\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WillDeleteFilesFeature = exports.WillRenameFilesFeature = exports.WillCreateFilesFeature = exports.DidDeleteFilesFeature = exports.DidRenameFilesFeature = exports.DidCreateFilesFeature = void 0;\nconst code = require(\"vscode\");\nconst minimatch = require(\"minimatch\");\nconst proto = require(\"vscode-languageserver-protocol\");\nconst UUID = require(\"./utils/uuid\");\nfunction ensure(target, key) {\n    if (target[key] === void 0) {\n        target[key] = {};\n    }\n    return target[key];\n}\nfunction access(target, key) {\n    return target[key];\n}\nfunction assign(target, key, value) {\n    target[key] = value;\n}\nclass FileOperationFeature {\n    constructor(client, event, registrationType, clientCapability, serverCapability) {\n        this._client = client;\n        this._event = event;\n        this._registrationType = registrationType;\n        this._clientCapability = clientCapability;\n        this._serverCapability = serverCapability;\n        this._filters = new Map();\n    }\n    getState() {\n        return { kind: 'workspace', id: this._registrationType.method, registrations: this._filters.size > 0 };\n    }\n    filterSize() {\n        return this._filters.size;\n    }\n    get registrationType() {\n        return this._registrationType;\n    }\n    fillClientCapabilities(capabilities) {\n        const value = ensure(ensure(capabilities, 'workspace'), 'fileOperations');\n        // this happens n times but it is the same value so we tolerate this.\n        assign(value, 'dynamicRegistration', true);\n        assign(value, this._clientCapability, true);\n    }\n    initialize(capabilities) {\n        const options = capabilities.workspace?.fileOperations;\n        const capability = options !== undefined ? access(options, this._serverCapability) : undefined;\n        if (capability?.filters !== undefined) {\n            try {\n                this.register({\n                    id: UUID.generateUuid(),\n                    registerOptions: { filters: capability.filters }\n                });\n            }\n            catch (e) {\n                this._client.warn(`Ignoring invalid glob pattern for ${this._serverCapability} registration: ${e}`);\n            }\n        }\n    }\n    register(data) {\n        if (!this._listener) {\n            this._listener = this._event(this.send, this);\n        }\n        const minimatchFilter = data.registerOptions.filters.map((filter) => {\n            const matcher = new minimatch.Minimatch(filter.pattern.glob, FileOperationFeature.asMinimatchOptions(filter.pattern.options));\n            if (!matcher.makeRe()) {\n                throw new Error(`Invalid pattern ${filter.pattern.glob}!`);\n            }\n            return { scheme: filter.scheme, matcher, kind: filter.pattern.matches };\n        });\n        this._filters.set(data.id, minimatchFilter);\n    }\n    unregister(id) {\n        this._filters.delete(id);\n        if (this._filters.size === 0 && this._listener) {\n            this._listener.dispose();\n            this._listener = undefined;\n        }\n    }\n    clear() {\n        this._filters.clear();\n        if (this._listener) {\n            this._listener.dispose();\n            this._listener = undefined;\n        }\n    }\n    getFileType(uri) {\n        return FileOperationFeature.getFileType(uri);\n    }\n    async filter(event, prop) {\n        // (Asynchronously) map each file onto a boolean of whether it matches\n        // any of the globs.\n        const fileMatches = await Promise.all(event.files.map(async (item) => {\n            const uri = prop(item);\n            // Use fsPath to make this consistent with file system watchers but help\n            // minimatch to use '/' instead of `\\\\` if present.\n            const path = uri.fsPath.replace(/\\\\/g, '/');\n            for (const filters of this._filters.values()) {\n                for (const filter of filters) {\n                    if (filter.scheme !== undefined && filter.scheme !== uri.scheme) {\n                        continue;\n                    }\n                    if (filter.matcher.match(path)) {\n                        // The pattern matches. If kind is undefined then everything is ok\n                        if (filter.kind === undefined) {\n                            return true;\n                        }\n                        const fileType = await this.getFileType(uri);\n                        // If we can't determine the file type than we treat it as a match.\n                        // Dropping it would be another alternative.\n                        if (fileType === undefined) {\n                            this._client.error(`Failed to determine file type for ${uri.toString()}.`);\n                            return true;\n                        }\n                        if ((fileType === code.FileType.File && filter.kind === proto.FileOperationPatternKind.file) || (fileType === code.FileType.Directory && filter.kind === proto.FileOperationPatternKind.folder)) {\n                            return true;\n                        }\n                    }\n                    else if (filter.kind === proto.FileOperationPatternKind.folder) {\n                        const fileType = await FileOperationFeature.getFileType(uri);\n                        if (fileType === code.FileType.Directory && filter.matcher.match(`${path}/`)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n            return false;\n        }));\n        // Filter the files to those that matched.\n        const files = event.files.filter((_, index) => fileMatches[index]);\n        return { ...event, files };\n    }\n    static async getFileType(uri) {\n        try {\n            return (await code.workspace.fs.stat(uri)).type;\n        }\n        catch (e) {\n            return undefined;\n        }\n    }\n    static asMinimatchOptions(options) {\n        // The spec doesn't state that dot files don't match. So we make\n        // matching those the default.\n        const result = { dot: true };\n        if (options?.ignoreCase === true) {\n            result.nocase = true;\n        }\n        return result;\n    }\n}\nclass NotificationFileOperationFeature extends FileOperationFeature {\n    constructor(client, event, notificationType, clientCapability, serverCapability, accessUri, createParams) {\n        super(client, event, notificationType, clientCapability, serverCapability);\n        this._notificationType = notificationType;\n        this._accessUri = accessUri;\n        this._createParams = createParams;\n    }\n    async send(originalEvent) {\n        // Create a copy of the event that has the files filtered to match what the\n        // server wants.\n        const filteredEvent = await this.filter(originalEvent, this._accessUri);\n        if (filteredEvent.files.length) {\n            const next = async (event) => {\n                return this._client.sendNotification(this._notificationType, this._createParams(event));\n            };\n            return this.doSend(filteredEvent, next);\n        }\n    }\n}\nclass CachingNotificationFileOperationFeature extends NotificationFileOperationFeature {\n    constructor() {\n        super(...arguments);\n        this._fsPathFileTypes = new Map();\n    }\n    async getFileType(uri) {\n        const fsPath = uri.fsPath;\n        if (this._fsPathFileTypes.has(fsPath)) {\n            return this._fsPathFileTypes.get(fsPath);\n        }\n        const type = await FileOperationFeature.getFileType(uri);\n        if (type) {\n            this._fsPathFileTypes.set(fsPath, type);\n        }\n        return type;\n    }\n    async cacheFileTypes(event, prop) {\n        // Calling filter will force the matching logic to run. For any item\n        // that requires a getFileType lookup, the overriden getFileType will\n        // be called that will cache the result so that when onDidRename fires,\n        // it can still be checked even though the item no longer exists on disk\n        // in its original location.\n        await this.filter(event, prop);\n    }\n    clearFileTypeCache() {\n        this._fsPathFileTypes.clear();\n    }\n    unregister(id) {\n        super.unregister(id);\n        if (this.filterSize() === 0 && this._willListener) {\n            this._willListener.dispose();\n            this._willListener = undefined;\n        }\n    }\n    clear() {\n        super.clear();\n        if (this._willListener) {\n            this._willListener.dispose();\n            this._willListener = undefined;\n        }\n    }\n}\nclass DidCreateFilesFeature extends NotificationFileOperationFeature {\n    constructor(client) {\n        super(client, code.workspace.onDidCreateFiles, proto.DidCreateFilesNotification.type, 'didCreate', 'didCreate', (i) => i, client.code2ProtocolConverter.asDidCreateFilesParams);\n    }\n    doSend(event, next) {\n        const middleware = this._client.middleware.workspace;\n        return middleware?.didCreateFiles\n            ? middleware.didCreateFiles(event, next)\n            : next(event);\n    }\n}\nexports.DidCreateFilesFeature = DidCreateFilesFeature;\nclass DidRenameFilesFeature extends CachingNotificationFileOperationFeature {\n    constructor(client) {\n        super(client, code.workspace.onDidRenameFiles, proto.DidRenameFilesNotification.type, 'didRename', 'didRename', (i) => i.oldUri, client.code2ProtocolConverter.asDidRenameFilesParams);\n    }\n    register(data) {\n        if (!this._willListener) {\n            this._willListener = code.workspace.onWillRenameFiles(this.willRename, this);\n        }\n        super.register(data);\n    }\n    willRename(e) {\n        e.waitUntil(this.cacheFileTypes(e, (i) => i.oldUri));\n    }\n    doSend(event, next) {\n        this.clearFileTypeCache();\n        const middleware = this._client.middleware.workspace;\n        return middleware?.didRenameFiles\n            ? middleware.didRenameFiles(event, next)\n            : next(event);\n    }\n}\nexports.DidRenameFilesFeature = DidRenameFilesFeature;\nclass DidDeleteFilesFeature extends CachingNotificationFileOperationFeature {\n    constructor(client) {\n        super(client, code.workspace.onDidDeleteFiles, proto.DidDeleteFilesNotification.type, 'didDelete', 'didDelete', (i) => i, client.code2ProtocolConverter.asDidDeleteFilesParams);\n    }\n    register(data) {\n        if (!this._willListener) {\n            this._willListener = code.workspace.onWillDeleteFiles(this.willDelete, this);\n        }\n        super.register(data);\n    }\n    willDelete(e) {\n        e.waitUntil(this.cacheFileTypes(e, (i) => i));\n    }\n    doSend(event, next) {\n        this.clearFileTypeCache();\n        const middleware = this._client.middleware.workspace;\n        return middleware?.didDeleteFiles\n            ? middleware.didDeleteFiles(event, next)\n            : next(event);\n    }\n}\nexports.DidDeleteFilesFeature = DidDeleteFilesFeature;\nclass RequestFileOperationFeature extends FileOperationFeature {\n    constructor(client, event, requestType, clientCapability, serverCapability, accessUri, createParams) {\n        super(client, event, requestType, clientCapability, serverCapability);\n        this._requestType = requestType;\n        this._accessUri = accessUri;\n        this._createParams = createParams;\n    }\n    async send(originalEvent) {\n        const waitUntil = this.waitUntil(originalEvent);\n        originalEvent.waitUntil(waitUntil);\n    }\n    async waitUntil(originalEvent) {\n        // Create a copy of the event that has the files filtered to match what the\n        // server wants.\n        const filteredEvent = await this.filter(originalEvent, this._accessUri);\n        if (filteredEvent.files.length) {\n            const next = (event) => {\n                return this._client.sendRequest(this._requestType, this._createParams(event), event.token)\n                    .then(this._client.protocol2CodeConverter.asWorkspaceEdit);\n            };\n            return this.doSend(filteredEvent, next);\n        }\n        else {\n            return undefined;\n        }\n    }\n}\nclass WillCreateFilesFeature extends RequestFileOperationFeature {\n    constructor(client) {\n        super(client, code.workspace.onWillCreateFiles, proto.WillCreateFilesRequest.type, 'willCreate', 'willCreate', (i) => i, client.code2ProtocolConverter.asWillCreateFilesParams);\n    }\n    doSend(event, next) {\n        const middleware = this._client.middleware.workspace;\n        return middleware?.willCreateFiles\n            ? middleware.willCreateFiles(event, next)\n            : next(event);\n    }\n}\nexports.WillCreateFilesFeature = WillCreateFilesFeature;\nclass WillRenameFilesFeature extends RequestFileOperationFeature {\n    constructor(client) {\n        super(client, code.workspace.onWillRenameFiles, proto.WillRenameFilesRequest.type, 'willRename', 'willRename', (i) => i.oldUri, client.code2ProtocolConverter.asWillRenameFilesParams);\n    }\n    doSend(event, next) {\n        const middleware = this._client.middleware.workspace;\n        return middleware?.willRenameFiles\n            ? middleware.willRenameFiles(event, next)\n            : next(event);\n    }\n}\nexports.WillRenameFilesFeature = WillRenameFilesFeature;\nclass WillDeleteFilesFeature extends RequestFileOperationFeature {\n    constructor(client) {\n        super(client, code.workspace.onWillDeleteFiles, proto.WillDeleteFilesRequest.type, 'willDelete', 'willDelete', (i) => i, client.code2ProtocolConverter.asWillDeleteFilesParams);\n    }\n    doSend(event, next) {\n        const middleware = this._client.middleware.workspace;\n        return middleware?.willDeleteFiles\n            ? middleware.willDeleteFiles(event, next)\n            : next(event);\n    }\n}\nexports.WillDeleteFilesFeature = WillDeleteFilesFeature;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}