{"ast":null,"code":"import { Lazy } from './lazy.js';\nimport { consumeReadable, toReadable, consumeStream, toStream, prefixedStream, newWriteableStream, prefixedReadable } from './stream.js';\nconst hasBuffer = typeof Buffer !== 'undefined';\nconst indexOfTable = new Lazy(() => new Uint8Array(256));\nlet textEncoder;\nlet textDecoder;\nclass VSBuffer {\n  static alloc(byteLength) {\n    if (hasBuffer) {\n      return new VSBuffer(Buffer.allocUnsafe(byteLength));\n    } else {\n      return new VSBuffer(new Uint8Array(byteLength));\n    }\n  }\n  static wrap(actual) {\n    if (hasBuffer && !Buffer.isBuffer(actual)) {\n      actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n    }\n    return new VSBuffer(actual);\n  }\n  static fromString(source, options) {\n    const dontUseNodeBuffer = options?.dontUseNodeBuffer || false;\n    if (!dontUseNodeBuffer && hasBuffer) {\n      return new VSBuffer(Buffer.from(source));\n    } else {\n      if (!textEncoder) {\n        textEncoder = new TextEncoder();\n      }\n      return new VSBuffer(textEncoder.encode(source));\n    }\n  }\n  static fromByteArray(source) {\n    const result = VSBuffer.alloc(source.length);\n    for (let i = 0, len = source.length; i < len; i++) {\n      result.buffer[i] = source[i];\n    }\n    return result;\n  }\n  static concat(buffers, totalLength) {\n    if (typeof totalLength === 'undefined') {\n      totalLength = 0;\n      for (let i = 0, len = buffers.length; i < len; i++) {\n        totalLength += buffers[i].byteLength;\n      }\n    }\n    const ret = VSBuffer.alloc(totalLength);\n    let offset = 0;\n    for (let i = 0, len = buffers.length; i < len; i++) {\n      const element = buffers[i];\n      ret.set(element, offset);\n      offset += element.byteLength;\n    }\n    return ret;\n  }\n  constructor(buffer) {\n    this.buffer = buffer;\n    this.byteLength = this.buffer.byteLength;\n  }\n  clone() {\n    const result = VSBuffer.alloc(this.byteLength);\n    result.set(this);\n    return result;\n  }\n  toString() {\n    if (hasBuffer) {\n      return this.buffer.toString();\n    } else {\n      if (!textDecoder) {\n        textDecoder = new TextDecoder();\n      }\n      return textDecoder.decode(this.buffer);\n    }\n  }\n  slice(start, end) {\n    return new VSBuffer(this.buffer.subarray(start, end));\n  }\n  set(array, offset) {\n    if (array instanceof VSBuffer) {\n      this.buffer.set(array.buffer, offset);\n    } else if (array instanceof Uint8Array) {\n      this.buffer.set(array, offset);\n    } else if (array instanceof ArrayBuffer) {\n      this.buffer.set(new Uint8Array(array), offset);\n    } else if (ArrayBuffer.isView(array)) {\n      this.buffer.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength), offset);\n    } else {\n      throw new Error(`Unknown argument 'array'`);\n    }\n  }\n  readUInt32BE(offset) {\n    return readUInt32BE(this.buffer, offset);\n  }\n  writeUInt32BE(value, offset) {\n    writeUInt32BE(this.buffer, value, offset);\n  }\n  readUInt32LE(offset) {\n    return readUInt32LE(this.buffer, offset);\n  }\n  writeUInt32LE(value, offset) {\n    writeUInt32LE(this.buffer, value, offset);\n  }\n  readUInt8(offset) {\n    return readUInt8(this.buffer, offset);\n  }\n  writeUInt8(value, offset) {\n    writeUInt8(this.buffer, value, offset);\n  }\n  indexOf(subarray, offset = 0) {\n    return binaryIndexOf(this.buffer, subarray instanceof VSBuffer ? subarray.buffer : subarray, offset);\n  }\n}\nfunction binaryIndexOf(haystack, needle, offset = 0) {\n  const needleLen = needle.byteLength;\n  const haystackLen = haystack.byteLength;\n  if (needleLen === 0) {\n    return 0;\n  }\n  if (needleLen === 1) {\n    return haystack.indexOf(needle[0]);\n  }\n  if (needleLen > haystackLen - offset) {\n    return -1;\n  }\n  const table = indexOfTable.value;\n  table.fill(needle.length);\n  for (let i = 0; i < needle.length; i++) {\n    table[needle[i]] = needle.length - i - 1;\n  }\n  let i = offset + needle.length - 1;\n  let j = i;\n  let result = -1;\n  while (i < haystackLen) {\n    if (haystack[i] === needle[j]) {\n      if (j === 0) {\n        result = i;\n        break;\n      }\n      i--;\n      j--;\n    } else {\n      i += Math.max(needle.length - j, table[haystack[i]]);\n      j = needle.length - 1;\n    }\n  }\n  return result;\n}\nfunction readUInt16LE(source, offset) {\n  return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0;\n}\nfunction writeUInt16LE(destination, value, offset) {\n  destination[offset + 0] = value & 0b11111111;\n  value = value >>> 8;\n  destination[offset + 1] = value & 0b11111111;\n}\nfunction readUInt32BE(source, offset) {\n  return source[offset] * 2 ** 24 + source[offset + 1] * 2 ** 16 + source[offset + 2] * 2 ** 8 + source[offset + 3];\n}\nfunction writeUInt32BE(destination, value, offset) {\n  destination[offset + 3] = value;\n  value = value >>> 8;\n  destination[offset + 2] = value;\n  value = value >>> 8;\n  destination[offset + 1] = value;\n  value = value >>> 8;\n  destination[offset] = value;\n}\nfunction readUInt32LE(source, offset) {\n  return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0 | source[offset + 2] << 16 >>> 0 | source[offset + 3] << 24 >>> 0;\n}\nfunction writeUInt32LE(destination, value, offset) {\n  destination[offset + 0] = value & 0b11111111;\n  value = value >>> 8;\n  destination[offset + 1] = value & 0b11111111;\n  value = value >>> 8;\n  destination[offset + 2] = value & 0b11111111;\n  value = value >>> 8;\n  destination[offset + 3] = value & 0b11111111;\n}\nfunction readUInt8(source, offset) {\n  return source[offset];\n}\nfunction writeUInt8(destination, value, offset) {\n  destination[offset] = value;\n}\nfunction readableToBuffer(readable) {\n  return consumeReadable(readable, chunks => VSBuffer.concat(chunks));\n}\nfunction bufferToReadable(buffer) {\n  return toReadable(buffer);\n}\nfunction streamToBuffer(stream) {\n  return consumeStream(stream, chunks => VSBuffer.concat(chunks));\n}\nasync function bufferedStreamToBuffer(bufferedStream) {\n  if (bufferedStream.ended) {\n    return VSBuffer.concat(bufferedStream.buffer);\n  }\n  return VSBuffer.concat([...bufferedStream.buffer, await streamToBuffer(bufferedStream.stream)]);\n}\nfunction bufferToStream(buffer) {\n  return toStream(buffer, chunks => VSBuffer.concat(chunks));\n}\nfunction newWriteableBufferStream(options) {\n  return newWriteableStream(chunks => VSBuffer.concat(chunks), options);\n}\nfunction prefixedBufferReadable(prefix, readable) {\n  return prefixedReadable(prefix, readable, chunks => VSBuffer.concat(chunks));\n}\nfunction prefixedBufferStream(prefix, stream) {\n  return prefixedStream(prefix, stream, chunks => VSBuffer.concat(chunks));\n}\nfunction decodeBase64(encoded) {\n  let building = 0;\n  let remainder = 0;\n  let bufi = 0;\n  const buffer = new Uint8Array(Math.floor(encoded.length / 4 * 3));\n  const append = value => {\n    switch (remainder) {\n      case 3:\n        buffer[bufi++] = building | value;\n        remainder = 0;\n        break;\n      case 2:\n        buffer[bufi++] = building | value >>> 2;\n        building = value << 6;\n        remainder = 3;\n        break;\n      case 1:\n        buffer[bufi++] = building | value >>> 4;\n        building = value << 4;\n        remainder = 2;\n        break;\n      default:\n        building = value << 2;\n        remainder = 1;\n    }\n  };\n  for (let i = 0; i < encoded.length; i++) {\n    const code = encoded.charCodeAt(i);\n    if (code >= 65 && code <= 90) {\n      append(code - 65);\n    } else if (code >= 97 && code <= 122) {\n      append(code - 97 + 26);\n    } else if (code >= 48 && code <= 57) {\n      append(code - 48 + 52);\n    } else if (code === 43 || code === 45) {\n      append(62);\n    } else if (code === 47 || code === 95) {\n      append(63);\n    } else if (code === 61) {\n      break;\n    } else {\n      throw new SyntaxError(`Unexpected base64 character ${encoded[i]}`);\n    }\n  }\n  const unpadded = bufi;\n  while (remainder > 0) {\n    append(0);\n  }\n  return VSBuffer.wrap(buffer).slice(0, unpadded);\n}\nconst base64Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst base64UrlSafeAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\nfunction encodeBase64({\n  buffer\n}, padded = true, urlSafe = false) {\n  const dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;\n  let output = '';\n  const remainder = buffer.byteLength % 3;\n  let i = 0;\n  for (; i < buffer.byteLength - remainder; i += 3) {\n    const a = buffer[i + 0];\n    const b = buffer[i + 1];\n    const c = buffer[i + 2];\n    output += dictionary[a >>> 2];\n    output += dictionary[(a << 4 | b >>> 4) & 0b111111];\n    output += dictionary[(b << 2 | c >>> 6) & 0b111111];\n    output += dictionary[c & 0b111111];\n  }\n  if (remainder === 1) {\n    const a = buffer[i + 0];\n    output += dictionary[a >>> 2];\n    output += dictionary[a << 4 & 0b111111];\n    if (padded) {\n      output += '==';\n    }\n  } else if (remainder === 2) {\n    const a = buffer[i + 0];\n    const b = buffer[i + 1];\n    output += dictionary[a >>> 2];\n    output += dictionary[(a << 4 | b >>> 4) & 0b111111];\n    output += dictionary[b << 2 & 0b111111];\n    if (padded) {\n      output += '=';\n    }\n  }\n  return output;\n}\nexport { VSBuffer, binaryIndexOf, bufferToReadable, bufferToStream, bufferedStreamToBuffer, decodeBase64, encodeBase64, newWriteableBufferStream, prefixedBufferReadable, prefixedBufferStream, readUInt16LE, readUInt32BE, readUInt32LE, readUInt8, readableToBuffer, streamToBuffer, writeUInt16LE, writeUInt32BE, writeUInt32LE, writeUInt8 };","map":{"version":3,"names":["Lazy","consumeReadable","toReadable","consumeStream","toStream","prefixedStream","newWriteableStream","prefixedReadable","hasBuffer","Buffer","indexOfTable","Uint8Array","textEncoder","textDecoder","VSBuffer","alloc","byteLength","allocUnsafe","wrap","actual","isBuffer","from","buffer","byteOffset","fromString","source","options","dontUseNodeBuffer","TextEncoder","encode","fromByteArray","result","length","i","len","concat","buffers","totalLength","ret","offset","element","set","constructor","clone","toString","TextDecoder","decode","slice","start","end","subarray","array","ArrayBuffer","isView","Error","readUInt32BE","writeUInt32BE","value","readUInt32LE","writeUInt32LE","readUInt8","writeUInt8","indexOf","binaryIndexOf","haystack","needle","needleLen","haystackLen","table","fill","j","Math","max","readUInt16LE","writeUInt16LE","destination","readableToBuffer","readable","chunks","bufferToReadable","streamToBuffer","stream","bufferedStreamToBuffer","bufferedStream","ended","bufferToStream","newWriteableBufferStream","prefixedBufferReadable","prefix","prefixedBufferStream","decodeBase64","encoded","building","remainder","bufi","floor","append","code","charCodeAt","SyntaxError","unpadded","base64Alphabet","base64UrlSafeAlphabet","encodeBase64","padded","urlSafe","dictionary","output","a","b","c"],"sources":["/Users/phamtu/Downloads/Code/OCE/oce-frontend/node_modules/vscode/vscode/src/vs/base/common/buffer.js"],"sourcesContent":["import { Lazy } from './lazy.js';\nimport { consumeReadable, toReadable, consumeStream, toStream, prefixedStream, newWriteableStream, prefixedReadable } from './stream.js';\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst indexOfTable = ( new Lazy(() => ( new Uint8Array(256))));\nlet textEncoder;\nlet textDecoder;\nclass VSBuffer {\n    static alloc(byteLength) {\n        if (hasBuffer) {\n            return ( new VSBuffer(Buffer.allocUnsafe(byteLength)));\n        }\n        else {\n            return ( new VSBuffer(( new Uint8Array(byteLength))));\n        }\n    }\n    static wrap(actual) {\n        if (hasBuffer && !(Buffer.isBuffer(actual))) {\n            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n        }\n        return ( new VSBuffer(actual));\n    }\n    static fromString(source, options) {\n        const dontUseNodeBuffer = options?.dontUseNodeBuffer || false;\n        if (!dontUseNodeBuffer && hasBuffer) {\n            return ( new VSBuffer(Buffer.from(source)));\n        }\n        else {\n            if (!textEncoder) {\n                textEncoder = ( new TextEncoder());\n            }\n            return ( new VSBuffer(textEncoder.encode(source)));\n        }\n    }\n    static fromByteArray(source) {\n        const result = VSBuffer.alloc(source.length);\n        for (let i = 0, len = source.length; i < len; i++) {\n            result.buffer[i] = source[i];\n        }\n        return result;\n    }\n    static concat(buffers, totalLength) {\n        if (typeof totalLength === 'undefined') {\n            totalLength = 0;\n            for (let i = 0, len = buffers.length; i < len; i++) {\n                totalLength += buffers[i].byteLength;\n            }\n        }\n        const ret = VSBuffer.alloc(totalLength);\n        let offset = 0;\n        for (let i = 0, len = buffers.length; i < len; i++) {\n            const element = buffers[i];\n            ret.set(element, offset);\n            offset += element.byteLength;\n        }\n        return ret;\n    }\n    constructor(buffer) {\n        this.buffer = buffer;\n        this.byteLength = this.buffer.byteLength;\n    }\n    clone() {\n        const result = VSBuffer.alloc(this.byteLength);\n        result.set(this);\n        return result;\n    }\n    toString() {\n        if (hasBuffer) {\n            return ( this.buffer.toString());\n        }\n        else {\n            if (!textDecoder) {\n                textDecoder = ( new TextDecoder());\n            }\n            return textDecoder.decode(this.buffer);\n        }\n    }\n    slice(start, end) {\n        return ( new VSBuffer(this.buffer.subarray(start, end)));\n    }\n    set(array, offset) {\n        if (array instanceof VSBuffer) {\n            this.buffer.set(array.buffer, offset);\n        }\n        else if (array instanceof Uint8Array) {\n            this.buffer.set(array, offset);\n        }\n        else if (array instanceof ArrayBuffer) {\n            this.buffer.set(( new Uint8Array(array)), offset);\n        }\n        else if (ArrayBuffer.isView(array)) {\n            this.buffer.set(( new Uint8Array(array.buffer, array.byteOffset, array.byteLength)), offset);\n        }\n        else {\n            throw ( new Error(`Unknown argument 'array'`));\n        }\n    }\n    readUInt32BE(offset) {\n        return readUInt32BE(this.buffer, offset);\n    }\n    writeUInt32BE(value, offset) {\n        writeUInt32BE(this.buffer, value, offset);\n    }\n    readUInt32LE(offset) {\n        return readUInt32LE(this.buffer, offset);\n    }\n    writeUInt32LE(value, offset) {\n        writeUInt32LE(this.buffer, value, offset);\n    }\n    readUInt8(offset) {\n        return readUInt8(this.buffer, offset);\n    }\n    writeUInt8(value, offset) {\n        writeUInt8(this.buffer, value, offset);\n    }\n    indexOf(subarray, offset = 0) {\n        return binaryIndexOf(this.buffer, subarray instanceof VSBuffer ? subarray.buffer : subarray, offset);\n    }\n}\nfunction binaryIndexOf(haystack, needle, offset = 0) {\n    const needleLen = needle.byteLength;\n    const haystackLen = haystack.byteLength;\n    if (needleLen === 0) {\n        return 0;\n    }\n    if (needleLen === 1) {\n        return haystack.indexOf(needle[0]);\n    }\n    if (needleLen > haystackLen - offset) {\n        return -1;\n    }\n    const table = indexOfTable.value;\n    table.fill(needle.length);\n    for (let i = 0; i < needle.length; i++) {\n        table[needle[i]] = needle.length - i - 1;\n    }\n    let i = offset + needle.length - 1;\n    let j = i;\n    let result = -1;\n    while (i < haystackLen) {\n        if (haystack[i] === needle[j]) {\n            if (j === 0) {\n                result = i;\n                break;\n            }\n            i--;\n            j--;\n        }\n        else {\n            i += Math.max(needle.length - j, table[haystack[i]]);\n            j = needle.length - 1;\n        }\n    }\n    return result;\n}\nfunction readUInt16LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0));\n}\nfunction writeUInt16LE(destination, value, offset) {\n    destination[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 1] = (value & 0b11111111);\n}\nfunction readUInt32BE(source, offset) {\n    return (source[offset] * 2 ** 24\n        + source[offset + 1] * 2 ** 16\n        + source[offset + 2] * 2 ** 8\n        + source[offset + 3]);\n}\nfunction writeUInt32BE(destination, value, offset) {\n    destination[offset + 3] = value;\n    value = value >>> 8;\n    destination[offset + 2] = value;\n    value = value >>> 8;\n    destination[offset + 1] = value;\n    value = value >>> 8;\n    destination[offset] = value;\n}\nfunction readUInt32LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0) |\n        ((source[offset + 2] << 16) >>> 0) |\n        ((source[offset + 3] << 24) >>> 0));\n}\nfunction writeUInt32LE(destination, value, offset) {\n    destination[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 1] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 2] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 3] = (value & 0b11111111);\n}\nfunction readUInt8(source, offset) {\n    return source[offset];\n}\nfunction writeUInt8(destination, value, offset) {\n    destination[offset] = value;\n}\nfunction readableToBuffer(readable) {\n    return consumeReadable(readable, chunks => VSBuffer.concat(chunks));\n}\nfunction bufferToReadable(buffer) {\n    return toReadable(buffer);\n}\nfunction streamToBuffer(stream) {\n    return consumeStream(stream, chunks => VSBuffer.concat(chunks));\n}\nasync function bufferedStreamToBuffer(bufferedStream) {\n    if (bufferedStream.ended) {\n        return VSBuffer.concat(bufferedStream.buffer);\n    }\n    return VSBuffer.concat([\n        ...bufferedStream.buffer,\n        await streamToBuffer(bufferedStream.stream)\n    ]);\n}\nfunction bufferToStream(buffer) {\n    return toStream(buffer, chunks => VSBuffer.concat(chunks));\n}\nfunction newWriteableBufferStream(options) {\n    return newWriteableStream(chunks => VSBuffer.concat(chunks), options);\n}\nfunction prefixedBufferReadable(prefix, readable) {\n    return prefixedReadable(prefix, readable, chunks => VSBuffer.concat(chunks));\n}\nfunction prefixedBufferStream(prefix, stream) {\n    return prefixedStream(prefix, stream, chunks => VSBuffer.concat(chunks));\n}\nfunction decodeBase64(encoded) {\n    let building = 0;\n    let remainder = 0;\n    let bufi = 0;\n    const buffer = ( new Uint8Array(Math.floor(encoded.length / 4 * 3)));\n    const append = (value) => {\n        switch (remainder) {\n            case 3:\n                buffer[bufi++] = building | value;\n                remainder = 0;\n                break;\n            case 2:\n                buffer[bufi++] = building | (value >>> 2);\n                building = value << 6;\n                remainder = 3;\n                break;\n            case 1:\n                buffer[bufi++] = building | (value >>> 4);\n                building = value << 4;\n                remainder = 2;\n                break;\n            default:\n                building = value << 2;\n                remainder = 1;\n        }\n    };\n    for (let i = 0; i < encoded.length; i++) {\n        const code = encoded.charCodeAt(i);\n        if (code >= 65 && code <= 90) {\n            append(code - 65);\n        }\n        else if (code >= 97 && code <= 122) {\n            append(code - 97 + 26);\n        }\n        else if (code >= 48 && code <= 57) {\n            append(code - 48 + 52);\n        }\n        else if (code === 43 || code === 45) {\n            append(62);\n        }\n        else if (code === 47 || code === 95) {\n            append(63);\n        }\n        else if (code === 61) {\n            break;\n        }\n        else {\n            throw ( new SyntaxError(`Unexpected base64 character ${encoded[i]}`));\n        }\n    }\n    const unpadded = bufi;\n    while (remainder > 0) {\n        append(0);\n    }\n    return VSBuffer.wrap(buffer).slice(0, unpadded);\n}\nconst base64Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst base64UrlSafeAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\nfunction encodeBase64({ buffer }, padded = true, urlSafe = false) {\n    const dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;\n    let output = '';\n    const remainder = buffer.byteLength % 3;\n    let i = 0;\n    for (; i < buffer.byteLength - remainder; i += 3) {\n        const a = buffer[i + 0];\n        const b = buffer[i + 1];\n        const c = buffer[i + 2];\n        output += dictionary[a >>> 2];\n        output += dictionary[(a << 4 | b >>> 4) & 0b111111];\n        output += dictionary[(b << 2 | c >>> 6) & 0b111111];\n        output += dictionary[c & 0b111111];\n    }\n    if (remainder === 1) {\n        const a = buffer[i + 0];\n        output += dictionary[a >>> 2];\n        output += dictionary[(a << 4) & 0b111111];\n        if (padded) {\n            output += '==';\n        }\n    }\n    else if (remainder === 2) {\n        const a = buffer[i + 0];\n        const b = buffer[i + 1];\n        output += dictionary[a >>> 2];\n        output += dictionary[(a << 4 | b >>> 4) & 0b111111];\n        output += dictionary[(b << 2) & 0b111111];\n        if (padded) {\n            output += '=';\n        }\n    }\n    return output;\n}\nexport { VSBuffer, binaryIndexOf, bufferToReadable, bufferToStream, bufferedStreamToBuffer, decodeBase64, encodeBase64, newWriteableBufferStream, prefixedBufferReadable, prefixedBufferStream, readUInt16LE, readUInt32BE, readUInt32LE, readUInt8, readableToBuffer, streamToBuffer, writeUInt16LE, writeUInt32BE, writeUInt32LE, writeUInt8 };\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,WAAW;AAChC,SAASC,eAAe,EAAEC,UAAU,EAAEC,aAAa,EAAEC,QAAQ,EAAEC,cAAc,EAAEC,kBAAkB,EAAEC,gBAAgB,QAAQ,aAAa;AACxI,MAAMC,SAAS,GAAI,OAAOC,MAAM,KAAK,WAAY;AACjD,MAAMC,YAAY,GAAK,IAAIV,IAAI,CAAC,MAAQ,IAAIW,UAAU,CAAC,GAAG,CAAE,CAAE;AAC9D,IAAIC,WAAW;AACf,IAAIC,WAAW;AACf,MAAMC,QAAQ,CAAC;EACX,OAAOC,KAAKA,CAACC,UAAU,EAAE;IACrB,IAAIR,SAAS,EAAE;MACX,OAAS,IAAIM,QAAQ,CAACL,MAAM,CAACQ,WAAW,CAACD,UAAU,CAAC,CAAC;IACzD,CAAC,MACI;MACD,OAAS,IAAIF,QAAQ,CAAG,IAAIH,UAAU,CAACK,UAAU,CAAE,CAAC;IACxD;EACJ;EACA,OAAOE,IAAIA,CAACC,MAAM,EAAE;IAChB,IAAIX,SAAS,IAAI,CAAEC,MAAM,CAACW,QAAQ,CAACD,MAAM,CAAE,EAAE;MACzCA,MAAM,GAAGV,MAAM,CAACY,IAAI,CAACF,MAAM,CAACG,MAAM,EAAEH,MAAM,CAACI,UAAU,EAAEJ,MAAM,CAACH,UAAU,CAAC;IAC7E;IACA,OAAS,IAAIF,QAAQ,CAACK,MAAM,CAAC;EACjC;EACA,OAAOK,UAAUA,CAACC,MAAM,EAAEC,OAAO,EAAE;IAC/B,MAAMC,iBAAiB,GAAGD,OAAO,EAAEC,iBAAiB,IAAI,KAAK;IAC7D,IAAI,CAACA,iBAAiB,IAAInB,SAAS,EAAE;MACjC,OAAS,IAAIM,QAAQ,CAACL,MAAM,CAACY,IAAI,CAACI,MAAM,CAAC,CAAC;IAC9C,CAAC,MACI;MACD,IAAI,CAACb,WAAW,EAAE;QACdA,WAAW,GAAK,IAAIgB,WAAW,CAAC,CAAE;MACtC;MACA,OAAS,IAAId,QAAQ,CAACF,WAAW,CAACiB,MAAM,CAACJ,MAAM,CAAC,CAAC;IACrD;EACJ;EACA,OAAOK,aAAaA,CAACL,MAAM,EAAE;IACzB,MAAMM,MAAM,GAAGjB,QAAQ,CAACC,KAAK,CAACU,MAAM,CAACO,MAAM,CAAC;IAC5C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGT,MAAM,CAACO,MAAM,EAAEC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAC/CF,MAAM,CAACT,MAAM,CAACW,CAAC,CAAC,GAAGR,MAAM,CAACQ,CAAC,CAAC;IAChC;IACA,OAAOF,MAAM;EACjB;EACA,OAAOI,MAAMA,CAACC,OAAO,EAAEC,WAAW,EAAE;IAChC,IAAI,OAAOA,WAAW,KAAK,WAAW,EAAE;MACpCA,WAAW,GAAG,CAAC;MACf,KAAK,IAAIJ,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGE,OAAO,CAACJ,MAAM,EAAEC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QAChDI,WAAW,IAAID,OAAO,CAACH,CAAC,CAAC,CAACjB,UAAU;MACxC;IACJ;IACA,MAAMsB,GAAG,GAAGxB,QAAQ,CAACC,KAAK,CAACsB,WAAW,CAAC;IACvC,IAAIE,MAAM,GAAG,CAAC;IACd,KAAK,IAAIN,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGE,OAAO,CAACJ,MAAM,EAAEC,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAChD,MAAMO,OAAO,GAAGJ,OAAO,CAACH,CAAC,CAAC;MAC1BK,GAAG,CAACG,GAAG,CAACD,OAAO,EAAED,MAAM,CAAC;MACxBA,MAAM,IAAIC,OAAO,CAACxB,UAAU;IAChC;IACA,OAAOsB,GAAG;EACd;EACAI,WAAWA,CAACpB,MAAM,EAAE;IAChB,IAAI,CAACA,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACN,UAAU,GAAG,IAAI,CAACM,MAAM,CAACN,UAAU;EAC5C;EACA2B,KAAKA,CAAA,EAAG;IACJ,MAAMZ,MAAM,GAAGjB,QAAQ,CAACC,KAAK,CAAC,IAAI,CAACC,UAAU,CAAC;IAC9Ce,MAAM,CAACU,GAAG,CAAC,IAAI,CAAC;IAChB,OAAOV,MAAM;EACjB;EACAa,QAAQA,CAAA,EAAG;IACP,IAAIpC,SAAS,EAAE;MACX,OAAS,IAAI,CAACc,MAAM,CAACsB,QAAQ,CAAC,CAAC;IACnC,CAAC,MACI;MACD,IAAI,CAAC/B,WAAW,EAAE;QACdA,WAAW,GAAK,IAAIgC,WAAW,CAAC,CAAE;MACtC;MACA,OAAOhC,WAAW,CAACiC,MAAM,CAAC,IAAI,CAACxB,MAAM,CAAC;IAC1C;EACJ;EACAyB,KAAKA,CAACC,KAAK,EAAEC,GAAG,EAAE;IACd,OAAS,IAAInC,QAAQ,CAAC,IAAI,CAACQ,MAAM,CAAC4B,QAAQ,CAACF,KAAK,EAAEC,GAAG,CAAC,CAAC;EAC3D;EACAR,GAAGA,CAACU,KAAK,EAAEZ,MAAM,EAAE;IACf,IAAIY,KAAK,YAAYrC,QAAQ,EAAE;MAC3B,IAAI,CAACQ,MAAM,CAACmB,GAAG,CAACU,KAAK,CAAC7B,MAAM,EAAEiB,MAAM,CAAC;IACzC,CAAC,MACI,IAAIY,KAAK,YAAYxC,UAAU,EAAE;MAClC,IAAI,CAACW,MAAM,CAACmB,GAAG,CAACU,KAAK,EAAEZ,MAAM,CAAC;IAClC,CAAC,MACI,IAAIY,KAAK,YAAYC,WAAW,EAAE;MACnC,IAAI,CAAC9B,MAAM,CAACmB,GAAG,CAAG,IAAI9B,UAAU,CAACwC,KAAK,CAAC,EAAGZ,MAAM,CAAC;IACrD,CAAC,MACI,IAAIa,WAAW,CAACC,MAAM,CAACF,KAAK,CAAC,EAAE;MAChC,IAAI,CAAC7B,MAAM,CAACmB,GAAG,CAAG,IAAI9B,UAAU,CAACwC,KAAK,CAAC7B,MAAM,EAAE6B,KAAK,CAAC5B,UAAU,EAAE4B,KAAK,CAACnC,UAAU,CAAC,EAAGuB,MAAM,CAAC;IAChG,CAAC,MACI;MACD,MAAQ,IAAIe,KAAK,CAAE,0BAAyB,CAAC;IACjD;EACJ;EACAC,YAAYA,CAAChB,MAAM,EAAE;IACjB,OAAOgB,YAAY,CAAC,IAAI,CAACjC,MAAM,EAAEiB,MAAM,CAAC;EAC5C;EACAiB,aAAaA,CAACC,KAAK,EAAElB,MAAM,EAAE;IACzBiB,aAAa,CAAC,IAAI,CAAClC,MAAM,EAAEmC,KAAK,EAAElB,MAAM,CAAC;EAC7C;EACAmB,YAAYA,CAACnB,MAAM,EAAE;IACjB,OAAOmB,YAAY,CAAC,IAAI,CAACpC,MAAM,EAAEiB,MAAM,CAAC;EAC5C;EACAoB,aAAaA,CAACF,KAAK,EAAElB,MAAM,EAAE;IACzBoB,aAAa,CAAC,IAAI,CAACrC,MAAM,EAAEmC,KAAK,EAAElB,MAAM,CAAC;EAC7C;EACAqB,SAASA,CAACrB,MAAM,EAAE;IACd,OAAOqB,SAAS,CAAC,IAAI,CAACtC,MAAM,EAAEiB,MAAM,CAAC;EACzC;EACAsB,UAAUA,CAACJ,KAAK,EAAElB,MAAM,EAAE;IACtBsB,UAAU,CAAC,IAAI,CAACvC,MAAM,EAAEmC,KAAK,EAAElB,MAAM,CAAC;EAC1C;EACAuB,OAAOA,CAACZ,QAAQ,EAAEX,MAAM,GAAG,CAAC,EAAE;IAC1B,OAAOwB,aAAa,CAAC,IAAI,CAACzC,MAAM,EAAE4B,QAAQ,YAAYpC,QAAQ,GAAGoC,QAAQ,CAAC5B,MAAM,GAAG4B,QAAQ,EAAEX,MAAM,CAAC;EACxG;AACJ;AACA,SAASwB,aAAaA,CAACC,QAAQ,EAAEC,MAAM,EAAE1B,MAAM,GAAG,CAAC,EAAE;EACjD,MAAM2B,SAAS,GAAGD,MAAM,CAACjD,UAAU;EACnC,MAAMmD,WAAW,GAAGH,QAAQ,CAAChD,UAAU;EACvC,IAAIkD,SAAS,KAAK,CAAC,EAAE;IACjB,OAAO,CAAC;EACZ;EACA,IAAIA,SAAS,KAAK,CAAC,EAAE;IACjB,OAAOF,QAAQ,CAACF,OAAO,CAACG,MAAM,CAAC,CAAC,CAAC,CAAC;EACtC;EACA,IAAIC,SAAS,GAAGC,WAAW,GAAG5B,MAAM,EAAE;IAClC,OAAO,CAAC,CAAC;EACb;EACA,MAAM6B,KAAK,GAAG1D,YAAY,CAAC+C,KAAK;EAChCW,KAAK,CAACC,IAAI,CAACJ,MAAM,CAACjC,MAAM,CAAC;EACzB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgC,MAAM,CAACjC,MAAM,EAAEC,CAAC,EAAE,EAAE;IACpCmC,KAAK,CAACH,MAAM,CAAChC,CAAC,CAAC,CAAC,GAAGgC,MAAM,CAACjC,MAAM,GAAGC,CAAC,GAAG,CAAC;EAC5C;EACA,IAAIA,CAAC,GAAGM,MAAM,GAAG0B,MAAM,CAACjC,MAAM,GAAG,CAAC;EAClC,IAAIsC,CAAC,GAAGrC,CAAC;EACT,IAAIF,MAAM,GAAG,CAAC,CAAC;EACf,OAAOE,CAAC,GAAGkC,WAAW,EAAE;IACpB,IAAIH,QAAQ,CAAC/B,CAAC,CAAC,KAAKgC,MAAM,CAACK,CAAC,CAAC,EAAE;MAC3B,IAAIA,CAAC,KAAK,CAAC,EAAE;QACTvC,MAAM,GAAGE,CAAC;QACV;MACJ;MACAA,CAAC,EAAE;MACHqC,CAAC,EAAE;IACP,CAAC,MACI;MACDrC,CAAC,IAAIsC,IAAI,CAACC,GAAG,CAACP,MAAM,CAACjC,MAAM,GAAGsC,CAAC,EAAEF,KAAK,CAACJ,QAAQ,CAAC/B,CAAC,CAAC,CAAC,CAAC;MACpDqC,CAAC,GAAGL,MAAM,CAACjC,MAAM,GAAG,CAAC;IACzB;EACJ;EACA,OAAOD,MAAM;AACjB;AACA,SAAS0C,YAAYA,CAAChD,MAAM,EAAEc,MAAM,EAAE;EAClC,OAAUd,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,KAAM,CAAC,GAClCd,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,KAAM,CAAE;AACzC;AACA,SAASmC,aAAaA,CAACC,WAAW,EAAElB,KAAK,EAAElB,MAAM,EAAE;EAC/CoC,WAAW,CAACpC,MAAM,GAAG,CAAC,CAAC,GAAIkB,KAAK,GAAG,UAAW;EAC9CA,KAAK,GAAGA,KAAK,KAAK,CAAC;EACnBkB,WAAW,CAACpC,MAAM,GAAG,CAAC,CAAC,GAAIkB,KAAK,GAAG,UAAW;AAClD;AACA,SAASF,YAAYA,CAAC9B,MAAM,EAAEc,MAAM,EAAE;EAClC,OAAQd,MAAM,CAACc,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,GAC1Bd,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,EAAE,GAC5Bd,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,GAC3Bd,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC;AAC5B;AACA,SAASiB,aAAaA,CAACmB,WAAW,EAAElB,KAAK,EAAElB,MAAM,EAAE;EAC/CoC,WAAW,CAACpC,MAAM,GAAG,CAAC,CAAC,GAAGkB,KAAK;EAC/BA,KAAK,GAAGA,KAAK,KAAK,CAAC;EACnBkB,WAAW,CAACpC,MAAM,GAAG,CAAC,CAAC,GAAGkB,KAAK;EAC/BA,KAAK,GAAGA,KAAK,KAAK,CAAC;EACnBkB,WAAW,CAACpC,MAAM,GAAG,CAAC,CAAC,GAAGkB,KAAK;EAC/BA,KAAK,GAAGA,KAAK,KAAK,CAAC;EACnBkB,WAAW,CAACpC,MAAM,CAAC,GAAGkB,KAAK;AAC/B;AACA,SAASC,YAAYA,CAACjC,MAAM,EAAEc,MAAM,EAAE;EAClC,OAAUd,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,KAAM,CAAC,GAClCd,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,KAAM,CAAE,GAC/Bd,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,IAAI,EAAE,KAAM,CAAE,GAChCd,MAAM,CAACc,MAAM,GAAG,CAAC,CAAC,IAAI,EAAE,KAAM,CAAE;AAC1C;AACA,SAASoB,aAAaA,CAACgB,WAAW,EAAElB,KAAK,EAAElB,MAAM,EAAE;EAC/CoC,WAAW,CAACpC,MAAM,GAAG,CAAC,CAAC,GAAIkB,KAAK,GAAG,UAAW;EAC9CA,KAAK,GAAGA,KAAK,KAAK,CAAC;EACnBkB,WAAW,CAACpC,MAAM,GAAG,CAAC,CAAC,GAAIkB,KAAK,GAAG,UAAW;EAC9CA,KAAK,GAAGA,KAAK,KAAK,CAAC;EACnBkB,WAAW,CAACpC,MAAM,GAAG,CAAC,CAAC,GAAIkB,KAAK,GAAG,UAAW;EAC9CA,KAAK,GAAGA,KAAK,KAAK,CAAC;EACnBkB,WAAW,CAACpC,MAAM,GAAG,CAAC,CAAC,GAAIkB,KAAK,GAAG,UAAW;AAClD;AACA,SAASG,SAASA,CAACnC,MAAM,EAAEc,MAAM,EAAE;EAC/B,OAAOd,MAAM,CAACc,MAAM,CAAC;AACzB;AACA,SAASsB,UAAUA,CAACc,WAAW,EAAElB,KAAK,EAAElB,MAAM,EAAE;EAC5CoC,WAAW,CAACpC,MAAM,CAAC,GAAGkB,KAAK;AAC/B;AACA,SAASmB,gBAAgBA,CAACC,QAAQ,EAAE;EAChC,OAAO5E,eAAe,CAAC4E,QAAQ,EAAEC,MAAM,IAAIhE,QAAQ,CAACqB,MAAM,CAAC2C,MAAM,CAAC,CAAC;AACvE;AACA,SAASC,gBAAgBA,CAACzD,MAAM,EAAE;EAC9B,OAAOpB,UAAU,CAACoB,MAAM,CAAC;AAC7B;AACA,SAAS0D,cAAcA,CAACC,MAAM,EAAE;EAC5B,OAAO9E,aAAa,CAAC8E,MAAM,EAAEH,MAAM,IAAIhE,QAAQ,CAACqB,MAAM,CAAC2C,MAAM,CAAC,CAAC;AACnE;AACA,eAAeI,sBAAsBA,CAACC,cAAc,EAAE;EAClD,IAAIA,cAAc,CAACC,KAAK,EAAE;IACtB,OAAOtE,QAAQ,CAACqB,MAAM,CAACgD,cAAc,CAAC7D,MAAM,CAAC;EACjD;EACA,OAAOR,QAAQ,CAACqB,MAAM,CAAC,CACnB,GAAGgD,cAAc,CAAC7D,MAAM,EACxB,MAAM0D,cAAc,CAACG,cAAc,CAACF,MAAM,CAAC,CAC9C,CAAC;AACN;AACA,SAASI,cAAcA,CAAC/D,MAAM,EAAE;EAC5B,OAAOlB,QAAQ,CAACkB,MAAM,EAAEwD,MAAM,IAAIhE,QAAQ,CAACqB,MAAM,CAAC2C,MAAM,CAAC,CAAC;AAC9D;AACA,SAASQ,wBAAwBA,CAAC5D,OAAO,EAAE;EACvC,OAAOpB,kBAAkB,CAACwE,MAAM,IAAIhE,QAAQ,CAACqB,MAAM,CAAC2C,MAAM,CAAC,EAAEpD,OAAO,CAAC;AACzE;AACA,SAAS6D,sBAAsBA,CAACC,MAAM,EAAEX,QAAQ,EAAE;EAC9C,OAAOtE,gBAAgB,CAACiF,MAAM,EAAEX,QAAQ,EAAEC,MAAM,IAAIhE,QAAQ,CAACqB,MAAM,CAAC2C,MAAM,CAAC,CAAC;AAChF;AACA,SAASW,oBAAoBA,CAACD,MAAM,EAAEP,MAAM,EAAE;EAC1C,OAAO5E,cAAc,CAACmF,MAAM,EAAEP,MAAM,EAAEH,MAAM,IAAIhE,QAAQ,CAACqB,MAAM,CAAC2C,MAAM,CAAC,CAAC;AAC5E;AACA,SAASY,YAAYA,CAACC,OAAO,EAAE;EAC3B,IAAIC,QAAQ,GAAG,CAAC;EAChB,IAAIC,SAAS,GAAG,CAAC;EACjB,IAAIC,IAAI,GAAG,CAAC;EACZ,MAAMxE,MAAM,GAAK,IAAIX,UAAU,CAAC4D,IAAI,CAACwB,KAAK,CAACJ,OAAO,CAAC3D,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC,CAAE;EACpE,MAAMgE,MAAM,GAAIvC,KAAK,IAAK;IACtB,QAAQoC,SAAS;MACb,KAAK,CAAC;QACFvE,MAAM,CAACwE,IAAI,EAAE,CAAC,GAAGF,QAAQ,GAAGnC,KAAK;QACjCoC,SAAS,GAAG,CAAC;QACb;MACJ,KAAK,CAAC;QACFvE,MAAM,CAACwE,IAAI,EAAE,CAAC,GAAGF,QAAQ,GAAInC,KAAK,KAAK,CAAE;QACzCmC,QAAQ,GAAGnC,KAAK,IAAI,CAAC;QACrBoC,SAAS,GAAG,CAAC;QACb;MACJ,KAAK,CAAC;QACFvE,MAAM,CAACwE,IAAI,EAAE,CAAC,GAAGF,QAAQ,GAAInC,KAAK,KAAK,CAAE;QACzCmC,QAAQ,GAAGnC,KAAK,IAAI,CAAC;QACrBoC,SAAS,GAAG,CAAC;QACb;MACJ;QACID,QAAQ,GAAGnC,KAAK,IAAI,CAAC;QACrBoC,SAAS,GAAG,CAAC;IACrB;EACJ,CAAC;EACD,KAAK,IAAI5D,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0D,OAAO,CAAC3D,MAAM,EAAEC,CAAC,EAAE,EAAE;IACrC,MAAMgE,IAAI,GAAGN,OAAO,CAACO,UAAU,CAACjE,CAAC,CAAC;IAClC,IAAIgE,IAAI,IAAI,EAAE,IAAIA,IAAI,IAAI,EAAE,EAAE;MAC1BD,MAAM,CAACC,IAAI,GAAG,EAAE,CAAC;IACrB,CAAC,MACI,IAAIA,IAAI,IAAI,EAAE,IAAIA,IAAI,IAAI,GAAG,EAAE;MAChCD,MAAM,CAACC,IAAI,GAAG,EAAE,GAAG,EAAE,CAAC;IAC1B,CAAC,MACI,IAAIA,IAAI,IAAI,EAAE,IAAIA,IAAI,IAAI,EAAE,EAAE;MAC/BD,MAAM,CAACC,IAAI,GAAG,EAAE,GAAG,EAAE,CAAC;IAC1B,CAAC,MACI,IAAIA,IAAI,KAAK,EAAE,IAAIA,IAAI,KAAK,EAAE,EAAE;MACjCD,MAAM,CAAC,EAAE,CAAC;IACd,CAAC,MACI,IAAIC,IAAI,KAAK,EAAE,IAAIA,IAAI,KAAK,EAAE,EAAE;MACjCD,MAAM,CAAC,EAAE,CAAC;IACd,CAAC,MACI,IAAIC,IAAI,KAAK,EAAE,EAAE;MAClB;IACJ,CAAC,MACI;MACD,MAAQ,IAAIE,WAAW,CAAE,+BAA8BR,OAAO,CAAC1D,CAAC,CAAE,EAAC,CAAC;IACxE;EACJ;EACA,MAAMmE,QAAQ,GAAGN,IAAI;EACrB,OAAOD,SAAS,GAAG,CAAC,EAAE;IAClBG,MAAM,CAAC,CAAC,CAAC;EACb;EACA,OAAOlF,QAAQ,CAACI,IAAI,CAACI,MAAM,CAAC,CAACyB,KAAK,CAAC,CAAC,EAAEqD,QAAQ,CAAC;AACnD;AACA,MAAMC,cAAc,GAAG,kEAAkE;AACzF,MAAMC,qBAAqB,GAAG,kEAAkE;AAChG,SAASC,YAAYA,CAAC;EAAEjF;AAAO,CAAC,EAAEkF,MAAM,GAAG,IAAI,EAAEC,OAAO,GAAG,KAAK,EAAE;EAC9D,MAAMC,UAAU,GAAGD,OAAO,GAAGH,qBAAqB,GAAGD,cAAc;EACnE,IAAIM,MAAM,GAAG,EAAE;EACf,MAAMd,SAAS,GAAGvE,MAAM,CAACN,UAAU,GAAG,CAAC;EACvC,IAAIiB,CAAC,GAAG,CAAC;EACT,OAAOA,CAAC,GAAGX,MAAM,CAACN,UAAU,GAAG6E,SAAS,EAAE5D,CAAC,IAAI,CAAC,EAAE;IAC9C,MAAM2E,CAAC,GAAGtF,MAAM,CAACW,CAAC,GAAG,CAAC,CAAC;IACvB,MAAM4E,CAAC,GAAGvF,MAAM,CAACW,CAAC,GAAG,CAAC,CAAC;IACvB,MAAM6E,CAAC,GAAGxF,MAAM,CAACW,CAAC,GAAG,CAAC,CAAC;IACvB0E,MAAM,IAAID,UAAU,CAACE,CAAC,KAAK,CAAC,CAAC;IAC7BD,MAAM,IAAID,UAAU,CAAC,CAACE,CAAC,IAAI,CAAC,GAAGC,CAAC,KAAK,CAAC,IAAI,QAAQ,CAAC;IACnDF,MAAM,IAAID,UAAU,CAAC,CAACG,CAAC,IAAI,CAAC,GAAGC,CAAC,KAAK,CAAC,IAAI,QAAQ,CAAC;IACnDH,MAAM,IAAID,UAAU,CAACI,CAAC,GAAG,QAAQ,CAAC;EACtC;EACA,IAAIjB,SAAS,KAAK,CAAC,EAAE;IACjB,MAAMe,CAAC,GAAGtF,MAAM,CAACW,CAAC,GAAG,CAAC,CAAC;IACvB0E,MAAM,IAAID,UAAU,CAACE,CAAC,KAAK,CAAC,CAAC;IAC7BD,MAAM,IAAID,UAAU,CAAEE,CAAC,IAAI,CAAC,GAAI,QAAQ,CAAC;IACzC,IAAIJ,MAAM,EAAE;MACRG,MAAM,IAAI,IAAI;IAClB;EACJ,CAAC,MACI,IAAId,SAAS,KAAK,CAAC,EAAE;IACtB,MAAMe,CAAC,GAAGtF,MAAM,CAACW,CAAC,GAAG,CAAC,CAAC;IACvB,MAAM4E,CAAC,GAAGvF,MAAM,CAACW,CAAC,GAAG,CAAC,CAAC;IACvB0E,MAAM,IAAID,UAAU,CAACE,CAAC,KAAK,CAAC,CAAC;IAC7BD,MAAM,IAAID,UAAU,CAAC,CAACE,CAAC,IAAI,CAAC,GAAGC,CAAC,KAAK,CAAC,IAAI,QAAQ,CAAC;IACnDF,MAAM,IAAID,UAAU,CAAEG,CAAC,IAAI,CAAC,GAAI,QAAQ,CAAC;IACzC,IAAIL,MAAM,EAAE;MACRG,MAAM,IAAI,GAAG;IACjB;EACJ;EACA,OAAOA,MAAM;AACjB;AACA,SAAS7F,QAAQ,EAAEiD,aAAa,EAAEgB,gBAAgB,EAAEM,cAAc,EAAEH,sBAAsB,EAAEQ,YAAY,EAAEa,YAAY,EAAEjB,wBAAwB,EAAEC,sBAAsB,EAAEE,oBAAoB,EAAEhB,YAAY,EAAElB,YAAY,EAAEG,YAAY,EAAEE,SAAS,EAAEgB,gBAAgB,EAAEI,cAAc,EAAEN,aAAa,EAAElB,aAAa,EAAEG,aAAa,EAAEE,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}