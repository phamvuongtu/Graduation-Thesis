{"ast":null,"code":"\"use strict\";\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractMessageBuffer = void 0;\nconst CR = 13;\nconst LF = 10;\nconst CRLF = '\\r\\n';\nclass AbstractMessageBuffer {\n  constructor(encoding = 'utf-8') {\n    this._encoding = encoding;\n    this._chunks = [];\n    this._totalLength = 0;\n  }\n  get encoding() {\n    return this._encoding;\n  }\n  append(chunk) {\n    const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;\n    this._chunks.push(toAppend);\n    this._totalLength += toAppend.byteLength;\n  }\n  tryReadHeaders(lowerCaseKeys = false) {\n    if (this._chunks.length === 0) {\n      return undefined;\n    }\n    let state = 0;\n    let chunkIndex = 0;\n    let offset = 0;\n    let chunkBytesRead = 0;\n    row: while (chunkIndex < this._chunks.length) {\n      const chunk = this._chunks[chunkIndex];\n      offset = 0;\n      column: while (offset < chunk.length) {\n        const value = chunk[offset];\n        switch (value) {\n          case CR:\n            switch (state) {\n              case 0:\n                state = 1;\n                break;\n              case 2:\n                state = 3;\n                break;\n              default:\n                state = 0;\n            }\n            break;\n          case LF:\n            switch (state) {\n              case 1:\n                state = 2;\n                break;\n              case 3:\n                state = 4;\n                offset++;\n                break row;\n              default:\n                state = 0;\n            }\n            break;\n          default:\n            state = 0;\n        }\n        offset++;\n      }\n      chunkBytesRead += chunk.byteLength;\n      chunkIndex++;\n    }\n    if (state !== 4) {\n      return undefined;\n    }\n    // The buffer contains the two CRLF at the end. So we will\n    // have two empty lines after the split at the end as well.\n    const buffer = this._read(chunkBytesRead + offset);\n    const result = new Map();\n    const headers = this.toString(buffer, 'ascii').split(CRLF);\n    if (headers.length < 2) {\n      return result;\n    }\n    for (let i = 0; i < headers.length - 2; i++) {\n      const header = headers[i];\n      const index = header.indexOf(':');\n      if (index === -1) {\n        throw new Error(`Message header must separate key and value using ':'\\n${header}`);\n      }\n      const key = header.substr(0, index);\n      const value = header.substr(index + 1).trim();\n      result.set(lowerCaseKeys ? key.toLowerCase() : key, value);\n    }\n    return result;\n  }\n  tryReadBody(length) {\n    if (this._totalLength < length) {\n      return undefined;\n    }\n    return this._read(length);\n  }\n  get numberOfBytes() {\n    return this._totalLength;\n  }\n  _read(byteCount) {\n    if (byteCount === 0) {\n      return this.emptyBuffer();\n    }\n    if (byteCount > this._totalLength) {\n      throw new Error(`Cannot read so many bytes!`);\n    }\n    if (this._chunks[0].byteLength === byteCount) {\n      // super fast path, precisely first chunk must be returned\n      const chunk = this._chunks[0];\n      this._chunks.shift();\n      this._totalLength -= byteCount;\n      return this.asNative(chunk);\n    }\n    if (this._chunks[0].byteLength > byteCount) {\n      // fast path, the reading is entirely within the first chunk\n      const chunk = this._chunks[0];\n      const result = this.asNative(chunk, byteCount);\n      this._chunks[0] = chunk.slice(byteCount);\n      this._totalLength -= byteCount;\n      return result;\n    }\n    const result = this.allocNative(byteCount);\n    let resultOffset = 0;\n    let chunkIndex = 0;\n    while (byteCount > 0) {\n      const chunk = this._chunks[chunkIndex];\n      if (chunk.byteLength > byteCount) {\n        // this chunk will survive\n        const chunkPart = chunk.slice(0, byteCount);\n        result.set(chunkPart, resultOffset);\n        resultOffset += byteCount;\n        this._chunks[chunkIndex] = chunk.slice(byteCount);\n        this._totalLength -= byteCount;\n        byteCount -= byteCount;\n      } else {\n        // this chunk will be entirely read\n        result.set(chunk, resultOffset);\n        resultOffset += chunk.byteLength;\n        this._chunks.shift();\n        this._totalLength -= chunk.byteLength;\n        byteCount -= chunk.byteLength;\n      }\n    }\n    return result;\n  }\n}\nexports.AbstractMessageBuffer = AbstractMessageBuffer;","map":{"version":3,"names":["Object","defineProperty","exports","value","AbstractMessageBuffer","CR","LF","CRLF","constructor","encoding","_encoding","_chunks","_totalLength","append","chunk","toAppend","fromString","push","byteLength","tryReadHeaders","lowerCaseKeys","length","undefined","state","chunkIndex","offset","chunkBytesRead","row","column","buffer","_read","result","Map","headers","toString","split","i","header","index","indexOf","Error","key","substr","trim","set","toLowerCase","tryReadBody","numberOfBytes","byteCount","emptyBuffer","shift","asNative","slice","allocNative","resultOffset","chunkPart"],"sources":["/Users/phamtu/Downloads/Code/OCE/oce-frontend/node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"],"sourcesContent":["\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbstractMessageBuffer = void 0;\nconst CR = 13;\nconst LF = 10;\nconst CRLF = '\\r\\n';\nclass AbstractMessageBuffer {\n    constructor(encoding = 'utf-8') {\n        this._encoding = encoding;\n        this._chunks = [];\n        this._totalLength = 0;\n    }\n    get encoding() {\n        return this._encoding;\n    }\n    append(chunk) {\n        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;\n        this._chunks.push(toAppend);\n        this._totalLength += toAppend.byteLength;\n    }\n    tryReadHeaders(lowerCaseKeys = false) {\n        if (this._chunks.length === 0) {\n            return undefined;\n        }\n        let state = 0;\n        let chunkIndex = 0;\n        let offset = 0;\n        let chunkBytesRead = 0;\n        row: while (chunkIndex < this._chunks.length) {\n            const chunk = this._chunks[chunkIndex];\n            offset = 0;\n            column: while (offset < chunk.length) {\n                const value = chunk[offset];\n                switch (value) {\n                    case CR:\n                        switch (state) {\n                            case 0:\n                                state = 1;\n                                break;\n                            case 2:\n                                state = 3;\n                                break;\n                            default:\n                                state = 0;\n                        }\n                        break;\n                    case LF:\n                        switch (state) {\n                            case 1:\n                                state = 2;\n                                break;\n                            case 3:\n                                state = 4;\n                                offset++;\n                                break row;\n                            default:\n                                state = 0;\n                        }\n                        break;\n                    default:\n                        state = 0;\n                }\n                offset++;\n            }\n            chunkBytesRead += chunk.byteLength;\n            chunkIndex++;\n        }\n        if (state !== 4) {\n            return undefined;\n        }\n        // The buffer contains the two CRLF at the end. So we will\n        // have two empty lines after the split at the end as well.\n        const buffer = this._read(chunkBytesRead + offset);\n        const result = new Map();\n        const headers = this.toString(buffer, 'ascii').split(CRLF);\n        if (headers.length < 2) {\n            return result;\n        }\n        for (let i = 0; i < headers.length - 2; i++) {\n            const header = headers[i];\n            const index = header.indexOf(':');\n            if (index === -1) {\n                throw new Error(`Message header must separate key and value using ':'\\n${header}`);\n            }\n            const key = header.substr(0, index);\n            const value = header.substr(index + 1).trim();\n            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);\n        }\n        return result;\n    }\n    tryReadBody(length) {\n        if (this._totalLength < length) {\n            return undefined;\n        }\n        return this._read(length);\n    }\n    get numberOfBytes() {\n        return this._totalLength;\n    }\n    _read(byteCount) {\n        if (byteCount === 0) {\n            return this.emptyBuffer();\n        }\n        if (byteCount > this._totalLength) {\n            throw new Error(`Cannot read so many bytes!`);\n        }\n        if (this._chunks[0].byteLength === byteCount) {\n            // super fast path, precisely first chunk must be returned\n            const chunk = this._chunks[0];\n            this._chunks.shift();\n            this._totalLength -= byteCount;\n            return this.asNative(chunk);\n        }\n        if (this._chunks[0].byteLength > byteCount) {\n            // fast path, the reading is entirely within the first chunk\n            const chunk = this._chunks[0];\n            const result = this.asNative(chunk, byteCount);\n            this._chunks[0] = chunk.slice(byteCount);\n            this._totalLength -= byteCount;\n            return result;\n        }\n        const result = this.allocNative(byteCount);\n        let resultOffset = 0;\n        let chunkIndex = 0;\n        while (byteCount > 0) {\n            const chunk = this._chunks[chunkIndex];\n            if (chunk.byteLength > byteCount) {\n                // this chunk will survive\n                const chunkPart = chunk.slice(0, byteCount);\n                result.set(chunkPart, resultOffset);\n                resultOffset += byteCount;\n                this._chunks[chunkIndex] = chunk.slice(byteCount);\n                this._totalLength -= byteCount;\n                byteCount -= byteCount;\n            }\n            else {\n                // this chunk will be entirely read\n                result.set(chunk, resultOffset);\n                resultOffset += chunk.byteLength;\n                this._chunks.shift();\n                this._totalLength -= chunk.byteLength;\n                byteCount -= chunk.byteLength;\n            }\n        }\n        return result;\n    }\n}\nexports.AbstractMessageBuffer = AbstractMessageBuffer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}