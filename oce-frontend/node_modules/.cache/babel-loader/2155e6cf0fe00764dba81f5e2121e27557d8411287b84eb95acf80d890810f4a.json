{"ast":null,"code":"\"use strict\";\n\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NotebookDocumentSyncFeature = void 0;\nconst vscode = require(\"vscode\");\nconst minimatch = require(\"minimatch\");\nconst proto = require(\"vscode-languageserver-protocol\");\nconst UUID = require(\"./utils/uuid\");\nconst Is = require(\"./utils/is\");\nfunction ensure(target, key) {\n  if (target[key] === void 0) {\n    target[key] = {};\n  }\n  return target[key];\n}\nvar Converter;\n(function (Converter) {\n  let c2p;\n  (function (c2p) {\n    function asVersionedNotebookDocumentIdentifier(notebookDocument, base) {\n      return {\n        version: notebookDocument.version,\n        uri: base.asUri(notebookDocument.uri)\n      };\n    }\n    c2p.asVersionedNotebookDocumentIdentifier = asVersionedNotebookDocumentIdentifier;\n    function asNotebookDocument(notebookDocument, cells, base) {\n      const result = proto.NotebookDocument.create(base.asUri(notebookDocument.uri), notebookDocument.notebookType, notebookDocument.version, asNotebookCells(cells, base));\n      if (Object.keys(notebookDocument.metadata).length > 0) {\n        result.metadata = asMetadata(notebookDocument.metadata);\n      }\n      return result;\n    }\n    c2p.asNotebookDocument = asNotebookDocument;\n    function asNotebookCells(cells, base) {\n      return cells.map(cell => asNotebookCell(cell, base));\n    }\n    c2p.asNotebookCells = asNotebookCells;\n    function asMetadata(metadata) {\n      const seen = new Set();\n      return deepCopy(seen, metadata);\n    }\n    c2p.asMetadata = asMetadata;\n    function asNotebookCell(cell, base) {\n      const result = proto.NotebookCell.create(asNotebookCellKind(cell.kind), base.asUri(cell.document.uri));\n      if (Object.keys(cell.metadata).length > 0) {\n        result.metadata = asMetadata(cell.metadata);\n      }\n      if (cell.executionSummary !== undefined && Is.number(cell.executionSummary.executionOrder) && Is.boolean(cell.executionSummary.success)) {\n        result.executionSummary = {\n          executionOrder: cell.executionSummary.executionOrder,\n          success: cell.executionSummary.success\n        };\n      }\n      return result;\n    }\n    c2p.asNotebookCell = asNotebookCell;\n    function asNotebookCellKind(kind) {\n      switch (kind) {\n        case vscode.NotebookCellKind.Markup:\n          return proto.NotebookCellKind.Markup;\n        case vscode.NotebookCellKind.Code:\n          return proto.NotebookCellKind.Code;\n      }\n    }\n    function deepCopy(seen, value) {\n      if (seen.has(value)) {\n        throw new Error(`Can't deep copy cyclic structures.`);\n      }\n      if (Array.isArray(value)) {\n        const result = [];\n        for (const elem of value) {\n          if (elem !== null && typeof elem === 'object' || Array.isArray(elem)) {\n            result.push(deepCopy(seen, elem));\n          } else {\n            if (elem instanceof RegExp) {\n              throw new Error(`Can't transfer regular expressions to the server`);\n            }\n            result.push(elem);\n          }\n        }\n        return result;\n      } else {\n        const props = Object.keys(value);\n        const result = Object.create(null);\n        for (const prop of props) {\n          const elem = value[prop];\n          if (elem !== null && typeof elem === 'object' || Array.isArray(elem)) {\n            result[prop] = deepCopy(seen, elem);\n          } else {\n            if (elem instanceof RegExp) {\n              throw new Error(`Can't transfer regular expressions to the server`);\n            }\n            result[prop] = elem;\n          }\n        }\n        return result;\n      }\n    }\n    function asTextContentChange(event, base) {\n      const params = base.asChangeTextDocumentParams(event, event.document.uri, event.document.version);\n      return {\n        document: params.textDocument,\n        changes: params.contentChanges\n      };\n    }\n    c2p.asTextContentChange = asTextContentChange;\n    function asNotebookDocumentChangeEvent(event, base) {\n      const result = Object.create(null);\n      if (event.metadata) {\n        result.metadata = Converter.c2p.asMetadata(event.metadata);\n      }\n      if (event.cells !== undefined) {\n        const cells = Object.create(null);\n        const changedCells = event.cells;\n        if (changedCells.structure) {\n          cells.structure = {\n            array: {\n              start: changedCells.structure.array.start,\n              deleteCount: changedCells.structure.array.deleteCount,\n              cells: changedCells.structure.array.cells !== undefined ? changedCells.structure.array.cells.map(cell => Converter.c2p.asNotebookCell(cell, base)) : undefined\n            },\n            didOpen: changedCells.structure.didOpen !== undefined ? changedCells.structure.didOpen.map(cell => base.asOpenTextDocumentParams(cell.document).textDocument) : undefined,\n            didClose: changedCells.structure.didClose !== undefined ? changedCells.structure.didClose.map(cell => base.asCloseTextDocumentParams(cell.document).textDocument) : undefined\n          };\n        }\n        if (changedCells.data !== undefined) {\n          cells.data = changedCells.data.map(cell => Converter.c2p.asNotebookCell(cell, base));\n        }\n        if (changedCells.textContent !== undefined) {\n          cells.textContent = changedCells.textContent.map(event => Converter.c2p.asTextContentChange(event, base));\n        }\n        if (Object.keys(cells).length > 0) {\n          result.cells = cells;\n        }\n      }\n      return result;\n    }\n    c2p.asNotebookDocumentChangeEvent = asNotebookDocumentChangeEvent;\n  })(c2p = Converter.c2p || (Converter.c2p = {}));\n})(Converter || (Converter = {}));\nvar $NotebookCell;\n(function ($NotebookCell) {\n  function computeDiff(originalCells, modifiedCells, compareMetadata) {\n    const originalLength = originalCells.length;\n    const modifiedLength = modifiedCells.length;\n    let startIndex = 0;\n    while (startIndex < modifiedLength && startIndex < originalLength && equals(originalCells[startIndex], modifiedCells[startIndex], compareMetadata)) {\n      startIndex++;\n    }\n    if (startIndex < modifiedLength && startIndex < originalLength) {\n      let originalEndIndex = originalLength - 1;\n      let modifiedEndIndex = modifiedLength - 1;\n      while (originalEndIndex >= 0 && modifiedEndIndex >= 0 && equals(originalCells[originalEndIndex], modifiedCells[modifiedEndIndex], compareMetadata)) {\n        originalEndIndex--;\n        modifiedEndIndex--;\n      }\n      const deleteCount = originalEndIndex + 1 - startIndex;\n      const newCells = startIndex === modifiedEndIndex + 1 ? undefined : modifiedCells.slice(startIndex, modifiedEndIndex + 1);\n      return newCells !== undefined ? {\n        start: startIndex,\n        deleteCount,\n        cells: newCells\n      } : {\n        start: startIndex,\n        deleteCount\n      };\n    } else if (startIndex < modifiedLength) {\n      return {\n        start: startIndex,\n        deleteCount: 0,\n        cells: modifiedCells.slice(startIndex)\n      };\n    } else if (startIndex < originalLength) {\n      return {\n        start: startIndex,\n        deleteCount: originalLength - startIndex\n      };\n    } else {\n      // The two arrays are the same.\n      return undefined;\n    }\n  }\n  $NotebookCell.computeDiff = computeDiff;\n  /**\n   * We only sync kind, document, execution and metadata to the server. So we only need to compare those.\n   */\n  function equals(one, other, compareMetaData = true) {\n    if (one.kind !== other.kind || one.document.uri.toString() !== other.document.uri.toString() || one.document.languageId !== other.document.languageId || !equalsExecution(one.executionSummary, other.executionSummary)) {\n      return false;\n    }\n    return !compareMetaData || compareMetaData && equalsMetadata(one.metadata, other.metadata);\n  }\n  function equalsExecution(one, other) {\n    if (one === other) {\n      return true;\n    }\n    if (one === undefined || other === undefined) {\n      return false;\n    }\n    return one.executionOrder === other.executionOrder && one.success === other.success && equalsTiming(one.timing, other.timing);\n  }\n  function equalsTiming(one, other) {\n    if (one === other) {\n      return true;\n    }\n    if (one === undefined || other === undefined) {\n      return false;\n    }\n    return one.startTime === other.startTime && one.endTime === other.endTime;\n  }\n  function equalsMetadata(one, other) {\n    if (one === other) {\n      return true;\n    }\n    if (one === null || one === undefined || other === null || other === undefined) {\n      return false;\n    }\n    if (typeof one !== typeof other) {\n      return false;\n    }\n    if (typeof one !== 'object') {\n      return false;\n    }\n    const oneArray = Array.isArray(one);\n    const otherArray = Array.isArray(other);\n    if (oneArray !== otherArray) {\n      return false;\n    }\n    if (oneArray && otherArray) {\n      if (one.length !== other.length) {\n        return false;\n      }\n      for (let i = 0; i < one.length; i++) {\n        if (!equalsMetadata(one[i], other[i])) {\n          return false;\n        }\n      }\n    }\n    if (isObjectLiteral(one) && isObjectLiteral(other)) {\n      const oneKeys = Object.keys(one);\n      const otherKeys = Object.keys(other);\n      if (oneKeys.length !== otherKeys.length) {\n        return false;\n      }\n      oneKeys.sort();\n      otherKeys.sort();\n      if (!equalsMetadata(oneKeys, otherKeys)) {\n        return false;\n      }\n      for (let i = 0; i < oneKeys.length; i++) {\n        const prop = oneKeys[i];\n        if (!equalsMetadata(one[prop], other[prop])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  function isObjectLiteral(value) {\n    return value !== null && typeof value === 'object';\n  }\n  $NotebookCell.isObjectLiteral = isObjectLiteral;\n})($NotebookCell || ($NotebookCell = {}));\nvar $NotebookDocumentFilter;\n(function ($NotebookDocumentFilter) {\n  function matchNotebook(filter, notebookDocument) {\n    if (typeof filter === 'string') {\n      return filter === '*' || notebookDocument.notebookType === filter;\n    }\n    if (filter.notebookType !== undefined && filter.notebookType !== '*' && notebookDocument.notebookType !== filter.notebookType) {\n      return false;\n    }\n    const uri = notebookDocument.uri;\n    if (filter.scheme !== undefined && filter.scheme !== '*' && uri.scheme !== filter.scheme) {\n      return false;\n    }\n    if (filter.pattern !== undefined) {\n      const matcher = new minimatch.Minimatch(filter.pattern, {\n        noext: true\n      });\n      if (!matcher.makeRe()) {\n        return false;\n      }\n      if (!matcher.match(uri.fsPath)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  $NotebookDocumentFilter.matchNotebook = matchNotebook;\n})($NotebookDocumentFilter || ($NotebookDocumentFilter = {}));\nvar $NotebookDocumentSyncOptions;\n(function ($NotebookDocumentSyncOptions) {\n  function asDocumentSelector(options) {\n    const selector = options.notebookSelector;\n    const result = [];\n    for (const element of selector) {\n      const notebookType = (typeof element.notebook === 'string' ? element.notebook : element.notebook?.notebookType) ?? '*';\n      const scheme = typeof element.notebook === 'string' ? undefined : element.notebook?.scheme;\n      const pattern = typeof element.notebook === 'string' ? undefined : element.notebook?.pattern;\n      if (element.cells !== undefined) {\n        for (const cell of element.cells) {\n          result.push(asDocumentFilter(notebookType, scheme, pattern, cell.language));\n        }\n      } else {\n        result.push(asDocumentFilter(notebookType, scheme, pattern, undefined));\n      }\n    }\n    return result;\n  }\n  $NotebookDocumentSyncOptions.asDocumentSelector = asDocumentSelector;\n  function asDocumentFilter(notebookType, scheme, pattern, language) {\n    return scheme === undefined && pattern === undefined ? {\n      notebook: notebookType,\n      language\n    } : {\n      notebook: {\n        notebookType,\n        scheme,\n        pattern\n      },\n      language\n    };\n  }\n})($NotebookDocumentSyncOptions || ($NotebookDocumentSyncOptions = {}));\nvar SyncInfo;\n(function (SyncInfo) {\n  function create(cells) {\n    return {\n      cells,\n      uris: new Set(cells.map(cell => cell.document.uri.toString()))\n    };\n  }\n  SyncInfo.create = create;\n})(SyncInfo || (SyncInfo = {}));\nclass NotebookDocumentSyncFeatureProvider {\n  constructor(client, options) {\n    this.client = client;\n    this.options = options;\n    this.notebookSyncInfo = new Map();\n    this.notebookDidOpen = new Set();\n    this.disposables = [];\n    this.selector = client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));\n    // open\n    vscode.workspace.onDidOpenNotebookDocument(notebookDocument => {\n      this.notebookDidOpen.add(notebookDocument.uri.toString());\n      this.didOpen(notebookDocument);\n    }, undefined, this.disposables);\n    for (const notebookDocument of vscode.workspace.notebookDocuments) {\n      this.notebookDidOpen.add(notebookDocument.uri.toString());\n      this.didOpen(notebookDocument);\n    }\n    // Notebook document changed.\n    vscode.workspace.onDidChangeNotebookDocument(event => this.didChangeNotebookDocument(event), undefined, this.disposables);\n    //save\n    if (this.options.save === true) {\n      vscode.workspace.onDidSaveNotebookDocument(notebookDocument => this.didSave(notebookDocument), undefined, this.disposables);\n    }\n    // close\n    vscode.workspace.onDidCloseNotebookDocument(notebookDocument => {\n      this.didClose(notebookDocument);\n      this.notebookDidOpen.delete(notebookDocument.uri.toString());\n    }, undefined, this.disposables);\n  }\n  getState() {\n    for (const notebook of vscode.workspace.notebookDocuments) {\n      const matchingCells = this.getMatchingCells(notebook);\n      if (matchingCells !== undefined) {\n        return {\n          kind: 'document',\n          id: '$internal',\n          registrations: true,\n          matches: true\n        };\n      }\n    }\n    return {\n      kind: 'document',\n      id: '$internal',\n      registrations: true,\n      matches: false\n    };\n  }\n  get mode() {\n    return 'notebook';\n  }\n  handles(textDocument) {\n    return vscode.languages.match(this.selector, textDocument) > 0;\n  }\n  didOpenNotebookCellTextDocument(notebookDocument, cell) {\n    if (vscode.languages.match(this.selector, cell.document) === 0) {\n      return;\n    }\n    if (!this.notebookDidOpen.has(notebookDocument.uri.toString())) {\n      // We have never received an open notification for the notebook document.\n      // VS Code guarantees that we first get cell document open and then\n      // notebook open. So simply wait for the notebook open.\n      return;\n    }\n    const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());\n    // In VS Code we receive a notebook open before a cell document open.\n    // The document and the cell is synced.\n    const cellMatches = this.cellMatches(notebookDocument, cell);\n    if (syncInfo !== undefined) {\n      const cellIsSynced = syncInfo.uris.has(cell.document.uri.toString());\n      if (cellMatches && cellIsSynced || !cellMatches && !cellIsSynced) {\n        // The cell doesn't match and was not synced or it matches and is synced.\n        // In both cases nothing to do.\n        //\n        // Note that if the language mode of a document changes we remove the\n        // cell and add it back to update the language mode on the server side.\n        return;\n      }\n      if (cellMatches) {\n        // don't use cells from above since there might be more matching cells in the notebook\n        // Since we had a matching cell above we will have matching cells now.\n        const matchingCells = this.getMatchingCells(notebookDocument);\n        if (matchingCells !== undefined) {\n          const event = this.asNotebookDocumentChangeEvent(notebookDocument, undefined, syncInfo, matchingCells);\n          if (event !== undefined) {\n            this.doSendChange(event, matchingCells).catch(() => {});\n          }\n        }\n      }\n    } else {\n      // No sync info. But we have a open event for the notebook document\n      // itself. If the cell matches then we need to send an open with\n      // exactly that cell.\n      if (cellMatches) {\n        this.doSendOpen(notebookDocument, [cell]).catch(() => {});\n      }\n    }\n  }\n  didChangeNotebookCellTextDocument(notebookDocument, event) {\n    // No match with the selector\n    if (vscode.languages.match(this.selector, event.document) === 0) {\n      return;\n    }\n    this.doSendChange({\n      notebook: notebookDocument,\n      cells: {\n        textContent: [event]\n      }\n    }, undefined).catch(() => {});\n  }\n  didCloseNotebookCellTextDocument(notebookDocument, cell) {\n    const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());\n    if (syncInfo === undefined) {\n      // The notebook document got never synced. So it doesn't matter if a cell\n      // document closes.\n      return;\n    }\n    const cellUri = cell.document.uri;\n    const index = syncInfo.cells.findIndex(item => item.document.uri.toString() === cellUri.toString());\n    if (index === -1) {\n      // The cell never got synced or it got deleted and we now received the document\n      // close event.\n      return;\n    }\n    if (index === 0 && syncInfo.cells.length === 1) {\n      // The last cell. Close the notebook document in the server.\n      this.doSendClose(notebookDocument, syncInfo.cells).catch(() => {});\n    } else {\n      const newCells = syncInfo.cells.slice();\n      const deleted = newCells.splice(index, 1);\n      this.doSendChange({\n        notebook: notebookDocument,\n        cells: {\n          structure: {\n            array: {\n              start: index,\n              deleteCount: 1\n            },\n            didClose: deleted\n          }\n        }\n      }, newCells).catch(() => {});\n    }\n  }\n  dispose() {\n    for (const disposable of this.disposables) {\n      disposable.dispose();\n    }\n  }\n  didOpen(notebookDocument, matchingCells = this.getMatchingCells(notebookDocument), syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {\n    if (syncInfo !== undefined) {\n      if (matchingCells !== undefined) {\n        const event = this.asNotebookDocumentChangeEvent(notebookDocument, undefined, syncInfo, matchingCells);\n        if (event !== undefined) {\n          this.doSendChange(event, matchingCells).catch(() => {});\n        }\n      } else {\n        this.doSendClose(notebookDocument, []).catch(() => {});\n      }\n    } else {\n      // Check if we need to sync the notebook document.\n      if (matchingCells === undefined) {\n        return;\n      }\n      this.doSendOpen(notebookDocument, matchingCells).catch(() => {});\n    }\n  }\n  didChangeNotebookDocument(event) {\n    const notebookDocument = event.notebook;\n    const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());\n    if (syncInfo === undefined) {\n      // We have no changes to the cells. Since the notebook wasn't synced\n      // it will not be synced now.\n      if (event.contentChanges.length === 0) {\n        return;\n      }\n      // Check if we have new matching cells.\n      const cells = this.getMatchingCells(notebookDocument);\n      // No matching cells and the notebook never synced. So still no need\n      // to sync it.\n      if (cells === undefined) {\n        return;\n      }\n      // Open the notebook document and ignore the rest of the changes\n      // this the notebooks will be synced with the correct settings.\n      this.didOpen(notebookDocument, cells, syncInfo);\n    } else {\n      // The notebook is synced. First check if we have no matching\n      // cells anymore and if so close the notebook\n      const cells = this.getMatchingCells(notebookDocument);\n      if (cells === undefined) {\n        this.didClose(notebookDocument, syncInfo);\n        return;\n      }\n      const newEvent = this.asNotebookDocumentChangeEvent(event.notebook, event, syncInfo, cells);\n      if (newEvent !== undefined) {\n        this.doSendChange(newEvent, cells).catch(() => {});\n      }\n    }\n  }\n  didSave(notebookDocument) {\n    const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());\n    if (syncInfo === undefined) {\n      return;\n    }\n    this.doSendSave(notebookDocument).catch(() => {});\n  }\n  didClose(notebookDocument, syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {\n    if (syncInfo === undefined) {\n      return;\n    }\n    const syncedCells = notebookDocument.getCells().filter(cell => syncInfo.uris.has(cell.document.uri.toString()));\n    this.doSendClose(notebookDocument, syncedCells).catch(() => {});\n  }\n  async sendDidOpenNotebookDocument(notebookDocument) {\n    const cells = this.getMatchingCells(notebookDocument);\n    if (cells === undefined) {\n      return;\n    }\n    return this.doSendOpen(notebookDocument, cells);\n  }\n  async doSendOpen(notebookDocument, cells) {\n    const send = async (notebookDocument, cells) => {\n      const nb = Converter.c2p.asNotebookDocument(notebookDocument, cells, this.client.code2ProtocolConverter);\n      const cellDocuments = cells.map(cell => this.client.code2ProtocolConverter.asTextDocumentItem(cell.document));\n      try {\n        await this.client.sendNotification(proto.DidOpenNotebookDocumentNotification.type, {\n          notebookDocument: nb,\n          cellTextDocuments: cellDocuments\n        });\n      } catch (error) {\n        this.client.error('Sending DidOpenNotebookDocumentNotification failed', error);\n        throw error;\n      }\n    };\n    const middleware = this.client.middleware?.notebooks;\n    this.notebookSyncInfo.set(notebookDocument.uri.toString(), SyncInfo.create(cells));\n    return middleware?.didOpen !== undefined ? middleware.didOpen(notebookDocument, cells, send) : send(notebookDocument, cells);\n  }\n  async sendDidChangeNotebookDocument(event) {\n    return this.doSendChange(event, undefined);\n  }\n  async doSendChange(event, cells = this.getMatchingCells(event.notebook)) {\n    const send = async event => {\n      try {\n        await this.client.sendNotification(proto.DidChangeNotebookDocumentNotification.type, {\n          notebookDocument: Converter.c2p.asVersionedNotebookDocumentIdentifier(event.notebook, this.client.code2ProtocolConverter),\n          change: Converter.c2p.asNotebookDocumentChangeEvent(event, this.client.code2ProtocolConverter)\n        });\n      } catch (error) {\n        this.client.error('Sending DidChangeNotebookDocumentNotification failed', error);\n        throw error;\n      }\n    };\n    const middleware = this.client.middleware?.notebooks;\n    if (event.cells?.structure !== undefined) {\n      this.notebookSyncInfo.set(event.notebook.uri.toString(), SyncInfo.create(cells ?? []));\n    }\n    return middleware?.didChange !== undefined ? middleware?.didChange(event, send) : send(event);\n  }\n  async sendDidSaveNotebookDocument(notebookDocument) {\n    return this.doSendSave(notebookDocument);\n  }\n  async doSendSave(notebookDocument) {\n    const send = async notebookDocument => {\n      try {\n        await this.client.sendNotification(proto.DidSaveNotebookDocumentNotification.type, {\n          notebookDocument: {\n            uri: this.client.code2ProtocolConverter.asUri(notebookDocument.uri)\n          }\n        });\n      } catch (error) {\n        this.client.error('Sending DidSaveNotebookDocumentNotification failed', error);\n        throw error;\n      }\n    };\n    const middleware = this.client.middleware?.notebooks;\n    return middleware?.didSave !== undefined ? middleware.didSave(notebookDocument, send) : send(notebookDocument);\n  }\n  async sendDidCloseNotebookDocument(notebookDocument) {\n    return this.doSendClose(notebookDocument, this.getMatchingCells(notebookDocument) ?? []);\n  }\n  async doSendClose(notebookDocument, cells) {\n    const send = async (notebookDocument, cells) => {\n      try {\n        await this.client.sendNotification(proto.DidCloseNotebookDocumentNotification.type, {\n          notebookDocument: {\n            uri: this.client.code2ProtocolConverter.asUri(notebookDocument.uri)\n          },\n          cellTextDocuments: cells.map(cell => this.client.code2ProtocolConverter.asTextDocumentIdentifier(cell.document))\n        });\n      } catch (error) {\n        this.client.error('Sending DidCloseNotebookDocumentNotification failed', error);\n        throw error;\n      }\n    };\n    const middleware = this.client.middleware?.notebooks;\n    this.notebookSyncInfo.delete(notebookDocument.uri.toString());\n    return middleware?.didClose !== undefined ? middleware.didClose(notebookDocument, cells, send) : send(notebookDocument, cells);\n  }\n  asNotebookDocumentChangeEvent(notebook, event, syncInfo, matchingCells) {\n    if (event !== undefined && event.notebook !== notebook) {\n      throw new Error('Notebook must be identical');\n    }\n    const result = {\n      notebook: notebook\n    };\n    if (event?.metadata !== undefined) {\n      result.metadata = Converter.c2p.asMetadata(event.metadata);\n    }\n    let matchingCellsSet;\n    if (event?.cellChanges !== undefined && event.cellChanges.length > 0) {\n      const data = [];\n      // Only consider the new matching cells.\n      matchingCellsSet = new Set(matchingCells.map(cell => cell.document.uri.toString()));\n      for (const cellChange of event.cellChanges) {\n        if (matchingCellsSet.has(cellChange.cell.document.uri.toString()) && (cellChange.executionSummary !== undefined || cellChange.metadata !== undefined)) {\n          data.push(cellChange.cell);\n        }\n      }\n      if (data.length > 0) {\n        result.cells = result.cells ?? {};\n        result.cells.data = data;\n      }\n    }\n    if ((event?.contentChanges !== undefined && event.contentChanges.length > 0 || event === undefined) && syncInfo !== undefined && matchingCells !== undefined) {\n      // We still have matching cells. Check if the cell changes\n      // affect the notebook on the server side.\n      const oldCells = syncInfo.cells;\n      const newCells = matchingCells;\n      // meta data changes are reported using on the cell itself. So we can ignore comparing\n      // it which has a positive effect on performance.\n      const diff = $NotebookCell.computeDiff(oldCells, newCells, false);\n      let addedCells;\n      let removedCells;\n      if (diff !== undefined) {\n        addedCells = diff.cells === undefined ? new Map() : new Map(diff.cells.map(cell => [cell.document.uri.toString(), cell]));\n        removedCells = diff.deleteCount === 0 ? new Map() : new Map(oldCells.slice(diff.start, diff.start + diff.deleteCount).map(cell => [cell.document.uri.toString(), cell]));\n        // Remove the onces that got deleted and inserted again.\n        for (const key of Array.from(removedCells.keys())) {\n          if (addedCells.has(key)) {\n            removedCells.delete(key);\n            addedCells.delete(key);\n          }\n        }\n        result.cells = result.cells ?? {};\n        const didOpen = [];\n        const didClose = [];\n        if (addedCells.size > 0 || removedCells.size > 0) {\n          for (const cell of addedCells.values()) {\n            didOpen.push(cell);\n          }\n          for (const cell of removedCells.values()) {\n            didClose.push(cell);\n          }\n        }\n        result.cells.structure = {\n          array: diff,\n          didOpen,\n          didClose\n        };\n      }\n    }\n    // The notebook is a property as well.\n    return Object.keys(result).length > 1 ? result : undefined;\n  }\n  getMatchingCells(notebookDocument, cells = notebookDocument.getCells()) {\n    if (this.options.notebookSelector === undefined) {\n      return undefined;\n    }\n    for (const item of this.options.notebookSelector) {\n      if (item.notebook === undefined || $NotebookDocumentFilter.matchNotebook(item.notebook, notebookDocument)) {\n        const filtered = this.filterCells(notebookDocument, cells, item.cells);\n        return filtered.length === 0 ? undefined : filtered;\n      }\n    }\n    return undefined;\n  }\n  cellMatches(notebookDocument, cell) {\n    const cells = this.getMatchingCells(notebookDocument, [cell]);\n    return cells !== undefined && cells[0] === cell;\n  }\n  filterCells(notebookDocument, cells, cellSelector) {\n    const filtered = cellSelector !== undefined ? cells.filter(cell => {\n      const cellLanguage = cell.document.languageId;\n      return cellSelector.some(filter => filter.language === '*' || cellLanguage === filter.language);\n    }) : cells;\n    return typeof this.client.clientOptions.notebookDocumentOptions?.filterCells === 'function' ? this.client.clientOptions.notebookDocumentOptions.filterCells(notebookDocument, filtered) : filtered;\n  }\n}\nclass NotebookDocumentSyncFeature {\n  constructor(client) {\n    this.client = client;\n    this.registrations = new Map();\n    this.registrationType = proto.NotebookDocumentSyncRegistrationType.type;\n    // We don't receive an event for cells where the document changes its language mode\n    // Since we allow servers to filter on the language mode we fire such an event ourselves.\n    vscode.workspace.onDidOpenTextDocument(textDocument => {\n      if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {\n        return;\n      }\n      const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);\n      if (notebookDocument === undefined || notebookCell === undefined) {\n        return;\n      }\n      for (const provider of this.registrations.values()) {\n        if (provider instanceof NotebookDocumentSyncFeatureProvider) {\n          provider.didOpenNotebookCellTextDocument(notebookDocument, notebookCell);\n        }\n      }\n    });\n    vscode.workspace.onDidChangeTextDocument(event => {\n      if (event.contentChanges.length === 0) {\n        return;\n      }\n      const textDocument = event.document;\n      if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {\n        return;\n      }\n      const [notebookDocument] = this.findNotebookDocumentAndCell(textDocument);\n      if (notebookDocument === undefined) {\n        return;\n      }\n      for (const provider of this.registrations.values()) {\n        if (provider instanceof NotebookDocumentSyncFeatureProvider) {\n          provider.didChangeNotebookCellTextDocument(notebookDocument, event);\n        }\n      }\n    });\n    vscode.workspace.onDidCloseTextDocument(textDocument => {\n      if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {\n        return;\n      }\n      // There are two cases when we receive a close for a text document\n      // 1: the cell got removed. This is handled in `onDidChangeNotebookCells`\n      // 2: the language mode of a cell changed. This keeps the URI stable so\n      //    we will still find the cell and the notebook document.\n      const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);\n      if (notebookDocument === undefined || notebookCell === undefined) {\n        return;\n      }\n      for (const provider of this.registrations.values()) {\n        if (provider instanceof NotebookDocumentSyncFeatureProvider) {\n          provider.didCloseNotebookCellTextDocument(notebookDocument, notebookCell);\n        }\n      }\n    });\n  }\n  getState() {\n    if (this.registrations.size === 0) {\n      return {\n        kind: 'document',\n        id: this.registrationType.method,\n        registrations: false,\n        matches: false\n      };\n    }\n    for (const provider of this.registrations.values()) {\n      const state = provider.getState();\n      if (state.kind === 'document' && state.registrations === true && state.matches === true) {\n        return {\n          kind: 'document',\n          id: this.registrationType.method,\n          registrations: true,\n          matches: true\n        };\n      }\n    }\n    return {\n      kind: 'document',\n      id: this.registrationType.method,\n      registrations: true,\n      matches: false\n    };\n  }\n  fillClientCapabilities(capabilities) {\n    const synchronization = ensure(ensure(capabilities, 'notebookDocument'), 'synchronization');\n    synchronization.dynamicRegistration = true;\n    synchronization.executionSummarySupport = true;\n  }\n  preInitialize(capabilities) {\n    const options = capabilities.notebookDocumentSync;\n    if (options === undefined) {\n      return;\n    }\n    this.dedicatedChannel = this.client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));\n  }\n  initialize(capabilities) {\n    const options = capabilities.notebookDocumentSync;\n    if (options === undefined) {\n      return;\n    }\n    const id = options.id ?? UUID.generateUuid();\n    this.register({\n      id,\n      registerOptions: options\n    });\n  }\n  register(data) {\n    const provider = new NotebookDocumentSyncFeatureProvider(this.client, data.registerOptions);\n    this.registrations.set(data.id, provider);\n  }\n  unregister(id) {\n    const provider = this.registrations.get(id);\n    provider && provider.dispose();\n  }\n  clear() {\n    for (const provider of this.registrations.values()) {\n      provider.dispose();\n    }\n    this.registrations.clear();\n  }\n  handles(textDocument) {\n    if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {\n      return false;\n    }\n    if (this.dedicatedChannel !== undefined && vscode.languages.match(this.dedicatedChannel, textDocument) > 0) {\n      return true;\n    }\n    for (const provider of this.registrations.values()) {\n      if (provider.handles(textDocument)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  getProvider(notebookCell) {\n    for (const provider of this.registrations.values()) {\n      if (provider.handles(notebookCell.document)) {\n        return provider;\n      }\n    }\n    return undefined;\n  }\n  findNotebookDocumentAndCell(textDocument) {\n    const uri = textDocument.uri.toString();\n    for (const notebookDocument of vscode.workspace.notebookDocuments) {\n      for (const cell of notebookDocument.getCells()) {\n        if (cell.document.uri.toString() === uri) {\n          return [notebookDocument, cell];\n        }\n      }\n    }\n    return [undefined, undefined];\n  }\n}\nexports.NotebookDocumentSyncFeature = NotebookDocumentSyncFeature;\nNotebookDocumentSyncFeature.CellScheme = 'vscode-notebook-cell';","map":{"version":3,"names":["Object","defineProperty","exports","value","NotebookDocumentSyncFeature","vscode","require","minimatch","proto","UUID","Is","ensure","target","key","Converter","c2p","asVersionedNotebookDocumentIdentifier","notebookDocument","base","version","uri","asUri","asNotebookDocument","cells","result","NotebookDocument","create","notebookType","asNotebookCells","keys","metadata","length","asMetadata","map","cell","asNotebookCell","seen","Set","deepCopy","NotebookCell","asNotebookCellKind","kind","document","executionSummary","undefined","number","executionOrder","boolean","success","NotebookCellKind","Markup","Code","has","Error","Array","isArray","elem","push","RegExp","props","prop","asTextContentChange","event","params","asChangeTextDocumentParams","textDocument","changes","contentChanges","asNotebookDocumentChangeEvent","changedCells","structure","array","start","deleteCount","didOpen","asOpenTextDocumentParams","didClose","asCloseTextDocumentParams","data","textContent","$NotebookCell","computeDiff","originalCells","modifiedCells","compareMetadata","originalLength","modifiedLength","startIndex","equals","originalEndIndex","modifiedEndIndex","newCells","slice","one","other","compareMetaData","toString","languageId","equalsExecution","equalsMetadata","equalsTiming","timing","startTime","endTime","oneArray","otherArray","i","isObjectLiteral","oneKeys","otherKeys","sort","$NotebookDocumentFilter","matchNotebook","filter","scheme","pattern","matcher","Minimatch","noext","makeRe","match","fsPath","$NotebookDocumentSyncOptions","asDocumentSelector","options","selector","notebookSelector","element","notebook","asDocumentFilter","language","SyncInfo","uris","NotebookDocumentSyncFeatureProvider","constructor","client","notebookSyncInfo","Map","notebookDidOpen","disposables","protocol2CodeConverter","workspace","onDidOpenNotebookDocument","add","notebookDocuments","onDidChangeNotebookDocument","didChangeNotebookDocument","save","onDidSaveNotebookDocument","didSave","onDidCloseNotebookDocument","delete","getState","matchingCells","getMatchingCells","id","registrations","matches","mode","handles","languages","didOpenNotebookCellTextDocument","syncInfo","get","cellMatches","cellIsSynced","doSendChange","catch","doSendOpen","didChangeNotebookCellTextDocument","didCloseNotebookCellTextDocument","cellUri","index","findIndex","item","doSendClose","deleted","splice","dispose","disposable","newEvent","doSendSave","syncedCells","getCells","sendDidOpenNotebookDocument","send","nb","code2ProtocolConverter","cellDocuments","asTextDocumentItem","sendNotification","DidOpenNotebookDocumentNotification","type","cellTextDocuments","error","middleware","notebooks","set","sendDidChangeNotebookDocument","DidChangeNotebookDocumentNotification","change","didChange","sendDidSaveNotebookDocument","DidSaveNotebookDocumentNotification","sendDidCloseNotebookDocument","DidCloseNotebookDocumentNotification","asTextDocumentIdentifier","matchingCellsSet","cellChanges","cellChange","oldCells","diff","addedCells","removedCells","from","size","values","filtered","filterCells","cellSelector","cellLanguage","some","clientOptions","notebookDocumentOptions","registrationType","NotebookDocumentSyncRegistrationType","onDidOpenTextDocument","CellScheme","notebookCell","findNotebookDocumentAndCell","provider","onDidChangeTextDocument","onDidCloseTextDocument","method","state","fillClientCapabilities","capabilities","synchronization","dynamicRegistration","executionSummarySupport","preInitialize","notebookDocumentSync","dedicatedChannel","initialize","generateUuid","register","registerOptions","unregister","clear","getProvider"],"sources":["/Users/phamtu/Downloads/Code/OCE/oce-frontend/node_modules/vscode-languageclient/lib/common/notebook.js"],"sourcesContent":["\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NotebookDocumentSyncFeature = void 0;\nconst vscode = require(\"vscode\");\nconst minimatch = require(\"minimatch\");\nconst proto = require(\"vscode-languageserver-protocol\");\nconst UUID = require(\"./utils/uuid\");\nconst Is = require(\"./utils/is\");\nfunction ensure(target, key) {\n    if (target[key] === void 0) {\n        target[key] = {};\n    }\n    return target[key];\n}\nvar Converter;\n(function (Converter) {\n    let c2p;\n    (function (c2p) {\n        function asVersionedNotebookDocumentIdentifier(notebookDocument, base) {\n            return {\n                version: notebookDocument.version,\n                uri: base.asUri(notebookDocument.uri)\n            };\n        }\n        c2p.asVersionedNotebookDocumentIdentifier = asVersionedNotebookDocumentIdentifier;\n        function asNotebookDocument(notebookDocument, cells, base) {\n            const result = proto.NotebookDocument.create(base.asUri(notebookDocument.uri), notebookDocument.notebookType, notebookDocument.version, asNotebookCells(cells, base));\n            if (Object.keys(notebookDocument.metadata).length > 0) {\n                result.metadata = asMetadata(notebookDocument.metadata);\n            }\n            return result;\n        }\n        c2p.asNotebookDocument = asNotebookDocument;\n        function asNotebookCells(cells, base) {\n            return cells.map(cell => asNotebookCell(cell, base));\n        }\n        c2p.asNotebookCells = asNotebookCells;\n        function asMetadata(metadata) {\n            const seen = new Set();\n            return deepCopy(seen, metadata);\n        }\n        c2p.asMetadata = asMetadata;\n        function asNotebookCell(cell, base) {\n            const result = proto.NotebookCell.create(asNotebookCellKind(cell.kind), base.asUri(cell.document.uri));\n            if (Object.keys(cell.metadata).length > 0) {\n                result.metadata = asMetadata(cell.metadata);\n            }\n            if (cell.executionSummary !== undefined && (Is.number(cell.executionSummary.executionOrder) && Is.boolean(cell.executionSummary.success))) {\n                result.executionSummary = {\n                    executionOrder: cell.executionSummary.executionOrder,\n                    success: cell.executionSummary.success\n                };\n            }\n            return result;\n        }\n        c2p.asNotebookCell = asNotebookCell;\n        function asNotebookCellKind(kind) {\n            switch (kind) {\n                case vscode.NotebookCellKind.Markup:\n                    return proto.NotebookCellKind.Markup;\n                case vscode.NotebookCellKind.Code:\n                    return proto.NotebookCellKind.Code;\n            }\n        }\n        function deepCopy(seen, value) {\n            if (seen.has(value)) {\n                throw new Error(`Can't deep copy cyclic structures.`);\n            }\n            if (Array.isArray(value)) {\n                const result = [];\n                for (const elem of value) {\n                    if (elem !== null && typeof elem === 'object' || Array.isArray(elem)) {\n                        result.push(deepCopy(seen, elem));\n                    }\n                    else {\n                        if (elem instanceof RegExp) {\n                            throw new Error(`Can't transfer regular expressions to the server`);\n                        }\n                        result.push(elem);\n                    }\n                }\n                return result;\n            }\n            else {\n                const props = Object.keys(value);\n                const result = Object.create(null);\n                for (const prop of props) {\n                    const elem = value[prop];\n                    if (elem !== null && typeof elem === 'object' || Array.isArray(elem)) {\n                        result[prop] = deepCopy(seen, elem);\n                    }\n                    else {\n                        if (elem instanceof RegExp) {\n                            throw new Error(`Can't transfer regular expressions to the server`);\n                        }\n                        result[prop] = elem;\n                    }\n                }\n                return result;\n            }\n        }\n        function asTextContentChange(event, base) {\n            const params = base.asChangeTextDocumentParams(event, event.document.uri, event.document.version);\n            return { document: params.textDocument, changes: params.contentChanges };\n        }\n        c2p.asTextContentChange = asTextContentChange;\n        function asNotebookDocumentChangeEvent(event, base) {\n            const result = Object.create(null);\n            if (event.metadata) {\n                result.metadata = Converter.c2p.asMetadata(event.metadata);\n            }\n            if (event.cells !== undefined) {\n                const cells = Object.create(null);\n                const changedCells = event.cells;\n                if (changedCells.structure) {\n                    cells.structure = {\n                        array: {\n                            start: changedCells.structure.array.start,\n                            deleteCount: changedCells.structure.array.deleteCount,\n                            cells: changedCells.structure.array.cells !== undefined ? changedCells.structure.array.cells.map(cell => Converter.c2p.asNotebookCell(cell, base)) : undefined\n                        },\n                        didOpen: changedCells.structure.didOpen !== undefined\n                            ? changedCells.structure.didOpen.map(cell => base.asOpenTextDocumentParams(cell.document).textDocument)\n                            : undefined,\n                        didClose: changedCells.structure.didClose !== undefined\n                            ? changedCells.structure.didClose.map(cell => base.asCloseTextDocumentParams(cell.document).textDocument)\n                            : undefined\n                    };\n                }\n                if (changedCells.data !== undefined) {\n                    cells.data = changedCells.data.map(cell => Converter.c2p.asNotebookCell(cell, base));\n                }\n                if (changedCells.textContent !== undefined) {\n                    cells.textContent = changedCells.textContent.map(event => Converter.c2p.asTextContentChange(event, base));\n                }\n                if (Object.keys(cells).length > 0) {\n                    result.cells = cells;\n                }\n            }\n            return result;\n        }\n        c2p.asNotebookDocumentChangeEvent = asNotebookDocumentChangeEvent;\n    })(c2p = Converter.c2p || (Converter.c2p = {}));\n})(Converter || (Converter = {}));\nvar $NotebookCell;\n(function ($NotebookCell) {\n    function computeDiff(originalCells, modifiedCells, compareMetadata) {\n        const originalLength = originalCells.length;\n        const modifiedLength = modifiedCells.length;\n        let startIndex = 0;\n        while (startIndex < modifiedLength && startIndex < originalLength && equals(originalCells[startIndex], modifiedCells[startIndex], compareMetadata)) {\n            startIndex++;\n        }\n        if (startIndex < modifiedLength && startIndex < originalLength) {\n            let originalEndIndex = originalLength - 1;\n            let modifiedEndIndex = modifiedLength - 1;\n            while (originalEndIndex >= 0 && modifiedEndIndex >= 0 && equals(originalCells[originalEndIndex], modifiedCells[modifiedEndIndex], compareMetadata)) {\n                originalEndIndex--;\n                modifiedEndIndex--;\n            }\n            const deleteCount = (originalEndIndex + 1) - startIndex;\n            const newCells = startIndex === modifiedEndIndex + 1 ? undefined : modifiedCells.slice(startIndex, modifiedEndIndex + 1);\n            return newCells !== undefined ? { start: startIndex, deleteCount, cells: newCells } : { start: startIndex, deleteCount };\n        }\n        else if (startIndex < modifiedLength) {\n            return { start: startIndex, deleteCount: 0, cells: modifiedCells.slice(startIndex) };\n        }\n        else if (startIndex < originalLength) {\n            return { start: startIndex, deleteCount: originalLength - startIndex };\n        }\n        else {\n            // The two arrays are the same.\n            return undefined;\n        }\n    }\n    $NotebookCell.computeDiff = computeDiff;\n    /**\n     * We only sync kind, document, execution and metadata to the server. So we only need to compare those.\n     */\n    function equals(one, other, compareMetaData = true) {\n        if (one.kind !== other.kind || one.document.uri.toString() !== other.document.uri.toString() || one.document.languageId !== other.document.languageId ||\n            !equalsExecution(one.executionSummary, other.executionSummary)) {\n            return false;\n        }\n        return !compareMetaData || (compareMetaData && equalsMetadata(one.metadata, other.metadata));\n    }\n    function equalsExecution(one, other) {\n        if (one === other) {\n            return true;\n        }\n        if (one === undefined || other === undefined) {\n            return false;\n        }\n        return one.executionOrder === other.executionOrder && one.success === other.success && equalsTiming(one.timing, other.timing);\n    }\n    function equalsTiming(one, other) {\n        if (one === other) {\n            return true;\n        }\n        if (one === undefined || other === undefined) {\n            return false;\n        }\n        return one.startTime === other.startTime && one.endTime === other.endTime;\n    }\n    function equalsMetadata(one, other) {\n        if (one === other) {\n            return true;\n        }\n        if (one === null || one === undefined || other === null || other === undefined) {\n            return false;\n        }\n        if (typeof one !== typeof other) {\n            return false;\n        }\n        if (typeof one !== 'object') {\n            return false;\n        }\n        const oneArray = Array.isArray(one);\n        const otherArray = Array.isArray(other);\n        if (oneArray !== otherArray) {\n            return false;\n        }\n        if (oneArray && otherArray) {\n            if (one.length !== other.length) {\n                return false;\n            }\n            for (let i = 0; i < one.length; i++) {\n                if (!equalsMetadata(one[i], other[i])) {\n                    return false;\n                }\n            }\n        }\n        if (isObjectLiteral(one) && isObjectLiteral(other)) {\n            const oneKeys = Object.keys(one);\n            const otherKeys = Object.keys(other);\n            if (oneKeys.length !== otherKeys.length) {\n                return false;\n            }\n            oneKeys.sort();\n            otherKeys.sort();\n            if (!equalsMetadata(oneKeys, otherKeys)) {\n                return false;\n            }\n            for (let i = 0; i < oneKeys.length; i++) {\n                const prop = oneKeys[i];\n                if (!equalsMetadata(one[prop], other[prop])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    function isObjectLiteral(value) {\n        return value !== null && typeof value === 'object';\n    }\n    $NotebookCell.isObjectLiteral = isObjectLiteral;\n})($NotebookCell || ($NotebookCell = {}));\nvar $NotebookDocumentFilter;\n(function ($NotebookDocumentFilter) {\n    function matchNotebook(filter, notebookDocument) {\n        if (typeof filter === 'string') {\n            return filter === '*' || notebookDocument.notebookType === filter;\n        }\n        if (filter.notebookType !== undefined && filter.notebookType !== '*' && notebookDocument.notebookType !== filter.notebookType) {\n            return false;\n        }\n        const uri = notebookDocument.uri;\n        if (filter.scheme !== undefined && filter.scheme !== '*' && uri.scheme !== filter.scheme) {\n            return false;\n        }\n        if (filter.pattern !== undefined) {\n            const matcher = new minimatch.Minimatch(filter.pattern, { noext: true });\n            if (!matcher.makeRe()) {\n                return false;\n            }\n            if (!matcher.match(uri.fsPath)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    $NotebookDocumentFilter.matchNotebook = matchNotebook;\n})($NotebookDocumentFilter || ($NotebookDocumentFilter = {}));\nvar $NotebookDocumentSyncOptions;\n(function ($NotebookDocumentSyncOptions) {\n    function asDocumentSelector(options) {\n        const selector = options.notebookSelector;\n        const result = [];\n        for (const element of selector) {\n            const notebookType = (typeof element.notebook === 'string' ? element.notebook : element.notebook?.notebookType) ?? '*';\n            const scheme = (typeof element.notebook === 'string') ? undefined : element.notebook?.scheme;\n            const pattern = (typeof element.notebook === 'string') ? undefined : element.notebook?.pattern;\n            if (element.cells !== undefined) {\n                for (const cell of element.cells) {\n                    result.push(asDocumentFilter(notebookType, scheme, pattern, cell.language));\n                }\n            }\n            else {\n                result.push(asDocumentFilter(notebookType, scheme, pattern, undefined));\n            }\n        }\n        return result;\n    }\n    $NotebookDocumentSyncOptions.asDocumentSelector = asDocumentSelector;\n    function asDocumentFilter(notebookType, scheme, pattern, language) {\n        return scheme === undefined && pattern === undefined\n            ? { notebook: notebookType, language }\n            : { notebook: { notebookType, scheme, pattern }, language };\n    }\n})($NotebookDocumentSyncOptions || ($NotebookDocumentSyncOptions = {}));\nvar SyncInfo;\n(function (SyncInfo) {\n    function create(cells) {\n        return {\n            cells,\n            uris: new Set(cells.map(cell => cell.document.uri.toString()))\n        };\n    }\n    SyncInfo.create = create;\n})(SyncInfo || (SyncInfo = {}));\nclass NotebookDocumentSyncFeatureProvider {\n    constructor(client, options) {\n        this.client = client;\n        this.options = options;\n        this.notebookSyncInfo = new Map();\n        this.notebookDidOpen = new Set();\n        this.disposables = [];\n        this.selector = client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));\n        // open\n        vscode.workspace.onDidOpenNotebookDocument((notebookDocument) => {\n            this.notebookDidOpen.add(notebookDocument.uri.toString());\n            this.didOpen(notebookDocument);\n        }, undefined, this.disposables);\n        for (const notebookDocument of vscode.workspace.notebookDocuments) {\n            this.notebookDidOpen.add(notebookDocument.uri.toString());\n            this.didOpen(notebookDocument);\n        }\n        // Notebook document changed.\n        vscode.workspace.onDidChangeNotebookDocument(event => this.didChangeNotebookDocument(event), undefined, this.disposables);\n        //save\n        if (this.options.save === true) {\n            vscode.workspace.onDidSaveNotebookDocument(notebookDocument => this.didSave(notebookDocument), undefined, this.disposables);\n        }\n        // close\n        vscode.workspace.onDidCloseNotebookDocument((notebookDocument) => {\n            this.didClose(notebookDocument);\n            this.notebookDidOpen.delete(notebookDocument.uri.toString());\n        }, undefined, this.disposables);\n    }\n    getState() {\n        for (const notebook of vscode.workspace.notebookDocuments) {\n            const matchingCells = this.getMatchingCells(notebook);\n            if (matchingCells !== undefined) {\n                return { kind: 'document', id: '$internal', registrations: true, matches: true };\n            }\n        }\n        return { kind: 'document', id: '$internal', registrations: true, matches: false };\n    }\n    get mode() {\n        return 'notebook';\n    }\n    handles(textDocument) {\n        return vscode.languages.match(this.selector, textDocument) > 0;\n    }\n    didOpenNotebookCellTextDocument(notebookDocument, cell) {\n        if (vscode.languages.match(this.selector, cell.document) === 0) {\n            return;\n        }\n        if (!this.notebookDidOpen.has(notebookDocument.uri.toString())) {\n            // We have never received an open notification for the notebook document.\n            // VS Code guarantees that we first get cell document open and then\n            // notebook open. So simply wait for the notebook open.\n            return;\n        }\n        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());\n        // In VS Code we receive a notebook open before a cell document open.\n        // The document and the cell is synced.\n        const cellMatches = this.cellMatches(notebookDocument, cell);\n        if (syncInfo !== undefined) {\n            const cellIsSynced = syncInfo.uris.has(cell.document.uri.toString());\n            if ((cellMatches && cellIsSynced) || (!cellMatches && !cellIsSynced)) {\n                // The cell doesn't match and was not synced or it matches and is synced.\n                // In both cases nothing to do.\n                //\n                // Note that if the language mode of a document changes we remove the\n                // cell and add it back to update the language mode on the server side.\n                return;\n            }\n            if (cellMatches) {\n                // don't use cells from above since there might be more matching cells in the notebook\n                // Since we had a matching cell above we will have matching cells now.\n                const matchingCells = this.getMatchingCells(notebookDocument);\n                if (matchingCells !== undefined) {\n                    const event = this.asNotebookDocumentChangeEvent(notebookDocument, undefined, syncInfo, matchingCells);\n                    if (event !== undefined) {\n                        this.doSendChange(event, matchingCells).catch(() => { });\n                    }\n                }\n            }\n        }\n        else {\n            // No sync info. But we have a open event for the notebook document\n            // itself. If the cell matches then we need to send an open with\n            // exactly that cell.\n            if (cellMatches) {\n                this.doSendOpen(notebookDocument, [cell]).catch(() => { });\n            }\n        }\n    }\n    didChangeNotebookCellTextDocument(notebookDocument, event) {\n        // No match with the selector\n        if (vscode.languages.match(this.selector, event.document) === 0) {\n            return;\n        }\n        this.doSendChange({\n            notebook: notebookDocument,\n            cells: { textContent: [event] }\n        }, undefined).catch(() => { });\n    }\n    didCloseNotebookCellTextDocument(notebookDocument, cell) {\n        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());\n        if (syncInfo === undefined) {\n            // The notebook document got never synced. So it doesn't matter if a cell\n            // document closes.\n            return;\n        }\n        const cellUri = cell.document.uri;\n        const index = syncInfo.cells.findIndex((item) => item.document.uri.toString() === cellUri.toString());\n        if (index === -1) {\n            // The cell never got synced or it got deleted and we now received the document\n            // close event.\n            return;\n        }\n        if (index === 0 && syncInfo.cells.length === 1) {\n            // The last cell. Close the notebook document in the server.\n            this.doSendClose(notebookDocument, syncInfo.cells).catch(() => { });\n        }\n        else {\n            const newCells = syncInfo.cells.slice();\n            const deleted = newCells.splice(index, 1);\n            this.doSendChange({\n                notebook: notebookDocument,\n                cells: {\n                    structure: {\n                        array: { start: index, deleteCount: 1 },\n                        didClose: deleted\n                    }\n                }\n            }, newCells).catch(() => { });\n        }\n    }\n    dispose() {\n        for (const disposable of this.disposables) {\n            disposable.dispose();\n        }\n    }\n    didOpen(notebookDocument, matchingCells = this.getMatchingCells(notebookDocument), syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {\n        if (syncInfo !== undefined) {\n            if (matchingCells !== undefined) {\n                const event = this.asNotebookDocumentChangeEvent(notebookDocument, undefined, syncInfo, matchingCells);\n                if (event !== undefined) {\n                    this.doSendChange(event, matchingCells).catch(() => { });\n                }\n            }\n            else {\n                this.doSendClose(notebookDocument, []).catch(() => { });\n            }\n        }\n        else {\n            // Check if we need to sync the notebook document.\n            if (matchingCells === undefined) {\n                return;\n            }\n            this.doSendOpen(notebookDocument, matchingCells).catch(() => { });\n        }\n    }\n    didChangeNotebookDocument(event) {\n        const notebookDocument = event.notebook;\n        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());\n        if (syncInfo === undefined) {\n            // We have no changes to the cells. Since the notebook wasn't synced\n            // it will not be synced now.\n            if (event.contentChanges.length === 0) {\n                return;\n            }\n            // Check if we have new matching cells.\n            const cells = this.getMatchingCells(notebookDocument);\n            // No matching cells and the notebook never synced. So still no need\n            // to sync it.\n            if (cells === undefined) {\n                return;\n            }\n            // Open the notebook document and ignore the rest of the changes\n            // this the notebooks will be synced with the correct settings.\n            this.didOpen(notebookDocument, cells, syncInfo);\n        }\n        else {\n            // The notebook is synced. First check if we have no matching\n            // cells anymore and if so close the notebook\n            const cells = this.getMatchingCells(notebookDocument);\n            if (cells === undefined) {\n                this.didClose(notebookDocument, syncInfo);\n                return;\n            }\n            const newEvent = this.asNotebookDocumentChangeEvent(event.notebook, event, syncInfo, cells);\n            if (newEvent !== undefined) {\n                this.doSendChange(newEvent, cells).catch(() => { });\n            }\n        }\n    }\n    didSave(notebookDocument) {\n        const syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString());\n        if (syncInfo === undefined) {\n            return;\n        }\n        this.doSendSave(notebookDocument).catch(() => { });\n    }\n    didClose(notebookDocument, syncInfo = this.notebookSyncInfo.get(notebookDocument.uri.toString())) {\n        if (syncInfo === undefined) {\n            return;\n        }\n        const syncedCells = notebookDocument.getCells().filter(cell => syncInfo.uris.has(cell.document.uri.toString()));\n        this.doSendClose(notebookDocument, syncedCells).catch(() => { });\n    }\n    async sendDidOpenNotebookDocument(notebookDocument) {\n        const cells = this.getMatchingCells(notebookDocument);\n        if (cells === undefined) {\n            return;\n        }\n        return this.doSendOpen(notebookDocument, cells);\n    }\n    async doSendOpen(notebookDocument, cells) {\n        const send = async (notebookDocument, cells) => {\n            const nb = Converter.c2p.asNotebookDocument(notebookDocument, cells, this.client.code2ProtocolConverter);\n            const cellDocuments = cells.map(cell => this.client.code2ProtocolConverter.asTextDocumentItem(cell.document));\n            try {\n                await this.client.sendNotification(proto.DidOpenNotebookDocumentNotification.type, {\n                    notebookDocument: nb,\n                    cellTextDocuments: cellDocuments\n                });\n            }\n            catch (error) {\n                this.client.error('Sending DidOpenNotebookDocumentNotification failed', error);\n                throw error;\n            }\n        };\n        const middleware = this.client.middleware?.notebooks;\n        this.notebookSyncInfo.set(notebookDocument.uri.toString(), SyncInfo.create(cells));\n        return middleware?.didOpen !== undefined ? middleware.didOpen(notebookDocument, cells, send) : send(notebookDocument, cells);\n    }\n    async sendDidChangeNotebookDocument(event) {\n        return this.doSendChange(event, undefined);\n    }\n    async doSendChange(event, cells = this.getMatchingCells(event.notebook)) {\n        const send = async (event) => {\n            try {\n                await this.client.sendNotification(proto.DidChangeNotebookDocumentNotification.type, {\n                    notebookDocument: Converter.c2p.asVersionedNotebookDocumentIdentifier(event.notebook, this.client.code2ProtocolConverter),\n                    change: Converter.c2p.asNotebookDocumentChangeEvent(event, this.client.code2ProtocolConverter)\n                });\n            }\n            catch (error) {\n                this.client.error('Sending DidChangeNotebookDocumentNotification failed', error);\n                throw error;\n            }\n        };\n        const middleware = this.client.middleware?.notebooks;\n        if (event.cells?.structure !== undefined) {\n            this.notebookSyncInfo.set(event.notebook.uri.toString(), SyncInfo.create(cells ?? []));\n        }\n        return middleware?.didChange !== undefined ? middleware?.didChange(event, send) : send(event);\n    }\n    async sendDidSaveNotebookDocument(notebookDocument) {\n        return this.doSendSave(notebookDocument);\n    }\n    async doSendSave(notebookDocument) {\n        const send = async (notebookDocument) => {\n            try {\n                await this.client.sendNotification(proto.DidSaveNotebookDocumentNotification.type, {\n                    notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument.uri) }\n                });\n            }\n            catch (error) {\n                this.client.error('Sending DidSaveNotebookDocumentNotification failed', error);\n                throw error;\n            }\n        };\n        const middleware = this.client.middleware?.notebooks;\n        return middleware?.didSave !== undefined ? middleware.didSave(notebookDocument, send) : send(notebookDocument);\n    }\n    async sendDidCloseNotebookDocument(notebookDocument) {\n        return this.doSendClose(notebookDocument, this.getMatchingCells(notebookDocument) ?? []);\n    }\n    async doSendClose(notebookDocument, cells) {\n        const send = async (notebookDocument, cells) => {\n            try {\n                await this.client.sendNotification(proto.DidCloseNotebookDocumentNotification.type, {\n                    notebookDocument: { uri: this.client.code2ProtocolConverter.asUri(notebookDocument.uri) },\n                    cellTextDocuments: cells.map(cell => this.client.code2ProtocolConverter.asTextDocumentIdentifier(cell.document))\n                });\n            }\n            catch (error) {\n                this.client.error('Sending DidCloseNotebookDocumentNotification failed', error);\n                throw error;\n            }\n        };\n        const middleware = this.client.middleware?.notebooks;\n        this.notebookSyncInfo.delete(notebookDocument.uri.toString());\n        return middleware?.didClose !== undefined ? middleware.didClose(notebookDocument, cells, send) : send(notebookDocument, cells);\n    }\n    asNotebookDocumentChangeEvent(notebook, event, syncInfo, matchingCells) {\n        if (event !== undefined && event.notebook !== notebook) {\n            throw new Error('Notebook must be identical');\n        }\n        const result = {\n            notebook: notebook\n        };\n        if (event?.metadata !== undefined) {\n            result.metadata = Converter.c2p.asMetadata(event.metadata);\n        }\n        let matchingCellsSet;\n        if (event?.cellChanges !== undefined && event.cellChanges.length > 0) {\n            const data = [];\n            // Only consider the new matching cells.\n            matchingCellsSet = new Set(matchingCells.map(cell => cell.document.uri.toString()));\n            for (const cellChange of event.cellChanges) {\n                if (matchingCellsSet.has(cellChange.cell.document.uri.toString()) && (cellChange.executionSummary !== undefined || cellChange.metadata !== undefined)) {\n                    data.push(cellChange.cell);\n                }\n            }\n            if (data.length > 0) {\n                result.cells = result.cells ?? {};\n                result.cells.data = data;\n            }\n        }\n        if (((event?.contentChanges !== undefined && event.contentChanges.length > 0) || event === undefined) && syncInfo !== undefined && matchingCells !== undefined) {\n            // We still have matching cells. Check if the cell changes\n            // affect the notebook on the server side.\n            const oldCells = syncInfo.cells;\n            const newCells = matchingCells;\n            // meta data changes are reported using on the cell itself. So we can ignore comparing\n            // it which has a positive effect on performance.\n            const diff = $NotebookCell.computeDiff(oldCells, newCells, false);\n            let addedCells;\n            let removedCells;\n            if (diff !== undefined) {\n                addedCells = diff.cells === undefined\n                    ? new Map()\n                    : new Map(diff.cells.map(cell => [cell.document.uri.toString(), cell]));\n                removedCells = diff.deleteCount === 0\n                    ? new Map()\n                    : new Map(oldCells.slice(diff.start, diff.start + diff.deleteCount).map(cell => [cell.document.uri.toString(), cell]));\n                // Remove the onces that got deleted and inserted again.\n                for (const key of Array.from(removedCells.keys())) {\n                    if (addedCells.has(key)) {\n                        removedCells.delete(key);\n                        addedCells.delete(key);\n                    }\n                }\n                result.cells = result.cells ?? {};\n                const didOpen = [];\n                const didClose = [];\n                if (addedCells.size > 0 || removedCells.size > 0) {\n                    for (const cell of addedCells.values()) {\n                        didOpen.push(cell);\n                    }\n                    for (const cell of removedCells.values()) {\n                        didClose.push(cell);\n                    }\n                }\n                result.cells.structure = {\n                    array: diff,\n                    didOpen,\n                    didClose\n                };\n            }\n        }\n        // The notebook is a property as well.\n        return Object.keys(result).length > 1 ? result : undefined;\n    }\n    getMatchingCells(notebookDocument, cells = notebookDocument.getCells()) {\n        if (this.options.notebookSelector === undefined) {\n            return undefined;\n        }\n        for (const item of this.options.notebookSelector) {\n            if (item.notebook === undefined || $NotebookDocumentFilter.matchNotebook(item.notebook, notebookDocument)) {\n                const filtered = this.filterCells(notebookDocument, cells, item.cells);\n                return filtered.length === 0 ? undefined : filtered;\n            }\n        }\n        return undefined;\n    }\n    cellMatches(notebookDocument, cell) {\n        const cells = this.getMatchingCells(notebookDocument, [cell]);\n        return cells !== undefined && cells[0] === cell;\n    }\n    filterCells(notebookDocument, cells, cellSelector) {\n        const filtered = cellSelector !== undefined ? cells.filter((cell) => {\n            const cellLanguage = cell.document.languageId;\n            return cellSelector.some((filter => (filter.language === '*' || cellLanguage === filter.language)));\n        }) : cells;\n        return typeof this.client.clientOptions.notebookDocumentOptions?.filterCells === 'function'\n            ? this.client.clientOptions.notebookDocumentOptions.filterCells(notebookDocument, filtered)\n            : filtered;\n    }\n}\nclass NotebookDocumentSyncFeature {\n    constructor(client) {\n        this.client = client;\n        this.registrations = new Map();\n        this.registrationType = proto.NotebookDocumentSyncRegistrationType.type;\n        // We don't receive an event for cells where the document changes its language mode\n        // Since we allow servers to filter on the language mode we fire such an event ourselves.\n        vscode.workspace.onDidOpenTextDocument((textDocument) => {\n            if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {\n                return;\n            }\n            const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);\n            if (notebookDocument === undefined || notebookCell === undefined) {\n                return;\n            }\n            for (const provider of this.registrations.values()) {\n                if (provider instanceof NotebookDocumentSyncFeatureProvider) {\n                    provider.didOpenNotebookCellTextDocument(notebookDocument, notebookCell);\n                }\n            }\n        });\n        vscode.workspace.onDidChangeTextDocument((event) => {\n            if (event.contentChanges.length === 0) {\n                return;\n            }\n            const textDocument = event.document;\n            if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {\n                return;\n            }\n            const [notebookDocument,] = this.findNotebookDocumentAndCell(textDocument);\n            if (notebookDocument === undefined) {\n                return;\n            }\n            for (const provider of this.registrations.values()) {\n                if (provider instanceof NotebookDocumentSyncFeatureProvider) {\n                    provider.didChangeNotebookCellTextDocument(notebookDocument, event);\n                }\n            }\n        });\n        vscode.workspace.onDidCloseTextDocument((textDocument) => {\n            if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {\n                return;\n            }\n            // There are two cases when we receive a close for a text document\n            // 1: the cell got removed. This is handled in `onDidChangeNotebookCells`\n            // 2: the language mode of a cell changed. This keeps the URI stable so\n            //    we will still find the cell and the notebook document.\n            const [notebookDocument, notebookCell] = this.findNotebookDocumentAndCell(textDocument);\n            if (notebookDocument === undefined || notebookCell === undefined) {\n                return;\n            }\n            for (const provider of this.registrations.values()) {\n                if (provider instanceof NotebookDocumentSyncFeatureProvider) {\n                    provider.didCloseNotebookCellTextDocument(notebookDocument, notebookCell);\n                }\n            }\n        });\n    }\n    getState() {\n        if (this.registrations.size === 0) {\n            return { kind: 'document', id: this.registrationType.method, registrations: false, matches: false };\n        }\n        for (const provider of this.registrations.values()) {\n            const state = provider.getState();\n            if (state.kind === 'document' && state.registrations === true && state.matches === true) {\n                return { kind: 'document', id: this.registrationType.method, registrations: true, matches: true };\n            }\n        }\n        return { kind: 'document', id: this.registrationType.method, registrations: true, matches: false };\n    }\n    fillClientCapabilities(capabilities) {\n        const synchronization = ensure(ensure(capabilities, 'notebookDocument'), 'synchronization');\n        synchronization.dynamicRegistration = true;\n        synchronization.executionSummarySupport = true;\n    }\n    preInitialize(capabilities) {\n        const options = capabilities.notebookDocumentSync;\n        if (options === undefined) {\n            return;\n        }\n        this.dedicatedChannel = this.client.protocol2CodeConverter.asDocumentSelector($NotebookDocumentSyncOptions.asDocumentSelector(options));\n    }\n    initialize(capabilities) {\n        const options = capabilities.notebookDocumentSync;\n        if (options === undefined) {\n            return;\n        }\n        const id = options.id ?? UUID.generateUuid();\n        this.register({ id, registerOptions: options });\n    }\n    register(data) {\n        const provider = new NotebookDocumentSyncFeatureProvider(this.client, data.registerOptions);\n        this.registrations.set(data.id, provider);\n    }\n    unregister(id) {\n        const provider = this.registrations.get(id);\n        provider && provider.dispose();\n    }\n    clear() {\n        for (const provider of this.registrations.values()) {\n            provider.dispose();\n        }\n        this.registrations.clear();\n    }\n    handles(textDocument) {\n        if (textDocument.uri.scheme !== NotebookDocumentSyncFeature.CellScheme) {\n            return false;\n        }\n        if (this.dedicatedChannel !== undefined && vscode.languages.match(this.dedicatedChannel, textDocument) > 0) {\n            return true;\n        }\n        for (const provider of this.registrations.values()) {\n            if (provider.handles(textDocument)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    getProvider(notebookCell) {\n        for (const provider of this.registrations.values()) {\n            if (provider.handles(notebookCell.document)) {\n                return provider;\n            }\n        }\n        return undefined;\n    }\n    findNotebookDocumentAndCell(textDocument) {\n        const uri = textDocument.uri.toString();\n        for (const notebookDocument of vscode.workspace.notebookDocuments) {\n            for (const cell of notebookDocument.getCells()) {\n                if (cell.document.uri.toString() === uri) {\n                    return [notebookDocument, cell];\n                }\n            }\n        }\n        return [undefined, undefined];\n    }\n}\nexports.NotebookDocumentSyncFeature = NotebookDocumentSyncFeature;\nNotebookDocumentSyncFeature.CellScheme = 'vscode-notebook-cell';\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}