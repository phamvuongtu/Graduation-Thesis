import { StandaloneServices } from 'vscode/vscode/vs/editor/standalone/browser/standaloneServices';
import { positionFromString, positionToString } from 'vscode/vscode/vs/workbench/services/layout/browser/layoutService';
import { ILayoutService } from 'vscode/vscode/vs/platform/layout/browser/layoutService.service';
import { Event, Emitter } from 'vscode/vscode/vs/base/common/event';
import { getActiveDocument, getWindows, isActiveDocument, getWindow, Dimension, isAncestorUsingFlowTo, getClientArea } from 'vscode/vscode/vs/base/browser/dom';
import { SyncDescriptor } from 'vscode/vscode/vs/platform/instantiation/common/descriptors';
import { IPaneCompositePartService } from 'vscode/vscode/vs/workbench/services/panecomposite/browser/panecomposite.service';
import { IViewDescriptorService } from 'vscode/vscode/vs/workbench/common/views.service';
import { isWindows, isLinux, isChrome, isFirefox, isSafari } from 'vscode/vscode/vs/base/common/platform';
import { coalesce } from 'vscode/vscode/vs/base/common/arrays';
import { IEditorGroupsService } from 'vscode/vscode/vs/workbench/services/editor/common/editorGroupsService.service';
import { IStatusbarService } from 'vscode/vscode/vs/workbench/services/statusbar/browser/statusbar.service';
import { IConfigurationService } from 'vscode/vscode/vs/platform/configuration/common/configuration.service';
import { Disposable, DisposableStore, toDisposable } from 'vscode/vscode/vs/base/common/lifecycle';
import { IAuxiliaryWindowService } from 'vscode/vscode/vs/workbench/services/auxiliaryWindow/browser/auxiliaryWindowService.service';
import { StandaloneCodeEditor } from 'vscode/vscode/vs/editor/standalone/browser/standaloneCodeEditor';
import { IHostService } from 'vscode/vscode/vs/workbench/services/host/browser/host.service';
import { ICodeEditorService } from 'vscode/vscode/vs/editor/browser/services/codeEditorService';
import { getMenuBarVisibility, getTitleBarStyle } from 'vscode/vscode/vs/platform/window/common/window';
import { onRenderWorkbench } from 'vscode/lifecycle';
import { getWorkbenchContainer } from 'vscode/workbench';

class LayoutService extends Disposable {
    constructor(mainContainer = getWorkbenchContainer()) {
        super();
        this.mainContainer = mainContainer;
        this.onDidChangeMainEditorCenteredLayout = Event.None;
        this.whenActiveContainerStylesLoaded = Promise.resolve();
        this._onDidLayoutContainer = this._register(new Emitter());
        this.onDidLayoutContainer = this._onDidLayoutContainer.event;
        this._onDidAddContainer = this._register(new Emitter());
        this.onDidAddContainer = this._onDidAddContainer.event;
        this._onDidRemoveContainer = this._register(new Emitter());
        this.onDidRemoveContainer = this._onDidRemoveContainer.event;
        this._onDidLayoutMainContainer = this._register(new Emitter());
        this.onDidLayoutMainContainer = this._onDidLayoutMainContainer.event;
        this._onDidLayoutActiveContainer = this._register(new Emitter());
        this.onDidLayoutActiveContainer = this._onDidLayoutActiveContainer.event;
        this._onDidChangeActiveContainer = this._register(new Emitter());
        this.onDidChangeActiveContainer = this._onDidChangeActiveContainer.event;
        this.mainContainerOffset = { top: 0, quickPickTop: 0 };
        this.activeContainerOffset = { top: 0, quickPickTop: 0 };
        this.onDidChangeFullscreen = Event.None;
        this.onDidChangeZenMode = Event.None;
        this.onDidChangeWindowMaximized = Event.None;
        this.onDidChangeCenteredLayout = Event.None;
        this._onDidChangePanelPosition = this._register(new Emitter());
        this.onDidChangePanelPosition = this._onDidChangePanelPosition.event;
        this._onDidChangeSideBarPosition = this._register(new Emitter());
        this.onDidChangeSideBarPosition = this._onDidChangeSideBarPosition.event;
        this.onDidChangePanelAlignment = Event.None;
        this.onDidChangeNotificationsVisibility = Event.None;
        this.openedDefaultEditors = false;
        this.whenRestored = Promise.resolve();
        this.parts = new Map();
        this.hiddenParts = new Set();
        this._onDidChangePartVisibility = new Emitter();
        this.onDidChangePartVisibility = this._onDidChangePartVisibility.event;
        this.offset = { top: 0, quickPickTop: 0 };
        this._onDidLayout = new Emitter();
        this.onDidLayout = this._onDidLayout.event;
        window.addEventListener('resize', () => this.layout());
        this.layout();
        const platformClass = isWindows ? 'windows' : isLinux ? 'linux' : 'mac';
        const workbenchClasses = coalesce([
            'monaco-workbench',
            platformClass,
            'web',
            isChrome ? 'chromium' : isFirefox ? 'firefox' : isSafari ? 'safari' : undefined
        ]);
        mainContainer.classList.add(...workbenchClasses);
        document.body.classList.add(platformClass);
        document.body.classList.add('web');
    }
    whenContainerStylesLoaded() {
        return undefined;
    }
    hasMainWindowBorder() {
        return false;
    }
    getMainWindowBorderRadius() {
        return undefined;
    }
    isMainEditorLayoutCentered() {
        return false;
    }
    centerMainEditorLayout() {
    }
    get activeContainer() { return this.getContainerFromDocument(getActiveDocument()); }
    get containers() {
        const containers = [];
        for (const { window } of getWindows()) {
            containers.push(this.getContainerFromDocument(window.document));
        }
        return containers;
    }
    getContainerFromDocument(document) {
        if (document === this.mainContainer.ownerDocument) {
            return this.mainContainer;
        }
        else {
            return document.body.getElementsByClassName('monaco-workbench')[0];
        }
    }
    init(accessor) {
        this.editorGroupService = accessor.get(IEditorGroupsService);
        this.paneCompositeService = accessor.get(IPaneCompositePartService);
        this.statusBarService = accessor.get(IStatusbarService);
        this.viewDescriptorService = accessor.get(IViewDescriptorService);
        this.configurationService = accessor.get(IConfigurationService);
        this.auxiliaryWindowService = accessor.get(IAuxiliaryWindowService);
        this.hostService = accessor.get(IHostService);
        this._register(this.configurationService.onDidChangeConfiguration((e) => {
            if (e.affectsConfiguration("workbench.activityBar.location" )) {
                this.setPartHidden(this.isActivityBarHidden(), "workbench.parts.activitybar" );
            }
            if (e.affectsConfiguration('workbench.statusBar.visible')) {
                this.setPartHidden(!this.configurationService.getValue('workbench.statusBar.visible'), "workbench.parts.statusbar" );
            }
            if (e.affectsConfiguration('workbench.sideBar.location')) {
                this.setSideBarPosition(positionFromString(this.configurationService.getValue('workbench.sideBar.location') ?? 'left'));
            }
            if (e.affectsConfiguration('workbench.panel.defaultLocation')) {
                this.setPanelPosition(positionFromString(this.configurationService.getValue('workbench.panel.defaultLocation') ?? 'bottom'));
            }
        }));
        this.setPartHidden(this.isActivityBarHidden(), "workbench.parts.activitybar" );
        this.setPartHidden(!this.configurationService.getValue('workbench.statusBar.visible'), "workbench.parts.statusbar" );
        this.sideBarPosition = positionFromString(this.configurationService.getValue('workbench.sideBar.location') ?? 'left');
        this.panelPosition = positionFromString(this.configurationService.getValue('workbench.panel.defaultLocation') ?? 'bottom');
        this._register(this.hostService.onDidChangeActiveWindow(() => this.onActiveWindowChanged()));
        this._register(this.auxiliaryWindowService.onDidOpenAuxiliaryWindow(({ window, disposables }) => {
            this._onDidAddContainer.fire({ container: window.container, disposables: new DisposableStore() });
            disposables.add(window.onDidLayout(dimension => this.handleContainerDidLayout(window.container, dimension)));
            disposables.add(toDisposable(() => this._onDidRemoveContainer.fire(window.container)));
        }));
    }
    handleContainerDidLayout(container, dimension) {
        if (container === this.mainContainer) {
            this._onDidLayoutMainContainer.fire(dimension);
        }
        if (isActiveDocument(container)) {
            this._onDidLayoutActiveContainer.fire(dimension);
        }
    }
    getActiveContainerId() {
        const activeContainer = this.activeContainer;
        return getWindow(activeContainer).vscodeWindowId;
    }
    onActiveWindowChanged() {
        const activeContainerId = this.getActiveContainerId();
        if (this.activeContainerId !== activeContainerId) {
            this.activeContainerId = activeContainerId;
            this._onDidChangeActiveContainer.fire();
        }
    }
    isActivityBarHidden() {
        const oldValue = this.configurationService.getValue('workbench.activityBar.visible');
        if (oldValue !== undefined) {
            return !oldValue;
        }
        return this.configurationService.getValue("workbench.activityBar.location" ) !== "default" ;
    }
    focusPart(part) {
        switch (part) {
            case "workbench.parts.editor" :
                this.editorGroupService.activeGroup.focus();
                break;
            case "workbench.parts.panel" : {
                const activePanel = this.paneCompositeService.getActivePaneComposite(1 );
                activePanel?.focus();
                break;
            }
            case "workbench.parts.sidebar" : {
                const activeViewlet = this.paneCompositeService.getActivePaneComposite(0 );
                activeViewlet?.focus();
                break;
            }
            case "workbench.parts.activitybar" :
                this.getPart("workbench.parts.activitybar" ).focus();
                break;
            case "workbench.parts.statusbar" :
                this.statusBarService.focus();
                break;
            default: {
                const container = this.getContainer(part);
                container?.focus();
            }
        }
    }
    getDimension(part) {
        return this.getPart(part)?.dimension;
    }
    toggleMaximizedPanel() {
    }
    toggleMenuBar() {
        let currentVisibilityValue = getMenuBarVisibility(this.configurationService);
        if (typeof currentVisibilityValue !== 'string') {
            currentVisibilityValue = 'classic';
        }
        let newVisibilityValue;
        if (currentVisibilityValue === 'visible' || currentVisibilityValue === 'classic') {
            newVisibilityValue = getTitleBarStyle(this.configurationService) === 'native' ? 'toggle' : 'compact';
        }
        else {
            newVisibilityValue = 'classic';
        }
        void this.configurationService.updateValue('window.menuBarVisibility', newVisibilityValue);
    }
    setPanelPosition(position) {
        this.panelPosition = position;
        const panelPart = this.getPart("workbench.parts.panel" );
        panelPart?.updateStyles();
        this._onDidChangePanelPosition.fire(positionToString(position));
    }
    getPanelAlignment() {
        return 'left';
    }
    setPanelAlignment() {
    }
    toggleZenMode() {
    }
    isEditorLayoutCentered() {
        return false;
    }
    centerEditorLayout() {
    }
    resizePart() {
    }
    isWindowMaximized() {
        return false;
    }
    updateWindowMaximizedState() {
    }
    getVisibleNeighborPart() {
        return undefined;
    }
    getMaximumEditorDimensions() {
        return new Dimension(Infinity, Infinity);
    }
    isPanelMaximized() {
        return false;
    }
    getPanelPosition() {
        return this.panelPosition;
    }
    hasFocus(part) {
        const activeElement = document.activeElement;
        if (activeElement == null) {
            return false;
        }
        const container = this.getContainer(part);
        return !(container == null) && isAncestorUsingFlowTo(activeElement, container);
    }
    getContainer(windowOrPart) {
        if (typeof windowOrPart === 'string') {
            if (this.parts.get(windowOrPart) == null) {
                return undefined;
            }
            return this.getPart(windowOrPart)?.getContainer();
        }
        else {
            if (windowOrPart.document === this.mainContainer.ownerDocument) {
                return this.mainContainer;
            }
            else {
                return windowOrPart.document.body.getElementsByClassName('monaco-workbench')[0];
            }
        }
    }
    getPart(key) {
        return this.parts.get(key);
    }
    hasViews(id) {
        const viewContainer = this.viewDescriptorService.getViewContainerById(id);
        if (viewContainer == null) {
            return false;
        }
        const viewContainerModel = this.viewDescriptorService.getViewContainerModel(viewContainer);
        if (viewContainerModel == null) {
            return false;
        }
        return viewContainerModel.activeViewDescriptors.length >= 1;
    }
    setPartHidden(hidden, part) {
        if (hidden) {
            this.hiddenParts.add(part);
        }
        else {
            this.hiddenParts.delete(part);
        }
        this._onDidChangePartVisibility.fire();
        const location = {
            ["workbench.parts.sidebar" ]: 0 ,
            ["workbench.parts.auxiliarybar" ]: 2 ,
            ["workbench.parts.panel" ]: 1
        }[part];
        if (location != null) {
            const paneComposite = this.paneCompositeService.getActivePaneComposite(location);
            if (paneComposite != null && hidden) {
                this.paneCompositeService.hideActivePaneComposite(location);
            }
            else if (paneComposite == null && !hidden) {
                let panelToOpen = this.paneCompositeService.getLastActivePaneCompositeId(location);
                if (panelToOpen == null || !this.hasViews(panelToOpen)) {
                    panelToOpen = this.viewDescriptorService
                        .getViewContainersByLocation(location)
                        .find(viewContainer => this.hasViews(viewContainer.id))?.id;
                }
                if (panelToOpen != null) {
                    void this.paneCompositeService.openPaneComposite(panelToOpen, location, true);
                }
            }
        }
        this.getPart(part)?.setVisible(!hidden);
    }
    isVisible(part) {
        return !( this.hiddenParts.has(part));
    }
    getSideBarPosition() {
        return this.sideBarPosition;
    }
    setSideBarPosition(position) {
        this.sideBarPosition = position;
        const activityBar = this.getPart("workbench.parts.activitybar" );
        const sideBar = this.getPart("workbench.parts.sidebar" );
        const auxiliaryBar = this.getPart("workbench.parts.auxiliarybar" );
        activityBar?.updateStyles();
        sideBar?.updateStyles();
        auxiliaryBar?.updateStyles();
        this._onDidChangeSideBarPosition.fire(positionToString(position));
    }
    registerPart(part) {
        const id = part.getId();
        this.parts.set(id, part);
        return toDisposable(() => this.parts.delete(id));
    }
    isRestored() {
        return true;
    }
    get mainContainerDimension() { return this._mainContainerDimension; }
    get activeContainerDimension() {
        const activeContainer = this.activeContainer;
        if (activeContainer === this.mainContainer) {
            return this.mainContainerDimension;
        }
        else {
            return getClientArea(activeContainer);
        }
    }
    layout() {
        this._mainContainerDimension = getClientArea(window.document.body);
        this._onDidLayout.fire(this._mainContainerDimension);
    }
    get hasContainer() {
        return true;
    }
    focus() {
        const activeContainer = this.activeContainer;
        if (activeContainer === this.mainContainer) {
            const focusedCodeEditor = StandaloneServices.get(ICodeEditorService).getFocusedCodeEditor();
            if (focusedCodeEditor instanceof StandaloneCodeEditor) {
                focusedCodeEditor.focus();
            }
            else {
                this.focusPart("workbench.parts.editor" );
            }
        }
        else {
            this.editorGroupService.getPart(activeContainer).activeGroup.focus();
        }
    }
}
onRenderWorkbench((accessor) => {
    const layoutService = accessor.get(ILayoutService);
    if (layoutService instanceof LayoutService) {
        layoutService.init(accessor);
    }
});
function getServiceOverride(container) {
    return {
        [( ILayoutService.toString())]: new SyncDescriptor(LayoutService, [container], true)
    };
}

export { LayoutService, getServiceOverride as default };
