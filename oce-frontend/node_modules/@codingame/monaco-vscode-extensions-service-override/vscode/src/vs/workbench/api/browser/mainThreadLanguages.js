import { __decorate, __param } from 'vscode/external/tslib/tslib.es6.js';
import { URI } from 'vscode/vscode/vs/base/common/uri';
import { ILanguageService } from 'vscode/vscode/vs/editor/common/languages/language';
import { IModelService } from 'vscode/vscode/vs/editor/common/services/model';
import { ExtHostContext, MainContext } from 'vscode/vscode/vs/workbench/api/common/extHost.protocol';
import { extHostNamedCustomer } from '../../services/extensions/common/extHostCustomers.js';
import { Range } from 'vscode/vscode/vs/editor/common/core/range';
import { ITextModelService } from 'vscode/vscode/vs/editor/common/services/resolverService';
import { ILanguageStatusService } from 'vscode/vscode/vs/workbench/services/languageStatus/common/languageStatusService.service';
import { DisposableStore, DisposableMap } from 'vscode/vscode/vs/base/common/lifecycle';

let MainThreadLanguages = class MainThreadLanguages {
    constructor(_extHostContext, _languageService, _modelService, _resolverService, _languageStatusService) {
        this._languageService = _languageService;
        this._modelService = _modelService;
        this._resolverService = _resolverService;
        this._languageStatusService = _languageStatusService;
        this._disposables = ( new DisposableStore());
        this._status = ( new DisposableMap());
        this._proxy = ( _extHostContext.getProxy(ExtHostContext.ExtHostLanguages));
        this._proxy.$acceptLanguageIds(_languageService.getRegisteredLanguageIds());
        this._disposables.add(_languageService.onDidChange(_ => {
            this._proxy.$acceptLanguageIds(_languageService.getRegisteredLanguageIds());
        }));
    }
    dispose() {
        this._disposables.dispose();
        this._status.dispose();
    }
    async $changeLanguage(resource, languageId) {
        if (!this._languageService.isRegisteredLanguageId(languageId)) {
            return Promise.reject(( new Error(`Unknown language id: ${languageId}`)));
        }
        const uri = URI.revive(resource);
        const ref = await this._resolverService.createModelReference(uri);
        try {
            ref.object.textEditorModel.setLanguage(this._languageService.createById(languageId));
        }
        finally {
            ref.dispose();
        }
    }
    async $tokensAtPosition(resource, position) {
        const uri = URI.revive(resource);
        const model = this._modelService.getModel(uri);
        if (!model) {
            return undefined;
        }
        model.tokenization.tokenizeIfCheap(position.lineNumber);
        const tokens = model.tokenization.getLineTokens(position.lineNumber);
        const idx = tokens.findTokenIndexAtOffset(position.column - 1);
        return {
            type: tokens.getStandardTokenType(idx),
            range: ( new Range(
                position.lineNumber,
                1 + tokens.getStartOffset(idx),
                position.lineNumber,
                1 + tokens.getEndOffset(idx)
            ))
        };
    }
    $setLanguageStatus(handle, status) {
        this._status.get(handle)?.dispose();
        this._status.set(handle, this._languageStatusService.addStatus(status));
    }
    $removeLanguageStatus(handle) {
        this._status.get(handle)?.dispose();
    }
};
MainThreadLanguages = __decorate([
    extHostNamedCustomer(MainContext.MainThreadLanguages),
    ( __param(1, ILanguageService)),
    ( __param(2, IModelService)),
    ( __param(3, ITextModelService)),
    ( __param(4, ILanguageStatusService))
], MainThreadLanguages);

export { MainThreadLanguages };
