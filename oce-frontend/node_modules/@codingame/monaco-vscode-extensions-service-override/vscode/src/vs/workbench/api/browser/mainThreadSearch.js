import { __decorate, __param } from 'vscode/external/tslib/tslib.es6.js';
import { CancellationToken } from 'vscode/vscode/vs/base/common/cancellation';
import { dispose, DisposableStore } from 'vscode/vscode/vs/base/common/lifecycle';
import { URI } from 'vscode/vscode/vs/base/common/uri';
import { IConfigurationService } from 'vscode/vscode/vs/platform/configuration/common/configuration.service';
import { ITelemetryService } from 'vscode/vscode/vs/platform/telemetry/common/telemetry.service';
import { extHostNamedCustomer } from '../../services/extensions/common/extHostCustomers.js';
import { ISearchService } from 'vscode/vscode/vs/workbench/services/search/common/search.service';
import { ExtHostContext, MainContext } from 'vscode/vscode/vs/workbench/api/common/extHost.protocol';
import { revive } from 'vscode/vscode/vs/base/common/marshalling';
import { SearchContext } from 'vscode/vscode/vs/workbench/contrib/search/common/constants';
import { IContextKeyService } from 'vscode/vscode/vs/platform/contextkey/common/contextkey.service';

let MainThreadSearch = class MainThreadSearch {
    constructor(extHostContext, _searchService, _telemetryService, _configurationService, contextKeyService) {
        this._searchService = _searchService;
        this._telemetryService = _telemetryService;
        this.contextKeyService = contextKeyService;
        this._searchProvider = ( new Map());
        this._proxy = ( extHostContext.getProxy(ExtHostContext.ExtHostSearch));
        this._proxy.$enableExtensionHostSearch();
    }
    dispose() {
        this._searchProvider.forEach(value => value.dispose());
        this._searchProvider.clear();
    }
    $registerTextSearchProvider(handle, scheme) {
        this._searchProvider.set(handle, ( new RemoteSearchProvider(
            this._searchService,
            1 ,
            scheme,
            handle,
            this._proxy
        )));
    }
    $registerAITextSearchProvider(handle, scheme) {
        SearchContext.hasAIResultProvider.bindTo(this.contextKeyService).set(true);
        this._searchProvider.set(handle, ( new RemoteSearchProvider(
            this._searchService,
            2 ,
            scheme,
            handle,
            this._proxy
        )));
    }
    $registerFileSearchProvider(handle, scheme) {
        this._searchProvider.set(handle, ( new RemoteSearchProvider(
            this._searchService,
            0 ,
            scheme,
            handle,
            this._proxy
        )));
    }
    $unregisterProvider(handle) {
        dispose(this._searchProvider.get(handle));
        this._searchProvider.delete(handle);
    }
    $handleFileMatch(handle, session, data) {
        const provider = this._searchProvider.get(handle);
        if (!provider) {
            throw ( new Error('Got result for unknown provider'));
        }
        provider.handleFindMatch(session, data);
    }
    $handleTextMatch(handle, session, data) {
        const provider = this._searchProvider.get(handle);
        if (!provider) {
            throw ( new Error('Got result for unknown provider'));
        }
        provider.handleFindMatch(session, data);
    }
    $handleTelemetry(eventName, data) {
        this._telemetryService.publicLog(eventName, data);
    }
};
MainThreadSearch = __decorate([
    extHostNamedCustomer(MainContext.MainThreadSearch),
    ( __param(1, ISearchService)),
    ( __param(2, ITelemetryService)),
    ( __param(3, IConfigurationService)),
    ( __param(4, IContextKeyService))
], MainThreadSearch);
class SearchOperation {
    static { this._idPool = 0; }
    constructor(progress, id = ++SearchOperation._idPool, matches = ( new Map())) {
        this.progress = progress;
        this.id = id;
        this.matches = matches;
    }
    addMatch(match) {
        const existingMatch = this.matches.get(( match.resource.toString()));
        if (existingMatch) {
            if (existingMatch.results && match.results) {
                existingMatch.results.push(...match.results);
            }
        }
        else {
            this.matches.set(( match.resource.toString()), match);
        }
        this.progress?.(match);
    }
}
class RemoteSearchProvider {
    constructor(searchService, type, _scheme, _handle, _proxy) {
        this._scheme = _scheme;
        this._handle = _handle;
        this._proxy = _proxy;
        this._registrations = ( new DisposableStore());
        this._searches = ( new Map());
        this._registrations.add(searchService.registerSearchResultProvider(this._scheme, type, this));
    }
    dispose() {
        this._registrations.dispose();
    }
    fileSearch(query, token = CancellationToken.None) {
        return this.doSearch(query, undefined, token);
    }
    textSearch(query, onProgress, token = CancellationToken.None) {
        return this.doSearch(query, onProgress, token);
    }
    doSearch(query, onProgress, token = CancellationToken.None) {
        if (!query.folderQueries.length) {
            throw ( new Error('Empty folderQueries'));
        }
        const search = ( new SearchOperation(onProgress));
        this._searches.set(search.id, search);
        const searchP = this._provideSearchResults(query, search.id, token);
        return Promise.resolve(searchP).then((result) => {
            this._searches.delete(search.id);
            return { results: Array.from(( search.matches.values())), stats: result.stats, limitHit: result.limitHit, messages: result.messages };
        }, err => {
            this._searches.delete(search.id);
            return Promise.reject(err);
        });
    }
    clearCache(cacheKey) {
        return Promise.resolve(this._proxy.$clearCache(cacheKey));
    }
    handleFindMatch(session, dataOrUri) {
        const searchOp = this._searches.get(session);
        if (!searchOp) {
            return;
        }
        dataOrUri.forEach(result => {
            if (result.results) {
                searchOp.addMatch(revive(result));
            }
            else {
                searchOp.addMatch({
                    resource: URI.revive(result)
                });
            }
        });
    }
    _provideSearchResults(query, session, token) {
        switch (query.type) {
            case 1 :
                return this._proxy.$provideFileSearchResults(this._handle, session, query, token);
            case 2 :
                return this._proxy.$provideTextSearchResults(this._handle, session, query, token);
            default:
                return this._proxy.$provideAITextSearchResults(this._handle, session, query, token);
        }
    }
}

export { MainThreadSearch };
