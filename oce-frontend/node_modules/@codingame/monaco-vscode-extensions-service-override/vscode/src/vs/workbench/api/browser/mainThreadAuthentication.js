import { __decorate, __param } from 'vscode/external/tslib/tslib.es6.js';
import { Disposable, DisposableMap } from 'vscode/vscode/vs/base/common/lifecycle';
import { localizeWithPath } from 'vscode/vscode/vs/nls';
import { extHostNamedCustomer } from '../../services/extensions/common/extHostCustomers.js';
import { IAuthenticationService, IAuthenticationExtensionsService } from 'vscode/vscode/vs/workbench/services/authentication/common/authentication.service';
import { ExtHostContext, MainContext } from 'vscode/vscode/vs/workbench/api/common/extHost.protocol';
import { IDialogService } from 'vscode/vscode/vs/platform/dialogs/common/dialogs.service';
import Severity$1 from 'vscode/vscode/vs/base/common/severity';
import { INotificationService } from 'vscode/vscode/vs/platform/notification/common/notification.service';
import { IExtensionService } from 'vscode/vscode/vs/workbench/services/extensions/common/extensions.service';
import { ITelemetryService } from 'vscode/vscode/vs/platform/telemetry/common/telemetry.service';
import { Emitter } from 'vscode/vscode/vs/base/common/event';
import { IAuthenticationAccessService } from 'vscode/vscode/vs/workbench/services/authentication/browser/authenticationAccessService.service';
import { IAuthenticationUsageService } from 'vscode/vscode/vs/workbench/services/authentication/browser/authenticationUsageService.service';
import { getAuthenticationProviderActivationEvent } from 'vscode/vscode/vs/workbench/services/authentication/browser/authenticationService';
import { URI } from 'vscode/vscode/vs/base/common/uri';
import { IOpenerService } from 'vscode/vscode/vs/platform/opener/common/opener.service';

const _moduleId = "vs/workbench/api/browser/mainThreadAuthentication";
class MainThreadAuthenticationProvider extends Disposable {
    constructor(_proxy, id, label, supportsMultipleAccounts, notificationService, onDidChangeSessionsEmitter) {
        super();
        this._proxy = _proxy;
        this.id = id;
        this.label = label;
        this.supportsMultipleAccounts = supportsMultipleAccounts;
        this.notificationService = notificationService;
        this.onDidChangeSessions = onDidChangeSessionsEmitter.event;
    }
    async getSessions(scopes) {
        return this._proxy.$getSessions(this.id, scopes);
    }
    createSession(scopes, options) {
        return this._proxy.$createSession(this.id, scopes, options);
    }
    async removeSession(sessionId) {
        await this._proxy.$removeSession(this.id, sessionId);
        this.notificationService.info(( localizeWithPath(_moduleId, 0, "Successfully signed out.")));
    }
}
let MainThreadAuthentication = class MainThreadAuthentication extends Disposable {
    constructor(extHostContext, authenticationService, authenticationExtensionsService, authenticationAccessService, authenticationUsageService, dialogService, notificationService, extensionService, telemetryService, openerService) {
        super();
        this.authenticationService = authenticationService;
        this.authenticationExtensionsService = authenticationExtensionsService;
        this.authenticationAccessService = authenticationAccessService;
        this.authenticationUsageService = authenticationUsageService;
        this.dialogService = dialogService;
        this.notificationService = notificationService;
        this.extensionService = extensionService;
        this.telemetryService = telemetryService;
        this.openerService = openerService;
        this._registrations = this._register(( (new DisposableMap())));
        this._proxy = ( (extHostContext.getProxy(ExtHostContext.ExtHostAuthentication)));
        this._register(this.authenticationService.onDidChangeSessions(e => {
            this._proxy.$onDidChangeAuthenticationSessions(e.providerId, e.label);
        }));
    }
    async $registerAuthenticationProvider(id, label, supportsMultipleAccounts) {
        const emitter = ( (new Emitter()));
        this._registrations.set(id, emitter);
        const provider = ( (new MainThreadAuthenticationProvider(
            this._proxy,
            id,
            label,
            supportsMultipleAccounts,
            this.notificationService,
            emitter
        )));
        this.authenticationService.registerAuthenticationProvider(id, provider);
    }
    $unregisterAuthenticationProvider(id) {
        this._registrations.deleteAndDispose(id);
        this.authenticationService.unregisterAuthenticationProvider(id);
    }
    async $ensureProvider(id) {
        if (!this.authenticationService.isAuthenticationProviderRegistered(id)) {
            return await this.extensionService.activateByEvent(getAuthenticationProviderActivationEvent(id), 1 );
        }
    }
    $sendDidChangeSessions(providerId, event) {
        const obj = this._registrations.get(providerId);
        if (obj instanceof Emitter) {
            obj.fire(event);
        }
    }
    $removeSession(providerId, sessionId) {
        return this.authenticationService.removeSession(providerId, sessionId);
    }
    async loginPrompt(providerName, extensionName, recreatingSession, options) {
        const message = recreatingSession
            ? ( localizeWithPath(
            _moduleId,
            1,
            "The extension '{0}' wants you to sign in again using {1}.",
            extensionName,
            providerName
        ))
            : ( localizeWithPath(
            _moduleId,
            2,
            "The extension '{0}' wants to sign in using {1}.",
            extensionName,
            providerName
        ));
        const buttons = [
            {
                label: ( localizeWithPath(_moduleId, 3, "&&Allow")),
                run() {
                    return true;
                },
            }
        ];
        if (options?.learnMore) {
            buttons.push({
                label: ( localizeWithPath(_moduleId, 4, "Learn more")),
                run: async () => {
                    const result = this.loginPrompt(providerName, extensionName, recreatingSession, options);
                    await this.openerService.open(URI.revive(options.learnMore), { allowCommands: true });
                    return await result;
                }
            });
        }
        const { result } = await this.dialogService.prompt({
            type: Severity$1.Info,
            message,
            buttons,
            detail: options?.detail,
            cancelButton: true,
        });
        return result ?? false;
    }
    async doGetSession(providerId, scopes, extensionId, extensionName, options) {
        const sessions = await this.authenticationService.getSessions(providerId, scopes, true);
        const provider = this.authenticationService.getProvider(providerId);
        if (options.forceNewSession && options.createIfNone) {
            throw ( (new Error(
                'Invalid combination of options. Please remove one of the following: forceNewSession, createIfNone'
            )));
        }
        if (options.forceNewSession && options.silent) {
            throw ( (new Error(
                'Invalid combination of options. Please remove one of the following: forceNewSession, silent'
            )));
        }
        if (options.createIfNone && options.silent) {
            throw ( (new Error(
                'Invalid combination of options. Please remove one of the following: createIfNone, silent'
            )));
        }
        if (!options.forceNewSession && sessions.length) {
            if (provider.supportsMultipleAccounts) {
                if (options.clearSessionPreference) {
                    this.authenticationExtensionsService.removeSessionPreference(providerId, extensionId, scopes);
                }
                else {
                    const existingSessionPreference = this.authenticationExtensionsService.getSessionPreference(providerId, extensionId, scopes);
                    if (existingSessionPreference) {
                        const matchingSession = sessions.find(session => session.id === existingSessionPreference);
                        if (matchingSession && this.authenticationAccessService.isAccessAllowed(providerId, matchingSession.account.label, extensionId)) {
                            return matchingSession;
                        }
                    }
                }
            }
            else if (this.authenticationAccessService.isAccessAllowed(providerId, sessions[0].account.label, extensionId)) {
                return sessions[0];
            }
        }
        if (options.createIfNone || options.forceNewSession) {
            let uiOptions;
            if (typeof options.forceNewSession === 'object') {
                uiOptions = options.forceNewSession;
            }
            const recreatingSession = !!(options.forceNewSession && sessions.length);
            const isAllowed = await this.loginPrompt(provider.label, extensionName, recreatingSession, uiOptions);
            if (!isAllowed) {
                throw ( (new Error('User did not consent to login.')));
            }
            let session;
            if (sessions?.length && !options.forceNewSession) {
                session = provider.supportsMultipleAccounts
                    ? await this.authenticationExtensionsService.selectSession(providerId, extensionId, extensionName, scopes, sessions)
                    : sessions[0];
            }
            else {
                let sessionToRecreate;
                if (typeof options.forceNewSession === 'object' && options.forceNewSession.sessionToRecreate) {
                    sessionToRecreate = options.forceNewSession.sessionToRecreate;
                }
                else {
                    const sessionIdToRecreate = this.authenticationExtensionsService.getSessionPreference(providerId, extensionId, scopes);
                    sessionToRecreate = sessionIdToRecreate ? sessions.find(session => session.id === sessionIdToRecreate) : undefined;
                }
                session = await this.authenticationService.createSession(providerId, scopes, { activateImmediate: true, sessionToRecreate });
            }
            this.authenticationAccessService.updateAllowedExtensions(providerId, session.account.label, [{ id: extensionId, name: extensionName, allowed: true }]);
            this.authenticationExtensionsService.updateSessionPreference(providerId, extensionId, session);
            return session;
        }
        const validSession = sessions.find(session => this.authenticationAccessService.isAccessAllowed(providerId, session.account.label, extensionId));
        if (validSession) {
            return validSession;
        }
        if (!options.silent) {
            sessions.length
                ? this.authenticationExtensionsService.requestSessionAccess(providerId, extensionId, extensionName, scopes, sessions)
                : await this.authenticationExtensionsService.requestNewSession(providerId, scopes, extensionId, extensionName);
        }
        return undefined;
    }
    async $getSession(providerId, scopes, extensionId, extensionName, options) {
        const session = await this.doGetSession(providerId, scopes, extensionId, extensionName, options);
        if (session) {
            this.sendProviderUsageTelemetry(extensionId, providerId);
            this.authenticationUsageService.addAccountUsage(providerId, session.account.label, extensionId, extensionName);
        }
        return session;
    }
    async $getSessions(providerId, scopes, extensionId, extensionName) {
        const sessions = await this.authenticationService.getSessions(providerId, [...scopes], true);
        const accessibleSessions = sessions.filter(s => this.authenticationAccessService.isAccessAllowed(providerId, s.account.label, extensionId));
        if (accessibleSessions.length) {
            this.sendProviderUsageTelemetry(extensionId, providerId);
            for (const session of accessibleSessions) {
                this.authenticationUsageService.addAccountUsage(providerId, session.account.label, extensionId, extensionName);
            }
        }
        return accessibleSessions;
    }
    sendProviderUsageTelemetry(extensionId, providerId) {
        this.telemetryService.publicLog2('authentication.providerUsage', { providerId, extensionId });
    }
};
MainThreadAuthentication = __decorate([
    extHostNamedCustomer(MainContext.MainThreadAuthentication),
    ( (__param(1, IAuthenticationService))),
    ( (__param(2, IAuthenticationExtensionsService))),
    ( (__param(3, IAuthenticationAccessService))),
    ( (__param(4, IAuthenticationUsageService))),
    ( (__param(5, IDialogService))),
    ( (__param(6, INotificationService))),
    ( (__param(7, IExtensionService))),
    ( (__param(8, ITelemetryService))),
    ( (__param(9, IOpenerService)))
], MainThreadAuthentication);

export { MainThreadAuthentication, MainThreadAuthenticationProvider };
