import { __decorate, __param } from 'vscode/external/tslib/tslib.es6.js';
import { Action } from 'vscode/vscode/vs/base/common/actions';
import { CancellationToken } from 'vscode/vscode/vs/base/common/cancellation';
import { FileAccess } from 'vscode/vscode/vs/base/common/network';
import Severity$1 from 'vscode/vscode/vs/base/common/severity';
import { URI } from 'vscode/vscode/vs/base/common/uri';
import { localizeWithPath } from 'vscode/vscode/vs/nls';
import { ICommandService } from 'vscode/vscode/vs/platform/commands/common/commands.service';
import { areSameExtensions } from 'vscode/vscode/vs/platform/extensionManagement/common/extensionManagementUtil';
import { INotificationService } from 'vscode/vscode/vs/platform/notification/common/notification.service';
import { WebSocketRemoteConnection, ManagedRemoteConnection } from 'vscode/vscode/vs/platform/remote/common/remoteAuthorityResolver';
import { ExtHostContext, MainContext } from 'vscode/vscode/vs/workbench/api/common/extHost.protocol';
import { IExtensionsWorkbenchService } from 'vscode/vscode/vs/workbench/contrib/extensions/common/extensions.service';
import { IWorkbenchEnvironmentService } from 'vscode/vscode/vs/workbench/services/environment/common/environmentService.service';
import { IWorkbenchExtensionEnablementService } from 'vscode/vscode/vs/workbench/services/extensionManagement/common/extensionManagement.service';
import { IExtensionService } from 'vscode/vscode/vs/workbench/services/extensions/common/extensions.service';
import { extHostNamedCustomer } from '../../services/extensions/common/extHostCustomers.js';
import { IHostService } from 'vscode/vscode/vs/workbench/services/host/browser/host.service';
import { ITimerService } from 'vscode/vscode/vs/workbench/services/timer/browser/timerService.service';

const _moduleId = "vs/workbench/api/browser/mainThreadExtensionService";
let MainThreadExtensionService = class MainThreadExtensionService {
    constructor(extHostContext, _extensionService, _notificationService, _extensionsWorkbenchService, _hostService, _extensionEnablementService, _timerService, _commandService, _environmentService) {
        this._extensionService = _extensionService;
        this._notificationService = _notificationService;
        this._extensionsWorkbenchService = _extensionsWorkbenchService;
        this._hostService = _hostService;
        this._extensionEnablementService = _extensionEnablementService;
        this._timerService = _timerService;
        this._commandService = _commandService;
        this._environmentService = _environmentService;
        this._extensionHostKind = extHostContext.extensionHostKind;
        const internalExtHostContext = extHostContext;
        this._internalExtensionService = internalExtHostContext.internalExtensionService;
        internalExtHostContext._setExtensionHostProxy(( (new ExtensionHostProxy(
             (extHostContext.getProxy(ExtHostContext.ExtHostExtensionService))
        ))));
        internalExtHostContext._setAllMainProxyIdentifiers(( (( (Object.keys(MainContext))).map((key) => MainContext[key]))));
    }
    dispose() {
    }
    $getExtension(extensionId) {
        return this._extensionService.getExtension(extensionId);
    }
    $activateExtension(extensionId, reason) {
        return this._internalExtensionService._activateById(extensionId, reason);
    }
    async $onWillActivateExtension(extensionId) {
        this._internalExtensionService._onWillActivateExtension(extensionId);
    }
    $onDidActivateExtension(extensionId, codeLoadingTime, activateCallTime, activateResolvedTime, activationReason) {
        this._internalExtensionService._onDidActivateExtension(extensionId, codeLoadingTime, activateCallTime, activateResolvedTime, activationReason);
    }
    $onExtensionRuntimeError(extensionId, data) {
        const error = ( (new Error()));
        error.name = data.name;
        error.message = data.message;
        error.stack = data.stack;
        this._internalExtensionService._onExtensionRuntimeError(extensionId, error);
        console.error(`[${extensionId.value}]${error.message}`);
        console.error(error.stack);
    }
    async $onExtensionActivationError(extensionId, data, missingExtensionDependency) {
        const error = ( (new Error()));
        error.name = data.name;
        error.message = data.message;
        error.stack = data.stack;
        this._internalExtensionService._onDidActivateExtensionError(extensionId, error);
        if (missingExtensionDependency) {
            const extension = await this._extensionService.getExtension(extensionId.value);
            if (extension) {
                const local = await this._extensionsWorkbenchService.queryLocal();
                const installedDependency = local.find(i => areSameExtensions(i.identifier, { id: missingExtensionDependency.dependency }));
                if (installedDependency?.local) {
                    await this._handleMissingInstalledDependency(extension, installedDependency.local);
                    return;
                }
                else {
                    await this._handleMissingNotInstalledDependency(extension, missingExtensionDependency.dependency);
                    return;
                }
            }
        }
        const isDev = !this._environmentService.isBuilt || this._environmentService.isExtensionDevelopment;
        if (isDev) {
            this._notificationService.error(error);
            return;
        }
        console.error(error.message);
    }
    async _handleMissingInstalledDependency(extension, missingInstalledDependency) {
        const extName = extension.displayName || extension.name;
        if (this._extensionEnablementService.isEnabled(missingInstalledDependency)) {
            this._notificationService.notify({
                severity: Severity$1.Error,
                message: ( localizeWithPath(
                    _moduleId,
                    0,
                    "Cannot activate the '{0}' extension because it depends on the '{1}' extension, which is not loaded. Would you like to reload the window to load the extension?",
                    extName,
                    missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
                )),
                actions: {
                    primary: [( (new Action('reload', ( localizeWithPath(_moduleId, 1, "Reload Window")), '', true, () => this._hostService.reload())))]
                }
            });
        }
        else {
            const enablementState = this._extensionEnablementService.getEnablementState(missingInstalledDependency);
            if (enablementState === 4 ) {
                this._notificationService.notify({
                    severity: Severity$1.Error,
                    message: ( localizeWithPath(
                        _moduleId,
                        2,
                        "Cannot activate the '{0}' extension because it depends on the '{1}' extension which is not supported in the current workspace",
                        extName,
                        missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
                    )),
                });
            }
            else if (enablementState === 0 ) {
                this._notificationService.notify({
                    severity: Severity$1.Error,
                    message: ( localizeWithPath(
                        _moduleId,
                        3,
                        "Cannot activate the '{0}' extension because it depends on the '{1}' extension which is not supported in Restricted Mode",
                        extName,
                        missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
                    )),
                    actions: {
                        primary: [( (new Action('manageWorkspaceTrust', ( localizeWithPath(_moduleId, 4, "Manage Workspace Trust")), '', true, () => this._commandService.executeCommand('workbench.trust.manage'))))]
                    }
                });
            }
            else if (this._extensionEnablementService.canChangeEnablement(missingInstalledDependency)) {
                this._notificationService.notify({
                    severity: Severity$1.Error,
                    message: ( localizeWithPath(
                        _moduleId,
                        5,
                        "Cannot activate the '{0}' extension because it depends on the '{1}' extension which is disabled. Would you like to enable the extension and reload the window?",
                        extName,
                        missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
                    )),
                    actions: {
                        primary: [( (new Action('enable', ( localizeWithPath(_moduleId, 6, "Enable and Reload")), '', true, () => this._extensionEnablementService.setEnablement([missingInstalledDependency], enablementState === 6  ? 8  : 9 )
                                .then(() => this._hostService.reload(), e => this._notificationService.error(e)))))]
                    }
                });
            }
            else {
                this._notificationService.notify({
                    severity: Severity$1.Error,
                    message: ( localizeWithPath(
                        _moduleId,
                        7,
                        "Cannot activate the '{0}' extension because it depends on the '{1}' extension which is disabled.",
                        extName,
                        missingInstalledDependency.manifest.displayName || missingInstalledDependency.manifest.name
                    )),
                });
            }
        }
    }
    async _handleMissingNotInstalledDependency(extension, missingDependency) {
        const extName = extension.displayName || extension.name;
        let dependencyExtension = null;
        try {
            dependencyExtension = (await this._extensionsWorkbenchService.getExtensions([{ id: missingDependency }], CancellationToken.None))[0];
        }
        catch (err) {
        }
        if (dependencyExtension) {
            this._notificationService.notify({
                severity: Severity$1.Error,
                message: ( localizeWithPath(
                    _moduleId,
                    8,
                    "Cannot activate the '{0}' extension because it depends on the '{1}' extension from '{2}', which is not installed. Would you like to install the extension and reload the window?",
                    extName,
                    dependencyExtension.displayName,
                    dependencyExtension.publisherDisplayName
                )),
                actions: {
                    primary: [( (new Action('install', ( localizeWithPath(_moduleId, 9, "Install and Reload")), '', true, () => this._extensionsWorkbenchService.install(dependencyExtension)
                            .then(() => this._hostService.reload(), e => this._notificationService.error(e)))))]
                }
            });
        }
        else {
            this._notificationService.error(( localizeWithPath(
                _moduleId,
                10,
                "Cannot activate the '{0}' extension because it depends on an unknown '{1}' extension.",
                extName,
                missingDependency
            )));
        }
    }
    async $setPerformanceMarks(marks) {
        if (this._extensionHostKind === 1 ) {
            this._timerService.setPerformanceMarks('localExtHost', marks);
        }
        else if (this._extensionHostKind === 2 ) {
            this._timerService.setPerformanceMarks('workerExtHost', marks);
        }
        else {
            this._timerService.setPerformanceMarks('remoteExtHost', marks);
        }
    }
    async $asBrowserUri(uri) {
        return FileAccess.uriToBrowserUri(URI.revive(uri));
    }
    async $getAllStaticBrowserUris() {
        return Array.from(FileAccess.getRegisteredBrowserUris(), uri => [
            uri,
            FileAccess.uriToBrowserUri(uri)
        ]);
    }
};
MainThreadExtensionService = __decorate([
    extHostNamedCustomer(MainContext.MainThreadExtensionService),
    ( (__param(1, IExtensionService))),
    ( (__param(2, INotificationService))),
    ( (__param(3, IExtensionsWorkbenchService))),
    ( (__param(4, IHostService))),
    ( (__param(5, IWorkbenchExtensionEnablementService))),
    ( (__param(6, ITimerService))),
    ( (__param(7, ICommandService))),
    ( (__param(8, IWorkbenchEnvironmentService)))
], MainThreadExtensionService);
class ExtensionHostProxy {
    constructor(_actual) {
        this._actual = _actual;
    }
    async resolveAuthority(remoteAuthority, resolveAttempt) {
        const resolved = reviveResolveAuthorityResult(await this._actual.$resolveAuthority(remoteAuthority, resolveAttempt));
        return resolved;
    }
    async getCanonicalURI(remoteAuthority, uri) {
        const uriComponents = await this._actual.$getCanonicalURI(remoteAuthority, uri);
        return (uriComponents ? URI.revive(uriComponents) : uriComponents);
    }
    startExtensionHost(extensionsDelta) {
        return this._actual.$startExtensionHost(extensionsDelta);
    }
    extensionTestsExecute() {
        return this._actual.$extensionTestsExecute();
    }
    activateByEvent(activationEvent, activationKind) {
        return this._actual.$activateByEvent(activationEvent, activationKind);
    }
    activate(extensionId, reason) {
        return this._actual.$activate(extensionId, reason);
    }
    setRemoteEnvironment(env) {
        return this._actual.$setRemoteEnvironment(env);
    }
    updateRemoteConnectionData(connectionData) {
        return this._actual.$updateRemoteConnectionData(connectionData);
    }
    deltaExtensions(extensionsDelta) {
        return this._actual.$deltaExtensions(extensionsDelta);
    }
    test_latency(n) {
        return this._actual.$test_latency(n);
    }
    test_up(b) {
        return this._actual.$test_up(b);
    }
    test_down(size) {
        return this._actual.$test_down(size);
    }
}
function reviveResolveAuthorityResult(result) {
    if (result.type === 'ok') {
        return {
            type: 'ok',
            value: {
                ...result.value,
                authority: reviveResolvedAuthority(result.value.authority),
            }
        };
    }
    else {
        return result;
    }
}
function reviveResolvedAuthority(resolvedAuthority) {
    return {
        ...resolvedAuthority,
        connectTo: reviveConnection(resolvedAuthority.connectTo),
    };
}
function reviveConnection(connection) {
    if (connection.type === 0 ) {
        return (
             (new WebSocketRemoteConnection(connection.host, connection.port))
        );
    }
    return (
         (new ManagedRemoteConnection(connection.id))
    );
}

export { MainThreadExtensionService };
